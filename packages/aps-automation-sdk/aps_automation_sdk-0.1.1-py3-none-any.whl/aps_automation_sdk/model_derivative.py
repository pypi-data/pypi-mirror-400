import os
import base64
import requests
import time
from typing import Any

# APS API endpoints
APS_BASE_URL = "https://developer.api.autodesk.com"
MD_BASE_URL = f"{APS_BASE_URL}/modelderivative/v2"
AUTH_URL = f"{APS_BASE_URL}/authentication/v2/token"


def safe_base64_encode(text: str) -> str:
    """Encode text to URL-safe base64 format (used for URNs)."""
    return base64.urlsafe_b64encode(text.encode()).decode().strip("=")


def to_md_urn(wip_urn: str) -> str:
    """Convert WIP URN to Model Derivative URN."""
    raw = wip_urn.split("?", 1)[0]
    encoded = base64.urlsafe_b64encode(raw.encode("utf8")).decode("utf8")
    return encoded.rstrip("=")


def get_revit_version_from_manifest(manifest: dict) -> str | None:
    """Extract Revit version from manifest."""
    try:
        derivatives = manifest.get("derivatives", [])
        if not derivatives:
            return None
        
        for derivative in derivatives:
            properties = derivative.get("properties", {})
            doc_info = properties.get("Document Information", {})
            rvt_version = doc_info.get("RVTVersion")
            if rvt_version:
                return str(rvt_version)
        
        return None
    except Exception as e:
        print(f"Error extracting Revit version from manifest: {e}")
        return None


def fetch_manifest(token: str, object_urn: str) -> dict:
    """Fetch model derivative manifest."""
    response = requests.get(
        f"{MD_BASE_URL}/designdata/{object_urn}/manifest",
        headers={"Authorization": f"Bearer {token}"},
        timeout=30
    )
    response.raise_for_status()
    return response.json()


def get_revit_version_from_oss_object(token: str, bucket_key: str, object_key: str) -> str | None:
    """
    Get Revit version from an OSS object by translating it and checking the manifest.
    Revit version string (e.g., "2024") or None if not detected
    """
    print(f"üîç Detecting Revit version for object: {object_key}")
    
    # Build the OSS object URN
    oss_object_id = f"urn:adsk.objects:os.object:{bucket_key}/{object_key}"
    object_urn = safe_base64_encode(oss_object_id)
    
    # Start a basic translation job to get the manifest
    try:
        start_svf_translation_job(token, object_urn)
        
        # Wait a bit for the manifest to be generated
        import time
        max_wait = 60
        interval = 5
        elapsed = 0
        
        while elapsed < max_wait:
            try:
                manifest = fetch_manifest(token, object_urn)
                version = get_revit_version_from_manifest(manifest)
                
                if version:
                    print(f"‚úÖ Detected Revit version: {version}")
                    return version
                    
                # If manifest exists but no version yet, wait a bit more
                if manifest.get("status") in ["success", "failed"]:
                    break
                    
            except requests.exceptions.RequestException:
                pass
            
            time.sleep(interval)
            elapsed += interval
        
        print("‚ö†Ô∏è  Could not detect Revit version from manifest")
        return None
        
    except Exception as e:
        print(f"‚ö†Ô∏è  Error detecting Revit version: {e}")
        return None


def start_svf_translation_job(token: str, object_urn: str) -> dict[str, Any]:
    """
    Start SVF translation job for the Revit file generated by Design Automation.
    """
    print("üîÑ Starting Model Derivative translation job...")
    
    job_payload = {
        "input": {"urn": object_urn},
        "output": {
            "formats": [
                {
                    "type": "svf2",
                    "views": ["3d", "2d"]
                }
            ]
        }
    }
    
    headers = {
        "Authorization": f"Bearer {token}",
        "Content-Type": "application/json",
        "x-ads-force": "true"
    }
    
    response = requests.post(
        f"{MD_BASE_URL}/designdata/job",
        headers=headers,
        json=job_payload,
        timeout=30
    )
    response.raise_for_status()
    
    result = response.json()
    return result


def get_translation_status(token: str, object_urn: str) -> tuple[str, str]:
    """
    Check the status of a Model Derivative translation job.
    """
    response = requests.get(
        f"{MD_BASE_URL}/designdata/{object_urn}/manifest",
        headers={"Authorization": f"Bearer {token}"},
        timeout=30
    )
    
    if response.status_code == 202:
        return "inprogress", "Manifest not ready"
    
    response.raise_for_status()
    manifest = response.json()
    
    status = manifest.get("status", "unknown")
    progress = manifest.get("progress", "N/A")
    
    return status, progress


def translate_file_in_oss(
    token: str,
    bucket_key: str,
    output_object_key: str,
    max_wait_time: int = 300,
    poll_interval: int = 15,
    verbose: bool = False,
) -> str:
    """
    Translate a file in OSS (bucket/object) into SVF for APS Viewer.
    Returns the base64 URN to use with APS Viewer.
    """
    def log(*args, **kwargs):
        if verbose:
            print(*args, **kwargs)

    log("üéØ STARTING MODEL TRANSLATION FOR VIEWING")
    log(f"Bucket: {bucket_key}")
    log(f"Object: {output_object_key}")

    oss_object_id = f"urn:adsk.objects:os.object:{bucket_key}/{output_object_key}"
    object_urn = to_md_urn(oss_object_id)
    log(f"üîó Object URN: {object_urn}")

    job = start_svf_translation_job(token, object_urn)
    log(f"üìã Job Details: {job.get('urn', 'No URN in response')}")
    log("‚è≥ Monitoring translation progress...")

    elapsed_time = 0

    while elapsed_time < max_wait_time:
        try:
            status, progress = get_translation_status(token, object_urn)
            log(f"  > MD Status: {status} ({progress})")

            if status == "success":
                log("‚úÖ Translation completed successfully!")
                log(f"üéâ Model ready for viewing with URN: {object_urn}")
                return object_urn
            if status == "failed":
                log("‚ùå Translation failed!")
                raise RuntimeError("Model Derivative translation failed")
            if status in ["inprogress", "pending"]:
                pass
            else:
                log(f"‚ö†Ô∏è Unknown status: {status}")
        except requests.exceptions.RequestException as exc:
            log(f"‚ö†Ô∏è Error checking translation status: {exc}. Retrying...")

        time.sleep(poll_interval)
        elapsed_time += poll_interval

    log(f"‚è∞ Translation timed out after {max_wait_time}s")
    raise RuntimeError(f"Translation timeout after {max_wait_time} seconds")

def get_translation_info(token: str, object_urn: str) -> dict[str, Any]:
    """
    Get detailed information about a translated model.
    """
    
    response = requests.get(
        f"{MD_BASE_URL}/designdata/{object_urn}/manifest",
        headers={"Authorization": f"Bearer {token}"},
        timeout=30
    )
    response.raise_for_status()
    
    manifest = response.json()
    
    # Extract useful information
    info = {
        "status": manifest.get("status"),
        "progress": manifest.get("progress"),
        "type": manifest.get("type"),
        "region": manifest.get("region"),
        "urn": object_urn
    }
    
    # Get derivative information
    derivatives = manifest.get("derivatives", [])
    if derivatives:
        derivative = derivatives[0]
        info.update({
            "output_type": derivative.get("outputType"),
            "has_thumbnail": "thumbnail" in derivative,
            "children_count": len(derivative.get("children", [])),
        })
    
    return info
