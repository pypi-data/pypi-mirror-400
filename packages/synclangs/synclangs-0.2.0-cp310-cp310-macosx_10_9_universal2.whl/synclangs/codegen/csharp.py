"""C# code generator for SyncLangs types."""

from __future__ import annotations


from synclangs.codegen.base import CodeGenerator
from synclangs.parser.ast import (
    ConstDef,
    ConstValue,
    EnumDef,
    FunctionDef,
    InterfaceDef,
    ListTypeExpr,
    MapTypeExpr,
    Module,
    NullableTypeExpr,
    PrimitiveType,
    PrimitiveTypeExpr,
    TypeDef,
    TypeExpr,
    TypeRef,
    VoidType,
)


class CSharpGenerator(CodeGenerator):
    """Generate C# classes from SyncLangs AST."""

    def __init__(
        self,
        file_extension: str = ".cs",
        namespace_name: str = "Types",
    ) -> None:
        self._file_extension = file_extension
        self._namespace_name = namespace_name

    def generate(self, module: Module) -> str:
        """Generate C# source code for a module."""
        lines: list[str] = [
            "// Auto-generated by SyncLangs - DO NOT EDIT",
            "",
        ]

        # Collect usings needed
        usings = self._collect_usings(module)
        for using in sorted(usings):
            lines.append(f"using {using};")
        if usings:
            lines.append("")

        # Open namespace
        lines.append(f"namespace {self._namespace_name}")
        lines.append("{")

        # Generate constants as a static class
        if module.constants:
            lines.append("    public static class Constants")
            lines.append("    {")
            for const_def in module.constants:
                lines.extend(self._generate_constant(const_def))
            lines.append("    }")
            lines.append("")

        # Generate enums
        for enum_def in module.enums:
            lines.extend(self._generate_enum(enum_def))
            lines.append("")

        # Generate classes for types
        for type_def in module.types:
            lines.extend(self._generate_type(type_def))
            lines.append("")

        # Generate interfaces
        for interface_def in module.interfaces:
            lines.extend(self._generate_interface(interface_def))
            lines.append("")

        # Generate delegate types for functions
        for fn_def in module.functions:
            lines.extend(self._generate_function_type(fn_def))
            lines.append("")

        # Close namespace
        lines.append("}")

        return "\n".join(lines).rstrip() + "\n"

    def _generate_type(self, type_def: TypeDef) -> list[str]:
        """Generate a C# class for a type definition."""
        lines: list[str] = []
        if type_def.doc_comment:
            lines.extend(self._format_xml_doc(type_def.doc_comment, "    "))

        # Build inheritance
        inheritance_list: list[str] = []
        if type_def.extends:
            inheritance_list.append(type_def.extends)
        if type_def.implements:
            inheritance_list.extend(f"I{impl}" for impl in type_def.implements)

        inheritance = ""
        if inheritance_list:
            inheritance = f" : {', '.join(inheritance_list)}"

        lines.append(f"    public class {type_def.name}{inheritance}")
        lines.append("    {")

        # Generate properties
        for field in type_def.fields:
            if field.doc_comment:
                lines.extend(self._format_xml_doc(field.doc_comment, "        "))
            csharp_type, is_nullable = self._field_type(field.type_expr)
            prop_name = self._to_pascal_case(field.name)
            nullable_suffix = "?" if is_nullable else ""
            lines.append(f"        public {csharp_type}{nullable_suffix} {prop_name} {{ get; set; }}")

        lines.append("    }")
        return lines

    def _generate_interface(self, interface_def: InterfaceDef) -> list[str]:
        """Generate a C# interface definition."""
        lines: list[str] = []
        if interface_def.doc_comment:
            lines.extend(self._format_xml_doc(interface_def.doc_comment, "    "))
        
        # C# convention: interfaces start with 'I'
        interface_name = f"I{interface_def.name}"
        lines.append(f"    public interface {interface_name}")
        lines.append("    {")

        # Generate method signatures
        for fn_def in interface_def.functions:
            if fn_def.doc_comment:
                lines.extend(self._format_xml_doc(fn_def.doc_comment, "        "))
            signature = self._function_signature(fn_def)
            lines.append(f"        {signature}")

        lines.append("    }")
        return lines

    def _generate_function_type(self, fn_def: FunctionDef) -> list[str]:
        """Generate a C# delegate type for a function."""
        lines: list[str] = []
        if fn_def.doc_comment:
            lines.extend(self._format_xml_doc(fn_def.doc_comment, "    "))

        # Build parameter list
        params = ", ".join(
            f"{self._type_to_csharp(p.type_expr)} {p.name}"
            for p in fn_def.params
        )

        return_type = self._return_type_to_csharp(fn_def.return_type)
        type_name = f"{fn_def.name[0].upper()}{fn_def.name[1:]}Fn"
        
        lines.append(f"    public delegate {return_type} {type_name}({params});")
        return lines

    def _function_signature(self, fn_def: FunctionDef) -> str:
        """Generate a C# method signature."""
        params = ", ".join(
            f"{self._type_to_csharp(p.type_expr)} {p.name}"
            for p in fn_def.params
        )

        return_type = self._return_type_to_csharp(fn_def.return_type)
        method_name = self._to_pascal_case(fn_def.name)

        if fn_def.is_async:
            return f"Task<{return_type}> {method_name}Async({params});"
        return f"{return_type} {method_name}({params});"

    def _return_type_to_csharp(self, return_type: TypeExpr | VoidType) -> str:
        """Convert a return type to C#."""
        if isinstance(return_type, VoidType):
            return "void"
        return self._type_to_csharp(return_type)

    def _collect_usings(self, module: Module) -> set[str]:
        """Collect C# usings needed for the module."""
        usings: set[str] = set()

        for type_def in module.types:
            for field in type_def.fields:
                self._collect_type_usings(field.type_expr, usings)

        for interface_def in module.interfaces:
            for fn_def in interface_def.functions:
                if fn_def.is_async:
                    usings.add("System.Threading.Tasks")
                for param in fn_def.params:
                    self._collect_type_usings(param.type_expr, usings)
                if not isinstance(fn_def.return_type, VoidType):
                    self._collect_type_usings(fn_def.return_type, usings)

        for fn_def in module.functions:
            for param in fn_def.params:
                self._collect_type_usings(param.type_expr, usings)
            if not isinstance(fn_def.return_type, VoidType):
                self._collect_type_usings(fn_def.return_type, usings)

        return usings

    def _collect_type_usings(self, type_expr: TypeExpr, usings: set[str]) -> None:
        """Collect usings for a type expression."""
        if isinstance(type_expr, ListTypeExpr):
            usings.add("System.Collections.Generic")
            self._collect_type_usings(type_expr.element_type, usings)
        elif isinstance(type_expr, MapTypeExpr):
            usings.add("System.Collections.Generic")
            self._collect_type_usings(type_expr.key_type, usings)
            self._collect_type_usings(type_expr.value_type, usings)
        elif isinstance(type_expr, NullableTypeExpr):
            self._collect_type_usings(type_expr.inner_type, usings)

    def _generate_constant(self, const_def: ConstDef) -> list[str]:
        """Generate a C# constant definition."""
        lines: list[str] = []
        if const_def.doc_comment:
            lines.extend(self._format_xml_doc(const_def.doc_comment, "        "))
        csharp_type = self._type_to_csharp(const_def.type_expr)
        value = self._const_value_to_csharp(const_def.value)
        
        # Use const for primitives, static readonly for reference types
        if csharp_type == "string":
            lines.append(f"        public const {csharp_type} {const_def.name} = {value};")
        elif csharp_type in ("long", "double", "bool", "int", "float"):
            lines.append(f"        public const {csharp_type} {const_def.name} = {value};")
        else:
            lines.append(f"        public static readonly {csharp_type} {const_def.name} = {value};")
        return lines

    def _generate_enum(self, enum_def: EnumDef) -> list[str]:
        """Generate a C# enum definition."""
        lines: list[str] = []
        if enum_def.doc_comment:
            lines.extend(self._format_xml_doc(enum_def.doc_comment, "    "))
        lines.append(f"    public enum {enum_def.name}")
        lines.append("    {")
        
        for i, variant in enumerate(enum_def.variants):
            if variant.doc_comment:
                lines.extend(self._format_xml_doc(variant.doc_comment, "        "))
            comma = "," if i < len(enum_def.variants) - 1 else ""
            lines.append(f"        {variant.name}{comma}")
        
        lines.append("    }")
        return lines

    def _const_value_to_csharp(self, value: ConstValue) -> str:
        """Convert a constant value to C# literal."""
        if isinstance(value.value, str):
            return f'"{value.value}"'
        if isinstance(value.value, bool):
            return "true" if value.value else "false"
        if isinstance(value.value, float):
            return f"{value.value}d"
        return str(value.value)

    def _field_type(self, type_expr: TypeExpr) -> tuple[str, bool]:
        """Return the C# type and nullable flag for a field."""
        if isinstance(type_expr, NullableTypeExpr):
            inner_type = self._type_to_csharp(type_expr.inner_type)
            return inner_type, True
        return self._type_to_csharp(type_expr), False

    def _type_to_csharp(self, type_expr: TypeExpr) -> str:
        """Convert a type expression to a C# type."""
        if isinstance(type_expr, PrimitiveTypeExpr):
            return self._primitive_to_csharp(type_expr.primitive)
        if isinstance(type_expr, ListTypeExpr):
            inner = self._type_to_csharp(type_expr.element_type)
            return f"List<{inner}>"
        if isinstance(type_expr, MapTypeExpr):
            key = self._type_to_csharp(type_expr.key_type)
            value = self._type_to_csharp(type_expr.value_type)
            return f"Dictionary<{key}, {value}>"
        if isinstance(type_expr, NullableTypeExpr):
            inner = self._type_to_csharp(type_expr.inner_type)
            return f"{inner}?"
        if isinstance(type_expr, TypeRef):
            return type_expr.name
        raise TypeError(f"Unsupported type expression: {type_expr}")

    def _primitive_to_csharp(self, primitive: PrimitiveType) -> str:
        """Map primitive SyncLangs types to C# types."""
        mapping = {
            PrimitiveType.STRING: "string",
            PrimitiveType.INT: "long",
            PrimitiveType.FLOAT: "double",
            PrimitiveType.BOOL: "bool",
            PrimitiveType.ANY: "object",
        }
        return mapping[primitive]

    def _to_pascal_case(self, name: str) -> str:
        """Convert a name to PascalCase."""
        if name and name[0].islower():
            return name[0].upper() + name[1:]
        return name

    def _format_xml_doc(self, text: str, indent: str) -> list[str]:
        """Format an XML documentation comment with the provided indentation."""
        lines = text.splitlines()
        formatted = [f"{indent}/// <summary>"]
        for line in lines:
            formatted.append(f"{indent}/// {line}")
        formatted.append(f"{indent}/// </summary>")
        return formatted
