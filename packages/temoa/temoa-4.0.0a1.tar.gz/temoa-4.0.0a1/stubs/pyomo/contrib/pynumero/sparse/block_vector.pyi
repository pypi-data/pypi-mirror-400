from ..dependencies import numpy as np
from .base_block import BaseBlockVector as BaseBlockVector
from .base_block import vec_associative_reductions as vec_associative_reductions
from .base_block import vec_binary_ufuncs as vec_binary_ufuncs
from .base_block import vec_unary_ufuncs as vec_unary_ufuncs

class NotFullyDefinedBlockVectorError(Exception): ...

def assert_block_structure(vec) -> None: ...

class BlockVector(BaseBlockVector, np.ndarray):
    def __new__(cls, nblocks): ...
    def __init__(self, nblocks) -> None: ...
    def __array_finalize__(self, obj) -> None: ...
    def __array_prepare__(self, out_arr, context=None): ...
    def __array_wrap__(self, out_arr, context=None): ...
    def __array_ufunc__(self, ufunc, method, *inputs, **kwargs): ...
    @property
    def nblocks(self): ...
    @property
    def bshape(self): ...
    @property
    def shape(self): ...
    @property
    def size(self): ...
    @property
    def ndim(self): ...
    @property
    def has_none(self): ...
    def block_sizes(self, copy: bool = True): ...
    def get_block_size(self, ndx): ...
    def is_block_defined(self, ndx): ...
    def dot(self, other, out=None): ...
    def sum(self, axis=None, dtype=None, out=None, keepdims: bool = False): ...
    def all(self, axis=None, out=None, keepdims: bool = False): ...
    def any(self, axis=None, out=None, keepdims: bool = False): ...
    def max(self, axis=None, out=None, keepdims: bool = False): ...
    def astype(
        self,
        dtype,
        order: str = 'K',
        casting: str = 'unsafe',
        subok: bool = True,
        copy: bool = True,
    ): ...
    def clip(self, min=None, max=None, out=None): ...
    def compress(self, condition, axis=None, out=None): ...
    def conj(self): ...
    def conjugate(self): ...
    def nonzero(self): ...
    def ptp(self, axis=None, out=None, keepdims: bool = False): ...
    def round(self, decimals: int = 0, out=None): ...
    def std(self, axis=None, dtype=None, out=None, ddof: int = 0, keepdims: bool = False): ...
    def var(self, axis=None, dtype=None, out=None, ddof: int = 0, keepdims: bool = False): ...
    def tofile(self, fid, sep: str = '', format: str = '%s') -> None: ...
    def min(self, axis=None, out=None, keepdims: bool = False): ...
    def mean(self, axis=None, dtype=None, out=None, keepdims: bool = False): ...
    def prod(self, axis=None, dtype=None, out=None, keepdims: bool = False): ...
    def fill(self, value) -> None: ...
    def tolist(self): ...
    def flatten(self, order: str = 'C'): ...
    def ravel(self, order: str = 'C'): ...
    def argmax(self, axis=None, out=None): ...
    def argmin(self, axis=None, out=None): ...
    def cumprod(self, axis=None, dtype=None, out=None): ...
    def cumsum(self, axis=None, dtype=None, out=None): ...
    def clone(self, value=None, copy: bool = True): ...
    def copyfrom(self, other) -> None: ...
    def copyto(self, other) -> None: ...
    def copy(self, order: str = 'C'): ...
    def copy_structure(self): ...
    def set_blocks(self, blocks) -> None: ...
    def __iter__(self): ...
    def __add__(self, other): ...
    def __radd__(self, other): ...
    def __sub__(self, other): ...
    def __rsub__(self, other): ...
    def __mul__(self, other): ...
    def __rmul__(self, other): ...
    def __truediv__(self, other): ...
    def __rtruediv__(self, other): ...
    def __floordiv__(self, other): ...
    def __rfloordiv__(self, other): ...
    def __iadd__(self, other): ...
    def __isub__(self, other): ...
    def __imul__(self, other): ...
    def __itruediv__(self, other): ...
    def __div__(self, other): ...
    def __rdiv__(self, other): ...
    def __idiv__(self, other): ...
    def get_block(self, key): ...
    def set_block(self, key, value) -> None: ...
    def __getitem__(self, item) -> None: ...
    def __setitem__(self, key, value) -> None: ...
    def __le__(self, other): ...
    def __lt__(self, other): ...
    def __ge__(self, other): ...
    def __gt__(self, other): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    def __neg__(self): ...
    def __contains__(self, item) -> bool: ...
    def __len__(self) -> int: ...
    def pprint(self) -> None: ...
    def toMPIBlockVector(self, rank_ownership, mpi_comm, assert_correct_owners: bool = False): ...
