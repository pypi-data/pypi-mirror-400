# Copyright (c) 2025 Artoo Corporation
# Licensed under the Business Source License 1.1 (see LICENSE).
# Change Date: 2029-09-08  â€¢  Change License: LGPL-3.0-or-later

"""Command implementations for the D2 CLI."""

from __future__ import annotations

import argparse
import asyncio
import base64
import json
import logging
import os
import time
import uuid
from datetime import datetime, timedelta, timezone
from pathlib import Path
from typing import Any, Dict, Iterable, Optional, Sequence
from urllib import parse as _urlp

import httpx
from nacl.signing import SigningKey

from .._crypto import get_or_create_key
from ..cache import CacheManager, gc_old_caches
from ..exceptions import ConfigurationError, PolicyError
from ..policy import FilePolicyLoader
from ..policy.files import locate_policy_file, require_app_name
from ..telemetry.plan_limits import emit_plan_limit_warning
from ..utils import DEFAULT_API_URL, HTTP_TIMEOUT_SECONDS
from ..validator import resolve_limits, validate_bundle
from .discovery import DEFAULT_SKIP_DIRS, discover_tools, validate_condition_arguments

logger = logging.getLogger("d2.cli")

try:  # pragma: no cover - optional dependency
    import yaml  # type: ignore
except ImportError:  # pragma: no cover
    yaml = None


DEFAULT_POLICY_CONTENT = """
version: 1
policies:
  - role: admin
    permissions:
      - "*"

  - role: developer
    permissions:
{developer_permissions}

  - role: viewer
    permissions:
      - "ping"
""".lstrip()

DEFAULT_DEVELOPER_SAMPLE = [
    "database:query",
    "weather_api",
    "notifications:send",
]


def _render_policy_content(tools: Sequence[str]) -> Dict[str, Any]:
    developer_permissions = list(tools) if tools else DEFAULT_DEVELOPER_SAMPLE
    expires_at = (datetime.now(timezone.utc) + timedelta(days=7)).isoformat()

    return {
        "metadata": {
            "name": "<FILL_ME_IN>",
            "description": "Describe this policy bundle",
            "expires": expires_at,
        },
        "version": 1,
        "policies": [
            {"role": "admin", "permissions": ["*"]},
            {"role": "developer", "permissions": developer_permissions},
            {"role": "viewer", "permissions": ["ping"]},
        ],
    }


def _write_policy_file(path: Path, data: Dict[str, Any], *, fmt: str) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    if fmt == "json":
        path.write_text(json.dumps(data, indent=2) + "\n")
    else:
        if yaml is None:
            raise ConfigurationError(
                "PyYAML is required to render YAML policies. Install with: pip install \"d2[cli]\"."
            )
        header = (
            "# D2 policy generated by `d2 init`\n"
            "# This file is used when the D2_TOKEN environment variable is NOT set.\n"
            "# Free-tier local policies expire automatically after 7 days. Run `d2 init --force` to refresh.\n\n"
        )
        yaml_output = yaml.safe_dump(data, sort_keys=False, indent=2)
        path.write_text(header + yaml_output)


def init_command(args: argparse.Namespace) -> None:
    project_root = Path(args.path).resolve()
    if not project_root.exists():
        raise ConfigurationError(f"Provided --path {project_root} does not exist.")

    tool_signatures = discover_tools(project_root, skip_dirs=DEFAULT_SKIP_DIRS)
    discovered_tools = sorted(tool_signatures.keys())

    if discovered_tools:
        logger.info("ðŸ” Found %d tool(s) guarded by @d2_guard in %s", len(discovered_tools), project_root)
        if len(discovered_tools) > 25:
            emit_plan_limit_warning()
        elif len(discovered_tools) >= 22:
            logger.warning("Within three tools of the free-tier cap (25). Plan for an upgrade soon.")
    else:
        logger.warning(
            "No @d2_guard usage found in %s. Pass --path /path/to/your/app if your project lives elsewhere.",
            project_root,
        )
        logger.info("Generating sample policy instead.")

    config_dir = Path(os.environ.get("XDG_CONFIG_HOME", "~/.config")).expanduser() / "d2"
    config_dir.mkdir(parents=True, exist_ok=True)
    target_file = config_dir / f"policy.{args.format}"
    existing_candidates = list(config_dir.glob("policy.*"))

    if existing_candidates and not args.force:
        pretty = "\n   â€¢ " + "\n   â€¢ ".join(str(p) for p in existing_candidates)
        raise ConfigurationError(
            "Multiple policy files detected:" + pretty + "\n"
            "Only one policy file should exist. Pass --force to overwrite."
        )

    for candidate in existing_candidates:
        candidate.unlink(missing_ok=True)
        logger.info("ðŸ—‘ï¸  Removed: %s", candidate)

    policy_data = _render_policy_content(discovered_tools)
    _write_policy_file(target_file, policy_data, fmt=args.format)
    logger.info("âœ… Created default policy file at: %s", target_file)


async def _fetch_cloud_policy(
    api_url: str,
    token: str,
    *,
    app_name_override: Optional[str] = None,
    stage: str = "bundle",
) -> Dict[str, Any]:
    if stage not in ("bundle", "published", "auto", "draft"):
        raise ValueError(f"Invalid stage: {stage}")

    bundle_url = f"{api_url.rstrip('/')}/v1/policy/bundle"
    params: Dict[str, str] = {}
    if app_name_override:
        params["app_name"] = app_name_override
    if stage in ("published", "auto", "draft"):
        params["stage"] = stage

    headers = {
        "Authorization": f"Bearer {token}",
        "X-Request-Id": str(uuid.uuid4()),
    }

    async with httpx.AsyncClient() as client:
        response = await client.get(
            bundle_url,
            headers=headers,
            params=params,
            timeout=HTTP_TIMEOUT_SECONDS,
        )
        response.raise_for_status()
        data = response.json()
        if "etag" in response.headers:
            data["etag"] = response.headers["etag"]
        return data


def _extract_policy_content(policy_data: Dict[str, Any]) -> Dict[str, Any]:
    jws = policy_data.get("jws")
    bundle = policy_data.get("bundle")

    if jws:
        parts = jws.split(".")
        if len(parts) != 3:
            raise ValueError("Invalid JWS format")
        payload_b64 = parts[1]
        padding = 4 - len(payload_b64) % 4
        if padding != 4:
            payload_b64 += "=" * padding
        payload_bytes = base64.urlsafe_b64decode(payload_b64)
        payload = json.loads(payload_bytes)
        if "metadata" not in payload or "policies" not in payload:
            raise ValueError("JWT payload missing required fields")
        return {"metadata": payload["metadata"], "policies": payload["policies"]}

    if isinstance(bundle, dict):
        if "metadata" not in bundle and "policies" not in bundle:
            raise ValueError("Bundle missing required 'metadata' or 'policies'")
        return bundle

    api_metadata_fields = {"version", "etag", "jws", "bundle"}
    bundle_content = {k: v for k, v in policy_data.items() if k not in api_metadata_fields}
    if not bundle_content:
        raise ValueError("No policy content found")
    if "metadata" not in bundle_content and "policies" not in bundle_content:
        raise ValueError("Policy content missing required fields")
    return bundle_content


async def pull_command(args: argparse.Namespace) -> None:
    token = os.getenv("D2_TOKEN")
    if not token:
        logger.info("D2_TOKEN not set â€“ operating in local-file mode.")
        try:
            loader = FilePolicyLoader()
            logger.info("Local policy file located at: %s", loader.policy_path)
        except ConfigurationError as exc:
            logger.info("%s", exc)
        return

    app_name = args.app_name or os.getenv("D2_APP_NAME")
    if not app_name:
        try:
            app_name = require_app_name()
        except ConfigurationError:
            app_name = None

    stage = args.stage or "published"
    policy_data = await _fetch_cloud_policy(DEFAULT_API_URL, token, app_name_override=app_name, stage=stage)
    bundle = _extract_policy_content(policy_data)

    if args.output:
        output_path = Path(args.output)
    else:
        try:
            output_path = locate_policy_file(env=os.environ)
        except ConfigurationError:
            config_dir = Path(os.environ.get("XDG_CONFIG_HOME", "~/.config")).expanduser() / "d2"
            output_path = config_dir / "policy.yaml"

    fmt = args.format or ("json" if output_path.suffix == ".json" else "yaml")
    _write_policy_file(output_path, bundle, fmt=fmt)
    logger.info("âœ… Cloud policy written to %s", output_path)


async def inspect_command(args: argparse.Namespace) -> None:
    token = os.getenv("D2_TOKEN")
    if token:
        app_name = getattr(args, "app_name", None)
        if not app_name:
            try:
                app_name = require_app_name()
            except ConfigurationError:
                app_name = None
        try:
            policy_data = await _fetch_cloud_policy(
                DEFAULT_API_URL,
                token,
                app_name_override=app_name,
                stage="bundle",
            )
            bundle = _extract_policy_content(policy_data)
        except Exception as exc:
            raise PolicyError(f"Failed to fetch policy: {exc}") from exc
    else:
        loader = FilePolicyLoader()
        bundle = await loader.load_policy()

    policies = bundle.get("policies", [])
    if args.verbose:
        if yaml is None:
            print(json.dumps(policies, indent=2))
        else:
            print(yaml.safe_dump(policies, sort_keys=False, indent=2))
        return

    permissions: Iterable[str] = sorted({perm for policy in policies for perm in policy.get("permissions", [])})
    print("Permissions:")
    for perm in permissions:
        print(f"  - {perm}")


async def diagnose_command(args: argparse.Namespace) -> None:
    loader = FilePolicyLoader()
    policy_path = loader.policy_path
    bundle = await loader.load_policy()

    raw_size = len(policy_path.read_bytes())
    validate_bundle(bundle, raw_bundle_size=raw_size)

    tool_signatures = discover_tools(Path(args.path).resolve(), skip_dirs=DEFAULT_SKIP_DIRS)
    warnings = validate_condition_arguments(bundle, tool_signatures)
    for message in warnings:
        logger.error("âŒ %s", message)

    # Count unique tools (permissions can be strings or dicts with "tool" key)
    tools = set()
    for policy in bundle.get("policies", []):
        for perm in policy.get("permissions", []):
            if perm == "*":
                continue
            if isinstance(perm, str):
                tools.add(perm)
            elif isinstance(perm, dict) and "tool" in perm:
                tools.add(perm["tool"])
    tool_count = len(tools)
    token = os.getenv("D2_TOKEN")
    limits = resolve_limits(token)
    logger.info("Tools defined: %d / %s", tool_count, limits.get("max_tools", 25))


async def publish_command(args: argparse.Namespace) -> None:
    token = os.getenv("D2_TOKEN")
    if not token:
        raise ConfigurationError("D2_TOKEN environment variable required for cloud publish.")

    policy_path = locate_policy_file()
    raw_bytes = policy_path.read_bytes()

    async with httpx.AsyncClient(base_url=DEFAULT_API_URL, headers={"Authorization": f"Bearer {token}"}) as client:
        priv_path, key_id = await get_or_create_key(client)
        sign_key = SigningKey(priv_path.read_bytes())
        signature_b64 = base64.b64encode(sign_key.sign(raw_bytes).signature).decode()

        headers = {
            "X-D2-Signature": signature_b64,
            "X-D2-Key-Id": key_id,
            "Content-Type": "application/octet-stream",
            "If-Match": "*",
        }

        app_name = require_app_name()
        url = f"/v1/policy/publish?app_name={_urlp.quote(app_name)}"
        response = await client.post(url, content=raw_bytes, headers=headers)
        response.raise_for_status()
        logger.info("âœ… Policy published (status %s)", response.status_code)


async def draft_command(_args: argparse.Namespace) -> None:
    token = os.getenv("D2_TOKEN")
    if not token:
        raise ConfigurationError("D2_TOKEN environment variable required for cloud draft upload.")

    policy_path = locate_policy_file()
    raw = policy_path.read_bytes()
    if policy_path.suffix == ".json":
        bundle = json.loads(raw)
    else:
        if yaml is None:
            raise ConfigurationError("PyYAML is required to read YAML policy files.")
        bundle = yaml.safe_load(raw)

    if "metadata" not in bundle or not bundle["metadata"].get("name"):
        raise ConfigurationError("metadata.name is required for draft upload.")

    async with httpx.AsyncClient(base_url=DEFAULT_API_URL, headers={"Authorization": f"Bearer {token}"}) as client:
        response = await client.put("/v1/policy/draft", json={"bundle": bundle})
        response.raise_for_status()
        logger.info("âœ… Draft uploaded")


async def status_command(_args: argparse.Namespace) -> None:
    token = os.getenv("D2_TOKEN")
    if not token:
        logger.error("D2_TOKEN not set - no cache context available.")
        return

    app_name = require_app_name()
    cache = CacheManager(token, app_name)
    etag = cache.get_cached_etag()
    version = cache.get_cached_version()
    bundle_age = cache.get_cache_age()

    if etag:
        logger.info("Bundle ETag  : %s", etag)
    if version is not None:
        logger.info("Bundle Version: %s", version)
    if bundle_age is not None:
        logger.info("Bundle age    : %ds", int(bundle_age))


async def switch_command(args: argparse.Namespace) -> None:
    token = os.getenv("D2_TOKEN")
    if not token:
        raise ConfigurationError("D2_TOKEN required for switching apps.")

    new_app_name = args.app_name.strip()
    if not new_app_name:
        raise ConfigurationError("App name cannot be empty")

    policy_data = await _fetch_cloud_policy(DEFAULT_API_URL, token, app_name_override=new_app_name, stage="auto")
    bundle = _extract_policy_content(policy_data)

    policy_path = locate_policy_file()
    fmt = "json" if policy_path.suffix == ".json" else "yaml"
    _write_policy_file(policy_path, bundle, fmt=fmt)

    cache = CacheManager(token, new_app_name)
    etag = policy_data.get("etag", "")
    jws = policy_data.get("jws", "")
    version = policy_data.get("version", 0)
    if etag:
        cache.save_bundle(jws, etag, version)

    logger.info("âœ… Switched to app '%s'", new_app_name)


def license_info_command(_args: argparse.Namespace) -> None:
    print(
        "D2 is source-available under BSL 1.1 (Change Date 2029-09-08 â†’ LGPL-3.0-or-later).\n"
        "Internal production use allowed; managed-service offerings prohibited without commercial terms.\n"
        "See LICENSE."
    )


async def run_gc_on_startup() -> None:
    try:
        gc_result = gc_old_caches(dry_run=False)
        if gc_result["cleaned_count"] > 0:
            freed_mb = gc_result["freed_bytes"] / (1024 * 1024)
            logger.info(
                "Cleaned %d unused policy caches (%.1f MiB)",
                gc_result["cleaned_count"],
                freed_mb,
            )
    except Exception:  # pragma: no cover - best effort cleanup
        pass


__all__ = [
    "draft_command",
    "diagnose_command",
    "init_command",
    "inspect_command",
    "license_info_command",
    "pull_command",
    "publish_command",
    "run_gc_on_startup",
    "status_command",
    "switch_command",
] 