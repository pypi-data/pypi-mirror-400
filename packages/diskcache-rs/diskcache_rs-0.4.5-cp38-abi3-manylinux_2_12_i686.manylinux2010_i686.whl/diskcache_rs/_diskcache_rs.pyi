# Type stubs for _diskcache_rs module (Rust extension)
# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import typing
from typing import Any, Dict, List, Optional

# Rust Cache Classes
class PyCache:
    """Python wrapper for the Cache"""
    def __init__(
        self,
        directory: str,
        max_size: Optional[int] = None,
        max_entries: Optional[int] = None,
    ) -> None: ...
    def get(self, key: str) -> Optional[bytes]: ...
    def set(
        self,
        key: str,
        value: Any,
        expire_time: Optional[int] = None,
        tags: Optional[List[str]] = None,
    ) -> None: ...
    def delete(self, key: str) -> bool: ...
    def clear(self) -> None: ...
    def exists(self, key: str) -> bool: ...
    def keys(self) -> List[str]: ...
    def size(self) -> int: ...
    def hit_rate(self) -> float: ...

class Cache:
    """Drop-in replacement for diskcache.Cache"""
    def __init__(self, directory: str, **kwargs: Any) -> None: ...
    def __contains__(self, key: str) -> bool: ...
    def __getitem__(self, key: str) -> Any: ...
    def __setitem__(self, key: str, value: Any) -> None: ...
    def __delitem__(self, key: str) -> None: ...
    def __iter__(self) -> typing.Iterator[str]: ...
    def __len__(self) -> int: ...
    def get(self, key: str, default: Any = None, retry: bool = False) -> Any: ...
    def set(
        self,
        key: str,
        value: Any,
        expire: Optional[int] = None,
        read: Optional[bool] = None,
        tag: Optional[str] = None,
        retry: Optional[bool] = None,
    ) -> bool: ...
    def add(
        self, key: str, value: Any, expire: Optional[int] = None, retry: bool = False
    ) -> bool: ...
    def delete(self, key: str, retry: bool = False) -> bool: ...
    def pop(
        self,
        key: str,
        default: Any = None,
        expire: Optional[int] = None,
        retry: bool = False,
    ) -> Any: ...
    def clear(self, retry: bool = False) -> int: ...
    def close(self) -> None: ...
    def exists(self, key: str) -> bool: ...
    def keys(self) -> List[str]: ...
    def values(self) -> List[Any]: ...
    def items(self) -> List[tuple[str, Any]]: ...
    def iterkeys(self) -> typing.Iterator[str]: ...
    def itervalues(self) -> typing.Iterator[Any]: ...
    def iteritems(self) -> typing.Iterator[tuple[str, Any]]: ...
    def expire(self, now: Optional[float] = None) -> int: ...
    def evict(self, tag: Optional[str] = None) -> int: ...
    def stats(self, enable: bool = True, reset: bool = False) -> tuple[int, int]: ...
    def volume(self) -> int: ...
    def reset(self, key: str, value: Any = None) -> None: ...
    def touch(
        self, key: str, expire: Optional[int] = None, retry: bool = False
    ) -> bool: ...
    def incr(
        self,
        key: str,
        delta: typing.Union[int, float] = 1,
        default: typing.Union[int, float] = 0,
        retry: bool = False,
    ) -> typing.Union[int, float]: ...
    def decr(
        self,
        key: str,
        delta: typing.Union[int, float] = 1,
        default: typing.Union[int, float] = 0,
        retry: bool = False,
    ) -> typing.Union[int, float]: ...

class FanoutCache:
    """Drop-in replacement for diskcache.FanoutCache"""
    def __init__(
        self, directory: str, shards: Optional[int] = None, **kwargs: Any
    ) -> None: ...
    def __contains__(self, key: str) -> bool: ...
    def __getitem__(self, key: str) -> Any: ...
    def __setitem__(self, key: str, value: Any) -> None: ...
    def __delitem__(self, key: str) -> None: ...
    def __iter__(self) -> typing.Iterator[str]: ...
    def __len__(self) -> int: ...
    def get(self, key: str, default: Any = None, retry: bool = False) -> Any: ...
    def set(
        self,
        key: str,
        value: Any,
        expire: Optional[int] = None,
        read: Optional[bool] = None,
        tag: Optional[str] = None,
        retry: Optional[bool] = None,
    ) -> bool: ...
    def delete(self, key: str) -> bool: ...
    def iterkeys(self) -> List[str]: ...

class PickleCache:
    """High-performance pickle cache with expiration support"""
    def __init__(
        self,
        directory: str,
        max_size: Optional[int] = None,
        default_ttl_seconds: Optional[int] = None,
    ) -> None: ...
    def set_pickle(
        self, key: str, pickled_data: Any, ttl_seconds: Optional[int] = None
    ) -> None: ...
    def get_pickle(self, key: str) -> Optional[bytes]: ...
    def delete(self, key: str) -> bool: ...
    def clear(self) -> None: ...
    def exists(self, key: str) -> bool: ...
    def keys(self) -> List[str]: ...
    def is_expired(self, key: str) -> bool: ...
    def cleanup_expired(self) -> int: ...
    def get_stats(self) -> Dict[str, Any]: ...

# Utility Functions
def detect_diskcache_format_py(path: str) -> bool:
    """Python wrapper for detect_diskcache_format"""
    ...

def rust_pickle_dumps(obj: Any) -> Any:
    """High-performance pickle serialization using Rust"""
    ...

def rust_pickle_loads(data: Any) -> Any:
    """High-performance pickle deserialization using Rust"""
    ...
