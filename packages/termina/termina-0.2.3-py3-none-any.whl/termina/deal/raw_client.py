# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pydantic_utilities import parse_obj_as
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..errors.content_too_large_error import ContentTooLargeError
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..types.deal_extra_metadata_response import DealExtraMetadataResponse
from ..types.deal_metadata_tag import DealMetadataTag
from ..types.deal_search_filter import DealSearchFilter
from ..types.deal_status import DealStatus
from ..types.deal_user_access_response import DealUserAccessResponse
from ..types.deal_with_files_response import DealWithFilesResponse
from ..types.default_role import DefaultRole
from ..types.http_validation_error import HttpValidationError
from ..types.list_deals_response import ListDealsResponse
from ..types.paginated_response_user_member_response import PaginatedResponseUserMemberResponse
from ..types.priority import Priority
from ..types.sort_criterion import SortCriterion
from .types.metadata import Metadata

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawDealClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def advanced_search(
        self,
        *,
        filters: typing.Optional[DealSearchFilter] = OMIT,
        sort: typing.Optional[typing.Sequence[SortCriterion]] = OMIT,
        page: typing.Optional[int] = OMIT,
        page_size: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ListDealsResponse]:
        """
        Parameters
        ----------
        filters : typing.Optional[DealSearchFilter]

        sort : typing.Optional[typing.Sequence[SortCriterion]]
            Optional list of sort criteria. Earlier items take precedence. Each item must specify 'sort_by' (SortField, BenchmarkMetricField, or DateField enum) and 'sort_order'. 'sort_by' values must be unique.

        page : typing.Optional[int]
            Page number

        page_size : typing.Optional[int]
            Number of items per page

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ListDealsResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/deal/advanced-search",
            method="POST",
            json={
                "filters": convert_and_respect_annotation_metadata(
                    object_=filters, annotation=DealSearchFilter, direction="write"
                ),
                "sort": convert_and_respect_annotation_metadata(
                    object_=sort, annotation=typing.Sequence[SortCriterion], direction="write"
                ),
                "page": page,
                "page_size": page_size,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListDealsResponse,
                    parse_obj_as(
                        type_=ListDealsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def batch_lookup_deals(
        self,
        *,
        deal_ids: typing.Sequence[int],
        sort_by: typing.Optional[str] = None,
        sort_order: typing.Optional[str] = None,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ListDealsResponse]:
        """
        Batch lookup deals by IDs with pagination.

        Returns only deals the user has access to (via group membership OR direct deal access).
        Silently filters out deals without access (no errors for inaccessible deals).

        Super users can see all deals.

        Parameters
        ----------
        deal_ids : typing.Sequence[int]
            List of deal IDs to retrieve

        sort_by : typing.Optional[str]

        sort_order : typing.Optional[str]

        page : typing.Optional[int]

        page_size : typing.Optional[int]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ListDealsResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/deal/batch-lookup",
            method="POST",
            params={
                "sort_by": sort_by,
                "sort_order": sort_order,
                "page": page,
                "page_size": page_size,
            },
            json={
                "deal_ids": deal_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListDealsResponse,
                    parse_obj_as(
                        type_=ListDealsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def search_users(
        self,
        group_id: int,
        deal_id: int,
        *,
        text: typing.Optional[str] = None,
        only_direct: typing.Optional[bool] = None,
        sort_by: typing.Optional[str] = None,
        sort_order: typing.Optional[str] = None,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[PaginatedResponseUserMemberResponse]:
        """
        Search users who have access to this deal.

        Requires READER role or above on the deal. By default, users with either group or direct deal access are returned.
        Set `only_direct` to true to limit results to users with direct deal access only.

        Args:
            text: Optional case-insensitive search across user name and email

        Parameters
        ----------
        group_id : int

        deal_id : int

        text : typing.Optional[str]

        only_direct : typing.Optional[bool]
            When true, returns only users with direct access to the deal (excludes group access)

        sort_by : typing.Optional[str]

        sort_order : typing.Optional[str]

        page : typing.Optional[int]

        page_size : typing.Optional[int]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PaginatedResponseUserMemberResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/{jsonable_encoder(deal_id)}/search-users",
            method="GET",
            params={
                "text": text,
                "only_direct": only_direct,
                "sort_by": sort_by,
                "sort_order": sort_order,
                "page": page,
                "page_size": page_size,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PaginatedResponseUserMemberResponse,
                    parse_obj_as(
                        type_=PaginatedResponseUserMemberResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def set_user_deal_role(
        self,
        group_id: int,
        deal_id: int,
        user_id: int,
        *,
        role_name: typing.Optional[DefaultRole] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[DealUserAccessResponse]:
        """
        Set the user's direct access role for this deal.

        The user will always end up with exactly one direct role for the deal.
        Requires admin role to manage members.

        Parameters
        ----------
        group_id : int

        deal_id : int

        user_id : int

        role_name : typing.Optional[DefaultRole]
            The role to set for the user

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DealUserAccessResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/{jsonable_encoder(deal_id)}/users/{jsonable_encoder(user_id)}",
            method="PUT",
            json={
                "role_name": role_name,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DealUserAccessResponse,
                    parse_obj_as(
                        type_=DealUserAccessResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def remove_user_from_deal(
        self, group_id: int, deal_id: int, user_id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[None]:
        """
        Remove a user's direct access to this deal.
        Requires admin role to manage members.

        Parameters
        ----------
        group_id : int

        deal_id : int

        user_id : int

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/{jsonable_encoder(deal_id)}/users/{jsonable_encoder(user_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create(
        self,
        group_id: int,
        *,
        round_name: str,
        company_id: int,
        notes: typing.Optional[str] = OMIT,
        priority: typing.Optional[Priority] = OMIT,
        status: typing.Optional[DealStatus] = OMIT,
        round_amount: typing.Optional[int] = OMIT,
        round_target: typing.Optional[int] = OMIT,
        tags: typing.Optional[typing.Sequence[str]] = OMIT,
        company_summary: typing.Optional[str] = OMIT,
        deal_lead_id: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[DealWithFilesResponse]:
        """
        Create a new deal.

        Parameters
        ----------
        group_id : int

        round_name : str
            The name of the round

        company_id : int

        notes : typing.Optional[str]
            Notes about the deal

        priority : typing.Optional[Priority]
            The priority of the deal

        status : typing.Optional[DealStatus]
            The current status of the deal

        round_amount : typing.Optional[int]
            The dollar amount to be raised of the round

        round_target : typing.Optional[int]
            The target post-money dollar amount of the round

        tags : typing.Optional[typing.Sequence[str]]
            The tags associated with the deal

        company_summary : typing.Optional[str]
            The summary of the company

        deal_lead_id : typing.Optional[int]
            The id of the user who is the deal lead

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DealWithFilesResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal",
            method="POST",
            json={
                "round_name": round_name,
                "notes": notes,
                "priority": priority,
                "status": status,
                "round_amount": round_amount,
                "round_target": round_target,
                "tags": tags,
                "company_summary": company_summary,
                "deal_lead_id": deal_lead_id,
                "company_id": company_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DealWithFilesResponse,
                    parse_obj_as(
                        type_=DealWithFilesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list(
        self,
        group_id: int,
        *,
        sort_by: typing.Optional[str] = None,
        sort_order: typing.Optional[str] = None,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ListDealsResponse]:
        """
        Get all deals for a group.

        Parameters
        ----------
        group_id : int

        sort_by : typing.Optional[str]

        sort_order : typing.Optional[str]

        page : typing.Optional[int]

        page_size : typing.Optional[int]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ListDealsResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/all",
            method="GET",
            params={
                "sort_by": sort_by,
                "sort_order": sort_order,
                "page": page,
                "page_size": page_size,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListDealsResponse,
                    parse_obj_as(
                        type_=ListDealsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def search(
        self,
        group_id: int,
        *,
        round_name: typing.Optional[str] = None,
        notes: typing.Optional[str] = None,
        tags: typing.Optional[str] = None,
        company_name: typing.Optional[str] = None,
        company_domain: typing.Optional[str] = None,
        categories: typing.Optional[str] = None,
        deal_lead: typing.Optional[str] = None,
        ignore_archived: typing.Optional[bool] = None,
        sort_by: typing.Optional[str] = None,
        sort_order: typing.Optional[str] = None,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ListDealsResponse]:
        """
        Search deals within a group.

        Parameters
        ----------
        group_id : int

        round_name : typing.Optional[str]

        notes : typing.Optional[str]

        tags : typing.Optional[str]

        company_name : typing.Optional[str]

        company_domain : typing.Optional[str]

        categories : typing.Optional[str]

        deal_lead : typing.Optional[str]

        ignore_archived : typing.Optional[bool]

        sort_by : typing.Optional[str]

        sort_order : typing.Optional[str]

        page : typing.Optional[int]

        page_size : typing.Optional[int]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ListDealsResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/search",
            method="GET",
            params={
                "round_name": round_name,
                "notes": notes,
                "tags": tags,
                "company_name": company_name,
                "company_domain": company_domain,
                "categories": categories,
                "deal_lead": deal_lead,
                "ignore_archived": ignore_archived,
                "sort_by": sort_by,
                "sort_order": sort_order,
                "page": page,
                "page_size": page_size,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListDealsResponse,
                    parse_obj_as(
                        type_=ListDealsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def search_advanced(
        self,
        group_id: int,
        *,
        filters: typing.Optional[DealSearchFilter] = OMIT,
        sort: typing.Optional[typing.Sequence[SortCriterion]] = OMIT,
        page: typing.Optional[int] = OMIT,
        page_size: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ListDealsResponse]:
        """
        Search deals within a group using flexible filters.

        .. deprecated::
            This endpoint is deprecated and will be removed in favor of the /deal/advanced-search endpoint.

        Parameters
        ----------
        group_id : int

        filters : typing.Optional[DealSearchFilter]

        sort : typing.Optional[typing.Sequence[SortCriterion]]
            Optional list of sort criteria. Earlier items take precedence. Each item must specify 'sort_by' (SortField, BenchmarkMetricField, or DateField enum) and 'sort_order'. 'sort_by' values must be unique.

        page : typing.Optional[int]
            Page number

        page_size : typing.Optional[int]
            Number of items per page

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ListDealsResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/search-advanced",
            method="POST",
            json={
                "filters": convert_and_respect_annotation_metadata(
                    object_=filters, annotation=DealSearchFilter, direction="write"
                ),
                "sort": convert_and_respect_annotation_metadata(
                    object_=sort, annotation=typing.Sequence[SortCriterion], direction="write"
                ),
                "page": page,
                "page_size": page_size,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListDealsResponse,
                    parse_obj_as(
                        type_=ListDealsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get(
        self, group_id: int, deal_id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[DealWithFilesResponse]:
        """
        Retrieve a deal by its ID.

        Parameters
        ----------
        group_id : int

        deal_id : int

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DealWithFilesResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/{jsonable_encoder(deal_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DealWithFilesResponse,
                    parse_obj_as(
                        type_=DealWithFilesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def update(
        self,
        group_id: int,
        deal_id: int,
        *,
        round_name: typing.Optional[str] = OMIT,
        notes: typing.Optional[str] = OMIT,
        priority: typing.Optional[Priority] = OMIT,
        status: typing.Optional[DealStatus] = OMIT,
        round_amount: typing.Optional[int] = OMIT,
        round_target: typing.Optional[int] = OMIT,
        tags: typing.Optional[typing.Sequence[str]] = OMIT,
        company_summary: typing.Optional[str] = OMIT,
        deal_lead_id: typing.Optional[int] = OMIT,
        company_id: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[DealWithFilesResponse]:
        """
        Update a deal.

        Parameters
        ----------
        group_id : int

        deal_id : int

        round_name : typing.Optional[str]

        notes : typing.Optional[str]
            Notes about the deal

        priority : typing.Optional[Priority]
            The priority of the deal

        status : typing.Optional[DealStatus]

        round_amount : typing.Optional[int]
            The dollar amount to be raised of the round

        round_target : typing.Optional[int]
            The target post-money dollar amount of the round

        tags : typing.Optional[typing.Sequence[str]]
            The tags associated with the deal

        company_summary : typing.Optional[str]
            The summary of the company

        deal_lead_id : typing.Optional[int]
            The id of the user who is the deal lead

        company_id : typing.Optional[int]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DealWithFilesResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/{jsonable_encoder(deal_id)}",
            method="PUT",
            json={
                "round_name": round_name,
                "notes": notes,
                "priority": priority,
                "status": status,
                "round_amount": round_amount,
                "round_target": round_target,
                "tags": tags,
                "company_summary": company_summary,
                "deal_lead_id": deal_lead_id,
                "company_id": company_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DealWithFilesResponse,
                    parse_obj_as(
                        type_=DealWithFilesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete(
        self,
        group_id: int,
        deal_id: int,
        *,
        archive: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Delete a deal.

        Parameters
        ----------
        group_id : int

        deal_id : int

        archive : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/{jsonable_encoder(deal_id)}",
            method="DELETE",
            params={
                "archive": archive,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def extra_metadata(
        self, group_id: int, deal_id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[DealExtraMetadataResponse]:
        """
        Retrieve extra metadata for a deal, such as questions and meeting times.

        Parameters
        ----------
        group_id : int

        deal_id : int

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DealExtraMetadataResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/{jsonable_encoder(deal_id)}/extra-metadata",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DealExtraMetadataResponse,
                    parse_obj_as(
                        type_=DealExtraMetadataResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def set_metadata(
        self,
        group_id: int,
        deal_id: int,
        metadata_tag: DealMetadataTag,
        *,
        request: Metadata,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[DealExtraMetadataResponse]:
        """
        Create or update questions for a deal. If questions already exist for this deal, they will be updated.
        If no questions exist, they will be created.


        Limitations:
        - The metadata payload cannot exceed 2048 characters.

        Parameters
        ----------
        group_id : int

        deal_id : int

        metadata_tag : DealMetadataTag

        request : Metadata

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DealExtraMetadataResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/{jsonable_encoder(deal_id)}/extra-metadata/{jsonable_encoder(metadata_tag)}",
            method="PUT",
            json=convert_and_respect_annotation_metadata(object_=request, annotation=Metadata, direction="write"),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DealExtraMetadataResponse,
                    parse_obj_as(
                        type_=DealExtraMetadataResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete_metadata(
        self,
        group_id: int,
        deal_id: int,
        metadata_tag: DealMetadataTag,
        *,
        archive: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Delete questions for a deal.

        Parameters
        ----------
        group_id : int

        deal_id : int

        metadata_tag : DealMetadataTag

        archive : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/{jsonable_encoder(deal_id)}/extra-metadata/{jsonable_encoder(metadata_tag)}",
            method="DELETE",
            params={
                "archive": archive,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def order(
        self, group_id: int, deal_id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Submit an order for a deal scan to be performed.

        Parameters
        ----------
        group_id : int

        deal_id : int

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/{jsonable_encoder(deal_id)}/order-scan",
            method="POST",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    parse_obj_as(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_comparable_deals(
        self,
        group_id: int,
        deal_id: int,
        *,
        category: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[DealWithFilesResponse]]:
        """
        Get deals comparable to the current deal.

        Categories are required for meaningful comparison. Only deals with overlapping categories
        will be returned. If the current deal has no categories, no comparable deals will be returned.

        Returns the top 5 most recent deals with overlapping categories, sorted by updated timestamp.

        Parameters
        ----------
        group_id : int

        deal_id : int

        category : typing.Optional[typing.Union[str, typing.Sequence[str]]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[DealWithFilesResponse]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/{jsonable_encoder(deal_id)}/comparable-deals",
            method="GET",
            params={
                "category": category,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[DealWithFilesResponse],
                    parse_obj_as(
                        type_=typing.List[DealWithFilesResponse],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawDealClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def advanced_search(
        self,
        *,
        filters: typing.Optional[DealSearchFilter] = OMIT,
        sort: typing.Optional[typing.Sequence[SortCriterion]] = OMIT,
        page: typing.Optional[int] = OMIT,
        page_size: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ListDealsResponse]:
        """
        Parameters
        ----------
        filters : typing.Optional[DealSearchFilter]

        sort : typing.Optional[typing.Sequence[SortCriterion]]
            Optional list of sort criteria. Earlier items take precedence. Each item must specify 'sort_by' (SortField, BenchmarkMetricField, or DateField enum) and 'sort_order'. 'sort_by' values must be unique.

        page : typing.Optional[int]
            Page number

        page_size : typing.Optional[int]
            Number of items per page

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ListDealsResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/deal/advanced-search",
            method="POST",
            json={
                "filters": convert_and_respect_annotation_metadata(
                    object_=filters, annotation=DealSearchFilter, direction="write"
                ),
                "sort": convert_and_respect_annotation_metadata(
                    object_=sort, annotation=typing.Sequence[SortCriterion], direction="write"
                ),
                "page": page,
                "page_size": page_size,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListDealsResponse,
                    parse_obj_as(
                        type_=ListDealsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def batch_lookup_deals(
        self,
        *,
        deal_ids: typing.Sequence[int],
        sort_by: typing.Optional[str] = None,
        sort_order: typing.Optional[str] = None,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ListDealsResponse]:
        """
        Batch lookup deals by IDs with pagination.

        Returns only deals the user has access to (via group membership OR direct deal access).
        Silently filters out deals without access (no errors for inaccessible deals).

        Super users can see all deals.

        Parameters
        ----------
        deal_ids : typing.Sequence[int]
            List of deal IDs to retrieve

        sort_by : typing.Optional[str]

        sort_order : typing.Optional[str]

        page : typing.Optional[int]

        page_size : typing.Optional[int]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ListDealsResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/deal/batch-lookup",
            method="POST",
            params={
                "sort_by": sort_by,
                "sort_order": sort_order,
                "page": page,
                "page_size": page_size,
            },
            json={
                "deal_ids": deal_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListDealsResponse,
                    parse_obj_as(
                        type_=ListDealsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def search_users(
        self,
        group_id: int,
        deal_id: int,
        *,
        text: typing.Optional[str] = None,
        only_direct: typing.Optional[bool] = None,
        sort_by: typing.Optional[str] = None,
        sort_order: typing.Optional[str] = None,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[PaginatedResponseUserMemberResponse]:
        """
        Search users who have access to this deal.

        Requires READER role or above on the deal. By default, users with either group or direct deal access are returned.
        Set `only_direct` to true to limit results to users with direct deal access only.

        Args:
            text: Optional case-insensitive search across user name and email

        Parameters
        ----------
        group_id : int

        deal_id : int

        text : typing.Optional[str]

        only_direct : typing.Optional[bool]
            When true, returns only users with direct access to the deal (excludes group access)

        sort_by : typing.Optional[str]

        sort_order : typing.Optional[str]

        page : typing.Optional[int]

        page_size : typing.Optional[int]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PaginatedResponseUserMemberResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/{jsonable_encoder(deal_id)}/search-users",
            method="GET",
            params={
                "text": text,
                "only_direct": only_direct,
                "sort_by": sort_by,
                "sort_order": sort_order,
                "page": page,
                "page_size": page_size,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PaginatedResponseUserMemberResponse,
                    parse_obj_as(
                        type_=PaginatedResponseUserMemberResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def set_user_deal_role(
        self,
        group_id: int,
        deal_id: int,
        user_id: int,
        *,
        role_name: typing.Optional[DefaultRole] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[DealUserAccessResponse]:
        """
        Set the user's direct access role for this deal.

        The user will always end up with exactly one direct role for the deal.
        Requires admin role to manage members.

        Parameters
        ----------
        group_id : int

        deal_id : int

        user_id : int

        role_name : typing.Optional[DefaultRole]
            The role to set for the user

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DealUserAccessResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/{jsonable_encoder(deal_id)}/users/{jsonable_encoder(user_id)}",
            method="PUT",
            json={
                "role_name": role_name,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DealUserAccessResponse,
                    parse_obj_as(
                        type_=DealUserAccessResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def remove_user_from_deal(
        self, group_id: int, deal_id: int, user_id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[None]:
        """
        Remove a user's direct access to this deal.
        Requires admin role to manage members.

        Parameters
        ----------
        group_id : int

        deal_id : int

        user_id : int

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/{jsonable_encoder(deal_id)}/users/{jsonable_encoder(user_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create(
        self,
        group_id: int,
        *,
        round_name: str,
        company_id: int,
        notes: typing.Optional[str] = OMIT,
        priority: typing.Optional[Priority] = OMIT,
        status: typing.Optional[DealStatus] = OMIT,
        round_amount: typing.Optional[int] = OMIT,
        round_target: typing.Optional[int] = OMIT,
        tags: typing.Optional[typing.Sequence[str]] = OMIT,
        company_summary: typing.Optional[str] = OMIT,
        deal_lead_id: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[DealWithFilesResponse]:
        """
        Create a new deal.

        Parameters
        ----------
        group_id : int

        round_name : str
            The name of the round

        company_id : int

        notes : typing.Optional[str]
            Notes about the deal

        priority : typing.Optional[Priority]
            The priority of the deal

        status : typing.Optional[DealStatus]
            The current status of the deal

        round_amount : typing.Optional[int]
            The dollar amount to be raised of the round

        round_target : typing.Optional[int]
            The target post-money dollar amount of the round

        tags : typing.Optional[typing.Sequence[str]]
            The tags associated with the deal

        company_summary : typing.Optional[str]
            The summary of the company

        deal_lead_id : typing.Optional[int]
            The id of the user who is the deal lead

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DealWithFilesResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal",
            method="POST",
            json={
                "round_name": round_name,
                "notes": notes,
                "priority": priority,
                "status": status,
                "round_amount": round_amount,
                "round_target": round_target,
                "tags": tags,
                "company_summary": company_summary,
                "deal_lead_id": deal_lead_id,
                "company_id": company_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DealWithFilesResponse,
                    parse_obj_as(
                        type_=DealWithFilesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list(
        self,
        group_id: int,
        *,
        sort_by: typing.Optional[str] = None,
        sort_order: typing.Optional[str] = None,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ListDealsResponse]:
        """
        Get all deals for a group.

        Parameters
        ----------
        group_id : int

        sort_by : typing.Optional[str]

        sort_order : typing.Optional[str]

        page : typing.Optional[int]

        page_size : typing.Optional[int]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ListDealsResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/all",
            method="GET",
            params={
                "sort_by": sort_by,
                "sort_order": sort_order,
                "page": page,
                "page_size": page_size,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListDealsResponse,
                    parse_obj_as(
                        type_=ListDealsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def search(
        self,
        group_id: int,
        *,
        round_name: typing.Optional[str] = None,
        notes: typing.Optional[str] = None,
        tags: typing.Optional[str] = None,
        company_name: typing.Optional[str] = None,
        company_domain: typing.Optional[str] = None,
        categories: typing.Optional[str] = None,
        deal_lead: typing.Optional[str] = None,
        ignore_archived: typing.Optional[bool] = None,
        sort_by: typing.Optional[str] = None,
        sort_order: typing.Optional[str] = None,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ListDealsResponse]:
        """
        Search deals within a group.

        Parameters
        ----------
        group_id : int

        round_name : typing.Optional[str]

        notes : typing.Optional[str]

        tags : typing.Optional[str]

        company_name : typing.Optional[str]

        company_domain : typing.Optional[str]

        categories : typing.Optional[str]

        deal_lead : typing.Optional[str]

        ignore_archived : typing.Optional[bool]

        sort_by : typing.Optional[str]

        sort_order : typing.Optional[str]

        page : typing.Optional[int]

        page_size : typing.Optional[int]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ListDealsResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/search",
            method="GET",
            params={
                "round_name": round_name,
                "notes": notes,
                "tags": tags,
                "company_name": company_name,
                "company_domain": company_domain,
                "categories": categories,
                "deal_lead": deal_lead,
                "ignore_archived": ignore_archived,
                "sort_by": sort_by,
                "sort_order": sort_order,
                "page": page,
                "page_size": page_size,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListDealsResponse,
                    parse_obj_as(
                        type_=ListDealsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def search_advanced(
        self,
        group_id: int,
        *,
        filters: typing.Optional[DealSearchFilter] = OMIT,
        sort: typing.Optional[typing.Sequence[SortCriterion]] = OMIT,
        page: typing.Optional[int] = OMIT,
        page_size: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ListDealsResponse]:
        """
        Search deals within a group using flexible filters.

        .. deprecated::
            This endpoint is deprecated and will be removed in favor of the /deal/advanced-search endpoint.

        Parameters
        ----------
        group_id : int

        filters : typing.Optional[DealSearchFilter]

        sort : typing.Optional[typing.Sequence[SortCriterion]]
            Optional list of sort criteria. Earlier items take precedence. Each item must specify 'sort_by' (SortField, BenchmarkMetricField, or DateField enum) and 'sort_order'. 'sort_by' values must be unique.

        page : typing.Optional[int]
            Page number

        page_size : typing.Optional[int]
            Number of items per page

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ListDealsResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/search-advanced",
            method="POST",
            json={
                "filters": convert_and_respect_annotation_metadata(
                    object_=filters, annotation=DealSearchFilter, direction="write"
                ),
                "sort": convert_and_respect_annotation_metadata(
                    object_=sort, annotation=typing.Sequence[SortCriterion], direction="write"
                ),
                "page": page,
                "page_size": page_size,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListDealsResponse,
                    parse_obj_as(
                        type_=ListDealsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get(
        self, group_id: int, deal_id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[DealWithFilesResponse]:
        """
        Retrieve a deal by its ID.

        Parameters
        ----------
        group_id : int

        deal_id : int

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DealWithFilesResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/{jsonable_encoder(deal_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DealWithFilesResponse,
                    parse_obj_as(
                        type_=DealWithFilesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def update(
        self,
        group_id: int,
        deal_id: int,
        *,
        round_name: typing.Optional[str] = OMIT,
        notes: typing.Optional[str] = OMIT,
        priority: typing.Optional[Priority] = OMIT,
        status: typing.Optional[DealStatus] = OMIT,
        round_amount: typing.Optional[int] = OMIT,
        round_target: typing.Optional[int] = OMIT,
        tags: typing.Optional[typing.Sequence[str]] = OMIT,
        company_summary: typing.Optional[str] = OMIT,
        deal_lead_id: typing.Optional[int] = OMIT,
        company_id: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[DealWithFilesResponse]:
        """
        Update a deal.

        Parameters
        ----------
        group_id : int

        deal_id : int

        round_name : typing.Optional[str]

        notes : typing.Optional[str]
            Notes about the deal

        priority : typing.Optional[Priority]
            The priority of the deal

        status : typing.Optional[DealStatus]

        round_amount : typing.Optional[int]
            The dollar amount to be raised of the round

        round_target : typing.Optional[int]
            The target post-money dollar amount of the round

        tags : typing.Optional[typing.Sequence[str]]
            The tags associated with the deal

        company_summary : typing.Optional[str]
            The summary of the company

        deal_lead_id : typing.Optional[int]
            The id of the user who is the deal lead

        company_id : typing.Optional[int]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DealWithFilesResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/{jsonable_encoder(deal_id)}",
            method="PUT",
            json={
                "round_name": round_name,
                "notes": notes,
                "priority": priority,
                "status": status,
                "round_amount": round_amount,
                "round_target": round_target,
                "tags": tags,
                "company_summary": company_summary,
                "deal_lead_id": deal_lead_id,
                "company_id": company_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DealWithFilesResponse,
                    parse_obj_as(
                        type_=DealWithFilesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete(
        self,
        group_id: int,
        deal_id: int,
        *,
        archive: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Delete a deal.

        Parameters
        ----------
        group_id : int

        deal_id : int

        archive : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/{jsonable_encoder(deal_id)}",
            method="DELETE",
            params={
                "archive": archive,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def extra_metadata(
        self, group_id: int, deal_id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[DealExtraMetadataResponse]:
        """
        Retrieve extra metadata for a deal, such as questions and meeting times.

        Parameters
        ----------
        group_id : int

        deal_id : int

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DealExtraMetadataResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/{jsonable_encoder(deal_id)}/extra-metadata",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DealExtraMetadataResponse,
                    parse_obj_as(
                        type_=DealExtraMetadataResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def set_metadata(
        self,
        group_id: int,
        deal_id: int,
        metadata_tag: DealMetadataTag,
        *,
        request: Metadata,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[DealExtraMetadataResponse]:
        """
        Create or update questions for a deal. If questions already exist for this deal, they will be updated.
        If no questions exist, they will be created.


        Limitations:
        - The metadata payload cannot exceed 2048 characters.

        Parameters
        ----------
        group_id : int

        deal_id : int

        metadata_tag : DealMetadataTag

        request : Metadata

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DealExtraMetadataResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/{jsonable_encoder(deal_id)}/extra-metadata/{jsonable_encoder(metadata_tag)}",
            method="PUT",
            json=convert_and_respect_annotation_metadata(object_=request, annotation=Metadata, direction="write"),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DealExtraMetadataResponse,
                    parse_obj_as(
                        type_=DealExtraMetadataResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete_metadata(
        self,
        group_id: int,
        deal_id: int,
        metadata_tag: DealMetadataTag,
        *,
        archive: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Delete questions for a deal.

        Parameters
        ----------
        group_id : int

        deal_id : int

        metadata_tag : DealMetadataTag

        archive : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/{jsonable_encoder(deal_id)}/extra-metadata/{jsonable_encoder(metadata_tag)}",
            method="DELETE",
            params={
                "archive": archive,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def order(
        self, group_id: int, deal_id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Submit an order for a deal scan to be performed.

        Parameters
        ----------
        group_id : int

        deal_id : int

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/{jsonable_encoder(deal_id)}/order-scan",
            method="POST",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    parse_obj_as(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_comparable_deals(
        self,
        group_id: int,
        deal_id: int,
        *,
        category: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[DealWithFilesResponse]]:
        """
        Get deals comparable to the current deal.

        Categories are required for meaningful comparison. Only deals with overlapping categories
        will be returned. If the current deal has no categories, no comparable deals will be returned.

        Returns the top 5 most recent deals with overlapping categories, sorted by updated timestamp.

        Parameters
        ----------
        group_id : int

        deal_id : int

        category : typing.Optional[typing.Union[str, typing.Sequence[str]]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[DealWithFilesResponse]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/{jsonable_encoder(deal_id)}/comparable-deals",
            method="GET",
            params={
                "category": category,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[DealWithFilesResponse],
                    parse_obj_as(
                        type_=typing.List[DealWithFilesResponse],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
