
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union, Optional as _Optional


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "util"

@_ods_cext.register_operation(_Dialect)
class AlignOp(_ods_ir.OpView):
  r"""
  Aligns |value| up to the given power-of-two |alignment| if required.
  """

  OPERATION_NAME = "util.align"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, alignment, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    operands.append(alignment)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def alignment(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def align(value, alignment, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AlignOp(value=value, alignment=alignment, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AssumeIntOp(_ods_ir.OpView):
  r"""
  This op is used to memorialize the result of some integer analysis or
  outside knowledge across a boundary beyond which such information can
  not be easily recovered. Assumptions are made per op/result pair.
  
  Assumptions are tied to operands as rows of permutations of an
  `#util.assume.int` per operand. The number of permutations is the rank.
  Typically multiple permutations record a specific subset of assumptions
  broken down per call-site in some way that is meaningful to the receiver.
  Implementations can use this information to specialize on each
  permutation if it is meaninful to do so (i.e. vs unioning across them).
  In such cases, there will typically be one such op at the top of a
  function or scope which passes all covered operands through it.
  """

  OPERATION_NAME = "util.assume.int"

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, operands_, assumptions, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["assumptions"] = (assumptions if (
    isinstance(assumptions, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Util_MultiValueIntAssumptionAttrList')) else
      _ods_ir.AttrBuilder.get('Util_MultiValueIntAssumptionAttrList')(assumptions, context=_ods_context))
    results = []
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def assumptions(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["assumptions"]

  @assumptions.setter
  def assumptions(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["assumptions"] = value

  @builtins.property
  def results_(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def assume_int(results_, operands_, assumptions, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, AssumeIntOp]:
  op = AssumeIntOp(results_=results_, operands_=operands_, assumptions=assumptions, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class BufferAllocOp(_ods_ir.OpView):
  r"""
  Allocates a buffer with undefined contents. Consumers of the allocated
  result must assume nothing of the contents.
  """

  OPERATION_NAME = "util.buffer.alloc"

  _ODS_REGIONS = (0, True)

  def __init__(self, storage_size, *, alignment=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(storage_size)
    _ods_context = _ods_get_default_loc_context(loc)
    if alignment is not None: attributes["alignment"] = (alignment if (
        isinstance(alignment, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('IndexAttr')) else
          _ods_ir.AttrBuilder.get('IndexAttr')(alignment, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def storage_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[0]

  @builtins.property
  def alignment(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "alignment" not in self.operation.attributes:
      return None
    return self.operation.attributes["alignment"]

  @alignment.setter
  def alignment(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["alignment"] = value
    elif "alignment" in self.operation.attributes:
      del self.operation.attributes["alignment"]

  @alignment.deleter
  def alignment(self):
    del self.operation.attributes["alignment"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def buffer_alloc(storage_size, *, alignment=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BufferAllocOp(storage_size=storage_size, alignment=alignment, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferCompareOp(_ods_ir.OpView):
  r"""
  Returns true if the two ranges are bitwise equivalent, somewhat like memcmp.
  """

  OPERATION_NAME = "util.buffer.compare"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, lhs_size, lhs_offset, rhs, rhs_size, rhs_offset, length, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(lhs_size)
    operands.append(lhs_offset)
    operands.append(rhs)
    operands.append(rhs_size)
    operands.append(rhs_offset)
    operands.append(length)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def lhs_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def lhs_offset(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[2]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def rhs_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[4]

  @builtins.property
  def rhs_offset(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[5]

  @builtins.property
  def length(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[6]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def buffer_compare(lhs, lhs_size, lhs_offset, rhs, rhs_size, rhs_offset, length, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BufferCompareOp(lhs=lhs, lhs_size=lhs_size, lhs_offset=lhs_offset, rhs=rhs, rhs_size=rhs_size, rhs_offset=rhs_offset, length=length, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferConstantOp(_ods_ir.OpView):
  r"""
  Defines a compile-time byte buffer based on the given attribute value.
  The attribute will be serialized into the canonical IREE format for the
  chosen host target.
  """

  OPERATION_NAME = "util.buffer.constant"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, *, name=None, alignment=None, mime_type=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if name is not None: attributes["name"] = (name if (
        isinstance(name, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Util_AnySerializableAttr')) else
      _ods_ir.AttrBuilder.get('Util_AnySerializableAttr')(value, context=_ods_context))
    if alignment is not None: attributes["alignment"] = (alignment if (
        isinstance(alignment, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('IndexAttr')) else
          _ods_ir.AttrBuilder.get('IndexAttr')(alignment, context=_ods_context))
    if mime_type is not None: attributes["mime_type"] = (mime_type if (
        isinstance(mime_type, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(mime_type, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def name(self) -> _Optional[_ods_ir.StringAttr]:
    if "name" not in self.operation.attributes:
      return None
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["name"] = value
    elif "name" in self.operation.attributes:
      del self.operation.attributes["name"]

  @name.deleter
  def name(self):
    del self.operation.attributes["name"]

  @builtins.property
  def value(self) -> _ods_ir.Attribute:
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def alignment(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "alignment" not in self.operation.attributes:
      return None
    return self.operation.attributes["alignment"]

  @alignment.setter
  def alignment(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["alignment"] = value
    elif "alignment" in self.operation.attributes:
      del self.operation.attributes["alignment"]

  @alignment.deleter
  def alignment(self):
    del self.operation.attributes["alignment"]

  @builtins.property
  def mime_type(self) -> _Optional[_ods_ir.StringAttr]:
    if "mime_type" not in self.operation.attributes:
      return None
    return self.operation.attributes["mime_type"]

  @mime_type.setter
  def mime_type(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["mime_type"] = value
    elif "mime_type" in self.operation.attributes:
      del self.operation.attributes["mime_type"]

  @mime_type.deleter
  def mime_type(self):
    del self.operation.attributes["mime_type"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def buffer_constant(value, *, name=None, alignment=None, mime_type=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BufferConstantOp(value=value, name=name, alignment=alignment, mime_type=mime_type, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferCopyOp(_ods_ir.OpView):
  r"""
  Copies a range of bytes as with memcpy (no overlapping).
  """

  OPERATION_NAME = "util.buffer.copy"

  _ODS_REGIONS = (0, True)

  def __init__(self, source, source_size, source_offset, target, target_size, target_offset, length, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(source_size)
    operands.append(source_offset)
    operands.append(target)
    operands.append(target_size)
    operands.append(target_offset)
    operands.append(length)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def source_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def source_offset(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[2]

  @builtins.property
  def target(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def target_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[4]

  @builtins.property
  def target_offset(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[5]

  @builtins.property
  def length(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[6]

def buffer_copy(source, source_size, source_offset, target, target_size, target_offset, length, *, loc=None, ip=None) -> BufferCopyOp:
  return BufferCopyOp(source=source, source_size=source_size, source_offset=source_offset, target=target, target_size=target_size, target_offset=target_offset, length=length, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class BufferDeallocOp(_ods_ir.OpView):
  r"""
  Hints that the buffer contents can be discarded. Buffers are reference
  counted and other owners may keep it live beyond the dealloc.
  """

  OPERATION_NAME = "util.buffer.dealloc"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, operand_size, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    operands.append(operand_size)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

def buffer_dealloc(operand, operand_size, *, loc=None, ip=None) -> BufferDeallocOp:
  return BufferDeallocOp(operand=operand, operand_size=operand_size, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class BufferFillOp(_ods_ir.OpView):
  r"""
  Fills the contents of the buffer in the given byte range with a pattern.
  The offset and length must match the natural alignment of the pattern type.
  """

  OPERATION_NAME = "util.buffer.fill"

  _ODS_REGIONS = (0, True)

  def __init__(self, pattern, target, target_size, target_offset, length, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(pattern)
    operands.append(target)
    operands.append(target_size)
    operands.append(target_offset)
    operands.append(length)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def pattern(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def target(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def target_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[2]

  @builtins.property
  def target_offset(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[3]

  @builtins.property
  def length(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[4]

def buffer_fill(pattern, target, target_size, target_offset, length, *, loc=None, ip=None) -> BufferFillOp:
  return BufferFillOp(pattern=pattern, target=target, target_size=target_size, target_offset=target_offset, length=length, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class BufferHashOp(_ods_ir.OpView):
  r"""
  Computes the SipHash-2-4 of a value at a byte offset with the given length.
  This always uses a seed of `0x0001020304...0e0f` and produces a single 64
  bit value.
  """

  OPERATION_NAME = "util.buffer.hash"

  _ODS_REGIONS = (0, True)

  def __init__(self, source, source_size, source_offset, length, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(source_size)
    operands.append(source_offset)
    operands.append(length)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def source_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def source_offset(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[2]

  @builtins.property
  def length(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[3]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def buffer_hash(source, source_size, source_offset, length, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BufferHashOp(source=source, source_size=source_size, source_offset=source_offset, length=length, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferLoadOp(_ods_ir.OpView):
  r"""
  Loads a value at a byte offset. Must be aligned to the natural size of the
  result type.
  """

  OPERATION_NAME = "util.buffer.load"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, source, source_size, source_offset, length, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(source_size)
    operands.append(source_offset)
    operands.append(length)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def source_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def source_offset(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[2]

  @builtins.property
  def length(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[3]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def buffer_load(result, source, source_size, source_offset, length, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return BufferLoadOp(result=result, source=source, source_size=source_size, source_offset=source_offset, length=length, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferSizeOp(_ods_ir.OpView):
  r"""
  Returns the total length of the buffer in bytes from its base offset.
  """

  OPERATION_NAME = "util.buffer.size"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IndexType]:
    return self.operation.results[0]

def buffer_size(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BufferSizeOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferSliceOp(_ods_ir.OpView):
  r"""
  Returns a copy of the contents from the source buffer.
  """

  OPERATION_NAME = "util.buffer.slice"

  _ODS_REGIONS = (0, True)

  def __init__(self, source, source_size, source_offset, result_size, *, alignment=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(source_size)
    operands.append(source_offset)
    operands.append(result_size)
    _ods_context = _ods_get_default_loc_context(loc)
    if alignment is not None: attributes["alignment"] = (alignment if (
        isinstance(alignment, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('IndexAttr')) else
          _ods_ir.AttrBuilder.get('IndexAttr')(alignment, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def source_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def source_offset(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[2]

  @builtins.property
  def result_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[3]

  @builtins.property
  def alignment(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "alignment" not in self.operation.attributes:
      return None
    return self.operation.attributes["alignment"]

  @alignment.setter
  def alignment(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["alignment"] = value
    elif "alignment" in self.operation.attributes:
      del self.operation.attributes["alignment"]

  @alignment.deleter
  def alignment(self):
    del self.operation.attributes["alignment"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def buffer_slice(source, source_size, source_offset, result_size, *, alignment=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BufferSliceOp(source=source, source_size=source_size, source_offset=source_offset, result_size=result_size, alignment=alignment, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferStorageOp(_ods_ir.OpView):
  r"""
  Returns the buffer storage as a memref that must be offset and restricted to
  the returned range. The memref may be of any type and the user is
  responsible for ensuring that the reinterpret_cast-like behavior makes sense
  for the data they are accessing.
  """

  OPERATION_NAME = "util.buffer.storage"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, offset, operand, operand_size, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    operands.append(operand_size)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    results.append(offset)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.MemRefType]:
    return self.operation.results[0]

  @builtins.property
  def offset(self) -> _ods_ir.OpResult[_ods_ir.IndexType]:
    return self.operation.results[1]

def buffer_storage(result, offset, operand, operand_size, *, loc=None, ip=None) -> _ods_ir.OpResultList:
  return BufferStorageOp(result=result, offset=offset, operand=operand, operand_size=operand_size, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class BufferStoreOp(_ods_ir.OpView):
  r"""
  Stores a value at a byte offset. Must be aligned to the natural size of the
  source type.
  """

  OPERATION_NAME = "util.buffer.store"

  _ODS_REGIONS = (0, True)

  def __init__(self, source, target, target_size, target_offset, length, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(target)
    operands.append(target_size)
    operands.append(target_offset)
    operands.append(length)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def target(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def target_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[2]

  @builtins.property
  def target_offset(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[3]

  @builtins.property
  def length(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[4]

def buffer_store(source, target, target_size, target_offset, length, *, loc=None, ip=None) -> BufferStoreOp:
  return BufferStoreOp(source=source, target=target, target_size=target_size, target_offset=target_offset, length=length, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class BufferSubspanOp(_ods_ir.OpView):
  r"""
  Returns a logical view into an underlying source buffer. This induces
  aliasing and multiple SSA values may allow access to the same underlying
  buffer storage.
  
  Subspans are a compiler-only concept and are propagated by an analysis pass
  to result in absolute offsets on accesses any place the subrange would have
  been used.
  """

  OPERATION_NAME = "util.buffer.subspan"

  _ODS_REGIONS = (0, True)

  def __init__(self, source, source_size, source_offset, result_size, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(source_size)
    operands.append(source_offset)
    operands.append(result_size)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def source_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def source_offset(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[2]

  @builtins.property
  def result_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[3]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def buffer_subspan(source, source_size, source_offset, result_size, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BufferSubspanOp(source=source, source_size=source_size, source_offset=source_offset, result_size=result_size, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CallOp(_ods_ir.OpView):
  r"""
  Represents a direct call to a function that is within the same symbol scope
  as the call. The operands and result types of the call must match the
  specified function type.
  
  Calls support tied operands which indicate that specific results alias
  a specific operand. The operand and result types are allowed to differ if
  a cast is performed within the callee.
  
  Example:
  ```mlir
  util.func @fn(%arg0: i32, %arg1: tensor<f32>) -> (f32, %arg1 as tensor<i32>)
  ...
  %0 = util.call @fn(%0, %1) : (i32, tensor<f32>) -> (f32, %1 as tensor<i32>)
  ```
  """

  OPERATION_NAME = "util.call"

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, callee, operands_, *, tied_operands=None, arg_attrs=None, res_attrs=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["callee"] = (callee if (
    isinstance(callee, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(callee, context=_ods_context))
    if tied_operands is not None: attributes["tied_operands"] = (tied_operands if (
        isinstance(tied_operands, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Util_TiedOpStorageAttr')) else
          _ods_ir.AttrBuilder.get('Util_TiedOpStorageAttr')(tied_operands, context=_ods_context))
    if arg_attrs is not None: attributes["arg_attrs"] = (arg_attrs if (
        isinstance(arg_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(arg_attrs, context=_ods_context))
    if res_attrs is not None: attributes["res_attrs"] = (res_attrs if (
        isinstance(res_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(res_attrs, context=_ods_context))
    results = []
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def callee(self) -> _ods_ir.FlatSymbolRefAttr:
    return self.operation.attributes["callee"]

  @callee.setter
  def callee(self, value: _ods_ir.FlatSymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["callee"] = value

  @builtins.property
  def tied_operands(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tied_operands" not in self.operation.attributes:
      return None
    return self.operation.attributes["tied_operands"]

  @tied_operands.setter
  def tied_operands(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tied_operands"] = value
    elif "tied_operands" in self.operation.attributes:
      del self.operation.attributes["tied_operands"]

  @tied_operands.deleter
  def tied_operands(self):
    del self.operation.attributes["tied_operands"]

  @builtins.property
  def arg_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "arg_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["arg_attrs"]

  @arg_attrs.setter
  def arg_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["arg_attrs"] = value
    elif "arg_attrs" in self.operation.attributes:
      del self.operation.attributes["arg_attrs"]

  @arg_attrs.deleter
  def arg_attrs(self):
    del self.operation.attributes["arg_attrs"]

  @builtins.property
  def res_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "res_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["res_attrs"]

  @res_attrs.setter
  def res_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["res_attrs"] = value
    elif "res_attrs" in self.operation.attributes:
      del self.operation.attributes["res_attrs"]

  @res_attrs.deleter
  def res_attrs(self):
    del self.operation.attributes["res_attrs"]

  @builtins.property
  def results_(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def call(results_, callee, operands_, *, tied_operands=None, arg_attrs=None, res_attrs=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, CallOp]:
  op = CallOp(results_=results_, callee=callee, operands_=operands_, tied_operands=tied_operands, arg_attrs=arg_attrs, res_attrs=res_attrs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class CastOp(_ods_ir.OpView):
  r"""
  Performs a type cast between object types known to the util dialect.
  """

  OPERATION_NAME = "util.cast"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cast(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CastOp(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpEQOp(_ods_ir.OpView):
  r"""
  Compares two operands for equality. This is intended for comparing IREE
  reference types (like !util.buffer) that cannot be used with std.cmpi.
  """

  OPERATION_NAME = "util.cmp.eq"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_eq(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpEQOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpNEOp(_ods_ir.OpView):
  r"""
  Compares two operands for inequality. This is intended for comparing IREE
  reference types (like !util.buffer) that cannot be used with std.cmpi.
  """

  OPERATION_NAME = "util.cmp.ne"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_ne(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpNEOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FuncOp(_ods_ir.OpView):
  r"""
  An operation declaring a callable function.
  
  An external function declaration (used when referring to a function declared
  in some other module) has no body.
  """

  OPERATION_NAME = "util.func"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, function_type, *, tied_operands=None, sym_visibility=None, arg_attrs=None, res_attrs=None, inlining_policy=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["function_type"] = (function_type if (
    isinstance(function_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_657')) else
      _ods_ir.AttrBuilder.get('anonymous_657')(function_type, context=_ods_context))
    if tied_operands is not None: attributes["tied_operands"] = (tied_operands if (
        isinstance(tied_operands, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Util_TiedOpStorageAttr')) else
          _ods_ir.AttrBuilder.get('Util_TiedOpStorageAttr')(tied_operands, context=_ods_context))
    if sym_visibility is not None: attributes["sym_visibility"] = (sym_visibility if (
        isinstance(sym_visibility, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(sym_visibility, context=_ods_context))
    if arg_attrs is not None: attributes["arg_attrs"] = (arg_attrs if (
        isinstance(arg_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(arg_attrs, context=_ods_context))
    if res_attrs is not None: attributes["res_attrs"] = (res_attrs if (
        isinstance(res_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(res_attrs, context=_ods_context))
    if inlining_policy is not None: attributes["inlining_policy"] = (inlining_policy if (
        isinstance(inlining_policy, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Util_InliningPolicyAttrInterface')) else
          _ods_ir.AttrBuilder.get('Util_InliningPolicyAttrInterface')(inlining_policy, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def function_type(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["function_type"]

  @function_type.setter
  def function_type(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["function_type"] = value

  @builtins.property
  def tied_operands(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tied_operands" not in self.operation.attributes:
      return None
    return self.operation.attributes["tied_operands"]

  @tied_operands.setter
  def tied_operands(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tied_operands"] = value
    elif "tied_operands" in self.operation.attributes:
      del self.operation.attributes["tied_operands"]

  @tied_operands.deleter
  def tied_operands(self):
    del self.operation.attributes["tied_operands"]

  @builtins.property
  def sym_visibility(self) -> _Optional[_ods_ir.StringAttr]:
    if "sym_visibility" not in self.operation.attributes:
      return None
    return self.operation.attributes["sym_visibility"]

  @sym_visibility.setter
  def sym_visibility(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["sym_visibility"] = value
    elif "sym_visibility" in self.operation.attributes:
      del self.operation.attributes["sym_visibility"]

  @sym_visibility.deleter
  def sym_visibility(self):
    del self.operation.attributes["sym_visibility"]

  @builtins.property
  def arg_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "arg_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["arg_attrs"]

  @arg_attrs.setter
  def arg_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["arg_attrs"] = value
    elif "arg_attrs" in self.operation.attributes:
      del self.operation.attributes["arg_attrs"]

  @arg_attrs.deleter
  def arg_attrs(self):
    del self.operation.attributes["arg_attrs"]

  @builtins.property
  def res_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "res_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["res_attrs"]

  @res_attrs.setter
  def res_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["res_attrs"] = value
    elif "res_attrs" in self.operation.attributes:
      del self.operation.attributes["res_attrs"]

  @res_attrs.deleter
  def res_attrs(self):
    del self.operation.attributes["res_attrs"]

  @builtins.property
  def inlining_policy(self) -> _Optional[_ods_ir.Attribute]:
    if "inlining_policy" not in self.operation.attributes:
      return None
    return self.operation.attributes["inlining_policy"]

  @inlining_policy.setter
  def inlining_policy(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["inlining_policy"] = value
    elif "inlining_policy" in self.operation.attributes:
      del self.operation.attributes["inlining_policy"]

  @inlining_policy.deleter
  def inlining_policy(self):
    del self.operation.attributes["inlining_policy"]

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def func(sym_name, function_type, *, tied_operands=None, sym_visibility=None, arg_attrs=None, res_attrs=None, inlining_policy=None, loc=None, ip=None) -> FuncOp:
  return FuncOp(sym_name=sym_name, function_type=function_type, tied_operands=tied_operands, sym_visibility=sym_visibility, arg_attrs=arg_attrs, res_attrs=res_attrs, inlining_policy=inlining_policy, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GlobalAddressOp(_ods_ir.OpView):
  r"""
  Returns the address of a global as a typed reference. Can be used with the
  global load and store indirect ops.
  """

  OPERATION_NAME = "util.global.address"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, global_, *, is_immutable=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["global"] = (global_ if (
    isinstance(global_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(global_, context=_ods_context))
    if bool(is_immutable): attributes["is_immutable"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def global_(self) -> _ods_ir.FlatSymbolRefAttr:
    return self.operation.attributes["global"]

  @global_.setter
  def global_(self, value: _ods_ir.FlatSymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["global"] = value

  @builtins.property
  def is_immutable(self) -> bool:
    return "is_immutable" in self.operation.attributes

  @is_immutable.setter
  def is_immutable(self, value):
    if bool(value):
      self.operation.attributes["is_immutable"] = _ods_ir.UnitAttr.get()
    elif "is_immutable" in self.operation.attributes:
      del self.operation.attributes["is_immutable"]

  @is_immutable.deleter
  def is_immutable(self):
    del self.operation.attributes["is_immutable"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def global_address(result, global_, *, is_immutable=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GlobalAddressOp(result=result, global_=global_, is_immutable=is_immutable, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GlobalLoadIndirectOp(_ods_ir.OpView):
  r"""
  Returns a copy of the global variable value.
  """

  OPERATION_NAME = "util.global.load.indirect"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, global_, *, is_immutable=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(global_)
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(is_immutable): attributes["is_immutable"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def global_(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def is_immutable(self) -> bool:
    return "is_immutable" in self.operation.attributes

  @is_immutable.setter
  def is_immutable(self, value):
    if bool(value):
      self.operation.attributes["is_immutable"] = _ods_ir.UnitAttr.get()
    elif "is_immutable" in self.operation.attributes:
      del self.operation.attributes["is_immutable"]

  @is_immutable.deleter
  def is_immutable(self):
    del self.operation.attributes["is_immutable"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def global_load_indirect(result, global_, *, is_immutable=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GlobalLoadIndirectOp(result=result, global_=global_, is_immutable=is_immutable, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GlobalLoadOp(_ods_ir.OpView):
  r"""
  Returns a global variable value. |is_immutable| is a reflection of the
  mutability of the loaded global to minimize the need to traverse symbol
  tables.
  """

  OPERATION_NAME = "util.global.load"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, global_, *, is_immutable=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["global"] = (global_ if (
    isinstance(global_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(global_, context=_ods_context))
    if bool(is_immutable): attributes["is_immutable"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def global_(self) -> _ods_ir.FlatSymbolRefAttr:
    return self.operation.attributes["global"]

  @global_.setter
  def global_(self, value: _ods_ir.FlatSymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["global"] = value

  @builtins.property
  def is_immutable(self) -> bool:
    return "is_immutable" in self.operation.attributes

  @is_immutable.setter
  def is_immutable(self, value):
    if bool(value):
      self.operation.attributes["is_immutable"] = _ods_ir.UnitAttr.get()
    elif "is_immutable" in self.operation.attributes:
      del self.operation.attributes["is_immutable"]

  @is_immutable.deleter
  def is_immutable(self):
    del self.operation.attributes["is_immutable"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def global_load(result, global_, *, is_immutable=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GlobalLoadOp(result=result, global_=global_, is_immutable=is_immutable, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GlobalOp(_ods_ir.OpView):
  r"""
  Declares a global variable that maintains its value across invocations.
  The value is tied to the execution context of the module and different
  contexts will have different variable storage.
  
  Globals can be initialized with an `initial_value` attribute that specifies
  their value at module initialization time. This initial value is evaluated
  in module definition order: a global with an initial value is considered
  initialized at its definition point in the module, not when first accessed.
  
  During module initialization:
  * Globals with `initial_value` attributes conceptually have their value
    materialized and stored before any subsequent initialization points
  * Initialization order follows module definition order exactly
  * Globals are visible to initializers but only after their definition point
  
  Example:
  ```mlir
  // A is initialized to 1 at this point in module initialization.
  util.global @A = 1 : i32
  
  // This initializer can read A (it's defined above).
  util.initializer {
    %a = util.global.load @A : i32  // Loads 1
  }
  
  // B is initialized to 2 here, after the above initializer runs.
  util.global @B = 2 : i32
  ```
  
  Globals marked as mutable can be modified by stores anywhere in the program.
  Immutable globals have strict initialization rules:
  * Can only be initialized once - either by `initial_value` or by stores
    in initializers, never both.
  * Stores to immutable globals are only allowed in:
    - `util.initializer` ops directly
    - Functions that are only called from initializers (initializer-only)
  * Stores from externally-reachable functions are forbidden.
  * Initialization must respect module order - initializers can only
    access globals defined before them.
  
  Stores to immutable globals inside control flow regions (scf.if, scf.for,
  scf.while, etc) in initializer-only functions will generate warnings as
  they may indicate complex initialization patterns that could be fragile:
  ```mlir
  util.func private @init_func() {
    scf.if %cond {
      // Warning: conditional store in initializer-only function
      util.global.store %val, @immutable_global : i32
    }
  }
  ```
  While such patterns are allowed they should be used with caution as the
  initialization behavior depends on runtime control flow and the compiler
  may disable optimizations on those globals.
  """

  OPERATION_NAME = "util.global"

  _ODS_REGIONS = (0, True)

  def __init__(self, sym_name, type_, *, sym_visibility=None, is_mutable=None, initial_value=None, inlining_policy=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if sym_visibility is not None: attributes["sym_visibility"] = (sym_visibility if (
        isinstance(sym_visibility, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(sym_visibility, context=_ods_context))
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["type"] = (type_ if (
    isinstance(type_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(type_, context=_ods_context))
    if bool(is_mutable): attributes["is_mutable"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if initial_value is not None: attributes["initial_value"] = (initial_value if (
        isinstance(initial_value, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('TypedAttrInterface')) else
          _ods_ir.AttrBuilder.get('TypedAttrInterface')(initial_value, context=_ods_context))
    if inlining_policy is not None: attributes["inlining_policy"] = (inlining_policy if (
        isinstance(inlining_policy, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Util_InliningPolicyAttrInterface')) else
          _ods_ir.AttrBuilder.get('Util_InliningPolicyAttrInterface')(inlining_policy, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_visibility(self) -> _Optional[_ods_ir.StringAttr]:
    if "sym_visibility" not in self.operation.attributes:
      return None
    return self.operation.attributes["sym_visibility"]

  @sym_visibility.setter
  def sym_visibility(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["sym_visibility"] = value
    elif "sym_visibility" in self.operation.attributes:
      del self.operation.attributes["sym_visibility"]

  @sym_visibility.deleter
  def sym_visibility(self):
    del self.operation.attributes["sym_visibility"]

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def type_(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["type"]

  @type_.setter
  def type_(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["type"] = value

  @builtins.property
  def is_mutable(self) -> bool:
    return "is_mutable" in self.operation.attributes

  @is_mutable.setter
  def is_mutable(self, value):
    if bool(value):
      self.operation.attributes["is_mutable"] = _ods_ir.UnitAttr.get()
    elif "is_mutable" in self.operation.attributes:
      del self.operation.attributes["is_mutable"]

  @is_mutable.deleter
  def is_mutable(self):
    del self.operation.attributes["is_mutable"]

  @builtins.property
  def initial_value(self) -> _Optional[_ods_ir.Attribute]:
    if "initial_value" not in self.operation.attributes:
      return None
    return self.operation.attributes["initial_value"]

  @initial_value.setter
  def initial_value(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["initial_value"] = value
    elif "initial_value" in self.operation.attributes:
      del self.operation.attributes["initial_value"]

  @initial_value.deleter
  def initial_value(self):
    del self.operation.attributes["initial_value"]

  @builtins.property
  def inlining_policy(self) -> _Optional[_ods_ir.Attribute]:
    if "inlining_policy" not in self.operation.attributes:
      return None
    return self.operation.attributes["inlining_policy"]

  @inlining_policy.setter
  def inlining_policy(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["inlining_policy"] = value
    elif "inlining_policy" in self.operation.attributes:
      del self.operation.attributes["inlining_policy"]

  @inlining_policy.deleter
  def inlining_policy(self):
    del self.operation.attributes["inlining_policy"]

def global_(sym_name, type_, *, sym_visibility=None, is_mutable=None, initial_value=None, inlining_policy=None, loc=None, ip=None) -> GlobalOp:
  return GlobalOp(sym_name=sym_name, type_=type_, sym_visibility=sym_visibility, is_mutable=is_mutable, initial_value=initial_value, inlining_policy=inlining_policy, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GlobalStoreIndirectOp(_ods_ir.OpView):
  r"""
  Stores a copy of the value into a global variable.
  """

  OPERATION_NAME = "util.global.store.indirect"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, global_, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    operands.append(global_)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def global_(self) -> _ods_ir.Value:
    return self.operation.operands[1]

def global_store_indirect(value, global_, *, loc=None, ip=None) -> GlobalStoreIndirectOp:
  return GlobalStoreIndirectOp(value=value, global_=global_, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GlobalStoreOp(_ods_ir.OpView):
  r"""
  Stores a copy of the value into a global variable.
  """

  OPERATION_NAME = "util.global.store"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, global_, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["global"] = (global_ if (
    isinstance(global_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(global_, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def global_(self) -> _ods_ir.FlatSymbolRefAttr:
    return self.operation.attributes["global"]

  @global_.setter
  def global_(self, value: _ods_ir.FlatSymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["global"] = value

def global_store(value, global_, *, loc=None, ip=None) -> GlobalStoreOp:
  return GlobalStoreOp(value=value, global_=global_, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class InitializerOp(_ods_ir.OpView):
  r"""
  A function that is called in definition order upon module initialization.
  Must not load any globals that are defined or initialized after it in the
  module.
  
  Module initialization follows a strict execution order to ensure
  correctness:
  * Initialization points: two types of operations define initialization:
    - `util.initializer` ops: explicit initialization functions
    - `util.global` ops with initial values: implicit initialization via
      attributes
  * Execution order: initialization proceeds in exact module definition order:
    - Operations execute sequentially from top to bottom
    - Each `util.global` with an initial value conceptually materializes its
      value and stores it before the next initialization point
    - Each `util.initializer` executes its entire body before proceeding
  * Dependency rules:
    - Initializers may only access globals defined before them in module order
    - Globals with initial values are considered "initialized" at their
      definition point, not when first accessed
    - Function calls within initializers observe the current initialization
      state when the call is made
  * Transformation guarantees:
    - Combining passes preserve exact initialization order
    - Globals with initial values may be converted to explicit initialization
      while maintaining their position in the initialization sequence
    - The final initialization state must be identical to sequential execution
  
  Example execution:
  ```mlir
  util.global @A = 1 : i32           // A = 1
  util.initializer { ... }           // Executes with A = 1
  util.global @B = 2 : i32           // B = 2
  util.initializer {
    %a = util.global.load @A : i32   // Loads 1
    %b = util.global.load @B : i32   // Loads 2
  }
  ```
  """

  OPERATION_NAME = "util.initializer"

  _ODS_REGIONS = (1, True)

  def __init__(self, function_type, *, arg_attrs=None, res_attrs=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["function_type"] = (function_type if (
    isinstance(function_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_657')) else
      _ods_ir.AttrBuilder.get('anonymous_657')(function_type, context=_ods_context))
    if arg_attrs is not None: attributes["arg_attrs"] = (arg_attrs if (
        isinstance(arg_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(arg_attrs, context=_ods_context))
    if res_attrs is not None: attributes["res_attrs"] = (res_attrs if (
        isinstance(res_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(res_attrs, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def function_type(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["function_type"]

  @function_type.setter
  def function_type(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["function_type"] = value

  @builtins.property
  def arg_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "arg_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["arg_attrs"]

  @arg_attrs.setter
  def arg_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["arg_attrs"] = value
    elif "arg_attrs" in self.operation.attributes:
      del self.operation.attributes["arg_attrs"]

  @arg_attrs.deleter
  def arg_attrs(self):
    del self.operation.attributes["arg_attrs"]

  @builtins.property
  def res_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "res_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["res_attrs"]

  @res_attrs.setter
  def res_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["res_attrs"] = value
    elif "res_attrs" in self.operation.attributes:
      del self.operation.attributes["res_attrs"]

  @res_attrs.deleter
  def res_attrs(self):
    del self.operation.attributes["res_attrs"]

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def initializer(function_type, *, arg_attrs=None, res_attrs=None, loc=None, ip=None) -> InitializerOp:
  return InitializerOp(function_type=function_type, arg_attrs=arg_attrs, res_attrs=res_attrs, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ListConstructOp(_ods_ir.OpView):
  r"""
  Creates a new list with the given values added in order. The list will be
  allocated with an initial capacity equal to the number of values. This is a
  pseudo-operation that expands to a list create, resize, and a series of
  sets.
  """

  OPERATION_NAME = "util.list.construct"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, values, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(values))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def values(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def list_construct(result, values, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ListConstructOp(result=result, values=values, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ListCreateOp(_ods_ir.OpView):
  r"""
  Creates a new empty list with an optional initial capacity.
  """

  OPERATION_NAME = "util.list.create"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, *, initial_capacity=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    if initial_capacity is not None: operands.append(initial_capacity)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def initial_capacity(self) -> _Optional[_ods_ir.Value[_ods_ir.IndexType]]:
    return None if len(self.operation.operands) < 1 else self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def list_create(result, *, initial_capacity=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ListCreateOp(result=result, initial_capacity=initial_capacity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ListGetOp(_ods_ir.OpView):
  r"""
  Returns the value of the element at the given index. Note that the value
  may be null if the element is null or the type does not match.
  """

  OPERATION_NAME = "util.list.get"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, list, index, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(list)
    operands.append(index)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def list(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def index(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def list_get(result, list, index, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ListGetOp(result=result, list=list, index=index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ListResizeOp(_ods_ir.OpView):
  r"""
  Resizes the list to contain `new_size` elements. This will either truncate
  the list if the existing size is greater than `new_size` or extend the list
  with the default list value of the element type.
  """

  OPERATION_NAME = "util.list.resize"

  _ODS_REGIONS = (0, True)

  def __init__(self, list, new_size, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(list)
    operands.append(new_size)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def list(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def new_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

def list_resize(list, new_size, *, loc=None, ip=None) -> ListResizeOp:
  return ListResizeOp(list=list, new_size=new_size, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ListSetOp(_ods_ir.OpView):
  r"""
  Sets the element at the given index to the new value.
  """

  OPERATION_NAME = "util.list.set"

  _ODS_REGIONS = (0, True)

  def __init__(self, list, index, value, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(list)
    operands.append(index)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def list(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def index(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[2]

def list_set(list, index, value, *, loc=None, ip=None) -> ListSetOp:
  return ListSetOp(list=list, index=index, value=value, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ListSizeOp(_ods_ir.OpView):
  r"""
  Returns the current size of the list in elements.
  """

  OPERATION_NAME = "util.list.size"

  _ODS_REGIONS = (0, True)

  def __init__(self, list, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(list)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def list(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IndexType]:
    return self.operation.results[0]

def list_size(list, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ListSizeOp(list=list, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class NullOp(_ods_ir.OpView):
  r"""
  Defines an SSA value that is lowered into dialects supporting
  null/undefined/optional/etc values.
  """

  OPERATION_NAME = "util.null"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def null(result, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return NullOp(result=result, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class NumericOptionalNarrowOp(_ods_ir.OpView):
  r"""
  Serves as a placeholder for points in the computation where an optional
  numeric narrowing can be performed without loss of information. Such ops
  can guide optimization passes wishing to perform precision reduction.
  
  In addition to the operand and result type, this op takes an additional
  `semantic_type` attribute representing the semantic target type which can
  be:
    * FloatType
    * Signed IntegerType
    * Unsigned IntegerType
  
  Note that this `semantic_type` must be a sign-carrying integer if using an
  integer type and cannot be IndexType (i.e. it can be used to indicate a
  possible narrowing of an IndexType to a specific integer).
  
  If the operand is a TensorType, then the result must be a TensorType. The
  `semantic_type` constrains the element type.
  
  Optionally, the minimum and maximum integer values (for integer semantic
  types) are tracked if known.
  """

  OPERATION_NAME = "util.numeric.optional_narrow"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, semantic_type, *, min_value=None, max_value=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["semantic_type"] = (semantic_type if (
    isinstance(semantic_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(semantic_type, context=_ods_context))
    if min_value is not None: attributes["min_value"] = (min_value if (
        isinstance(min_value, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('APIntAttr')) else
          _ods_ir.AttrBuilder.get('APIntAttr')(min_value, context=_ods_context))
    if max_value is not None: attributes["max_value"] = (max_value if (
        isinstance(max_value, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('APIntAttr')) else
          _ods_ir.AttrBuilder.get('APIntAttr')(max_value, context=_ods_context))
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def semantic_type(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["semantic_type"]

  @semantic_type.setter
  def semantic_type(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["semantic_type"] = value

  @builtins.property
  def min_value(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "min_value" not in self.operation.attributes:
      return None
    return self.operation.attributes["min_value"]

  @min_value.setter
  def min_value(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["min_value"] = value
    elif "min_value" in self.operation.attributes:
      del self.operation.attributes["min_value"]

  @min_value.deleter
  def min_value(self):
    del self.operation.attributes["min_value"]

  @builtins.property
  def max_value(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "max_value" not in self.operation.attributes:
      return None
    return self.operation.attributes["max_value"]

  @max_value.setter
  def max_value(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["max_value"] = value
    elif "max_value" in self.operation.attributes:
      del self.operation.attributes["max_value"]

  @max_value.deleter
  def max_value(self):
    del self.operation.attributes["max_value"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def numeric_optional_narrow(operand, semantic_type, *, min_value=None, max_value=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return NumericOptionalNarrowOp(operand=operand, semantic_type=semantic_type, min_value=min_value, max_value=max_value, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class OptimizationBarrierOp(_ods_ir.OpView):
  r"""
  Wraps any operands in an unoptimizable identity to prevent its results from
  being folded. It will be dropped during the final step in compilation and
  has no effect at runtime.
  """

  OPERATION_NAME = "util.optimization_barrier"

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, operands_, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def results_(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def optimization_barrier(results_, operands_, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, OptimizationBarrierOp]:
  op = OptimizationBarrierOp(results_=results_, operands_=operands_, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class RangeExtentsOp(_ods_ir.OpView):
  r"""
  Computes min(offsets) and max(offsets + lengths). Though it's possible to
  express this with standard arithmetic this op enables more semantically
  meaningful folding/optimizations.
  """

  OPERATION_NAME = "util.range.extents"

  _ODS_REGIONS = (0, True)

  def __init__(self, offsets, lengths, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(offsets))
    operands.extend(_get_op_results_or_values(lengths))
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 2
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def offsets(self) -> _ods_ir.OpOperandList:
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 0, 2, 0, 0)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def lengths(self) -> _ods_ir.OpOperandList:
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 0, 2, 0, 1)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def min(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

  @builtins.property
  def max(self) -> _ods_ir.OpResult:
    return self.operation.results[1]

def range_extents(offsets, lengths, *, results=None, loc=None, ip=None) -> _ods_ir.OpResultList:
  return RangeExtentsOp(offsets=offsets, lengths=lengths, results=results, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class RangeMaxOp(_ods_ir.OpView):
  r"""
  Computes the max of a variadic list of operands. Though it's possible to
  express this with standard arithmetic this op enables more semantically
  meaningful folding/optimizations.
  """

  OPERATION_NAME = "util.range.max"

  _ODS_REGIONS = (0, True)

  def __init__(self, operands_, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def range_max(operands_, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return RangeMaxOp(operands_=operands_, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RangeMinOp(_ods_ir.OpView):
  r"""
  Computes the min of a variadic list of operands. Though it's possible to
  express this with standard arithmetic this op enables more semantically
  meaningful folding/optimizations.
  """

  OPERATION_NAME = "util.range.min"

  _ODS_REGIONS = (0, True)

  def __init__(self, operands_, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def range_min(operands_, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return RangeMinOp(operands_=operands_, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ReturnOp(_ods_ir.OpView):
  r"""
  Returns control from an initializer function.
  """

  OPERATION_NAME = "util.return"

  _ODS_REGIONS = (0, True)

  def __init__(self, operands_, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def return_(operands_, *, loc=None, ip=None) -> ReturnOp:
  return ReturnOp(operands_=operands_, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class SCFUnreachableOp(_ods_ir.OpView):
  r"""
  Marks a point as unreachable within SCF regions. Unlike `util.unreachable`
  this is not a terminator and must be followed by appropriate region
  terminators (e.g. `scf.yield`).
  
  When not in an SCF region (e.g. `util.func`) this op canonicalizes to an
  `util.unreachable` terminator that preserves the intended behavior.
  
  Note that this op has side effects to prevent code motion: reaching this op
  at runtime is observable indirectly (by way of what ops _don't_ execute). At
  minimum presence of the op indicates all following ops in the same region
  are unreachable and depending on the parent op may indicate the entire
  parent op is unreachable. The behavior is roughly equivalent to having
  lowered SCF to CFG and used `util.unreachable`.
  
  Example:
  ```mlir
  scf.while (...) {
    ...
    scf.condition(%true) ...
  } do {
    ...
    util.scf.unreachable "infinite loop body"
    scf.yield  // Required terminator with poison values
  }
  ```
  """

  OPERATION_NAME = "util.scf.unreachable"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, message=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if message is not None: attributes["message"] = (message if (
        isinstance(message, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(message, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def message(self) -> _Optional[_ods_ir.StringAttr]:
    if "message" not in self.operation.attributes:
      return None
    return self.operation.attributes["message"]

  @message.setter
  def message(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["message"] = value
    elif "message" in self.operation.attributes:
      del self.operation.attributes["message"]

  @message.deleter
  def message(self):
    del self.operation.attributes["message"]

def scf_unreachable(*, message=None, loc=None, ip=None) -> SCFUnreachableOp:
  return SCFUnreachableOp(message=message, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class SizeOfOp(_ods_ir.OpView):
  r"""
  Most datatypes have a static size at all layers of the compilation stack.
  However, those that only have a size for certain lowering flows can be
  challenging. This op represents such sizes in a way that can be specialized
  later.
  
  Returns the size in bytes, rounded up to the next whole byte of the
  specified type. This op will fold to a constant index value for IntegerType
  and FloatType. All others are not folded.
  """

  OPERATION_NAME = "util.sizeof"

  _ODS_REGIONS = (0, True)

  def __init__(self, sizedType, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sizedType"] = (sizedType if (
    isinstance(sizedType, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(sizedType, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sizedType(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["sizedType"]

  @sizedType.setter
  def sizedType(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sizedType"] = value

  @builtins.property
  def size(self) -> _ods_ir.OpResult[_ods_ir.IndexType]:
    return self.operation.results[0]

def sizeof(sized_type, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return SizeOfOp(sizedType=sized_type, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class StatusCheckOkOp(_ods_ir.OpView):
  r"""
  When the status is not 'ok' this signals a runtime failure that causes the
  entire active invocation - and possibly *all* in-flight and pending
  invocations - to fail with the given status. The status will be propagated
  back via the available runtime error handling mechanisms such as semaphores
  or synchronous invocation results.
  
  As the IREE execution model is deeply pipelined it's possible that failures
  have a latency between when they are emitted and when the application can
  observe the failure. It's also possible that other work that is in-flight
  or pending when the failure occurs will complete.
  """

  OPERATION_NAME = "util.status.check_ok"

  _ODS_REGIONS = (0, True)

  def __init__(self, status, *, message=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(status)
    _ods_context = _ods_get_default_loc_context(loc)
    if message is not None: attributes["message"] = (message if (
        isinstance(message, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(message, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def status(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def message(self) -> _Optional[_ods_ir.StringAttr]:
    if "message" not in self.operation.attributes:
      return None
    return self.operation.attributes["message"]

  @message.setter
  def message(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["message"] = value
    elif "message" in self.operation.attributes:
      del self.operation.attributes["message"]

  @message.deleter
  def message(self):
    del self.operation.attributes["message"]

def status_check_ok(status, *, message=None, loc=None, ip=None) -> StatusCheckOkOp:
  return StatusCheckOkOp(status=status, message=message, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class SwitchOp(_ods_ir.OpView):
  r"""
  Returns the value with the given `index` in `values` or `default_value` if
  the index is out of bounds.
  
  ```mlir
  // Switch %index to cases of %c100/%c200/%c300 if index==0, ==1, ==2.
  // If %index is out of range (<0 or >2) then default to %c5.
  %0 = util.switch %index[%c100, %c200, %c300] else %c5 : i32
  ```
  """

  OPERATION_NAME = "util.switch"

  _ODS_REGIONS = (0, True)

  def __init__(self, index, default_value, values, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(index)
    operands.append(default_value)
    operands.extend(_get_op_results_or_values(values))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def index(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[0]

  @builtins.property
  def default_value(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def values(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[2:2 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def switch(index, default_value, values, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return SwitchOp(index=index, default_value=default_value, values=values, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class UnfoldableConstantOp(_ods_ir.OpView):
  r"""
  Similar to a std.constant, but is declared as having a side effect and has
  no folder. This is really just syntactic sugar as it is canonicalized to a
  std.constant wrapped in an util.optimization_barrier.
  """

  OPERATION_NAME = "util.unfoldable_constant"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, value, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AnyAttr')) else
      _ods_ir.AttrBuilder.get('AnyAttr')(value, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Attribute:
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

def unfoldable_constant(result, value, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return UnfoldableConstantOp(result=result, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class UnreachableOp(_ods_ir.OpView):
  r"""
  Signals to the compiler that the parent block should not be reachable.
  This may be converted into a runtime assertion, though ideally they are
  stripped during translation.
  
  ```mlir
  ^bb0:
    %true = arith.constant true
    cond_br %true, ^bb2, ^bb1
  ^bb1:
    // Indicates that this branch should never be taken.
    util.unreachable "shouldn't be here"
  ^bb2:
    ...
  
  ```
  """

  OPERATION_NAME = "util.unreachable"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, message=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if message is not None: attributes["message"] = (message if (
        isinstance(message, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(message, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def message(self) -> _Optional[_ods_ir.StringAttr]:
    if "message" not in self.operation.attributes:
      return None
    return self.operation.attributes["message"]

  @message.setter
  def message(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["message"] = value
    elif "message" in self.operation.attributes:
      del self.operation.attributes["message"]

  @message.deleter
  def message(self):
    del self.operation.attributes["message"]

def unreachable(*, message=None, loc=None, ip=None) -> UnreachableOp:
  return UnreachableOp(message=message, loc=loc, ip=ip)
