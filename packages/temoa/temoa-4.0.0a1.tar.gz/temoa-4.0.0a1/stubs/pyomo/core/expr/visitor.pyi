import inspect
from collections.abc import Generator

from _typeshed import Incomplete
from pyomo.common.deprecation import deprecated as deprecated
from pyomo.common.deprecation import deprecation_warning as deprecation_warning
from pyomo.common.errors import DeveloperError as DeveloperError
from pyomo.common.errors import TemplateExpressionError as TemplateExpressionError
from pyomo.common.numeric_types import native_numeric_types as native_numeric_types
from pyomo.common.numeric_types import native_types as native_types
from pyomo.common.numeric_types import nonpyomo_leaf_types as nonpyomo_leaf_types
from pyomo.common.numeric_types import value as value
from pyomo.core.expr.symbol_map import SymbolMap as SymbolMap

logger: Incomplete
currentframe: Incomplete
currentframe = inspect.currentframe

def get_stack_depth(): ...

RECURSION_LIMIT: int

class RevertToNonrecursive(Exception): ...

class StreamBasedExpressionVisitor:
    client_methods: Incomplete
    recursion_stack: Incomplete
    def __init__(self, **kwds) -> None: ...
    def walk_expression(self, expr): ...
    def walk_expression_nonrecursive(self, expr): ...

class SimpleExpressionVisitor:
    def visit(self, node) -> None: ...
    def finalize(self) -> None: ...
    def xbfs(self, node): ...
    def xbfs_yield_leaves(self, node) -> Generator[Incomplete]: ...

class ExpressionValueVisitor:
    def visit(self, node, values) -> None: ...
    def visiting_potential_leaf(self, node) -> None: ...
    def finalize(self, ans): ...
    def dfs_postorder_stack(self, node): ...

def replace_expressions(
    expr,
    substitution_map,
    descend_into_named_expressions: bool = True,
    remove_named_expressions: bool = True,
): ...

class ExpressionReplacementVisitor(StreamBasedExpressionVisitor):
    substitute: Incomplete
    enter_named_expr: Incomplete
    rm_named_expr: Incomplete
    def __init__(
        self,
        substitute=None,
        descend_into_named_expressions: bool = True,
        remove_named_expressions: bool = True,
    ) -> None: ...
    def initializeWalker(self, expr): ...
    def beforeChild(self, node, child, child_idx): ...
    def enterNode(self, node): ...
    def acceptChildResult(self, node, data, child_result, child_idx): ...
    def exitNode(self, node, data): ...
    def dfs_postorder_stack(self, expr): ...

def evaluate_fixed_subexpressions(
    expr, descend_into_named_expressions: bool = True, remove_named_expressions: bool = True
): ...

class EvaluateFixedSubexpressionVisitor(ExpressionReplacementVisitor):
    def __init__(
        self, descend_into_named_expressions: bool = False, remove_named_expressions: bool = False
    ) -> None: ...
    def beforeChild(self, node, child, child_idx): ...

def clone_expression(expr, substitute=None): ...
def sizeof_expression(expr): ...

class _EvaluationVisitor(ExpressionValueVisitor):
    exception: Incomplete
    def __init__(self, exception) -> None: ...
    def visit(self, node, values): ...
    def visiting_potential_leaf(self, node): ...

class FixedExpressionError(Exception):
    def __init__(self, *args, **kwds) -> None: ...

class NonConstantExpressionError(Exception):
    def __init__(self, *args, **kwds) -> None: ...

class _EvaluateConstantExpressionVisitor(ExpressionValueVisitor):
    def visit(self, node, values): ...
    def visiting_potential_leaf(self, node): ...

def evaluate_expression(exp, exception: bool = True, constant: bool = False): ...

class _ComponentVisitor(StreamBasedExpressionVisitor):
    def __init__(self, types) -> None: ...
    def initializeWalker(self, expr): ...
    def finalizeResult(self, result): ...
    def exitNode(self, node, data) -> None: ...

def identify_components(expr, component_types) -> Generator[Incomplete, Incomplete]: ...

class IdentifyVariableVisitor(StreamBasedExpressionVisitor):
    def __init__(self, include_fixed: bool = False, named_expression_cache=None) -> None: ...
    def initializeWalker(self, expr): ...
    def beforeChild(self, parent, child, index): ...
    def exitNode(self, node, data) -> None: ...
    def finalizeResult(self, result): ...

def identify_variables(
    expr, include_fixed: bool = True, named_expression_cache=None
) -> Generator[Incomplete, Incomplete]: ...

class IdentifyMutableParamVisitor(IdentifyVariableVisitor):
    def __init__(self) -> None: ...
    def beforeChild(self, parent, child, index): ...

def identify_mutable_parameters(expr) -> Generator[Incomplete, Incomplete]: ...

class _PolynomialDegreeVisitor(ExpressionValueVisitor):
    def visit(self, node, values): ...
    def visiting_potential_leaf(self, node): ...

def polynomial_degree(node): ...

class _IsFixedVisitor(ExpressionValueVisitor):
    def visit(self, node, values): ...
    def visiting_potential_leaf(self, node): ...

LEFT_TO_RIGHT: Incomplete
RIGHT_TO_LEFT: Incomplete

class _ToStringVisitor(ExpressionValueVisitor):
    verbose: Incomplete
    smap: Incomplete
    def __init__(self, verbose, smap) -> None: ...
    def visit(self, node, values): ...
    def visiting_potential_leaf(self, node): ...

def expression_to_string(
    expr, verbose=None, labeler=None, smap=None, compute_values: bool = False
): ...
