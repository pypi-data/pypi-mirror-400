"""
Tests for Rust resolver.
"""

from unittest.mock import MagicMock, patch

import pytest

from oss_sustain_guard.resolvers.rust import RustResolver


class TestRustResolver:
    """Test RustResolver class."""

    def test_ecosystem_name(self):
        """Test ecosystem name."""
        resolver = RustResolver()
        assert resolver.ecosystem_name == "rust"

    async def test_get_manifest_files(self):
        """Test manifest files for Rust."""
        resolver = RustResolver()
        manifests = await resolver.get_manifest_files()
        assert "Cargo.toml" in manifests

    @patch("httpx.AsyncClient.get")
    async def test_resolve_github_url_success(self, mock_get):
        """Test resolving GitHub URL from crates.io."""
        mock_response = MagicMock()
        mock_response.json.return_value = {
            "crate": {
                "repository": "https://github.com/tokio-rs/tokio",
            }
        }
        mock_get.return_value = mock_response

        resolver = RustResolver()
        result = await resolver.resolve_github_url("tokio")
        assert result == ("tokio-rs", "tokio")

    @patch("httpx.AsyncClient.get")
    async def test_resolve_github_url_with_git_suffix(self, mock_get):
        """Test resolving URL with .git suffix."""
        mock_response = MagicMock()
        mock_response.json.return_value = {
            "crate": {
                "repository": "https://github.com/serde-rs/serde.git",
            }
        }
        mock_get.return_value = mock_response

        resolver = RustResolver()
        result = await resolver.resolve_github_url("serde")
        assert result == ("serde-rs", "serde")

    @patch("httpx.AsyncClient.get")
    async def test_resolve_github_url_not_found(self, mock_get):
        """Test resolving crate with no GitHub URL."""
        mock_response = MagicMock()
        mock_response.json.return_value = {
            "crate": {
                "repository": None,
            }
        }
        mock_get.return_value = mock_response

        resolver = RustResolver()
        result = await resolver.resolve_github_url("some-crate")
        assert result is None

    @patch("httpx.AsyncClient.get")
    async def test_resolve_github_url_network_error(self, mock_get):
        """Test resolving with network error."""
        import httpx

        mock_get.side_effect = httpx.RequestError("Network error")

        resolver = RustResolver()
        result = await resolver.resolve_github_url("tokio")
        assert result is None

    async def test_detect_lockfiles(self, tmp_path):
        """Test detecting Rust lockfiles."""
        (tmp_path / "Cargo.lock").touch()
        (tmp_path / "Cargo.toml").touch()

        resolver = RustResolver()
        lockfiles = await resolver.detect_lockfiles(str(tmp_path))

        assert len(lockfiles) == 1
        assert lockfiles[0].name == "Cargo.lock"

    async def test_parse_cargo_lock(self, tmp_path):
        """Test parsing Cargo.lock."""
        cargo_lock_content = """# This file is automatically @generated by Cargo.

[[package]]
name = "tokio"
version = "1.32.0"

[[package]]
name = "serde"
version = "1.0.164"

[[package]]
name = "regex"
version = "1.9.0"
"""
        lock_file = tmp_path / "Cargo.lock"
        lock_file.write_text(cargo_lock_content)

        resolver = RustResolver()
        packages = await resolver.parse_lockfile(str(lock_file))

        assert len(packages) == 3
        names = {p.name for p in packages}
        assert "tokio" in names
        assert "serde" in names
        assert "regex" in names
        assert all(p.ecosystem == "rust" for p in packages)

    async def test_parse_lockfile_not_found(self):
        """Test parsing non-existent lockfile."""
        resolver = RustResolver()
        with pytest.raises(FileNotFoundError):
            await resolver.parse_lockfile("/nonexistent/Cargo.lock")

    async def test_parse_lockfile_unknown_type(self, tmp_path):
        """Test parsing unknown lockfile type."""
        unknown_file = tmp_path / "unknown.lock"
        unknown_file.touch()

        resolver = RustResolver()
        with pytest.raises(ValueError, match="Unknown Rust lockfile type"):
            await resolver.parse_lockfile(str(unknown_file))

    async def test_parse_lockfile_missing_tomllib(self, tmp_path, monkeypatch):
        """Test parsing Cargo.lock without tomllib/tomli."""
        lock_file = tmp_path / "Cargo.lock"
        lock_file.write_text('[[package]]\nname = "tokio"\nversion = "1.0.0"\n')

        import builtins

        original_import = builtins.__import__

        def _fake_import(name, *args, **kwargs):
            if name in {"tomllib", "tomli"}:
                raise ImportError("missing")
            return original_import(name, *args, **kwargs)

        monkeypatch.setattr(builtins, "__import__", _fake_import)

        resolver = RustResolver()
        packages = await resolver.parse_lockfile(lock_file)

        assert packages == []

    async def test_parse_lockfile_tomllib_error(self, tmp_path, monkeypatch):
        """Test handling tomllib errors when parsing Cargo.lock."""
        lock_file = tmp_path / "Cargo.lock"
        lock_file.write_text('[[package]]\nname = "tokio"\nversion = "1.0.0"\n')

        import sys

        def _raise(*_args, **_kwargs):
            raise ValueError("parse error")

        fake_tomllib = MagicMock()
        fake_tomllib.load = _raise
        monkeypatch.setitem(sys.modules, "tomllib", fake_tomllib)

        resolver = RustResolver()
        packages = await resolver.parse_lockfile(lock_file)

        assert packages == []

    async def test_parse_manifest_not_found(self):
        """Test parsing missing Cargo.toml."""
        resolver = RustResolver()
        with pytest.raises(FileNotFoundError):
            await resolver.parse_manifest("/missing/Cargo.toml")

    async def test_parse_manifest_unknown(self, tmp_path):
        """Test parsing unknown manifest type."""
        manifest = tmp_path / "Cargo.lock"
        manifest.touch()

        resolver = RustResolver()
        with pytest.raises(ValueError, match="Unknown Rust manifest file type"):
            await resolver.parse_manifest(manifest)

    async def test_parse_manifest_cargo_toml(self, tmp_path):
        """Test parsing Cargo.toml."""
        manifest = tmp_path / "Cargo.toml"
        manifest.write_text(
            '[package]\nname = "example"\nversion = "0.1.0"\n\n'
            '[dependencies]\nserde = "1.0"\n'
            'tokio = { version = "1", features = ["full"] }\n\n'
            '[dev-dependencies]\nrstest = "0.18"\n\n'
            '[build-dependencies]\ncc = "1.0"\n'
        )

        resolver = RustResolver()
        packages = await resolver.parse_manifest(manifest)

        names = {pkg.name for pkg in packages}
        assert names == {"serde", "tokio", "rstest", "cc"}

    async def test_parse_manifest_missing_tomllib(self, tmp_path, monkeypatch):
        """Test parsing Cargo.toml without tomllib/tomli."""
        manifest = tmp_path / "Cargo.toml"
        manifest.write_text('[dependencies]\nserde = "1.0"\n')

        import builtins

        original_import = builtins.__import__

        def _fake_import(name, *args, **kwargs):
            if name in {"tomllib", "tomli"}:
                raise ImportError("missing")
            return original_import(name, *args, **kwargs)

        monkeypatch.setattr(builtins, "__import__", _fake_import)

        resolver = RustResolver()
        with pytest.raises(ValueError, match="tomllib or tomli is required"):
            await resolver.parse_manifest(manifest)
