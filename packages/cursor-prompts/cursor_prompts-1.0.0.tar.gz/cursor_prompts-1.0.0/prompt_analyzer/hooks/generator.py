"""Hook script generator and templates."""

import json
from pathlib import Path
from typing import Optional

from ..storage.paths import get_database_path


HOOK_SCRIPT_TEMPLATE = """// Cursor Prompts Hook Script
// Auto-generated by cursor-prompts setup command
// This script captures prompts and responses from Cursor and writes them to SQLite

const crypto = require('crypto');

// UUID v4 generator using built-in crypto
function uuidv4() {
  return crypto.randomUUID ? crypto.randomUUID() : 
    'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      const r = Math.random() * 16 | 0;
      const v = c === 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
}

// Load better-sqlite3 (synchronous SQLite library)
let Database;
try {
  Database = require('better-sqlite3');
} catch (e) {
  console.error('[cursor-prompts] better-sqlite3 not found. Please install: npm install better-sqlite3');
  console.error('[cursor-prompts] Error:', e.message);
  process.exit(1);
}

const DB_PATH = '{{DB_PATH}}';

// Initialize database connection
let db;
try {
  db = new Database(DB_PATH);
  db.pragma('journal_mode = WAL');
  db.pragma('foreign_keys = ON');
  
  // Ensure table exists
  db.exec(`
    CREATE TABLE IF NOT EXISTS prompts (
      id TEXT PRIMARY KEY,
      timestamp TEXT NOT NULL,
      prompt_text TEXT NOT NULL,
      response_text TEXT,
      user_action TEXT CHECK(user_action IN ('accepted', 'rejected', 'edited') OR user_action IS NULL),
      session_id TEXT NOT NULL,
      sequence_number INTEGER NOT NULL,
      project_path TEXT,
      analysis_score INTEGER CHECK(analysis_score >= 0 AND analysis_score <= 100),
      analysis_flags TEXT,
      analysis_suggestions TEXT,
      analysis_is_repeated INTEGER DEFAULT 0,
      analysis_repeated_with TEXT,
      created_at TEXT DEFAULT CURRENT_TIMESTAMP
    )
  `);
  
  // Add project_path column to existing tables if it doesn't exist
  try {
    db.exec(`ALTER TABLE prompts ADD COLUMN project_path TEXT`);
  } catch (e) {
    // Column already exists, ignore
  }
  
  // Create indexes
  db.exec(`
    CREATE INDEX IF NOT EXISTS idx_timestamp ON prompts(timestamp);
    CREATE INDEX IF NOT EXISTS idx_session_id ON prompts(session_id);
    CREATE INDEX IF NOT EXISTS idx_user_action ON prompts(user_action);
    CREATE INDEX IF NOT EXISTS idx_analysis_score ON prompts(analysis_score);
    CREATE INDEX IF NOT EXISTS idx_project_path ON prompts(project_path);
  `);
} catch (error) {
  console.error('[cursor-prompts] Failed to initialize database:', error.message);
  process.exit(1);
}

// Session tracking: map conversation_id to session metadata
const sessionCache = new Map();

function getSessionSequence(conversationId) {
  if (!sessionCache.has(conversationId)) {
    // Get max sequence number for this session
    try {
      const stmt = db.prepare('SELECT MAX(sequence_number) as max_seq FROM prompts WHERE session_id = ?');
      const result = stmt.get(conversationId);
      const maxSeq = result ? (result.max_seq || 0) : 0;
      sessionCache.set(conversationId, { sequence: maxSeq });
    } catch (error) {
      // If query fails, start from 0
      sessionCache.set(conversationId, { sequence: 0 });
    }
  }
  const session = sessionCache.get(conversationId);
  session.sequence += 1;
  return session.sequence;
}

function insertPrompt(data) {
  try {
    const {
      conversation_id,
      generation_id,
      hook_event_name,
      prompt_text,
      response_text,
      user_action,
      project_path
    } = data;

    // Use conversation_id as session_id
    const sessionId = conversation_id || uuidv4();
    const sequenceNumber = getSessionSequence(sessionId);
    const promptId = uuidv4();
    const timestamp = new Date().toISOString();

    const insert = db.prepare(`
      INSERT INTO prompts (
        id, timestamp, prompt_text, response_text, user_action,
        session_id, sequence_number, project_path
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    `);

    insert.run(
      promptId,
      timestamp,
      prompt_text || '',
      response_text || null,
      user_action || null,
      sessionId,
      sequenceNumber,
      project_path || null
    );

    return { success: true, promptId };
  } catch (error) {
    console.error('[cursor-prompts] Failed to insert prompt:', error.message);
    return { success: false, error: error.message };
  }
}

function updatePromptAction(promptId, userAction) {
  try {
    const update = db.prepare('UPDATE prompts SET user_action = ? WHERE id = ?');
    update.run(userAction, promptId);
    return { success: true };
  } catch (error) {
    console.error('[cursor-prompts] Failed to update prompt action:', error.message);
    return { success: false, error: error.message };
  }
}

// Main hook handler
function handleHook(input, hookType) {
  try {
    // Extract common fields
    const conversation_id = input.conversation_id || input.conversationId || input.session_id || input.sessionId;
    const generation_id = input.generation_id || input.generationId || input.id;
    
    // Determine hook type from parameter, environment, or input
    // Cursor may pass hook type in different ways
    const hook_event_name = hookType || 
                           process.env.CURSOR_HOOK_TYPE ||
                           input.hook_event_name || 
                           input.hookType || 
                           input.type ||
                           input.hook_type ||
                           'unknown';

    // Detect hook type from input structure if not explicitly provided
    // beforeSubmitPrompt typically has prompt-related fields
    // afterAgentResponse typically has response-related fields
    const hasPromptFields = input.prompt !== undefined || input.prompt_text !== undefined || 
                           input.message !== undefined || (input.text && !input.response);
    const hasResponseFields = input.response !== undefined || input.response_text !== undefined || 
                              input.content !== undefined || (input.text && input.response !== undefined);

    // Extract project path from workspace_roots
    const workspaceRoots = input.workspace_roots || input.workspaceRoots || [];
    const projectPath = workspaceRoots.length > 0 ? workspaceRoots[0] : null;

    // Handle different hook event types
    if (hook_event_name === 'beforeSubmitPrompt' || (hook_event_name === 'unknown' && hasPromptFields && !hasResponseFields)) {
      // Extract prompt text from input
      // Cursor passes the prompt in various possible fields
      const promptText = input.prompt || input.prompt_text || input.message || 
                       input.text || input.content || JSON.stringify(input);
      
      insertPrompt({
        conversation_id,
        generation_id,
        hook_event_name: 'beforeSubmitPrompt',
        prompt_text: promptText,
        user_action: null,
        project_path: projectPath
      });
    } else if (hook_event_name === 'afterAgentResponse' || (hook_event_name === 'unknown' && hasResponseFields)) {
      // Extract response text
      const responseText = input.response || input.response_text || input.content || 
                          input.message || input.text || JSON.stringify(input);
      
      // Try to find the corresponding prompt by conversation_id and update it
      const updateResponse = db.prepare(`
        UPDATE prompts 
        SET response_text = ? 
        WHERE session_id = ? AND response_text IS NULL 
        ORDER BY sequence_number DESC LIMIT 1
      `);
      updateResponse.run(responseText, conversation_id);
      
      // If no matching prompt found, create a new entry
      const check = db.prepare('SELECT COUNT(*) as count FROM prompts WHERE session_id = ? AND response_text IS NULL').get(conversation_id);
      if (check.count === 0) {
        // Create a new prompt entry with just the response (edge case)
        insertPrompt({
          conversation_id,
          generation_id,
          hook_event_name: 'afterAgentResponse',
          prompt_text: '',
          response_text: responseText,
          user_action: null,
          project_path: projectPath
        });
      }
    } else {
      // Fallback: try to extract prompt/response from any event
      const promptText = input.prompt || input.prompt_text || input.message || null;
      const responseText = input.response || input.response_text || input.content || null;
      
      if (promptText || responseText) {
        insertPrompt({
          conversation_id,
          generation_id,
          hook_event_name: hook_event_name,
          prompt_text: promptText || '',
          response_text: responseText || null,
          user_action: input.user_action || null,
          project_path: projectPath
        });
      }
    }

    return { success: true };
  } catch (error) {
    console.error('[cursor-prompts] Hook error:', error.message);
    return { success: false, error: error.message };
  }
}

// Process hook input from stdin
if (require.main === module) {
  let inputData = '';
  process.stdin.setEncoding('utf8');
  
  // Get hook type from command line argument or environment variable
  // Cursor may pass hook type as an argument: node script.js beforeSubmitPrompt
  const hookType = process.argv[2] || process.env.CURSOR_HOOK_TYPE;
  
  process.stdin.on('data', (chunk) => {
    inputData += chunk;
  });
  
  process.stdin.on('end', () => {
    try {
      const input = JSON.parse(inputData);
      const result = handleHook(input, hookType);
      process.stdout.write(JSON.stringify(result));
      process.exit(result.success ? 0 : 1);
    } catch (error) {
      console.error('[cursor-prompts] Parse error:', error.message);
      process.exit(1);
    }
  });
}

module.exports = { handleHook, insertPrompt, updatePromptAction };
"""


def generate_hook_script(db_path: Optional[Path] = None) -> str:
    """Generate the hook script with database path filled in."""
    if db_path is None:
        db_path = get_database_path()
    
    # Convert to absolute path and escape backslashes for JavaScript
    abs_path = str(db_path.expanduser().resolve()).replace('\\', '\\\\')
    
    script = HOOK_SCRIPT_TEMPLATE.replace('{{DB_PATH}}', abs_path)
    return script


def get_hooks_json_content(hook_script_path: Path) -> dict:
    """Generate hooks.json content."""
    # Convert to relative path from ~/.cursor/ if possible, otherwise use absolute
    script_path_str = str(hook_script_path)
    
    # Cursor hooks.json format requires:
    # - version: number
    # - hooks: object mapping event names to arrays of hook commands
    # Valid hook types: beforeShellExecution, beforeMCPExecution, afterShellExecution,
    # afterMCPExecution, beforeReadFile, afterFileEdit, stop, beforeSubmitPrompt, afterAgentResponse
    # Pass hook type as argument so the script knows which hook was triggered
    return {
        "version": 1,
        "hooks": {
            "beforeSubmitPrompt": [{"command": f"node {script_path_str} beforeSubmitPrompt"}],
            "afterAgentResponse": [{"command": f"node {script_path_str} afterAgentResponse"}]
        }
    }

