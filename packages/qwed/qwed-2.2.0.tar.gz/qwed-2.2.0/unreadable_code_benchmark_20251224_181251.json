[
  {
    "test_id": "01_prime_sieve",
    "test_name": "Prime Number Sieve",
    "domain": "Pure Mathematics",
    "model": "claude-opus-4.5",
    "code_generated": "n=1000;s=[1]*(n+1);s[0]=s[1]=0\nfor i in range(2,int(n**.5)+1):\n if s[i]:s[i*i::i]=[0]*len(s[i*i::i])\nprint([i for i,v in enumerate(s)if v])",
    "code_executed": true,
    "execution_output": "[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577",
    "verified": true,
    "verification_message": "All expected values present, no unexpected values",
    "time_to_generate": 4.26218318939209,
    "time_to_execute": 0.0,
    "human_readable": true
  },
  {
    "test_id": "02_matrix_mult",
    "test_name": "Matrix Multiplication",
    "domain": "Pure Mathematics",
    "model": "claude-opus-4.5",
    "code_generated": "from functools import reduce\n\nA = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nB = [[9, 8, 7], [6, 5, 4], [3, 2, 1]]\n\nresult = list(map(lambda i: list(map(lambda j: reduce(lambda acc, k: acc + A[i][k] * B[k][j], range(3), 0), range(3))), range(3)))\n\nprint(result)",
    "code_executed": true,
    "execution_output": "[[30, 24, 18], [84, 69, 54], [138, 114, 90]]",
    "verified": true,
    "verification_message": "Matrix multiplication verified by SymPy",
    "time_to_generate": 4.918382167816162,
    "time_to_execute": 0.0,
    "human_readable": true
  },
  {
    "test_id": "03_fibonacci_matrix",
    "test_name": "Fibonacci Matrix Exponentiation",
    "domain": "Pure Mathematics",
    "model": "claude-opus-4.5",
    "code_generated": "import numpy as np\n\ndef matrix_power(matrix, n):\n    if n == 0:\n        return np.array([[1, 0], [0, 1]], dtype=object)\n    if n == 1:\n        return matrix\n    \n    if n % 2 == 0:\n        half = matrix_power(matrix, n // 2)\n        return np.dot(half, half)\n    else:\n        return np.dot(matrix, matrix_power(matrix, n - 1))\n\ndef fibonacci(n):\n    if n == 0:\n        return 0\n    base_matrix = np.array([[1, 1], [1, 0]], dtype=object)\n    result = matrix_power(base_matrix, n)\n    return result[0][1]\n\nfib_numbers = [fibonacci(i) for i in range(20)]\nprint(fib_numbers)",
    "code_executed": true,
    "execution_output": "[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181]",
    "verified": true,
    "verification_message": "Fibonacci sequence verified",
    "time_to_generate": 4.8488616943359375,
    "time_to_execute": 1.9391601085662842,
    "human_readable": true
  },
  {
    "test_id": "04_backprop",
    "test_name": "Neural Network Backpropagation",
    "domain": "AI & Algorithms",
    "model": "claude-opus-4.5",
    "code_generated": "import math\n\nweights = [0.5, -0.5]\nbias = 0.1\ninputs = [1.0, 2.0]\ntarget = 1.0\nlearning_rate = 0.1\n\nz = sum(w * x for w, x in zip(weights, inputs)) + bias\n\noutput = 1 / (1 + math.exp(-z))\n\nerror = target - output\n\noutput_gradient = error * output * (1 - output)\n\nnew_weights = [w + learning_rate * output_gradient * x for w, x in zip(weights, inputs)]\nnew_bias = bias + learning_rate * output_gradient\n\nprint(f\"Updated weights: {new_weights}\")\nprint(f\"Updated bias: {new_bias}\")",
    "code_executed": true,
    "execution_output": "Updated weights: [0.5143841143684869, -0.47123177126302623]\nUpdated bias: 0.11438411436848689",
    "verified": true,
    "verification_message": "Gradient check - manual verification needed",
    "time_to_generate": 5.040303945541382,
    "time_to_execute": 0.0,
    "human_readable": true
  },
  {
    "test_id": "05_dfs_maze",
    "test_name": "DFS Maze Solver",
    "domain": "AI & Algorithms",
    "model": "claude-opus-4.5",
    "code_generated": "print((lambda maze, start, end: (lambda solve: solve(solve, start[0], start[1], set()))(lambda f, r, c, visited: True if (r, c) == end else False if r < 0 or r >= len(maze) or c < 0 or c >= len(maze[0]) or maze[r][c] == 1 or (r, c) in visited else any(f(f, r + dr, c + dc, visited | {(r, c)}) for dr, dc in [(0, 1), (1, 0), (0, -1), (-1, 0)])))([[0,0,1,0],[0,1,0,0],[0,0,0,1],[1,1,0,0]], (0,0), (3,3)))",
    "code_executed": true,
    "execution_output": "True",
    "verified": true,
    "verification_message": "Path found (as expected for this maze)",
    "time_to_generate": 5.208406686782837,
    "time_to_execute": 0.0,
    "human_readable": false
  },
  {
    "test_id": "06_bitonic_sort",
    "test_name": "Bitonic Sort",
    "domain": "AI & Algorithms",
    "model": "claude-opus-4.5",
    "code_generated": "def bitonic_sort(arr):\n    n = len(arr)\n    \n    compare_and_swap = lambda a, i, j, direction: (\n        (a.__setitem__(i, a[j]), a.__setitem__(j, a[i] if a[i] == a[j] else a[i]))[0]\n        if (a[i] > a[j]) == direction else None,\n        a\n    )[1] if i < len(a) and j < len(a) else a\n    \n    def bitonic_merge(arr, low, cnt, direction):\n        if cnt > 1:\n            k = cnt // 2\n            for i in range(low, low + k):\n                if (arr[i] > arr[i + k]) == direction:\n                    arr[i], arr[i + k] = arr[i + k], arr[i]\n            bitonic_merge(arr, low, k, direction)\n            bitonic_merge(arr, low + k, k, direction)\n    \n    def bitonic_sort_recursive(arr, low, cnt, direction):\n        if cnt > 1:\n            k = cnt // 2\n            bitonic_sort_recursive(arr, low, k, True)\n            bitonic_sort_recursive(arr, low + k, k, False)\n            bitonic_merge(arr, low, cnt, direction)\n    \n    power_of_2 = 1\n    while power_of_2 < n:\n        power_of_2 *= 2\n    \n    padded = arr + [float('inf')] * (power_of_2 - n)\n    bitonic_sort_recursive(padded, 0, power_of_2, True)\n    \n    return padded[:n]\n\narr = [3, 7, 4, 8, 6, 2, 1, 5, 9, 0, 12, 15, 10, 11, 13, 14]\nsorted_arr = bitonic_sort(arr)\nprint(sorted_arr)",
    "code_executed": true,
    "execution_output": "[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]",
    "verified": true,
    "verification_message": "List correctly sorted",
    "time_to_generate": 9.111904859542847,
    "time_to_execute": 0.0,
    "human_readable": true
  },
  {
    "test_id": "07_rsa",
    "test_name": "RSA Encryption",
    "domain": "Security & Finance",
    "model": "claude-opus-4.5",
    "code_generated": "print((lambda p,q,m:(lambda n,phi:(lambda e:(lambda d:(pow(m,e,n),pow(pow(m,e,n),d,n)))(pow(e,-1,phi)))(65537))(p*q,(p-1)*(q-1)))(61,53,42))",
    "code_executed": true,
    "execution_output": "(2557, 42)",
    "verified": true,
    "verification_message": "RSA verified: encrypt(42)=2557, decrypt=42",
    "time_to_generate": 9.614973068237305,
    "time_to_execute": 0.0009970664978027344,
    "human_readable": false
  },
  {
    "test_id": "08_black_scholes",
    "test_name": "Black-Scholes Option Pricing",
    "domain": "Security & Finance",
    "model": "claude-opus-4.5",
    "code_generated": "print((lambda S,K,T,r,sigma:(lambda d1,d2:(lambda cdf:S*cdf(d1)-K*(2.718281828459045**(-r*T))*cdf(d2))(lambda x:(lambda t:1-(1/(2.506628274631**(0.5)))*2.718281828459045**(-x*x/2)*(0.319381530*t-0.356563782*t**2+1.781477937*t**3-1.821255978*t**4+1.330274429*t**5) if x>=0 else 1-(1-(1/(2.506628274631**(0.5)))*2.718281828459045**(-x*x/2)*(0.319381530*(1/(1+0.2316419*(-x)))-0.356563782*(1/(1+0.2316419*(-x)))**2+1.781477937*(1/(1+0.2316419*(-x)))**3-1.821255978*(1/(1+0.2316419*(-x)))**4+1.330274429*(1/(1+0.2316419*(-x)))**5)))(1/(1+0.2316419*abs(x)))))((lambda x:x**0.5)(1/T)*((lambda x:x)(0.693147180559945*(S/K)/0.693147180559945)+(r+sigma**2/2)*T)/(sigma),(lambda x:x**0.5)(1/T)*((lambda x:x)(0.693147180559945*(S/K)/0.693147180559945)+(r+sigma**2/2)*T)/(sigma)-sigma*T**0.5))(100,100,1,0.05,0.2))",
    "code_executed": true,
    "execution_output": "4.8770702227968314",
    "verified": false,
    "verification_message": "Value 4.8771 outside range (9.0, 11.0)",
    "time_to_generate": 10.468721389770508,
    "time_to_execute": 0.010215044021606445,
    "human_readable": false
  },
  {
    "test_id": "09_game_of_life",
    "test_name": "Conway's Game of Life",
    "domain": "Simulation",
    "model": "claude-opus-4.5",
    "code_generated": "grid = [[0,1,0,0,0],[0,0,1,0,0],[1,1,1,0,0],[0,0,0,0,0],[0,0,0,0,0]]\nnext_gen = [[int((n := sum(grid[i+di][j+dj] for di in [-1,0,1] for dj in [-1,0,1] if 0<=i+di<5 and 0<=j+dj<5 and (di,dj)!=(0,0))) == 3 or (n == 2 and grid[i][j] == 1)) for j in range(5)] for i in range(5)]\nprint(next_gen)",
    "code_executed": true,
    "execution_output": "[[0, 0, 0, 0, 0], [1, 0, 1, 0, 0], [0, 1, 1, 0, 0], [0, 1, 0, 0, 0], [0, 0, 0, 0, 0]]",
    "verified": true,
    "verification_message": "Game of Life generation produced valid grid",
    "time_to_generate": 4.410305976867676,
    "time_to_execute": 0.0030710697174072266,
    "human_readable": true
  },
  {
    "test_id": "10_sudoku",
    "test_name": "Sudoku Validator",
    "domain": "Simulation",
    "model": "claude-opus-4.5",
    "code_generated": "print((lambda b: all(len(set(r))==9 and all(1<=x<=9 for x in r) for r in b) and all(len(set(b[i][j] for i in range(9)))==9 for j in range(9)) and all(len(set(b[i+di][j+dj] for di in range(3) for dj in range(3)))==9 for i in range(0,9,3) for j in range(0,9,3)))([[5,3,4,6,7,8,9,1,2],[6,7,2,1,9,5,3,4,8],[1,9,8,3,4,2,5,6,7],[8,5,9,7,6,1,4,2,3],[4,2,6,8,5,3,7,9,1],[7,1,3,9,2,4,8,5,6],[9,6,1,5,3,7,2,8,4],[2,8,7,4,1,9,6,3,5],[3,4,5,2,8,6,1,7,9]]))",
    "code_executed": true,
    "execution_output": "True",
    "verified": true,
    "verification_message": "Sudoku validation correct: True",
    "time_to_generate": 6.537340402603149,
    "time_to_execute": 0.0010190010070800781,
    "human_readable": false
  },
  {
    "test_id": "11_fibonacci_original",
    "test_name": "Fibonacci One-Liner (Original)",
    "domain": "Pure Mathematics",
    "model": "claude-opus-4.5",
    "code_generated": "print([((lambda f:f(f,n))(lambda s,n:[[1,0],[0,1]]if n==0 else(lambda m:[[m[0][0]*m[0][0]+m[0][1]*m[1][0],m[0][0]*m[0][1]+m[0][1]*m[1][1]],[m[1][0]*m[0][0]+m[1][1]*m[1][0],m[1][0]*m[0][1]+m[1][1]*m[1][1]]]if n&1==0 else[[m[0][0]+m[0][1],m[0][0]],[m[1][0]+m[1][1],m[1][0]]])(s(s,n>>1))if n&1==0 else(lambda m:[[(m[0][0]+m[0][1])*1+m[0][0]*0,(m[0][0]+m[0][1])*1+m[0][1]*0],[(m[1][0]+m[1][1])*1+m[1][0]*0,(m[1][0]+m[1][1])*1+m[1][1]*0]])(s(s,n-1)),n))[0][1]for n in range(100)])",
    "code_executed": false,
    "execution_output": "<listcomp>.<lambda>() takes 1 positional argument but 2 were given",
    "verified": false,
    "verification_message": "Not verified",
    "time_to_generate": 8.295490264892578,
    "time_to_execute": 0.0,
    "human_readable": true
  }
]