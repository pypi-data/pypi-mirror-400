// This file is autogenerated. DO NOT EDIT

#pragma once
#include <semiwrap.h>

// wrapped header

#include <frc/controller/SimpleMotorFeedforward.h>

// from extra_includes
#include <units/dimensionless.h>

#include <units_acceleration_type_caster.h>
#include <units_angle_type_caster.h>
#include <units_angular_acceleration_type_caster.h>
#include <units_angular_velocity_type_caster.h>
#include <units_compound_type_caster.h>
#include <units_length_type_caster.h>
#include <units_time_type_caster.h>
#include <units_velocity_type_caster.h>
#include <units_voltage_type_caster.h>

namespace swgen {

using namespace frc;

template <typename Distance>
struct bind_frc__SimpleMotorFeedforward {
  using Velocity = typename frc::SimpleMotorFeedforward<Distance>::Velocity;
  using Acceleration = typename frc::SimpleMotorFeedforward<Distance>::Acceleration;
  using kv_unit = typename frc::SimpleMotorFeedforward<Distance>::kv_unit;
  using ka_unit = typename frc::SimpleMotorFeedforward<Distance>::ka_unit;
  py::class_<typename frc::SimpleMotorFeedforward<Distance>, py::smart_holder> cls_SimpleMotorFeedforward;

  py::module &m;
  std::string clsName;
  bind_frc__SimpleMotorFeedforward(py::module &m, const char * clsName) :
    cls_SimpleMotorFeedforward(m, clsName),
    m(m),
    clsName(clsName) {
  }

  void finish(const char * set_doc = NULL, const char * add_doc = NULL) {
    cls_SimpleMotorFeedforward.doc() = 
      "A helper class that computes feedforward voltages for a simple\n"
      "permanent-magnet DC motor.";
    cls_SimpleMotorFeedforward.def(py::init<units::volt_t, units::unit_t<kv_unit>, units::unit_t<ka_unit>, units::second_t>()
      , py::arg("kS"), py::arg("kV"), py::arg("kA") = units::unit_t<ka_unit> (0), py::arg("dt") = (units::second_t)20_ms
      , release_gil()
      , py::doc(
      "Creates a new SimpleMotorFeedforward with the specified gains.\n"
      "\n"
      ":param kS: The static gain, in volts.\n"
      ":param kV: The velocity gain, in volt seconds per distance.\n"
      ":param kA: The acceleration gain, in volt secondsÂ² per distance.\n"
      ":param dt: The period in seconds.\n"
      "           @throws IllegalArgumentException for kv &lt; zero.\n"
      "           @throws IllegalArgumentException for ka &lt; zero.\n"
      "           @throws IllegalArgumentException for period &le; zero.")
    );
    cls_SimpleMotorFeedforward.def("calculate", static_cast<units::volt_t (frc::SimpleMotorFeedforward<Distance>::*)(units::unit_t<Velocity>) const>(&frc::SimpleMotorFeedforward<Distance>::Calculate)
      , py::arg("velocity")
      , release_gil()
      , py::doc(
      "Calculates the feedforward from the gains and velocity setpoint assuming\n"
      "discrete control. Use this method when the velocity setpoint does not\n"
      "change.\n"
      "\n"
      ":param velocity: The velocity setpoint.\n"
      "\n"
      ":returns: The computed feedforward, in volts.")
    );
    cls_SimpleMotorFeedforward.def("calculate", static_cast<units::volt_t (frc::SimpleMotorFeedforward<Distance>::*)(units::unit_t<Velocity>, units::unit_t<Velocity>) const>(&frc::SimpleMotorFeedforward<Distance>::Calculate)
      , py::arg("currentVelocity"), py::arg("nextVelocity")
      , release_gil()
      , py::doc(
      "Calculates the feedforward from the gains and setpoints assuming discrete\n"
      "control.\n"
      "\n"
      "Note this method is inaccurate when the velocity crosses 0.\n"
      "\n"
      ":param currentVelocity: The current velocity setpoint.\n"
      ":param nextVelocity:    The next velocity setpoint.\n"
      "\n"
      ":returns: The computed feedforward, in volts.")
    );
    cls_SimpleMotorFeedforward.def("maxAchievableVelocity", &frc::SimpleMotorFeedforward<Distance>::MaxAchievableVelocity
      , py::arg("maxVoltage"), py::arg("acceleration")
      , release_gil()
      , py::doc(
      "Calculates the maximum achievable velocity given a maximum voltage supply\n"
      "and an acceleration.  Useful for ensuring that velocity and\n"
      "acceleration constraints for a trapezoidal profile are simultaneously\n"
      "achievable - enter the acceleration constraint, and this will give you\n"
      "a simultaneously-achievable velocity constraint.\n"
      "\n"
      ":param maxVoltage:   The maximum voltage that can be supplied to the motor.\n"
      ":param acceleration: The acceleration of the motor.\n"
      "\n"
      ":returns: The maximum possible velocity at the given acceleration.")
    );
    cls_SimpleMotorFeedforward.def("minAchievableVelocity", &frc::SimpleMotorFeedforward<Distance>::MinAchievableVelocity
      , py::arg("maxVoltage"), py::arg("acceleration")
      , release_gil()
      , py::doc(
      "Calculates the minimum achievable velocity given a maximum voltage supply\n"
      "and an acceleration.  Useful for ensuring that velocity and\n"
      "acceleration constraints for a trapezoidal profile are simultaneously\n"
      "achievable - enter the acceleration constraint, and this will give you\n"
      "a simultaneously-achievable velocity constraint.\n"
      "\n"
      ":param maxVoltage:   The maximum voltage that can be supplied to the motor.\n"
      ":param acceleration: The acceleration of the motor.\n"
      "\n"
      ":returns: The minimum possible velocity at the given acceleration.")
    );
    cls_SimpleMotorFeedforward.def("maxAchievableAcceleration", &frc::SimpleMotorFeedforward<Distance>::MaxAchievableAcceleration
      , py::arg("maxVoltage"), py::arg("velocity")
      , release_gil()
      , py::doc(
      "Calculates the maximum achievable acceleration given a maximum voltage\n"
      "supply and a velocity. Useful for ensuring that velocity and\n"
      "acceleration constraints for a trapezoidal profile are simultaneously\n"
      "achievable - enter the velocity constraint, and this will give you\n"
      "a simultaneously-achievable acceleration constraint.\n"
      "\n"
      ":param maxVoltage: The maximum voltage that can be supplied to the motor.\n"
      ":param velocity:   The velocity of the motor.\n"
      "\n"
      ":returns: The maximum possible acceleration at the given velocity.")
    );
    cls_SimpleMotorFeedforward.def("minAchievableAcceleration", &frc::SimpleMotorFeedforward<Distance>::MinAchievableAcceleration
      , py::arg("maxVoltage"), py::arg("velocity")
      , release_gil()
      , py::doc(
      "Calculates the minimum achievable acceleration given a maximum voltage\n"
      "supply and a velocity. Useful for ensuring that velocity and\n"
      "acceleration constraints for a trapezoidal profile are simultaneously\n"
      "achievable - enter the velocity constraint, and this will give you\n"
      "a simultaneously-achievable acceleration constraint.\n"
      "\n"
      ":param maxVoltage: The maximum voltage that can be supplied to the motor.\n"
      ":param velocity:   The velocity of the motor.\n"
      "\n"
      ":returns: The minimum possible acceleration at the given velocity.")
    );
    cls_SimpleMotorFeedforward.def("setKs", &frc::SimpleMotorFeedforward<Distance>::SetKs
      , py::arg("kS")
      , release_gil()
      , py::doc(
      "Sets the static gain.\n"
      "\n"
      ":param kS: The static gain.")
    );
    cls_SimpleMotorFeedforward.def("setKv", &frc::SimpleMotorFeedforward<Distance>::SetKv
      , py::arg("kV")
      , release_gil()
      , py::doc(
      "Sets the velocity gain.\n"
      "\n"
      ":param kV: The velocity gain.")
    );
    cls_SimpleMotorFeedforward.def("setKa", &frc::SimpleMotorFeedforward<Distance>::SetKa
      , py::arg("kA")
      , release_gil()
      , py::doc(
      "Sets the acceleration gain.\n"
      "\n"
      ":param kA: The acceleration gain.")
    );
    cls_SimpleMotorFeedforward.def("getKs", &frc::SimpleMotorFeedforward<Distance>::GetKs
      , release_gil()
      , py::doc(
      "Returns the static gain.\n"
      "\n"
      ":returns: The static gain.")
    );
    cls_SimpleMotorFeedforward.def("getKv", &frc::SimpleMotorFeedforward<Distance>::GetKv
      , release_gil()
      , py::doc(
      "Returns the velocity gain.\n"
      "\n"
      ":returns: The velocity gain.")
    );
    cls_SimpleMotorFeedforward.def("getKa", &frc::SimpleMotorFeedforward<Distance>::GetKa
      , release_gil()
      , py::doc(
      "Returns the acceleration gain.\n"
      "\n"
      ":returns: The acceleration gain.")
    );
    cls_SimpleMotorFeedforward.def("getDt", &frc::SimpleMotorFeedforward<Distance>::GetDt
      , release_gil()
      , py::doc(
      "Returns the period.\n"
      "\n"
      ":returns: The period.")
    );
    if (set_doc) {
      cls_SimpleMotorFeedforward.doc() = set_doc;
    }
    if (add_doc) {
      cls_SimpleMotorFeedforward.doc() = py::cast<std::string>(cls_SimpleMotorFeedforward.doc()) + add_doc;
    }
  }
}; // struct bind_frc__SimpleMotorFeedforward

}; // namespace swgen
