# Copyright (c) 2024-2025 Veritas Collaborative, LLC
# SPDX-License-Identifier: LicenseRef-MCSL

"""Session-related CLI command implementations."""

from __future__ import annotations

import json
import time
from datetime import datetime
from pathlib import Path
from typing import Optional

from rich.markup import escape

from motus.core.errors import DatabaseError, MotusError
from motus.exceptions import MCError
from motus.logging import get_logger

from ..exit_codes import EXIT_ERROR

logger = get_logger(__name__)


def summary_command(session_id: Optional[str] = None) -> None:
    """Generate a summary for CLAUDE.md to preserve session context."""
    from rich.panel import Panel

    from motus.config import MC_STATE_DIR
    from motus.orchestrator import get_orchestrator

    from ..output import unified_session_to_session_info
    from ..validators import extract_decisions
    from ..watch_cmd import analyze_session
    from . import _get_console

    console = _get_console()
    orchestrator = get_orchestrator()
    max_age = 48 if session_id else 1
    unified_sessions = orchestrator.discover_all(max_age_hours=max_age)
    if not unified_sessions:
        console.print("[yellow]No active session found.[/yellow]")
        raise SystemExit(EXIT_ERROR)
    if session_id:
        unified = next(
            (session for session in unified_sessions if session.session_id.startswith(session_id)),
            None,
        )
        if not unified:
            console.print(f"[red]Session not found: {escape(session_id)}[/red]")
            console.print("Use 'motus list' to see available sessions.")
            raise SystemExit(EXIT_ERROR)
    else:
        unified = unified_sessions[0]

    session = unified_session_to_session_info(unified)
    stats = analyze_session(session, unified)
    decisions = extract_decisions(session.file_path)
    summary = (
        "## Motus Session Memory\n\n> Auto-generated by Motus. Add this to "
        "CLAUDE.md to preserve agent context.\n\n"
        "### Session Info\n"
        f"- **ID:** `{session.session_id[:12]}`\n- **Project:** `{session.project_path}`\n"
        f"- **Size:** {session.size // 1024}KB\n"
        f"- **Last Active:** {session.last_modified.strftime('%Y-%m-%d %H:%M')}\n\n"
        "### Activity Summary\n| Metric | Count |\n|--------|-------|\n"
        f"| Thinking blocks | {stats.thinking_count} |\n| Tool calls | {stats.tool_count} |\n"
        f"| Agents spawned | {stats.agent_count} |\n| Files modified | {len(stats.files_modified)} |\n"
        f"| High-risk ops | {stats.high_risk_ops} |\n\n"
        "### Files Modified This Session\n"
    )
    if stats.files_modified:
        for filename in list(stats.files_modified)[:15]:
            parts = filename.split("/")
            short_path = (
                "/".join(parts[-3:]) if len(filename) > 60 and len(parts) > 3 else filename
            )
            summary += f"- `{short_path}`\n"
    else:
        summary += "- None yet\n"
    summary += "\n### Decisions Made (from thinking blocks)\n"
    summary += (
        "".join(f"- {decision}\n" for decision in decisions[:8])
        if decisions
        else "- No explicit decisions captured\n"
    )
    summary += "\n### Recommendations for Next Session\n"
    for condition, message in (
        (
            stats.high_risk_ops > 3,
            "- âš ï¸ Multiple high-risk operations were performed. Review changes carefully.",
        ),
        (
            len(stats.files_modified) > 10,
            "- ðŸ“ Many files were modified. Consider committing before continuing.",
        ),
        (
            stats.agent_count > 3,
            "- ðŸ¤– Multiple subagents were spawned. Check for coordination issues.",
        ),
        (stats.tool_count > 100, "- âš¡ High tool usage. The session was very active."),
    ):
        if condition:
            summary += f"{message}\n"
    summary += (
        "\n---\n"
        "*Generated by [Motus](https://github.com/motus-os/motus) at"
        f"{datetime.now().strftime('%Y-%m-%d %H:%M')}*\n"
    )
    summary_file, latest_file = (
        MC_STATE_DIR / f"summary_{session.session_id[:8]}.md",
        MC_STATE_DIR / "latest_summary.md",
    )
    save_success = False
    try:
        summary_file.write_text(summary)
        latest_file.write_text(summary)
        save_success = True
    except (OSError, IOError) as e:
        logger.error(f"Failed to write summary files: {e}")
        console.print(f"[red]Warning: Failed to save files: {escape(str(e))}[/red]")

    console.print(
        Panel(
            summary,
            title="[bold green]ðŸ“‹ Motus Summary[/bold green]",
            subtitle=(
                "Copied to clipboard! [dim]and saved to .mc/[/dim]"
                if save_success
                else "[red]Not saved[/red]"
            ),
            border_style="green",
        )
    )


def _record_teleport_metric(elapsed_ms: float, target: str, success: bool) -> None:
    try:
        from motus.core.database import get_db_manager
        db = get_db_manager()
        db.record_metric(
            "teleport", elapsed_ms, success=success, metadata={"target": target, "success": success}
        )
    except (DatabaseError, ImportError, OSError) as e:
        logger.debug(
            "Teleport metrics recording failed", error_type=type(e).__name__, error=str(e)
        )


def teleport_command(args) -> None:
    """Export a session bundle for cross-session context transfer."""
    from motus.orchestrator import get_orchestrator

    from . import _get_console
    start = time.perf_counter()
    success = False
    console = _get_console()
    session_id = target = args.session_id
    include_docs = not getattr(args, "no_docs", False)
    output_path = getattr(args, "output", None)
    orch = get_orchestrator()
    sessions = orch.discover_all(max_age_hours=168)
    session = next((s for s in sessions if s.session_id.startswith(session_id)), None)
    if not session:
        console.print(f"[red]Session not found: {escape(session_id)}[/red]")
        _record_teleport_metric((time.perf_counter() - start) * 1000, target, success)
        return
    try:
        bundle = orch.export_teleport(session, include_planning_docs=include_docs)
        target = session.session_id
        bundle_dict = {
            "source_session": bundle.source_session,
            "source_model": bundle.source_model,
            "intent": bundle.intent,
            "decisions": bundle.decisions,
            "files_touched": bundle.files_touched,
            "hot_files": bundle.hot_files,
            "pending_todos": bundle.pending_todos,
            "last_action": bundle.last_action,
            "timestamp": bundle.timestamp.isoformat(),
            "planning_docs": bundle.planning_docs,
        }
        json_output = json.dumps(bundle_dict, indent=2)
        if output_path:
            Path(output_path).write_text(json_output)
            console.print(f"Teleport bundle written to {output_path}", style="green", markup=False)
        else:
            console.print(json_output, markup=False)
        success = True
    except (MCError, MotusError, OSError, TypeError, ValueError) as e:
        console.print(f"[red]Error exporting teleport bundle: {escape(str(e))}[/red]")
    finally:
        _record_teleport_metric((time.perf_counter() - start) * 1000, target, success)


def list_sessions(args=None) -> None:
    """List sessions command handler."""
    from . import _get_console
    try:
        from motus.commands.list_cmd import list_sessions as list_sessions_func
        list_sessions_func(fast=bool(getattr(args, "fast", False)) if args is not None else False)
    except ImportError:
        console = _get_console()
        console.print("[red]List command not available in this context.[/red]")
