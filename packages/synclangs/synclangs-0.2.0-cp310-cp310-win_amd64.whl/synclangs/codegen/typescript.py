"""TypeScript code generator for SyncLangs types."""

from __future__ import annotations

import posixpath

from synclangs.codegen.base import CodeGenerator
from synclangs.parser.ast import (
    ConstDef,
    EnumDef,
    FunctionDef,
    InterfaceDef,
    ListTypeExpr,
    MapTypeExpr,
    Module,
    NullableTypeExpr,
    PrimitiveType,
    PrimitiveTypeExpr,
    TypeDef,
    TypeExpr,
    TypeRef,
    VoidType,
)


class TypeScriptGenerator(CodeGenerator):
    """Generate TypeScript interfaces from SyncLangs AST."""

    def __init__(self, file_extension: str = ".types.ts") -> None:
        self._file_extension = file_extension

    def generate(self, module: Module) -> str:
        """Generate TypeScript source code for a module."""
        lines: list[str] = [
            "// Auto-generated by SyncLangs - DO NOT EDIT",
            "",
        ]

        if module.imports:
            for import_stmt in module.imports:
                import_path = self._ts_import_path(
                    module.path, import_stmt.path
                )
                names = ", ".join(import_stmt.names)
                lines.append(f"import type {{ {names} }} from '{import_path}';")
            lines.append("")

        # Generate constants first
        for const_def in module.constants:
            lines.extend(self._generate_constant(const_def))
        if module.constants:
            lines.append("")

        # Generate enums
        for enum_def in module.enums:
            lines.extend(self._generate_enum(enum_def))
            lines.append("")

        # Generate interfaces (types with optional extends)
        for type_def in module.types:
            lines.extend(self._generate_type(type_def))
            lines.append("")

        # Generate interface definitions
        for interface_def in module.interfaces:
            lines.extend(self._generate_interface(interface_def))
            lines.append("")

        # Generate function type definitions
        for fn_def in module.functions:
            lines.extend(self._generate_function_type(fn_def))
            lines.append("")

        return "\n".join(lines).rstrip() + "\n"

    def _generate_type(self, type_def: TypeDef) -> list[str]:
        """Generate a TypeScript interface for a type definition."""
        lines: list[str] = []
        if type_def.doc_comment:
            lines.extend(self._format_jsdoc(type_def.doc_comment, ""))

        # Build extends clause
        extends_clause = ""
        if type_def.extends:
            extends_clause = f" extends {type_def.extends}"
        elif type_def.implements:
            # In TypeScript, implements becomes extends for interfaces
            extends_clause = f" extends {', '.join(type_def.implements)}"

        lines.append(f"export interface {type_def.name}{extends_clause} {{")
        for field in type_def.fields:
            if field.doc_comment:
                lines.extend(self._format_jsdoc(field.doc_comment, "  "))
            field_type, optional = self._field_type(field.type_expr)
            suffix = "?" if optional else ""
            lines.append(f"  {field.name}{suffix}: {field_type};")
        lines.append("}")
        return lines

    def _generate_interface(self, interface_def: InterfaceDef) -> list[str]:
        """Generate a TypeScript interface definition."""
        lines: list[str] = []
        if interface_def.doc_comment:
            lines.extend(self._format_jsdoc(interface_def.doc_comment, ""))
        lines.append(f"export interface {interface_def.name} {{")

        # Generate fields
        for field in interface_def.fields:
            if field.doc_comment:
                lines.extend(self._format_jsdoc(field.doc_comment, "  "))
            field_type, optional = self._field_type(field.type_expr)
            suffix = "?" if optional else ""
            lines.append(f"  {field.name}{suffix}: {field_type};")

        # Generate function signatures as methods
        for fn_def in interface_def.functions:
            if fn_def.doc_comment:
                lines.extend(self._format_jsdoc(fn_def.doc_comment, "  "))
            signature = self._function_signature(fn_def, is_method=True)
            lines.append(f"  {signature}")

        lines.append("}")
        return lines

    def _generate_function_type(self, fn_def: FunctionDef) -> list[str]:
        """Generate a TypeScript function type alias."""
        lines: list[str] = []
        if fn_def.doc_comment:
            lines.extend(self._format_jsdoc(fn_def.doc_comment, ""))

        # Build parameter list
        params = ", ".join(
            f"{p.name}: {self._type_to_ts(p.type_expr)}"
            for p in fn_def.params
        )

        # Build return type
        return_type = self._return_type_to_ts(fn_def.return_type, fn_def.is_async)

        type_name = f"{fn_def.name[0].upper()}{fn_def.name[1:]}Fn"
        lines.append(f"export type {type_name} = ({params}) => {return_type};")
        return lines

    def _function_signature(self, fn_def: FunctionDef, is_method: bool = False) -> str:
        """Generate a function/method signature."""
        # Build parameter list
        params = ", ".join(
            f"{p.name}: {self._type_to_ts(p.type_expr)}"
            for p in fn_def.params
        )

        # Build return type
        return_type = self._return_type_to_ts(fn_def.return_type, fn_def.is_async)

        if is_method:
            return f"{fn_def.name}({params}): {return_type};"
        return f"({params}) => {return_type}"

    def _return_type_to_ts(self, return_type: TypeExpr | VoidType, is_async: bool) -> str:
        """Convert a return type to TypeScript."""
        if isinstance(return_type, VoidType):
            base_type = "void"
        else:
            base_type = self._type_to_ts(return_type)

        if is_async:
            return f"Promise<{base_type}>"
        return base_type

    def _generate_constant(self, const_def: ConstDef) -> list[str]:
        """Generate a TypeScript constant definition."""
        lines: list[str] = []
        if const_def.doc_comment:
            lines.extend(self._format_jsdoc(const_def.doc_comment, ""))
        ts_type = self._type_to_ts(const_def.type_expr)
        value = self._const_value_to_ts(const_def.value)
        lines.append(f"export const {const_def.name}: {ts_type} = {value};")
        return lines

    def _generate_enum(self, enum_def: EnumDef) -> list[str]:
        """Generate a TypeScript enum definition."""
        lines: list[str] = []
        if enum_def.doc_comment:
            lines.extend(self._format_jsdoc(enum_def.doc_comment, ""))
        lines.append(f"export enum {enum_def.name} {{")
        for variant in enum_def.variants:
            if variant.doc_comment:
                lines.extend(self._format_jsdoc(variant.doc_comment, "  "))
            lines.append(f'  {variant.name} = "{variant.name}",')
        lines.append("}")
        return lines

    def _const_value_to_ts(self, value: "ConstDef.value") -> str:
        """Convert a constant value to TypeScript literal."""
        from synclangs.parser.ast import ConstValue

        if not isinstance(value, ConstValue):
            return str(value)
        if isinstance(value.value, str):
            return f'"{value.value}"'
        if isinstance(value.value, bool):
            return "true" if value.value else "false"
        return str(value.value)

    def _field_type(self, type_expr: TypeExpr) -> tuple[str, bool]:
        """Return the TypeScript type and optional flag for a field."""
        if isinstance(type_expr, NullableTypeExpr):
            return self._type_to_ts(type_expr.inner_type), True
        return self._type_to_ts(type_expr), False

    def _type_to_ts(self, type_expr: TypeExpr) -> str:
        """Convert a type expression to a TypeScript type."""
        if isinstance(type_expr, PrimitiveTypeExpr):
            return self._primitive_to_ts(type_expr.primitive)
        if isinstance(type_expr, ListTypeExpr):
            inner = self._type_to_ts(type_expr.element_type)
            return self._array_type(inner)
        if isinstance(type_expr, MapTypeExpr):
            key = self._type_to_ts(type_expr.key_type)
            value = self._type_to_ts(type_expr.value_type)
            return f"Record<{key}, {value}>"
        if isinstance(type_expr, NullableTypeExpr):
            inner = self._type_to_ts(type_expr.inner_type)
            return f"{inner} | undefined"
        if isinstance(type_expr, TypeRef):
            return type_expr.name
        raise TypeError(f"Unsupported type expression: {type_expr}")

    def _primitive_to_ts(self, primitive: PrimitiveType) -> str:
        """Map primitive SyncLangs types to TypeScript types."""
        mapping = {
            PrimitiveType.STRING: "string",
            PrimitiveType.INT: "number",
            PrimitiveType.FLOAT: "number",
            PrimitiveType.BOOL: "boolean",
            PrimitiveType.ANY: "any",
        }
        return mapping[primitive]

    def _array_type(self, inner: str) -> str:
        """Return a TypeScript array type for the inner type."""
        if "|" in inner or "&" in inner:
            return f"Array<{inner}>"
        return f"{inner}[]"

    def _ts_import_path(self, module_path: str, import_path: str) -> str:
        """Resolve an import path to a TypeScript module specifier."""
        current_dir = posixpath.dirname(module_path)
        target_path = posixpath.normpath(posixpath.join(current_dir, import_path))
        base = current_dir if current_dir else "."
        rel_path = posixpath.relpath(target_path, base)
        if rel_path.endswith(".syln"):
            rel_path = rel_path[: -len(".syln")] + self._file_extension
        if rel_path.endswith(".ts"):
            rel_path = rel_path[: -len(".ts")]
        if not rel_path.startswith("."):
            rel_path = f"./{rel_path}"
        return rel_path

    def _format_jsdoc(self, text: str, indent: str) -> list[str]:
        """Format a JSDoc comment with the provided indentation."""
        lines = text.splitlines()
        if len(lines) == 1:
            return [f"{indent}/** {lines[0]} */"]
        formatted = [f"{indent}/**"]
        formatted.extend(f"{indent} * {line}" for line in lines)
        formatted.append(f"{indent} */")
        return formatted
