// This file is autogenerated. DO NOT EDIT

#pragma once
#include <semiwrap.h>

// wrapped header

#include <frc/kinematics/SwerveDriveOdometry3d.h>

#include <wpi_array_type_caster.h>

namespace swgen {

using namespace frc;

template <size_t NumModules>
struct bind_frc__SwerveDriveOdometry3d {
  py::class_<typename frc::SwerveDriveOdometry3d<NumModules>, py::smart_holder, frc::Odometry3d<wpi::array<SwerveModuleState, NumModules>, wpi::array<SwerveModulePosition, NumModules>>> cls_SwerveDriveOdometry3d;

  py::module &m;
  std::string clsName;
  bind_frc__SwerveDriveOdometry3d(py::module &m, const char * clsName) :
    cls_SwerveDriveOdometry3d(m, clsName),
    m(m),
    clsName(clsName) {
  }

  void finish(const char * set_doc = NULL, const char * add_doc = NULL) {
    cls_SwerveDriveOdometry3d.doc() = 
      "Class for swerve drive odometry. Odometry allows you to track the robot's\n"
      "position on the field over a course of a match using readings from your\n"
      "swerve drive encoders and swerve azimuth encoders.\n"
      "\n"
      "Teams can use odometry during the autonomous period for complex tasks like\n"
      "path following. Furthermore, odometry can be used for latency compensation\n"
      "when using computer-vision systems.";
    cls_SwerveDriveOdometry3d.def(py::init<SwerveDriveKinematics<NumModules>, const Rotation3d&, const wpi::array<SwerveModulePosition, NumModules>&, const Pose3d&>()
      , py::arg("kinematics"), py::arg("gyroAngle"), py::arg("modulePositions"), py::arg("initialPose") = Pose3d{}
      , release_gil(), py::keep_alive<1, 3>(), py::keep_alive<1, 4>(), py::keep_alive<1, 5>()
    );
    if (set_doc) {
      cls_SwerveDriveOdometry3d.doc() = set_doc;
    }
    if (add_doc) {
      cls_SwerveDriveOdometry3d.doc() = py::cast<std::string>(cls_SwerveDriveOdometry3d.doc()) + add_doc;
    }
  }
}; // struct bind_frc__SwerveDriveOdometry3d

}; // namespace swgen
