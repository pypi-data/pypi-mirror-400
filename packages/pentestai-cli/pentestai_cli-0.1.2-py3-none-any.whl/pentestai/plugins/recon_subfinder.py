from __future__ import annotations

import subprocess
from typing import Dict, Any

from pentestai.plugins.base import Plugin
from pentestai.core.artifacts import Artifact, now_iso, save_artifact, ws_paths
from pentestai.core.guardrails import require_scope_or_fail


class SubfinderPlugin(Plugin):
    name = "subfinder"

    def run(self, ctx, args: Dict[str, Any]) -> Dict[str, Any]:
        require_scope_or_fail(ctx.target, ctx.scope or [ctx.target])

        paths = ws_paths(ctx.workspace)
        out = paths["artifacts"] / "recon_subdomains.txt"

        # flags from ctx.vars (set by CLI)
        timeout = int(ctx.vars.get("subfinder_timeout", 30))
        dry_run = bool(ctx.vars.get("dry_run", False))
        verbose = bool(ctx.vars.get("verbose", False))

        # optional (if you add it later in CLI)
        sources = str(ctx.vars.get("subfinder_sources", "")).strip()

        # Build command
        cmd = ["subfinder", "-d", ctx.target, "-silent", "-timeout", str(timeout)]
        if sources:
            # subfinder supports -sources or -s? depends on version; keep as "-sources"
            cmd += ["-sources", sources]

        if verbose or dry_run:
            print(f"[PentestAI][subfinder] cmd: {' '.join(cmd)}")

        # Dry-run: do not execute, write empty output
        if dry_run:
            subs = []
            stderr_tail = ""
        else:
            r = subprocess.run(cmd, capture_output=True, text=True)
            subs = sorted(set(line.strip() for line in r.stdout.splitlines() if line.strip()))
            stderr_tail = (r.stderr or "")[-2000:]

            if verbose and stderr_tail:
                print(f"[PentestAI][subfinder] stderr(tail):\n{stderr_tail}")

        # Save outputs
        out.parent.mkdir(parents=True, exist_ok=True)
        out.write_text("\n".join(subs) + ("\n" if subs else ""), encoding="utf-8")

        art = Artifact(
            kind="recon.subdomains",
            created_at=now_iso(),
            data={"subdomains": subs, "count": len(subs)},
            meta={
                "cmd": cmd,
                "timeout": timeout,
                "dry_run": dry_run,
                "stderr_tail": stderr_tail,
            },
        )
        save_artifact(paths["artifacts"] / "recon_subdomains.json", art)
        return art.model_dump()
