"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .phoneendpointdto import PhoneEndpointDto, PhoneEndpointDtoTypedDict
from .slackchannelendpointdto import (
    SlackChannelEndpointDto,
    SlackChannelEndpointDtoTypedDict,
)
from .slackuserendpointdto import SlackUserEndpointDto, SlackUserEndpointDtoTypedDict
from .webhookendpointdto import WebhookEndpointDto, WebhookEndpointDtoTypedDict
from enum import Enum
from novu_py.types import BaseModel, Nullable, UNSET_SENTINEL
import pydantic
from pydantic import model_serializer
from typing import List, Union
from typing_extensions import Annotated, TypeAliasType, TypedDict


class GetChannelEndpointResponseDtoChannel(str, Enum):
    r"""The channel type (email, sms, push, chat, etc.)."""

    IN_APP = "in_app"
    EMAIL = "email"
    SMS = "sms"
    CHAT = "chat"
    PUSH = "push"


class GetChannelEndpointResponseDtoProviderID(str, Enum):
    r"""The provider identifier (e.g., sendgrid, twilio, slack, etc.)."""

    EMAILJS = "emailjs"
    MAILGUN = "mailgun"
    MAILJET = "mailjet"
    MANDRILL = "mandrill"
    NODEMAILER = "nodemailer"
    POSTMARK = "postmark"
    SENDGRID = "sendgrid"
    SENDINBLUE = "sendinblue"
    SES = "ses"
    NETCORE = "netcore"
    INFOBIP_EMAIL = "infobip-email"
    RESEND = "resend"
    PLUNK = "plunk"
    MAILERSEND = "mailersend"
    MAILTRAP = "mailtrap"
    CLICKATELL = "clickatell"
    OUTLOOK365 = "outlook365"
    NOVU_EMAIL = "novu-email"
    SPARKPOST = "sparkpost"
    EMAIL_WEBHOOK = "email-webhook"
    BRAZE = "braze"
    NEXMO = "nexmo"
    PLIVO = "plivo"
    SMS77 = "sms77"
    SMS_CENTRAL = "sms-central"
    SNS = "sns"
    TELNYX = "telnyx"
    TWILIO = "twilio"
    GUPSHUP = "gupshup"
    FIRETEXT = "firetext"
    INFOBIP_SMS = "infobip-sms"
    BURST_SMS = "burst-sms"
    BULK_SMS = "bulk-sms"
    ISEND_SMS = "isend-sms"
    FORTY_SIX_ELKS = "forty-six-elks"
    KANNEL = "kannel"
    MAQSAM = "maqsam"
    TERMII = "termii"
    AFRICAS_TALKING = "africas-talking"
    NOVU_SMS = "novu-sms"
    SENDCHAMP = "sendchamp"
    GENERIC_SMS = "generic-sms"
    CLICKSEND = "clicksend"
    BANDWIDTH = "bandwidth"
    MESSAGEBIRD = "messagebird"
    SIMPLETEXTING = "simpletexting"
    AZURE_SMS = "azure-sms"
    RING_CENTRAL = "ring-central"
    BREVO_SMS = "brevo-sms"
    EAZY_SMS = "eazy-sms"
    MOBISHASTRA = "mobishastra"
    AFRO_MESSAGE = "afro-message"
    UNIFONIC = "unifonic"
    SMSMODE = "smsmode"
    IMEDIA = "imedia"
    SINCH = "sinch"
    ISENDPRO_SMS = "isendpro-sms"
    FCM = "fcm"
    APNS = "apns"
    EXPO = "expo"
    ONE_SIGNAL = "one-signal"
    PUSHPAD = "pushpad"
    PUSH_WEBHOOK = "push-webhook"
    PUSHER_BEAMS = "pusher-beams"
    APPIO = "appio"
    NOVU = "novu"
    SLACK = "slack"
    DISCORD = "discord"
    MSTEAMS = "msteams"
    MATTERMOST = "mattermost"
    RYVER = "ryver"
    ZULIP = "zulip"
    GRAFANA_ON_CALL = "grafana-on-call"
    GETSTREAM = "getstream"
    ROCKET_CHAT = "rocket-chat"
    WHATSAPP_BUSINESS = "whatsapp-business"
    CHAT_WEBHOOK = "chat-webhook"
    NOVU_SLACK = "novu-slack"


class GetChannelEndpointResponseDtoType(str, Enum):
    r"""Type of channel endpoint"""

    SLACK_CHANNEL = "slack_channel"
    SLACK_USER = "slack_user"
    WEBHOOK = "webhook"
    PHONE = "phone"
    MS_TEAMS_CHANNEL = "ms_teams_channel"
    MS_TEAMS_USER = "ms_teams_user"


EndpointTypedDict = TypeAliasType(
    "EndpointTypedDict",
    Union[
        SlackChannelEndpointDtoTypedDict,
        SlackUserEndpointDtoTypedDict,
        PhoneEndpointDtoTypedDict,
        WebhookEndpointDtoTypedDict,
    ],
)
r"""Endpoint data specific to the channel type"""


Endpoint = TypeAliasType(
    "Endpoint",
    Union[
        SlackChannelEndpointDto,
        SlackUserEndpointDto,
        PhoneEndpointDto,
        WebhookEndpointDto,
    ],
)
r"""Endpoint data specific to the channel type"""


class GetChannelEndpointResponseDtoTypedDict(TypedDict):
    identifier: str
    r"""The unique identifier of the channel endpoint."""
    channel: Nullable[GetChannelEndpointResponseDtoChannel]
    r"""The channel type (email, sms, push, chat, etc.)."""
    provider_id: Nullable[GetChannelEndpointResponseDtoProviderID]
    r"""The provider identifier (e.g., sendgrid, twilio, slack, etc.)."""
    integration_identifier: Nullable[str]
    r"""The identifier of the integration to use for this channel endpoint."""
    connection_identifier: Nullable[str]
    r"""The identifier of the channel connection used for this endpoint."""
    subscriber_id: Nullable[str]
    r"""The subscriber ID to which the channel endpoint is linked"""
    context_keys: List[str]
    r"""The context of the channel connection"""
    type: GetChannelEndpointResponseDtoType
    r"""Type of channel endpoint"""
    endpoint: EndpointTypedDict
    r"""Endpoint data specific to the channel type"""
    created_at: str
    r"""The timestamp indicating when the channel endpoint was created, in ISO 8601 format."""
    updated_at: str
    r"""The timestamp indicating when the channel endpoint was last updated, in ISO 8601 format."""


class GetChannelEndpointResponseDto(BaseModel):
    identifier: str
    r"""The unique identifier of the channel endpoint."""

    channel: Nullable[GetChannelEndpointResponseDtoChannel]
    r"""The channel type (email, sms, push, chat, etc.)."""

    provider_id: Annotated[
        Nullable[GetChannelEndpointResponseDtoProviderID],
        pydantic.Field(alias="providerId"),
    ]
    r"""The provider identifier (e.g., sendgrid, twilio, slack, etc.)."""

    integration_identifier: Annotated[
        Nullable[str], pydantic.Field(alias="integrationIdentifier")
    ]
    r"""The identifier of the integration to use for this channel endpoint."""

    connection_identifier: Annotated[
        Nullable[str], pydantic.Field(alias="connectionIdentifier")
    ]
    r"""The identifier of the channel connection used for this endpoint."""

    subscriber_id: Annotated[Nullable[str], pydantic.Field(alias="subscriberId")]
    r"""The subscriber ID to which the channel endpoint is linked"""

    context_keys: Annotated[List[str], pydantic.Field(alias="contextKeys")]
    r"""The context of the channel connection"""

    type: GetChannelEndpointResponseDtoType
    r"""Type of channel endpoint"""

    endpoint: Endpoint
    r"""Endpoint data specific to the channel type"""

    created_at: Annotated[str, pydantic.Field(alias="createdAt")]
    r"""The timestamp indicating when the channel endpoint was created, in ISO 8601 format."""

    updated_at: Annotated[str, pydantic.Field(alias="updatedAt")]
    r"""The timestamp indicating when the channel endpoint was last updated, in ISO 8601 format."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = [
            "channel",
            "providerId",
            "integrationIdentifier",
            "connectionIdentifier",
            "subscriberId",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m
