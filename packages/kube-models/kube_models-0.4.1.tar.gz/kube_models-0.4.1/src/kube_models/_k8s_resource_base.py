# generated by https://github.com/puzl-cloud/kubesdk
import sys
from typing import ClassVar, Optional, Set, List, Dict, Any, Type
from dataclasses import dataclass, field
from typing import TypeVar, Generic

if sys.version_info < (3, 11):
    from typing_extensions import Self
else:
    from typing import Self

from .loader import Loadable, _LOAD_LAZY_FIELD, _LOAD_TYPES_ON_INIT
from .const import *

from kube_models.api_v1.io.k8s.apimachinery.pkg.apis.meta import ObjectMeta, ListMeta


_DYNAMIC_CLASS_VARS = ["apiVersion", "kind"]


@dataclass(slots=True, kw_only=True, frozen=True)
class K8sResource(Loadable):
    apiVersion: ClassVar[str]
    kind: ClassVar[str]
    metadata: ObjectMeta

    # OpenAPI fields which are not a part of the resource model
    plural_: ClassVar[str]
    group_: ClassVar[str]
    
    # Defaults for any resource including CRDs
    patch_strategies_: ClassVar[Set[PatchRequestType]] = {
        PatchRequestType.json,
        PatchRequestType.server_side_cbor,
        PatchRequestType.server_side,
        PatchRequestType.merge
    }
    is_namespaced_: ClassVar[bool]
    
    @classmethod
    def from_dict(cls, src: Dict[str, Any], lazy: bool = True) -> Self:
        for var in _DYNAMIC_CLASS_VARS:
            if var in src:
                del src[var]
        return cls(**src | {_LOAD_LAZY_FIELD: lazy, _LOAD_TYPES_ON_INIT: True})
        
    @classmethod
    def api_path(cls) -> str: 
        try:
            return cls.__api_path
        except AttributeError:
            version = cls.apiVersion.split("/", 1)[-1]
            base = f"apis/{cls.group_}/{version}" if cls.group_ else f"api/{version}"
            namespaced_path = "/namespaces/{namespace}" if cls.is_namespaced_ else ""
            cls.__api_path = f"{base}{namespaced_path}/{cls.plural_}"
            return cls.__api_path

    def to_dict(self, drop_nones: bool = False) -> Dict[str, Any]:
        res = super(K8sResource, self).to_dict(drop_nones)
        for var in _DYNAMIC_CLASS_VARS:
            res[var] = getattr(self, var)
        return res
        

def _bind_class_vars_from_original_kind(cls, params) -> Type:
    T = params[0] if isinstance(params, tuple) else params
    with cls._type_cache_lock:
        cached = cls._type_cache.get(T)
        if cached is not None:
            return cached

        # If vars are already concretely set on this class, don't override
        if all(cls.__dict__.get(var) is not None for var in _DYNAMIC_CLASS_VARS):
            cls._type_cache[T] = cls
            return cls

        # Check if something is unset in passed T class and do not inherit anything
        kw = {var: getattr(T, var, None) for var in _DYNAMIC_CLASS_VARS}
        for var, val in kw.items():
            if val is None:
                return cls

        # Modify kind to default, if it wasn't set on this class
        if not cls.__dict__.get("kind"):
            kw["kind"] = f"{kw['kind']}List"

        name = f"{cls.__name__}[{getattr(T, '__name__', repr(T))}]"
        specialized = type(name, (cls,), kw | {"__resource_type__": T})
        cls._type_cache[T] = specialized
        return specialized
