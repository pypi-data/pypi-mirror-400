{
    "worker_address": {
        "value": "127.0.0.1:31501",
        "description": "Address of worker in 'host:port' format (e.g., \"127.0.0.1:31501\"). The value cannot be empty."
    },
    "etcd_address": {
        "value": "",
        "description": "Address of ETCD server, (such as \"192.168.0.1:10001,192.168.0.2:10001,192.168.0.3:10001\")."
    },
    "shared_memory_size_mb": {
        "value": "1024",
        "description": "Upper limit of the shared memory, the unit is mb, must be greater than 0."
    },
    "sc_local_cache_memory_size_mb": {
        "value": "1024",
        "description": "Upper limit of the local cache used by stream cache, the unit is mb, must be greater than 0."
    },
    "oc_shm_threshold_percentage": {
        "value": "100",
        "description": "Upper limit of the shared memory in percentage can be used by OC, must be within (0, 100]"
    },
    "sc_shm_threshold_percentage": {
        "value": "100",
        "description": "Upper limit of the shared memory in percentage can be used by SC, must be within (0, 100]"
    },
    "heartbeat_interval_ms": {
        "value": "1000",
        "description": "Time interval between worker and etcd heartbeats."
    },
    "ipc_through_shared_memory": {
        "value": "true",
        "description": "Using shared memory to exchange data between client and worker. If this parameter is set to true, client and worker will pass control messages through Unix Domain Sockets (UDS); otherwise, they will pass control messages through TCP/IP and exchange data through TCP/IP."
    },
    "unix_domain_socket_dir": {
        "value": "./datasystem/uds",
        "description": "The directory to store unix domain socket file. The UDS generates temporary files in this path. Max length: 80"
    },
    "cluster_name": {
        "value": "",
        "description": "cluster_name is typically used in scenarios where multiple AZ datasystem share a single etcd cluster, allowing different clusters to be distinguished by the cluster_name."
    },
    "other_cluster_names": {
        "value": "",
        "description": "Specify other az names using the same etcd. Split by ','"
    },
    "enable_distributed_master": {
        "value": "true",
        "description": "Whether to support distributed master, default is true."
    },
    "sc_regular_socket_num": {
        "value": "32",
        "description": "The number of regular backend socket for stream cache, must be great equal than 0."
    },
    "sc_stream_socket_num": {
        "value": "32",
        "description": "The number of stream backend socket for stream cache, must be great equal than 0."
    },
    "oc_worker_worker_direct_port": {
        "value": "0",
        "description": "A direct tcp/ip port for worker to workers scenarios to improve latency. Acceptable values:0 or a positive integer. 0 indicates disabled."
    },
    "sc_worker_worker_direct_port": {
        "value": "0",
        "description": "A direct tcp/ip port for worker to workers scenarios to improve latency. Acceptable values:0, or some positive integer. 0 means disabled."
    },
    "oc_worker_worker_pool_size": {
        "value": "3",
        "description": "Number of parallel connections between worker/worker oc service. The flag `oc_worker_worker_direct_port` must be enabled for this setting to take effect"
    },
    "sc_worker_worker_pool_size": {
        "value": "3",
        "description": "Number of parallel connections between worker/worker sc service. Flag sc_worker_worker_direct_port must be enabled to take effect."
    },
    "sc_gc_interval_ms": {
        "value": "50",
        "description": "Memory resource clean up interval."
    },
    "sc_scan_interval_ms": {
        "value": "10",
        "description": "Scan interval for remote send"
    },
    "sc_metrics_log_interval_s": {
        "value": "60",
        "description": "Interval between logging stream metrics"
    },
    "sc_cache_pages": {
        "value": "16",
        "description": "Default number of cache pages"
    },
    "sc_scan_thread_num": {
        "value": "16",
        "description": "The num of threads used to scan new elements in shared memory."
    },
    "sc_scan_num_buckets": {
        "value": "1024",
        "description": "Number of partitions for scanning streams."
    },
    "sc_shared_page_size_mb": {
        "value": "4",
        "description": "The shared page size, should be in range [1, 16]."
    },
    "sc_shared_page_group_count": {
        "value": "4",
        "description": "The shared page group count for each remote worker, should be in range [1, 64]."
    },
    "master_sc_thread_num": {
        "value": "128",
        "description": "Max number of threads for (non rpc) master stream cache service work."
    },
    "payload_nocopy_threshold": {
        "value": "104857600",
        "description": "minimum payload size to trigger no memory copy"
    },
    "oc_thread_num": {
        "value": "32",
        "description": "The number of worker service for object cache, default is 32."
    },
    "eviction_thread_num": {
        "value": "1",
        "description": "Thread number of eviction for object cache."
    },
    "eviction_reserve_mem_threshold_mb": {
        "value": "10240",
        "description": "The reserved memory (MB) is determined by min(shared_memory_size_mb*0.2, eviction_reserve_mem_threshold_mb). Eviction begins when memory drops below this threshold.The valid range is 100-102400."
    },
    "client_reconnect_wait_s": {
        "value": "5",
        "description": "Client reconnect wait seconds, default is 5."
    },
    "page_size": {
        "value": "1048576",
        "description": "Size of the page used for caching worker files. The valid range is 4096-1073741824."
    },
    "etcd_meta_pool_size": {
        "value": "8",
        "description": "ETCD metadata async pool size."
    },
    "spill_directory": {
        "value": "",
        "description": "The path and file name prefix of the spilling, empty means spill disabled."
    },
    "spill_size_limit": {
        "value": 0,
        "description": "Maximum amount of spilled data that can be stored in the spill directory. If spill is enable and spill_size_limit is 0, spill_size_limit will be set to 95% of the spill directory."
    },
    "spill_thread_num": {
        "value": "8",
        "description": "It represents the maximum parallelism of writing files, more threads will consume more CPU and I/O resources."
    },
    "spill_file_max_size_mb": {
        "value": "200",
        "description": "The size limit of single spill file, spilling objects which lager than that value with one object per file. If there are some big objects, you can increase this value to avoid run out of inodes quickly. The valid range is 200-10240."
    },
    "spill_file_open_limit": {
        "value": "512",
        "description": "The maximum number of open file descriptors about spill. If opened file exceed this value, some files will be temporarily closed to prevent exceeding the maximum system limit. You need reduce this value if your system resources are limited. The valid range is greater than or equal to 8."
    },
    "spill_enable_readahead": {
        "value": "true",
        "description": "Disable readahead can mitigate the read amplification problem for offset read, default is true"
    },
    "log_monitor": {
        "value": "true",
        "description": "Record performance and resource logs."
    },
    "log_monitor_exporter": {
        "value": "harddisk",
        "description": "Specify the type of exporter, either harddisk or backend. Only takes effect when log_monitor is true."
    },
    "log_monitor_interval_ms": {
        "value": "10000",
        "description": "The sleep time between iterations of observability collector scan, default value is 10000ms(Must be greater than 0)."
    },
    "system_access_key": {
        "value": "",
        "description": "The access key for system component AK/SK authentication."
    },
    "system_secret_key": {
        "value": "",
        "description": "The secret key for system component AK/SK authentication."
    },
    "system_data_key": {
        "value": "",
        "description": "The data key for system to decrypt sensitive data. The length of encrypted datakey should be 32"
    },
    "tenant_access_key": {
        "value": "",
        "description": "The access key for tenant AK/SK authentication."
    },
    "tenant_secret_key": {
        "value": "",
        "description": "The secret key for tenant AK/SK authentication."
    },
    "request_expire_time_s": {
        "value": "300",
        "description": "When AK/SK authentication is used, if the duration from the client to the server is longer than this parameter, the authentication fails and the service is denied."
    },
    "max_client_num": {
        "value": "200",
        "description": "Maximum number of clients that can be connected to a worker. Value range: [1, 10000]."
    },
    "l2_cache_type": {
        "value": "none",
        "description": "Config the l2 cache type, obs. Optional value: 'obs', 'sfs', 'none'"
    },
    "l2_cache_delete_thread_num": {
        "value": "32",
        "description": "L2 cache delete thread number, increasing this value can improve the parallelism of deletion, but it will also increase the CPU consumption of the worker."
    },
    "object_del_retry_delay_sec": {
        "value": "3600",
        "description": "when we delete the object which is in uploading process, in this scenarios we need delay some time to retry."
    },
    "rocksdb_store_dir": {
        "value": "./datasystem/rocksdb",
        "description": "Config MASTER back store directory and must specify in rocksdb scenario. The rocksdb database is used to persistently store the metadata stored in the master so that the metadata before the restart can be re-obtained when the master restarts."
    },
    "rocksdb_max_open_file": {
        "value": "128",
        "description": "Number of open files that can be used by the rocksdb, default value is 128."
    },
    "rocksdb_background_threads": {
        "value": "16",
        "description": "Number of background threads rocksdb can use for flushing and compacting, default value is 16(Should be greater than 0)."
    },
    "rocksdb_write_mode": {
        "value": "async",
        "description": "Config the rocksdb support none, sync or async, async by default. Optional value: 'none', 'sync', 'async'. This represents the method of writing metadata to rocksdb."
    },
    "node_timeout_s": {
        "value": "60",
        "description": "Maximum time interval before a node is considered lost."
    },
    "node_dead_timeout_s": {
        "value": "300",
        "description": "Maximum time interval for the etcd to determine node death."
    },
    "arena_per_tenant": {
        "value": "16",
        "description": "The arena count for each tenant. Multiple arenas can improve the performance of share memory allocation for the first time, but each arena will use one more fd."
    },
    "shared_memory_populate": {
        "value": "false",
        "description": "Avoiding page faults during copying improves runtime performance but may result in longer worker startup times (depending on shared_memory_size_mb)."
    },
    "memory_reclamation_time_second": {
        "value": "600",
        "description": "The memory reclamation time after free."
    },
    "async_delete": {
        "value": "false",
        "description": "Master notify workers to delete objects asynchronously."
    },
    "add_node_wait_time_s": {
        "value": "60",
        "description": "Time to wait for the first node that wants to join a working hash ring."
    },
    "auto_del_dead_node": {
        "value": "true",
        "description": "Decide whether to remove the node from hash ring or not when node is dead"
    },
    "enable_hash_ring_self_healing": {
        "value": "false",
        "description": "Whether to support self-healing when the hash ring is in an abnormal state, default is false."
    },
    "client_dead_timeout_s": {
        "value": "120",
        "description": "Maximum time interval for the worker to determine client death, Value range: [15, UINT64_MAX)."
    },
    "monitor_config_file": {
        "value": "./datasystem/config/datasystem.config",
        "description": "Configure the path of the worker monitoring configuration file. During the execution of the worker, it periodically monitors whether the configuration file is changed to update the flag parameter value."
    },
    "enable_thp": {
        "value": "false",
        "description": "Control this process by enabling transparent huge pages, default is disabled. Enable Transparent Huge Pages (THP) can enhance performance and reduce page table overhead, but it may also lead to increased memory usage"
    },
    "cross_az_get_data_from_worker": {
        "value": "true",
        "description": "Control whether try to get data from other AZ's worker firstly, if false then get data from L2 cache directly."
    },
    "cross_az_get_meta_from_worker": {
        "value": "false",
        "description": "Control whether get meta data from other AZ's worker, if false then get meta data from local AZ."
    },
    "enable_worker_worker_batch_get": {
        "value": "false",
        "description": "Enable worker->worker OC batch get, default false."
    },
    "batch_get_threshold_mb": {
        "value": "100",
        "description": "The payload threshold to batch get objects, the unit is mb, must be greater than 0. Setting to 0 will indicate no split."
    },
    "enable_reconciliation": {
        "value": "true",
        "description": "Whether to enable reconciliation, default is true."
    },
    "data_migrate_rate_limit_mb": {
        "value": "40",
        "description": "Data migrate rate limit for every node when scale down happen."
    },
    "check_async_queue_empty_time_s": {
        "value": "15",
        "description": "The worker ensures a certain period of time that the asynchronous queues for sending messages to ETCD and L2 cache remain empty before it can exit properly."
    },
    "obs_access_key": {
        "value": "",
        "description": "Pass in access key for authentication when connecting to OBS."
    },
    "obs_secret_key": {
        "value": "",
        "description": "Pass in secret key for authentication when connecting to OBS."
    },
    "obs_endpoint": {
        "value": "",
        "description": "OBS address."
    },
    "obs_bucket": {
        "value": "",
        "description": "Name of OBS bucket to use. Can use only one bucket"
    },
    "obs_https_enabled": {
        "value": "false",
        "description": "Whether to enable the https in obs. false: use HTTP (default), true: use HTTPS"
    },
    "sfs_path": {
        "value": "",
        "description": "The path to the mounted SFS."
    },
    "health_check_path": {
        "value": "./datasystem/probe/healthy",
        "description": "File will create after the worker successfully."
    },
    "ready_check_path": {
        "value": "./datasystem/probe/ready",
        "description": "This file will be created after the worker service is started successfully and a connection can be established using the stub."
    },
    "rpc_thread_num": {
        "value": "16",
        "description": "Config rpc server thread number, must be great equal than 0."
    },
    "minloglevel": {
        "value": "0",
        "description": "Messages logged at a lower level than this don't actually get logged anywhere."
    },
    "log_dir": {
        "value": "./datasystem/logs",
        "description": "The directory where log files are stored."
    },
    "log_filename": {
        "value": "",
        "description": "Prefix of log filename, default is program invocation short name. Use standard characters only."
    },
    "log_async_queue_size": {
        "value": "65536",
        "description": "Size of async logger's message queue."
    },
    "max_log_size": {
        "value": "400",
        "description": "Maximum log file size (in MB), must be greater than 0."
    },
    "max_log_file_num": {
        "value": "5",
        "description": "Maximum number of log files to retain per severity level. And every log file size is limited by max_log_size."
    },
    "log_retention_day": {
        "value": "0",
        "description": "This value should be greater than or equal to 0.If log_retention_day is greater than 0, any log file from your project whose last modified time is greater than log_retention_day days will be unlinked. If log_retention_day is equal 0, will not unlink log file by time."
    },
    "log_async": {
        "value": "true",
        "description": "Flush log files with async mode."
    },
    "log_compress": {
        "value": "true",
        "description": "Compress old log files in .gz format. This parameter takes effect only when the size of the generated log is greater than max log size."
    },
    "logbufsecs": {
        "value": "10",
        "description": "Buffer log messages for at most this many seconds."
    },
    "v": {
        "value": "0",
        "description": "Vlog level, a larger value indicates more detailed logs. The value is between 0-3."
    },
    "enable_curve_zmq": {
        "value": "false",
        "description": "Whether to enable Curve ZMQ for authentication and authorization between components."
    },
    "zmq_server_io_context": {
        "value": "5",
        "description": "Optimize the performance of the customer. Default server 5. The higher the throughput, the higher the value, but should be in range [1, 32]."
    },
    "zmq_client_io_context": {
        "value": "5",
        "description": "Optimize the performance of a client stub. Default value 5. The higher the throughput, the higher the value, but should be in range [1, 32]."
    },
    "zmq_chunk_sz": {
        "value": "1048576",
        "description": "Parallel payload split chunk size. Default to 1048756 bytes."
    },
    "curve_key_dir": {
        "value": "",
        "description": "The directory to find ZMQ curve key files. This path must be specified when zmq authentication is enabled."
    },
    "enable_etcd_auth": {
        "value": "false",
        "description": "Whether to enable ETCD auth, default is false. ETCD certificate will be obtained."
    },
    "etcd_target_name_override": {
        "value": "",
        "description": "Set etcd target name override for SSL host name checking, default is none. The configuration value should be consistent with the DNS content of the Subject Alternate Names of the TLS certificate."
    },
    "etcd_ca": {
        "value": "",
        "description": "The path of encrypted root etcd certificate, default is none."
    },
    "etcd_cert": {
        "value": "",
        "description": "The path of encrypted client's etcd certificate chain, default is none."
    },
    "etcd_key": {
        "value": "",
        "description": "The path of encrypted client's etcd private key, default is none."
    },
    "etcd_passphrase_path": {
        "value": "",
        "description": "The path of passphrase for the encrypted etcd encypted private key, default is none."
    },
    "max_rpc_session_num": {
        "value": "2048",
        "description": "Maximum number of sessions that can be cached, must be within [512, 10'000]"
    },
    "enable_huge_tlb": {
        "value": "false",
        "description": "This is controlled by the flag of mmap(MAP_HUGETLB) which can improve memory access and reducing the overhead of page table, default is disable."
    },
    "enable_fallocate": {
        "value": "true",
        "description": "Due to k8s's resource calculation policies,shared memory is sometimes multiple counted , which can lead to client crashes, Using fallocate to address this issue."
    },
    "enable_lossless_data_exit_mode": {
        "value": "false",
        "description": "Migrate data to another node before the node exits if other nodes are available. If this is the only node in the cluster, exits directly and the data will be lost."
    },
    "enable_p2p_transfer": {
        "value": "false",
        "description": "Heterogeneous object transfer protocol Enables p2ptransfer."
    },
    "enable_cloud_service_token_rotation": {
        "value": "false",
        "description": "Enable the OBS client to access OBS using a temporary token. After the token expires, obtain a new token and connect to OBS again."
    },
    "enable_meta_replica": {
        "value": "false",
        "description": "Controls whether to enable multiple meta replica"
    },
    "enable_urma": {
        "value": "false",
        "description": "Option to turn on urma for OC worker to worker data transfer, default false."
    },
    "urma_connection_size": {
        "value": "16",
        "description": "Number of jfs and jfr pair"
    },
    "urma_event_mode": {
        "value": "false",
        "description": "Uses interrupt mode to poll completion events."
    },
    "urma_poll_size": {
        "value": "8",
        "description": "Number of complete record to poll at a time, 16 is the max this device can poll"
    },
    "urma_register_whole_arena": {
        "value": "true",
        "description": "Register the whole arena as segment during init, otherwise, register each object as a segment."
    },
    "urma_mode": {
        "value": "UB",
        "description": "Option to enable URMA over IB or UB, default UB to run with URMA over UB."
    },
    "logfile_mode": {
        "value": "416",
        "description": "Log file mode/permissions."
    },
    "oc_shm_transfer_threshold_kb": {
        "value": "500",
        "description": "The data threshold to transfer obj data between client and worker via shm, unit is KB"
    },
    "remote_send_thread_num": {
        "value": "8",
        "description": "The num of threads used to send elements to remote worker."
    },
    "shared_disk_arena_per_tenant": {
        "value": "8",
        "description": "The number of disk cache Arena for each tenant. Multiple arenas can improve the performance of shared disk allocation for the first time, but each arena will use one more fd. The valid range is 0 to 32."
    },
    "shared_disk_directory": {
        "value": "",
        "description": "Disk cache data placement directory, default value is empty, indicating that disk cache is not enabled."
    },
    "shared_disk_size_mb": {
        "value": "0",
        "description": "Upper limit of the shared disk, the unit is mb."
    },
    "stream_idle_time_s": {
        "value": "300",
        "description": "stream idle time. default 300s (5 minutes)"
    },
    "skip_authenticate": {
        "value": "false",
        "description": "Skip authentication for worker requests"
    },
    "enable_data_replication": {
        "value": "true",
        "description": "Allow data's replica to be cached locally"
    },
    "enable_redirect": {
        "value": "true",
        "description": "Enable query meta redirect when scale up or voluntary scale down, default is true"
    },
    "enable_rdma": {
        "value": "false",
        "description": "Option to turn on rdma for OC worker to worker data transfer, default false"
    },
    "rdma_register_whole_arena": {
        "value": "true",
        "description": "Register the whole arena as segment during init, otherwise, register each object as a segment"
    },
    "enable_stream_data_verification": {
        "value": "false",
        "description": "Option to verify if data from a producer is out of order"
    },
    "oc_io_from_l2cache_need_metadata": {
        "value": "true",
        "description": "Whether data read and write from the L2 cache daemon depend on metadata. Note: If set to false, it indicates that the metadata is not stored in etcd"
    },
    "oc_worker_aggregate_merge_size": {
        "value": "2097152",
        "description": "Target batch size for worker worker responses, default is 2MB"
    },
    "oc_worker_aggregate_single_max": {
        "value": "65536",
        "description": "Max single item size for batching worker worker batch rsp, default is 64KB"
    },
    "oc_worker_worker_parallel_min": {
        "value": "100",
        "description": "Min data count for parallel worker worker batch rsp, default is 100"
    },
    "oc_worker_worker_parallel_nums": {
        "value": "16",
        "description": "worker worker batch rsp control nums, default 0 means unlimited"
    },
    "sc_encrypt_secret_key": {
        "value": "",
        "description": "The encrypted secret key for stream cache. The key length is up to 1024 bytes and must be 32 bytes after decryption"
    },
    "iam_kit": {
        "value": "none",
        "description": "The type of iam kit, none is default, value range: [none, yuanrong_iam]"
    },
    "yuanrong_iam_url": {
        "value": "",
        "description": "yuanrong_iam auth server url"
    },
    "yuanrong_iam_ca": {
        "value": "",
        "description": "File path of trusted CA/ca bundle file for yuanrong iam, optional. Use standard characters only. if ca , cert, key is all empty, connect with yuanrong iam without tls."
    },
    "yuanrong_iam_cert": {
        "default": "",
        "description": "File path of client certificate file for yuanrong iam, optional. Use standard characters only. if ca , cert, key is all empty, connect with yuanrong iam without tls."
    },
    "yuanrong_iam_key": {
        "value": "",
        "description": "File path of client private key, optional for yuanrong iam. Use standard characters only. if ca , cert, key is all empty, connect with yuanrong iam without tls."
    },
    "yuanrong_iam_passphrase": {
        "value": "",
        "description": "File path of tls pwd, optional for yuanrong iam. Use standard characters only. if ca , cert, key is all empty, connect with yuanrong iam without tls."
    }
}