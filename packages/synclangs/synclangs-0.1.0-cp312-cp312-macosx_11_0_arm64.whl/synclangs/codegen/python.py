"""Python code generator for SyncLangs types."""

from __future__ import annotations

import posixpath

from synclangs.codegen.base import CodeGenerator
from synclangs.parser.ast import (
    ConstDef,
    EnumDef,
    Field,
    FunctionDef,
    InterfaceDef,
    ListTypeExpr,
    MapTypeExpr,
    Module,
    NullableTypeExpr,
    PrimitiveType,
    PrimitiveTypeExpr,
    TypeDef,
    TypeExpr,
    TypeRef,
    VoidType,
)


class PythonGenerator(CodeGenerator):
    """Generate Python dataclasses from SyncLangs AST."""

    def __init__(self, file_extension: str = "_types.py") -> None:
        self._file_extension = file_extension

    def generate(self, module: Module) -> str:
        """Generate Python source code for a module."""
        lines: list[str] = [
            "# Auto-generated by SyncLangs - DO NOT EDIT",
            "from __future__ import annotations",
            "",
        ]

        # Collect standard library imports
        stdlib_imports: list[str] = []
        if module.types:
            stdlib_imports.append("from dataclasses import dataclass")
        if module.enums:
            stdlib_imports.append("from enum import Enum")
        if module.interfaces:
            stdlib_imports.append("from abc import ABC, abstractmethod")
        lines.extend(stdlib_imports)

        typing_imports = self._collect_typing_imports(module)
        if typing_imports:
            imports = ", ".join(sorted(typing_imports))
            lines.append(f"from typing import {imports}")

        lines.append("")

        if module.imports:
            for import_stmt in module.imports:
                import_path = self._python_import_path(
                    module.path, import_stmt.path
                )
                names = ", ".join(import_stmt.names)
                lines.append(f"from {import_path} import {names}")
            lines.append("")

        # Generate constants first
        for const_def in module.constants:
            lines.extend(self._generate_constant(const_def))
        if module.constants:
            lines.append("")

        # Generate enums
        for enum_def in module.enums:
            lines.extend(self._generate_enum(enum_def))
            lines.append("")

        # Generate types (dataclasses with optional inheritance)
        for type_def in module.types:
            lines.extend(self._generate_type(type_def))
            lines.append("")

        # Generate interface definitions (as ABC classes)
        for interface_def in module.interfaces:
            lines.extend(self._generate_interface(interface_def))
            lines.append("")

        # Generate function type aliases
        for fn_def in module.functions:
            lines.extend(self._generate_function_type(fn_def))
            lines.append("")

        return "\n".join(lines).rstrip() + "\n"

    def _generate_type(self, type_def: TypeDef) -> list[str]:
        """Generate a Python dataclass for a type definition."""
        lines: list[str] = []
        lines.append("@dataclass")

        # Build base classes
        bases: list[str] = []
        if type_def.extends:
            bases.append(type_def.extends)
        if type_def.implements:
            bases.extend(type_def.implements)

        if bases:
            lines.append(f"class {type_def.name}({', '.join(bases)}):")
        else:
            lines.append(f"class {type_def.name}:")

        if type_def.doc_comment:
            lines.extend(self._format_docstring(type_def.doc_comment, "    "))
        if type_def.fields:
            for field in type_def.fields:
                if field.doc_comment:
                    for line in field.doc_comment.splitlines():
                        lines.append(f"    # {line}")
                field_type, is_optional = self._field_type(field)
                if is_optional:
                    lines.append(f"    {field.name}: {field_type} = None")
                else:
                    lines.append(f"    {field.name}: {field_type}")
        else:
            lines.append("    pass")
        return lines

    def _generate_interface(self, interface_def: InterfaceDef) -> list[str]:
        """Generate a Python ABC class for an interface definition."""
        lines: list[str] = []
        lines.append(f"class {interface_def.name}(ABC):")
        if interface_def.doc_comment:
            lines.extend(self._format_docstring(interface_def.doc_comment, "    "))

        has_members = interface_def.fields or interface_def.functions

        # Generate fields (as abstract properties could be an option, but we'll use class vars)
        for field in interface_def.fields:
            if field.doc_comment:
                for line in field.doc_comment.splitlines():
                    lines.append(f"    # {line}")
            field_type, is_optional = self._field_type(field)
            if is_optional:
                lines.append(f"    {field.name}: {field_type} = None")
            else:
                lines.append(f"    {field.name}: {field_type}")

        # Generate abstract methods
        for fn_def in interface_def.functions:
            lines.append("")
            lines.append("    @abstractmethod")
            signature = self._function_signature(fn_def)
            lines.append(f"    {signature}")
            if fn_def.doc_comment:
                lines.extend(self._format_docstring(fn_def.doc_comment, "        "))
            lines.append("        ...")

        if not has_members:
            lines.append("    pass")

        return lines

    def _generate_function_type(self, fn_def: FunctionDef) -> list[str]:
        """Generate a Python Callable type alias for a function."""
        lines: list[str] = []
        if fn_def.doc_comment:
            for line in fn_def.doc_comment.splitlines():
                lines.append(f"# {line}")

        # Build parameter types
        param_types = ", ".join(
            self._type_to_py(p.type_expr) for p in fn_def.params
        )

        # Build return type
        return_type = self._return_type_to_py(fn_def.return_type, fn_def.is_async)

        type_name = f"{fn_def.name[0].upper()}{fn_def.name[1:]}Fn"
        lines.append(f"{type_name} = Callable[[{param_types}], {return_type}]")
        return lines

    def _function_signature(self, fn_def: FunctionDef) -> str:
        """Generate a Python function signature."""
        params = ["self"] + [
            f"{p.name}: {self._type_to_py(p.type_expr)}"
            for p in fn_def.params
        ]
        params_str = ", ".join(params)

        return_type = self._return_type_to_py(fn_def.return_type, fn_def.is_async)

        if fn_def.is_async:
            return f"async def {fn_def.name}({params_str}) -> {return_type}:"
        return f"def {fn_def.name}({params_str}) -> {return_type}:"

    def _return_type_to_py(self, return_type: TypeExpr | VoidType, is_async: bool) -> str:
        """Convert a return type to Python."""
        if isinstance(return_type, VoidType):
            base_type = "None"
        else:
            base_type = self._type_to_py(return_type)

        if is_async:
            return f"Awaitable[{base_type}]"
        return base_type

    def _generate_constant(self, const_def: ConstDef) -> list[str]:
        """Generate a Python constant definition."""
        lines: list[str] = []
        if const_def.doc_comment:
            for line in const_def.doc_comment.splitlines():
                lines.append(f"# {line}")
        py_type = self._type_to_py(const_def.type_expr)
        value = self._const_value_to_py(const_def.value)
        lines.append(f"{const_def.name}: {py_type} = {value}")
        return lines

    def _generate_enum(self, enum_def: EnumDef) -> list[str]:
        """Generate a Python enum class."""
        lines: list[str] = []
        lines.append(f"class {enum_def.name}(str, Enum):")
        if enum_def.doc_comment:
            lines.extend(self._format_docstring(enum_def.doc_comment, "    "))
        if enum_def.variants:
            for variant in enum_def.variants:
                if variant.doc_comment:
                    for line in variant.doc_comment.splitlines():
                        lines.append(f"    # {line}")
                lines.append(f'    {variant.name.upper()} = "{variant.name}"')
        else:
            lines.append("    pass")
        return lines

    def _const_value_to_py(self, value: "ConstDef.value") -> str:
        """Convert a constant value to Python literal."""
        from synclangs.parser.ast import ConstValue

        if not isinstance(value, ConstValue):
            return str(value)
        if isinstance(value.value, str):
            return f'"{value.value}"'
        if isinstance(value.value, bool):
            return "True" if value.value else "False"
        return str(value.value)

    def _collect_typing_imports(self, module: Module) -> set[str]:
        """Collect typing imports needed by the module."""
        imports: set[str] = set()
        for type_def in module.types:
            for field in type_def.fields:
                self._collect_type_imports(field.type_expr, imports)
        for interface_def in module.interfaces:
            for field in interface_def.fields:
                self._collect_type_imports(field.type_expr, imports)
            for fn_def in interface_def.functions:
                self._collect_function_imports(fn_def, imports)
        for fn_def in module.functions:
            imports.add("Callable")
            self._collect_function_imports(fn_def, imports)
        return imports

    def _collect_function_imports(self, fn_def: FunctionDef, imports: set[str]) -> None:
        """Collect typing imports required for a function."""
        for param in fn_def.params:
            self._collect_type_imports(param.type_expr, imports)
        if not isinstance(fn_def.return_type, VoidType):
            self._collect_type_imports(fn_def.return_type, imports)
        if fn_def.is_async:
            imports.add("Awaitable")

    def _collect_type_imports(self, type_expr: TypeExpr, imports: set[str]) -> None:
        """Collect typing imports required for a type expression."""
        if isinstance(type_expr, NullableTypeExpr):
            imports.add("Optional")
            self._collect_type_imports(type_expr.inner_type, imports)
        elif isinstance(type_expr, ListTypeExpr):
            self._collect_type_imports(type_expr.element_type, imports)
        elif isinstance(type_expr, MapTypeExpr):
            self._collect_type_imports(type_expr.key_type, imports)
            self._collect_type_imports(type_expr.value_type, imports)
        elif isinstance(type_expr, PrimitiveTypeExpr):
            if type_expr.primitive == PrimitiveType.ANY:
                imports.add("Any")
        elif isinstance(type_expr, TypeRef):
            return

    def _field_type(self, field: Field) -> tuple[str, bool]:
        """Return the Python type and optional flag for a field."""
        if isinstance(field.type_expr, NullableTypeExpr):
            inner = self._type_to_py(field.type_expr.inner_type)
            return f"Optional[{inner}]", True
        return self._type_to_py(field.type_expr), False

    def _type_to_py(self, type_expr: TypeExpr) -> str:
        """Convert a type expression to a Python type hint."""
        if isinstance(type_expr, PrimitiveTypeExpr):
            return self._primitive_to_py(type_expr.primitive)
        if isinstance(type_expr, ListTypeExpr):
            inner = self._type_to_py(type_expr.element_type)
            return f"list[{inner}]"
        if isinstance(type_expr, MapTypeExpr):
            key = self._type_to_py(type_expr.key_type)
            value = self._type_to_py(type_expr.value_type)
            return f"dict[{key}, {value}]"
        if isinstance(type_expr, NullableTypeExpr):
            inner = self._type_to_py(type_expr.inner_type)
            return f"Optional[{inner}]"
        if isinstance(type_expr, TypeRef):
            return type_expr.name
        raise TypeError(f"Unsupported type expression: {type_expr}")

    def _primitive_to_py(self, primitive: PrimitiveType) -> str:
        """Map primitive SyncLangs types to Python types."""
        mapping = {
            PrimitiveType.STRING: "str",
            PrimitiveType.INT: "int",
            PrimitiveType.FLOAT: "float",
            PrimitiveType.BOOL: "bool",
            PrimitiveType.ANY: "Any",
        }
        return mapping[primitive]

    def _python_import_path(self, module_path: str, import_path: str) -> str:
        """Resolve an import path to a Python relative module path."""
        current_dir = posixpath.dirname(module_path)
        target_path = posixpath.normpath(posixpath.join(current_dir, import_path))
        if target_path.endswith(".syln"):
            target_path = target_path[: -len(".syln")] + self._file_extension
        if target_path.endswith(".py"):
            target_path = target_path[: -len(".py")]
        base = current_dir if current_dir else "."
        rel_path = posixpath.relpath(target_path, base)
        parts = rel_path.split("/")
        up_levels = 0
        while parts and parts[0] == "..":
            up_levels += 1
            parts.pop(0)
        prefix = "." * (up_levels + 1)
        suffix = ".".join(parts)
        return f"{prefix}{suffix}" if suffix else prefix

    def _format_docstring(self, text: str, indent: str) -> list[str]:
        """Format a docstring with the provided indentation."""
        lines = text.splitlines()
        if len(lines) == 1:
            return [f'{indent}"""{lines[0]}"""']
        formatted = [f'{indent}"""']
        formatted.extend(f"{indent}{line}" for line in lines)
        formatted.append(f'{indent}"""')
        return formatted
