# coding: utf-8

"""
    external/v1/auth_service.proto

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: version not set
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git

    NOTE
    ----
    standard swagger-codegen-cli for this python client has been modified
    by custom templates. The purpose of these templates is to include
    typing information in the API and Model code. Please refer to the
    main grid repository for more info
"""

from __future__ import absolute_import

import re  # noqa: F401
from typing import TYPE_CHECKING, Any

# python 2 and python 3 compatibility library
import six

from lightning_cloud.openapi.api_client import ApiClient

if TYPE_CHECKING:
    from datetime import datetime
    from lightning_cloud.openapi.models import *

class BillingServiceApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def billing_service_create_billing_portal_session(self, body: 'V1CreateBillingPortalSessionRequest', **kwargs) -> 'V1CreateBillingPortalSessionResponse':  # noqa: E501
        """billing_service_create_billing_portal_session  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.billing_service_create_billing_portal_session(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V1CreateBillingPortalSessionRequest body: (required)
        :return: V1CreateBillingPortalSessionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.billing_service_create_billing_portal_session_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.billing_service_create_billing_portal_session_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def billing_service_create_billing_portal_session_with_http_info(self, body: 'V1CreateBillingPortalSessionRequest', **kwargs) -> 'V1CreateBillingPortalSessionResponse':  # noqa: E501
        """billing_service_create_billing_portal_session  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.billing_service_create_billing_portal_session_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V1CreateBillingPortalSessionRequest body: (required)
        :return: V1CreateBillingPortalSessionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method billing_service_create_billing_portal_session" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `billing_service_create_billing_portal_session`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/billing/portal-session', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1CreateBillingPortalSessionResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def billing_service_create_billing_upgrade_trigger_record(self, body: 'BillingServiceCreateBillingUpgradeTriggerRecordBody', user_id: 'str', **kwargs) -> 'V1CreateBillingUpgradeTriggerRecordResponse':  # noqa: E501
        """billing_service_create_billing_upgrade_trigger_record  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.billing_service_create_billing_upgrade_trigger_record(body, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BillingServiceCreateBillingUpgradeTriggerRecordBody body: (required)
        :param str user_id: (required)
        :return: V1CreateBillingUpgradeTriggerRecordResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.billing_service_create_billing_upgrade_trigger_record_with_http_info(body, user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.billing_service_create_billing_upgrade_trigger_record_with_http_info(body, user_id, **kwargs)  # noqa: E501
            return data

    def billing_service_create_billing_upgrade_trigger_record_with_http_info(self, body: 'BillingServiceCreateBillingUpgradeTriggerRecordBody', user_id: 'str', **kwargs) -> 'V1CreateBillingUpgradeTriggerRecordResponse':  # noqa: E501
        """billing_service_create_billing_upgrade_trigger_record  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.billing_service_create_billing_upgrade_trigger_record_with_http_info(body, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BillingServiceCreateBillingUpgradeTriggerRecordBody body: (required)
        :param str user_id: (required)
        :return: V1CreateBillingUpgradeTriggerRecordResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'user_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method billing_service_create_billing_upgrade_trigger_record" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `billing_service_create_billing_upgrade_trigger_record`")  # noqa: E501
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `billing_service_create_billing_upgrade_trigger_record`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/billing/{userId}/upgrade-trigger', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1CreateBillingUpgradeTriggerRecordResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def billing_service_create_checkout_session(self, body: 'V1CreateCheckoutSessionRequest', **kwargs) -> 'V1CreateCheckoutSessionResponse':  # noqa: E501
        """billing_service_create_checkout_session  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.billing_service_create_checkout_session(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V1CreateCheckoutSessionRequest body: (required)
        :return: V1CreateCheckoutSessionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.billing_service_create_checkout_session_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.billing_service_create_checkout_session_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def billing_service_create_checkout_session_with_http_info(self, body: 'V1CreateCheckoutSessionRequest', **kwargs) -> 'V1CreateCheckoutSessionResponse':  # noqa: E501
        """billing_service_create_checkout_session  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.billing_service_create_checkout_session_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V1CreateCheckoutSessionRequest body: (required)
        :return: V1CreateCheckoutSessionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method billing_service_create_checkout_session" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `billing_service_create_checkout_session`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/billing/checkout', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1CreateCheckoutSessionResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def billing_service_create_org_checkout_session(self, body: 'BillingServiceCreateOrgCheckoutSessionBody', org_id: 'str', **kwargs) -> 'V1CreateCheckoutSessionResponse':  # noqa: E501
        """billing_service_create_org_checkout_session  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.billing_service_create_org_checkout_session(body, org_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BillingServiceCreateOrgCheckoutSessionBody body: (required)
        :param str org_id: (required)
        :return: V1CreateCheckoutSessionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.billing_service_create_org_checkout_session_with_http_info(body, org_id, **kwargs)  # noqa: E501
        else:
            (data) = self.billing_service_create_org_checkout_session_with_http_info(body, org_id, **kwargs)  # noqa: E501
            return data

    def billing_service_create_org_checkout_session_with_http_info(self, body: 'BillingServiceCreateOrgCheckoutSessionBody', org_id: 'str', **kwargs) -> 'V1CreateCheckoutSessionResponse':  # noqa: E501
        """billing_service_create_org_checkout_session  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.billing_service_create_org_checkout_session_with_http_info(body, org_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BillingServiceCreateOrgCheckoutSessionBody body: (required)
        :param str org_id: (required)
        :return: V1CreateCheckoutSessionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'org_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method billing_service_create_org_checkout_session" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `billing_service_create_org_checkout_session`")  # noqa: E501
        # verify the required parameter 'org_id' is set
        if ('org_id' not in params or
                params['org_id'] is None):
            raise ValueError("Missing the required parameter `org_id` when calling `billing_service_create_org_checkout_session`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'org_id' in params:
            path_params['orgId'] = params['org_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/orgs/{orgId}/billing/checkout', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1CreateCheckoutSessionResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def billing_service_create_subscription_checkout_session(self, body: 'V1CreateSubscriptionCheckoutSessionRequest', **kwargs) -> 'V1CreateSubscriptionCheckoutSessionResponse':  # noqa: E501
        """billing_service_create_subscription_checkout_session  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.billing_service_create_subscription_checkout_session(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V1CreateSubscriptionCheckoutSessionRequest body: (required)
        :return: V1CreateSubscriptionCheckoutSessionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.billing_service_create_subscription_checkout_session_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.billing_service_create_subscription_checkout_session_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def billing_service_create_subscription_checkout_session_with_http_info(self, body: 'V1CreateSubscriptionCheckoutSessionRequest', **kwargs) -> 'V1CreateSubscriptionCheckoutSessionResponse':  # noqa: E501
        """billing_service_create_subscription_checkout_session  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.billing_service_create_subscription_checkout_session_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V1CreateSubscriptionCheckoutSessionRequest body: (required)
        :return: V1CreateSubscriptionCheckoutSessionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method billing_service_create_subscription_checkout_session" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `billing_service_create_subscription_checkout_session`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/billing/subscription/checkout', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1CreateSubscriptionCheckoutSessionResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def billing_service_get_assistant_session_daily_aggregated(self, **kwargs) -> 'V1GetAssistantSessionDailyAggregatedResponse':  # noqa: E501
        """Aggregated assistant session endpoint to get credits spending information. Provides credits consumption data by particular project according to filters given.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.billing_service_get_assistant_session_daily_aggregated(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_id:
        :param datetime _from:
        :param datetime to:
        :param str user_id:
        :param str org_id:
        :param bool details: whether to display details of the sessions
        :return: V1GetAssistantSessionDailyAggregatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.billing_service_get_assistant_session_daily_aggregated_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.billing_service_get_assistant_session_daily_aggregated_with_http_info(**kwargs)  # noqa: E501
            return data

    def billing_service_get_assistant_session_daily_aggregated_with_http_info(self, **kwargs) -> 'V1GetAssistantSessionDailyAggregatedResponse':  # noqa: E501
        """Aggregated assistant session endpoint to get credits spending information. Provides credits consumption data by particular project according to filters given.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.billing_service_get_assistant_session_daily_aggregated_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_id:
        :param datetime _from:
        :param datetime to:
        :param str user_id:
        :param str org_id:
        :param bool details: whether to display details of the sessions
        :return: V1GetAssistantSessionDailyAggregatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', '_from', 'to', 'user_id', 'org_id', 'details']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method billing_service_get_assistant_session_daily_aggregated" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'project_id' in params:
            query_params.append(('projectId', params['project_id']))  # noqa: E501
        if '_from' in params:
            query_params.append(('from', params['_from']))  # noqa: E501
        if 'to' in params:
            query_params.append(('to', params['to']))  # noqa: E501
        if 'user_id' in params:
            query_params.append(('userId', params['user_id']))  # noqa: E501
        if 'org_id' in params:
            query_params.append(('orgId', params['org_id']))  # noqa: E501
        if 'details' in params:
            query_params.append(('details', params['details']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/billing/assistant-session', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1GetAssistantSessionDailyAggregatedResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def billing_service_get_billing_subscription(self, **kwargs) -> 'V1BillingSubscription':  # noqa: E501
        """Billing subscription endpoint that returns the organization's current subscription and its features  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.billing_service_get_billing_subscription(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str org_id:
        :param str project_id:
        :return: V1BillingSubscription
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.billing_service_get_billing_subscription_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.billing_service_get_billing_subscription_with_http_info(**kwargs)  # noqa: E501
            return data

    def billing_service_get_billing_subscription_with_http_info(self, **kwargs) -> 'V1BillingSubscription':  # noqa: E501
        """Billing subscription endpoint that returns the organization's current subscription and its features  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.billing_service_get_billing_subscription_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str org_id:
        :param str project_id:
        :return: V1BillingSubscription
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['org_id', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method billing_service_get_billing_subscription" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'org_id' in params:
            query_params.append(('orgId', params['org_id']))  # noqa: E501
        if 'project_id' in params:
            query_params.append(('projectId', params['project_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/billing/subscription', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1BillingSubscription',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def billing_service_get_org_balance(self, org_id: 'str', **kwargs) -> 'V1GetProjectBalanceResponse':  # noqa: E501
        """billing_service_get_org_balance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.billing_service_get_org_balance(org_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str org_id: (required)
        :param bool include_transactions:
        :return: V1GetProjectBalanceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.billing_service_get_org_balance_with_http_info(org_id, **kwargs)  # noqa: E501
        else:
            (data) = self.billing_service_get_org_balance_with_http_info(org_id, **kwargs)  # noqa: E501
            return data

    def billing_service_get_org_balance_with_http_info(self, org_id: 'str', **kwargs) -> 'V1GetProjectBalanceResponse':  # noqa: E501
        """billing_service_get_org_balance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.billing_service_get_org_balance_with_http_info(org_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str org_id: (required)
        :param bool include_transactions:
        :return: V1GetProjectBalanceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['org_id', 'include_transactions']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method billing_service_get_org_balance" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'org_id' is set
        if ('org_id' not in params or
                params['org_id'] is None):
            raise ValueError("Missing the required parameter `org_id` when calling `billing_service_get_org_balance`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'org_id' in params:
            path_params['orgId'] = params['org_id']  # noqa: E501

        query_params = []
        if 'include_transactions' in params:
            query_params.append(('includeTransactions', params['include_transactions']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/orgs/{orgId}/billing/balance', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1GetProjectBalanceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def billing_service_get_project_balance(self, project_id: 'str', **kwargs) -> 'V1GetProjectBalanceResponse':  # noqa: E501
        """billing_service_get_project_balance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.billing_service_get_project_balance(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_id: (required)
        :param bool include_transactions:
        :return: V1GetProjectBalanceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.billing_service_get_project_balance_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.billing_service_get_project_balance_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def billing_service_get_project_balance_with_http_info(self, project_id: 'str', **kwargs) -> 'V1GetProjectBalanceResponse':  # noqa: E501
        """billing_service_get_project_balance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.billing_service_get_project_balance_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_id: (required)
        :param bool include_transactions:
        :return: V1GetProjectBalanceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'include_transactions']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method billing_service_get_project_balance" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `billing_service_get_project_balance`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []
        if 'include_transactions' in params:
            query_params.append(('includeTransactions', params['include_transactions']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/projects/{projectId}/billing/balance', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1GetProjectBalanceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def billing_service_get_project_compute_usage(self, project_id: 'str', **kwargs) -> 'V1GetProjectComputeUsageResponse':  # noqa: E501
        """Compute usage, deprecate?  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.billing_service_get_project_compute_usage(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_id: required project id (required)
        :param datetime _from: Optional filter, defaults to the current day
        :param datetime to: Optional filter, defaults to the current day
        :param str resource_id: Optional filter based on resource ID, e.g. session or experiment ID
        :return: V1GetProjectComputeUsageResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.billing_service_get_project_compute_usage_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.billing_service_get_project_compute_usage_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def billing_service_get_project_compute_usage_with_http_info(self, project_id: 'str', **kwargs) -> 'V1GetProjectComputeUsageResponse':  # noqa: E501
        """Compute usage, deprecate?  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.billing_service_get_project_compute_usage_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_id: required project id (required)
        :param datetime _from: Optional filter, defaults to the current day
        :param datetime to: Optional filter, defaults to the current day
        :param str resource_id: Optional filter based on resource ID, e.g. session or experiment ID
        :return: V1GetProjectComputeUsageResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', '_from', 'to', 'resource_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method billing_service_get_project_compute_usage" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `billing_service_get_project_compute_usage`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []
        if '_from' in params:
            query_params.append(('from', params['_from']))  # noqa: E501
        if 'to' in params:
            query_params.append(('to', params['to']))  # noqa: E501
        if 'resource_id' in params:
            query_params.append(('resourceId', params['resource_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/projects/{projectId}/billing/compute', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1GetProjectComputeUsageResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def billing_service_get_usage_details(self, **kwargs) -> 'V1GetUsageDetailsResponse':  # noqa: E501
        """Usage report endpoint to get credits spending information. Provides credits consumption data by particular project according to filters given.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.billing_service_get_usage_details(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_id:
        :param str resource_id:
        :param str resource_type:
        :param datetime session_ended_at: To request billing sessions details for teamspace storage - since all entries will have the same resource_id
        :param datetime session_started_at: To request billing sessions details for studios - since all entries will have the same resource_id
        :return: V1GetUsageDetailsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.billing_service_get_usage_details_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.billing_service_get_usage_details_with_http_info(**kwargs)  # noqa: E501
            return data

    def billing_service_get_usage_details_with_http_info(self, **kwargs) -> 'V1GetUsageDetailsResponse':  # noqa: E501
        """Usage report endpoint to get credits spending information. Provides credits consumption data by particular project according to filters given.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.billing_service_get_usage_details_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_id:
        :param str resource_id:
        :param str resource_type:
        :param datetime session_ended_at: To request billing sessions details for teamspace storage - since all entries will have the same resource_id
        :param datetime session_started_at: To request billing sessions details for studios - since all entries will have the same resource_id
        :return: V1GetUsageDetailsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'resource_id', 'resource_type', 'session_ended_at', 'session_started_at']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method billing_service_get_usage_details" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'project_id' in params:
            query_params.append(('projectId', params['project_id']))  # noqa: E501
        if 'resource_id' in params:
            query_params.append(('resourceId', params['resource_id']))  # noqa: E501
        if 'resource_type' in params:
            query_params.append(('resourceType', params['resource_type']))  # noqa: E501
        if 'session_ended_at' in params:
            query_params.append(('sessionEndedAt', params['session_ended_at']))  # noqa: E501
        if 'session_started_at' in params:
            query_params.append(('sessionStartedAt', params['session_started_at']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/billing/usage-details', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1GetUsageDetailsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def billing_service_get_usage_report(self, **kwargs) -> 'V1UsageReport':  # noqa: E501
        """Usage report endpoint to get credits spending information. Provides credits consumption data by particular project according to filters given.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.billing_service_get_usage_report(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str org_id:
        :param str project_id:
        :param str cluster_id: Optional, if not specified, takes all clusters of the project
        :param str resource_type: Optional, if not specified, all resource types will be returned
        :param str resource_id: Optional, if not specified, all filtered resources will be returned
        :param datetime _from: Optional, if not specified, we take the project creation / resource creation time
        :param datetime to: Optional, if not specified, we take the resource deletion time or the current date
        :param str user_id: Optional, if specified, filters owner by User ID
        :param str time_zone: UTC offset of the user's timezone
        :param int limit: Optional, max number of entries to return. The UI will always send a limit to ensure we don't crash the grpc client.
        :param datetime search_after: Optional, only include usage entries strictly after this time. This time will be the time of the last returned usage report item. The API will return the next search_after to use.
        :return: V1UsageReport
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.billing_service_get_usage_report_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.billing_service_get_usage_report_with_http_info(**kwargs)  # noqa: E501
            return data

    def billing_service_get_usage_report_with_http_info(self, **kwargs) -> 'V1UsageReport':  # noqa: E501
        """Usage report endpoint to get credits spending information. Provides credits consumption data by particular project according to filters given.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.billing_service_get_usage_report_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str org_id:
        :param str project_id:
        :param str cluster_id: Optional, if not specified, takes all clusters of the project
        :param str resource_type: Optional, if not specified, all resource types will be returned
        :param str resource_id: Optional, if not specified, all filtered resources will be returned
        :param datetime _from: Optional, if not specified, we take the project creation / resource creation time
        :param datetime to: Optional, if not specified, we take the resource deletion time or the current date
        :param str user_id: Optional, if specified, filters owner by User ID
        :param str time_zone: UTC offset of the user's timezone
        :param int limit: Optional, max number of entries to return. The UI will always send a limit to ensure we don't crash the grpc client.
        :param datetime search_after: Optional, only include usage entries strictly after this time. This time will be the time of the last returned usage report item. The API will return the next search_after to use.
        :return: V1UsageReport
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['org_id', 'project_id', 'cluster_id', 'resource_type', 'resource_id', '_from', 'to', 'user_id', 'time_zone', 'limit', 'search_after']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method billing_service_get_usage_report" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'org_id' in params:
            query_params.append(('orgId', params['org_id']))  # noqa: E501
        if 'project_id' in params:
            query_params.append(('projectId', params['project_id']))  # noqa: E501
        if 'cluster_id' in params:
            query_params.append(('clusterId', params['cluster_id']))  # noqa: E501
        if 'resource_type' in params:
            query_params.append(('resourceType', params['resource_type']))  # noqa: E501
        if 'resource_id' in params:
            query_params.append(('resourceId', params['resource_id']))  # noqa: E501
        if '_from' in params:
            query_params.append(('from', params['_from']))  # noqa: E501
        if 'to' in params:
            query_params.append(('to', params['to']))  # noqa: E501
        if 'user_id' in params:
            query_params.append(('userId', params['user_id']))  # noqa: E501
        if 'time_zone' in params:
            query_params.append(('timeZone', params['time_zone']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'search_after' in params:
            query_params.append(('searchAfter', params['search_after']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/billing/usage-report', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1UsageReport',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def billing_service_get_user_balance(self, **kwargs) -> 'V1GetUserBalanceResponse':  # noqa: E501
        """billing_service_get_user_balance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.billing_service_get_user_balance(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool include_transactions:
        :return: V1GetUserBalanceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.billing_service_get_user_balance_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.billing_service_get_user_balance_with_http_info(**kwargs)  # noqa: E501
            return data

    def billing_service_get_user_balance_with_http_info(self, **kwargs) -> 'V1GetUserBalanceResponse':  # noqa: E501
        """billing_service_get_user_balance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.billing_service_get_user_balance_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool include_transactions:
        :return: V1GetUserBalanceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['include_transactions']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method billing_service_get_user_balance" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'include_transactions' in params:
            query_params.append(('includeTransactions', params['include_transactions']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/billing/balance', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1GetUserBalanceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def billing_service_purchase_annual_upsell(self, body: 'V1PurchaseAnnualUpsellRequest', **kwargs) -> 'V1PurchaseAnnualUpsellResponse':  # noqa: E501
        """billing_service_purchase_annual_upsell  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.billing_service_purchase_annual_upsell(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V1PurchaseAnnualUpsellRequest body: (required)
        :return: V1PurchaseAnnualUpsellResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.billing_service_purchase_annual_upsell_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.billing_service_purchase_annual_upsell_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def billing_service_purchase_annual_upsell_with_http_info(self, body: 'V1PurchaseAnnualUpsellRequest', **kwargs) -> 'V1PurchaseAnnualUpsellResponse':  # noqa: E501
        """billing_service_purchase_annual_upsell  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.billing_service_purchase_annual_upsell_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V1PurchaseAnnualUpsellRequest body: (required)
        :return: V1PurchaseAnnualUpsellResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method billing_service_purchase_annual_upsell" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `billing_service_purchase_annual_upsell`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/billing/annual-upsell', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1PurchaseAnnualUpsellResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def billing_service_quote_annual_upsell(self, **kwargs) -> 'V1QuoteAnnualUpsellResponse':  # noqa: E501
        """billing_service_quote_annual_upsell  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.billing_service_quote_annual_upsell(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str org_id:
        :return: V1QuoteAnnualUpsellResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.billing_service_quote_annual_upsell_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.billing_service_quote_annual_upsell_with_http_info(**kwargs)  # noqa: E501
            return data

    def billing_service_quote_annual_upsell_with_http_info(self, **kwargs) -> 'V1QuoteAnnualUpsellResponse':  # noqa: E501
        """billing_service_quote_annual_upsell  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.billing_service_quote_annual_upsell_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str org_id:
        :return: V1QuoteAnnualUpsellResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['org_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method billing_service_quote_annual_upsell" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'org_id' in params:
            query_params.append(('orgId', params['org_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/billing/annual-upsell', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1QuoteAnnualUpsellResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def billing_service_quote_subscription(self, **kwargs) -> 'V1QuoteSubscriptionResponse':  # noqa: E501
        """billing_service_quote_subscription  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.billing_service_quote_subscription(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str org_id: \"\" for PLG user.
        :param str product_id: Field no longer used, kept for compatibility.
        :param str tier: If set, return current pricing for the given tier.
        :return: V1QuoteSubscriptionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.billing_service_quote_subscription_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.billing_service_quote_subscription_with_http_info(**kwargs)  # noqa: E501
            return data

    def billing_service_quote_subscription_with_http_info(self, **kwargs) -> 'V1QuoteSubscriptionResponse':  # noqa: E501
        """billing_service_quote_subscription  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.billing_service_quote_subscription_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str org_id: \"\" for PLG user.
        :param str product_id: Field no longer used, kept for compatibility.
        :param str tier: If set, return current pricing for the given tier.
        :return: V1QuoteSubscriptionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['org_id', 'product_id', 'tier']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method billing_service_quote_subscription" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'org_id' in params:
            query_params.append(('orgId', params['org_id']))  # noqa: E501
        if 'product_id' in params:
            query_params.append(('productId', params['product_id']))  # noqa: E501
        if 'tier' in params:
            query_params.append(('tier', params['tier']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/billing/subscription/quote', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1QuoteSubscriptionResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def billing_service_transfer_org_balance(self, body: 'BillingServiceTransferOrgBalanceBody', org_src_id: 'str', **kwargs) -> 'V1TransferOrgBalanceResponse':  # noqa: E501
        """Org wallet management  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.billing_service_transfer_org_balance(body, org_src_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BillingServiceTransferOrgBalanceBody body: (required)
        :param str org_src_id: (required)
        :return: V1TransferOrgBalanceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.billing_service_transfer_org_balance_with_http_info(body, org_src_id, **kwargs)  # noqa: E501
        else:
            (data) = self.billing_service_transfer_org_balance_with_http_info(body, org_src_id, **kwargs)  # noqa: E501
            return data

    def billing_service_transfer_org_balance_with_http_info(self, body: 'BillingServiceTransferOrgBalanceBody', org_src_id: 'str', **kwargs) -> 'V1TransferOrgBalanceResponse':  # noqa: E501
        """Org wallet management  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.billing_service_transfer_org_balance_with_http_info(body, org_src_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BillingServiceTransferOrgBalanceBody body: (required)
        :param str org_src_id: (required)
        :return: V1TransferOrgBalanceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'org_src_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method billing_service_transfer_org_balance" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `billing_service_transfer_org_balance`")  # noqa: E501
        # verify the required parameter 'org_src_id' is set
        if ('org_src_id' not in params or
                params['org_src_id'] is None):
            raise ValueError("Missing the required parameter `org_src_id` when calling `billing_service_transfer_org_balance`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'org_src_id' in params:
            path_params['orgSrcId'] = params['org_src_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/orgs/{orgSrcId}/billing/transfer', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1TransferOrgBalanceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def billing_service_transfer_project_balance(self, body: 'BillingServiceTransferProjectBalanceBody', project_src_id: 'str', **kwargs) -> 'V1TransferProjectBalanceResponse':  # noqa: E501
        """Project wallet management  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.billing_service_transfer_project_balance(body, project_src_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BillingServiceTransferProjectBalanceBody body: (required)
        :param str project_src_id: (required)
        :return: V1TransferProjectBalanceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.billing_service_transfer_project_balance_with_http_info(body, project_src_id, **kwargs)  # noqa: E501
        else:
            (data) = self.billing_service_transfer_project_balance_with_http_info(body, project_src_id, **kwargs)  # noqa: E501
            return data

    def billing_service_transfer_project_balance_with_http_info(self, body: 'BillingServiceTransferProjectBalanceBody', project_src_id: 'str', **kwargs) -> 'V1TransferProjectBalanceResponse':  # noqa: E501
        """Project wallet management  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.billing_service_transfer_project_balance_with_http_info(body, project_src_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BillingServiceTransferProjectBalanceBody body: (required)
        :param str project_src_id: (required)
        :return: V1TransferProjectBalanceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'project_src_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method billing_service_transfer_project_balance" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `billing_service_transfer_project_balance`")  # noqa: E501
        # verify the required parameter 'project_src_id' is set
        if ('project_src_id' not in params or
                params['project_src_id'] is None):
            raise ValueError("Missing the required parameter `project_src_id` when calling `billing_service_transfer_project_balance`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_src_id' in params:
            path_params['projectSrcId'] = params['project_src_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/projects/{projectSrcId}/billing/transfer', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1TransferProjectBalanceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def billing_service_transfer_user_balance(self, body: 'V1TransferUserBalanceRequest', **kwargs) -> 'V1TransferUserBalanceResponse':  # noqa: E501
        """billing_service_transfer_user_balance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.billing_service_transfer_user_balance(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V1TransferUserBalanceRequest body: (required)
        :return: V1TransferUserBalanceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.billing_service_transfer_user_balance_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.billing_service_transfer_user_balance_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def billing_service_transfer_user_balance_with_http_info(self, body: 'V1TransferUserBalanceRequest', **kwargs) -> 'V1TransferUserBalanceResponse':  # noqa: E501
        """billing_service_transfer_user_balance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.billing_service_transfer_user_balance_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V1TransferUserBalanceRequest body: (required)
        :return: V1TransferUserBalanceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method billing_service_transfer_user_balance" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `billing_service_transfer_user_balance`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/billing/transfer', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1TransferUserBalanceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def billing_service_update_billing_subscription(self, body: 'V1UpdateBillingSubscriptionRequest', **kwargs) -> 'V1BillingSubscription':  # noqa: E501
        """billing_service_update_billing_subscription  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.billing_service_update_billing_subscription(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V1UpdateBillingSubscriptionRequest body: (required)
        :return: V1BillingSubscription
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.billing_service_update_billing_subscription_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.billing_service_update_billing_subscription_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def billing_service_update_billing_subscription_with_http_info(self, body: 'V1UpdateBillingSubscriptionRequest', **kwargs) -> 'V1BillingSubscription':  # noqa: E501
        """billing_service_update_billing_subscription  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.billing_service_update_billing_subscription_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V1UpdateBillingSubscriptionRequest body: (required)
        :return: V1BillingSubscription
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method billing_service_update_billing_subscription" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `billing_service_update_billing_subscription`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/billing/subscription', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1BillingSubscription',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
