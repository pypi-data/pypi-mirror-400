"""Post-processing module to convert OpenDRIVE objects to signals.

This module converts traffic sign objects (as generated by netconvert) into
proper OpenDRIVE signals for compatibility with simulators like CARLA.

Also handles geoReference fixup for CARLA compatibility.
"""

from __future__ import annotations

import re
import xml.etree.ElementTree as ET
from dataclasses import dataclass
from pathlib import Path

import utm
from loguru import logger

# CARLA / OpenDRIVE Standard Mapping (German StVO codes)
# These are commonly used traffic sign type IDs
TYPE_MAPPING: dict[str, str] = {
    "priority": "306",  # Priority road (Diamond sign)
    "yield": "205",  # Yield / Give Way
    "stop": "206",  # Stop
    "right before left": "102",  # Danger: Crossroad
    "speedLimit": "274",  # Speed Limit
}

# Default dimensions for different sign types (width, height) in meters
DIMENSIONS: dict[str, tuple[str, str]] = {
    "306": ("0.6", "0.6"),  # Priority road
    "205": ("0.9", "0.8"),  # Yield
    "206": ("0.75", "0.75"),  # Stop
    "102": ("0.7", "0.7"),  # Danger: Crossroad
    "274": ("0.6", "0.6"),  # Speed Limit
}


@dataclass
class ConversionResult:
    """Result of a signal conversion operation."""

    success: bool
    signals_converted: int
    poles_added: int
    error: str | None = None


def fix_georeference_for_carla(xodr_file: Path) -> bool:
    """Fix geoReference to include explicit lat_0/lon_0 for CARLA compatibility.

    CARLA's geoReference parser only extracts +lat_0 and +lon_0 values from the
    projection string for geocoordinate conversions (GNSS sensor, transform_to_geolocation).
    Without these parameters, CARLA falls back to incorrect default values.

    This function calculates the correct lat_0/lon_0 based on the OpenDRIVE
    offset (x, y) and the UTM zone defined in the projection string.
    The <offset> element in OpenDRIVE represents the translation applied to
    the original coordinates to get the local coordinates (i.e. origin (0,0)).
    Therefore, the offset values correspond to the UTM coordinates of the map origin.

    Args:
        xodr_file: Path to the OpenDRIVE file.

    Returns:
        True if geoReference was updated, False otherwise.
    """
    try:
        tree = ET.parse(xodr_file)
        root = tree.getroot()
    except ET.ParseError as e:
        logger.error(f"Failed to parse {xodr_file}: {e}")
        return False

    header = root.find("header")
    if header is None:
        logger.warning(f"No <header> element found in {xodr_file}")
        return False

    # Extract offset (defaults to 0 if missing)
    offset_elem = header.find("offset")
    if offset_elem is not None:
        offset_x = float(offset_elem.get("x", "0"))
        offset_y = float(offset_elem.get("y", "0"))
    else:
        # Some versions might store it as attributes on header, but
        # standard is subelement. Default to 0 if not found.
        offset_x = 0.0
        offset_y = 0.0

    georef = header.find("geoReference")
    if georef is None:
        logger.warning(f"No <geoReference> element found in {xodr_file}")
        return False

    current = georef.text or ""
    current = current.strip()

    if not current:
        logger.warning(f"Empty geoReference in {xodr_file}")
        return False

    # Check if lat_0/lon_0 already present
    if "+lat_0=" in current and "+lon_0=" in current:
        logger.debug("geoReference already contains lat_0/lon_0")
        return False

    # Parse UTM zone from string
    # Expected format like "+proj=utm +zone=33 +ellps=WGS84..."
    zone_match = re.search(r"\+zone=(\d+)", current)
    if not zone_match:
        logger.warning(f"Could not parse UTM zone from geoReference: {current}")
        return False

    zone_number = int(zone_match.group(1))

    # Check for southern hemisphere
    is_northern = "+south" not in current

    try:
        # Convert Offset (UTM) to Lat/Lon
        # The offset x,y is the UTM coordinate of the map origin (0,0)
        lat_0, lon_0 = utm.to_latlon(offset_x, offset_y, zone_number, northern=is_northern)
    except utm.error.OutOfRangeError as e:
        logger.error(f"Failed to convert UTM to Lat/Lon: {e}")
        return False

    # Remove existing partial lat_0 or lon_0 if present
    current = re.sub(r"\+lat_0=[\d.-]+\s*", "", current)
    current = re.sub(r"\+lon_0=[\d.-]+\s*", "", current)
    current = current.strip()

    # Append lat_0 and lon_0 with high precision
    new_ref = f"{current} +lat_0={lat_0:.10f} +lon_0={lon_0:.10f}"

    # Preserve the original formatting with newlines
    georef.text = f"\n{new_ref}\n        "

    try:
        tree.write(xodr_file, encoding="UTF-8", xml_declaration=True)
        logger.info(
            f"Fixed geoReference for CARLA: lat_0={lat_0:.6f}, lon_0={lon_0:.6f} "
            f"(derived from offset x={offset_x:.2f}, y={offset_y:.2f})"
        )
        return True
    except Exception as e:
        logger.error(f"Failed to write {xodr_file}: {e}")
        return False


def _add_pole(objects_elem: ET.Element, source_obj: ET.Element) -> None:
    """Add a pole object for a given sign object.

    Args:
        objects_elem: Parent objects element to add pole to.
        source_obj: Source sign object to create pole for.
    """
    pole = ET.SubElement(objects_elem, "object")
    pole.set("id", source_obj.get("id", "") + ".pole")
    pole.set("type", "pole")
    pole.set("name", "Sign Pole")
    pole.set("s", source_obj.get("s", "0.0"))
    pole.set("t", source_obj.get("t", "0.0"))
    pole.set("zOffset", "0.0")
    pole.set("height", "2.0")
    pole.set("radius", "0.05")
    pole.set("dynamic", "no")
    pole.set("hdg", "0.0")
    pole.set("pitch", "0.0")
    pole.set("roll", "0.0")


def _process_signals(
    objects_elem: ET.Element,
    signals_elem: ET.Element,
) -> tuple[int, int]:
    """Convert traffic sign objects to OpenDRIVE signals.

    Args:
        objects_elem: Objects element containing sign objects.
        signals_elem: Signals element to add converted signals to.

    Returns:
        Tuple of (signals_converted, poles_added).
    """
    to_remove: list[ET.Element] = []
    converted_count = 0
    poles_count = 0

    for obj in objects_elem.findall("object"):
        raw_type = obj.get("type")

        if raw_type in TYPE_MAPPING:
            signal_type_id = TYPE_MAPPING[raw_type]

            # Create Signal
            signal = ET.SubElement(signals_elem, "signal")
            signal.set("id", obj.get("id", ""))
            signal.set("type", signal_type_id)
            signal.set("name", raw_type or "")
            signal.set("s", obj.get("s", "0.0"))
            signal.set("t", obj.get("t", "0.0"))
            signal.set("dynamic", "no")
            signal.set("zOffset", "2.0")
            signal.set("country", "SE")  # Sweden

            w, h = DIMENSIONS.get(signal_type_id, ("0.5", "0.5"))
            signal.set("width", w)
            signal.set("height", h)

            signal.set("hOffset", "0.0")
            signal.set("pitch", "0.0")
            signal.set("roll", "0.0")

            # Set orientation based on t-coordinate
            try:
                t_str = obj.get("t")
                if t_str:
                    t_val = float(t_str)
                    signal.set("orientation", "+" if t_val < 0 else "-")
                else:
                    signal.set("orientation", "none")
            except (ValueError, TypeError):
                signal.set("orientation", "none")

            # Create Pole
            _add_pole(objects_elem, obj)
            poles_count += 1

            to_remove.append(obj)
            converted_count += 1

    for obj in to_remove:
        objects_elem.remove(obj)

    return converted_count, poles_count


def convert_objects_to_signals(xodr_file: Path) -> ConversionResult:
    """Convert traffic sign objects to OpenDRIVE signals in an XODR file.

    This function modifies the XODR file in place, converting objects
    with known traffic sign types to proper signal elements.

    Args:
        xodr_file: Path to the OpenDRIVE file to process.

    Returns:
        ConversionResult with success status and counts.
    """
    logger.info(f"Post-processing {xodr_file}...")

    if not xodr_file.exists():
        return ConversionResult(
            success=False,
            signals_converted=0,
            poles_added=0,
            error=f"File not found: {xodr_file}",
        )

    try:
        tree = ET.parse(xodr_file)
        root = tree.getroot()
    except ET.ParseError as e:
        return ConversionResult(
            success=False,
            signals_converted=0,
            poles_added=0,
            error=f"Failed to parse XML: {e}",
        )

    total_signals = 0
    total_poles = 0

    for road in root.findall("road"):
        objects_elem = road.find("objects")
        if objects_elem is None:
            continue

        signals_elem = road.find("signals")
        if signals_elem is None:
            signals_elem = ET.SubElement(road, "signals")

        signals, poles = _process_signals(objects_elem, signals_elem)
        total_signals += signals
        total_poles += poles

        # Remove empty objects element
        if len(objects_elem) == 0:
            road.remove(objects_elem)

    if total_signals > 0:
        try:
            tree.write(xodr_file, encoding="UTF-8", xml_declaration=True)
            logger.info(f"Converted {total_signals} signals, added {total_poles} poles")
        except Exception as e:
            return ConversionResult(
                success=False,
                signals_converted=total_signals,
                poles_added=total_poles,
                error=f"Failed to write file: {e}",
            )
    else:
        logger.info("No matching objects found to convert")

    return ConversionResult(
        success=True,
        signals_converted=total_signals,
        poles_added=total_poles,
    )
