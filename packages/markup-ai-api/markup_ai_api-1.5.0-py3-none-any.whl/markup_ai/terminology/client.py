# This file was auto-generated by Fern from our API Definition.

import typing

from .. import core
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.request_options import RequestOptions
from ..types.domain_response import DomainResponse
from ..types.import_summary import ImportSummary
from ..types.paginated_domains_response import PaginatedDomainsResponse
from ..types.paginated_term_sets_response import PaginatedTermSetsResponse
from ..types.term_create_request import TermCreateRequest
from ..types.term_response import TermResponse
from ..types.term_set_response import TermSetResponse
from ..types.term_set_with_terms import TermSetWithTerms
from ..types.term_type import TermType
from ..types.terminology_search_response import TerminologySearchResponse
from .raw_client import AsyncRawTerminologyClient, RawTerminologyClient

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class TerminologyClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._raw_client = RawTerminologyClient(client_wrapper=client_wrapper)

    @property
    def with_raw_response(self) -> RawTerminologyClient:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        RawTerminologyClient
        """
        return self._raw_client

    def export_terminology(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.Optional[typing.Any]:
        """
        Exports all term sets, terms and domains to CSV. The exported CSV follows the same format as the CSV import.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Optional[typing.Any]
            Successful Response

        Examples
        --------
        from markup_ai import MarkupAI

        client = MarkupAI(
            token="YOUR_TOKEN",
        )
        client.terminology.export_terminology()
        """
        _response = self._raw_client.export_terminology(request_options=request_options)
        return _response.data

    def import_terminology(
        self,
        *,
        file: core.File,
        delete_existing: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ImportSummary:
        """
        Uploads a CSV or ACTIF XML file and imports terminology.

        **CSV Format Requirements:**
        - CSV must include columns: Prohibited, Preferred, Context-Dependent, Instructions, Domains
        - The first row must contain the column headers in the exact same order as shown above
        - Multiple values within a single cell should be separated by semicolons with a space (e.g., term1; term2; term3)
        - Empty cells are allowed
        - The CSV import format is the same as the CSV export format.

        Parameters
        ----------
        file : core.File
            See core.File for more documentation

        delete_existing : typing.Optional[bool]
            Delete all existing terms, term sets and domains before importing

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ImportSummary
            Successful Response

        Examples
        --------
        from markup_ai import MarkupAI

        client = MarkupAI(
            token="YOUR_TOKEN",
        )
        client.terminology.import_terminology(
            delete_existing=True,
        )
        """
        _response = self._raw_client.import_terminology(
            file=file, delete_existing=delete_existing, request_options=request_options
        )
        return _response.data

    def search_terminology(
        self,
        *,
        query: str,
        domain_ids: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TerminologySearchResponse:
        """
        Searches the text for relevant terminology and returns matched term sets.

        Term sets are matched if any word sequence (up to 5 words) in the text is similar to one of the terms of the term set.
        The similarity measure used is a trigram similarity of 0.5 or higher between the word sequence and the term.

        Parameters
        ----------
        query : str

        domain_ids : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Optional domain filter

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TerminologySearchResponse
            Successful Response

        Examples
        --------
        from markup_ai import MarkupAI

        client = MarkupAI(
            token="YOUR_TOKEN",
        )
        client.terminology.search_terminology(
            query="query",
        )
        """
        _response = self._raw_client.search_terminology(
            query=query, domain_ids=domain_ids, request_options=request_options
        )
        return _response.data

    def list_term_sets(
        self,
        *,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        search_term: typing.Optional[str] = None,
        domain_ids: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> PaginatedTermSetsResponse:
        """
        Get a pageable list of term sets with all their associated terms and domains.

        The search filter searches the term set instructions and term text fields.

        Parameters
        ----------
        page : typing.Optional[int]
            Page number (1-based)

        page_size : typing.Optional[int]
            Number of items per page

        search_term : typing.Optional[str]
            Optional search term to filter term sets

        domain_ids : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Optional domain filter (any of these domains)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PaginatedTermSetsResponse
            Successful Response

        Examples
        --------
        from markup_ai import MarkupAI

        client = MarkupAI(
            token="YOUR_TOKEN",
        )
        client.terminology.list_term_sets(
            page=1,
            page_size=1,
            search_term="search_term",
        )
        """
        _response = self._raw_client.list_term_sets(
            page=page,
            page_size=page_size,
            search_term=search_term,
            domain_ids=domain_ids,
            request_options=request_options,
        )
        return _response.data

    def create_term_set(
        self,
        *,
        instructions: str,
        terms: typing.Optional[typing.Sequence[TermCreateRequest]] = OMIT,
        domain_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TermSetResponse:
        """
        Create a new term set. Terms and domains are linked to term sets.
        The term set instructions text will be used to determine whether a term should be flagged in the text and what the term replacement should be.

        Parameters
        ----------
        instructions : str

        terms : typing.Optional[typing.Sequence[TermCreateRequest]]

        domain_ids : typing.Optional[typing.Sequence[str]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TermSetResponse
            Successful Response

        Examples
        --------
        from markup_ai import MarkupAI

        client = MarkupAI(
            token="YOUR_TOKEN",
        )
        client.terminology.create_term_set(
            instructions="instructions",
        )
        """
        _response = self._raw_client.create_term_set(
            instructions=instructions, terms=terms, domain_ids=domain_ids, request_options=request_options
        )
        return _response.data

    def get_term_set(
        self, term_set_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> TermSetWithTerms:
        """
        Parameters
        ----------
        term_set_id : str
            UUID of the term set

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TermSetWithTerms
            Successful Response

        Examples
        --------
        from markup_ai import MarkupAI

        client = MarkupAI(
            token="YOUR_TOKEN",
        )
        client.terminology.get_term_set(
            term_set_id="term_set_id",
        )
        """
        _response = self._raw_client.get_term_set(term_set_id, request_options=request_options)
        return _response.data

    def delete_term_set(self, term_set_id: str, *, request_options: typing.Optional[RequestOptions] = None) -> None:
        """
        Parameters
        ----------
        term_set_id : str
            UUID of the term set

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from markup_ai import MarkupAI

        client = MarkupAI(
            token="YOUR_TOKEN",
        )
        client.terminology.delete_term_set(
            term_set_id="term_set_id",
        )
        """
        _response = self._raw_client.delete_term_set(term_set_id, request_options=request_options)
        return _response.data

    def update_term_set(
        self,
        term_set_id: str,
        *,
        instructions: typing.Optional[str] = OMIT,
        domain_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TermSetResponse:
        """
        Parameters
        ----------
        term_set_id : str
            UUID of the term set

        instructions : typing.Optional[str]

        domain_ids : typing.Optional[typing.Sequence[str]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TermSetResponse
            Successful Response

        Examples
        --------
        from markup_ai import MarkupAI

        client = MarkupAI(
            token="YOUR_TOKEN",
        )
        client.terminology.update_term_set(
            term_set_id="term_set_id",
        )
        """
        _response = self._raw_client.update_term_set(
            term_set_id, instructions=instructions, domain_ids=domain_ids, request_options=request_options
        )
        return _response.data

    def create_term(
        self, term_set_id: str, *, term: str, type: TermType, request_options: typing.Optional[RequestOptions] = None
    ) -> TermResponse:
        """
        Create terms that should be matched in the text. The term types are:

        * **preferred**: this is the preferred term for the associated term set
        * **prohibited**: this term should not be used to talk about the term set
        * **context_dependent**: this term is correct in certain cases, but incorrect in others, the instructions field of the term set should explain when the term is correct and when it is incorrect

        Parameters
        ----------
        term_set_id : str
            UUID of the term set

        term : str

        type : TermType

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TermResponse
            Successful Response

        Examples
        --------
        from markup_ai import MarkupAI

        client = MarkupAI(
            token="YOUR_TOKEN",
        )
        client.terminology.create_term(
            term_set_id="term_set_id",
            term="term",
            type="preferred",
        )
        """
        _response = self._raw_client.create_term(term_set_id, term=term, type=type, request_options=request_options)
        return _response.data

    def get_term(
        self, term_set_id: str, term_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> TermResponse:
        """
        Parameters
        ----------
        term_set_id : str
            UUID of the term set

        term_id : str
            UUID of the term

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TermResponse
            Successful Response

        Examples
        --------
        from markup_ai import MarkupAI

        client = MarkupAI(
            token="YOUR_TOKEN",
        )
        client.terminology.get_term(
            term_set_id="term_set_id",
            term_id="term_id",
        )
        """
        _response = self._raw_client.get_term(term_set_id, term_id, request_options=request_options)
        return _response.data

    def update_term(
        self,
        term_set_id: str,
        term_id: str,
        *,
        term: str,
        type: TermType,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TermResponse:
        """
        Parameters
        ----------
        term_set_id : str
            UUID of the term set

        term_id : str
            UUID of the term

        term : str

        type : TermType

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TermResponse
            Successful Response

        Examples
        --------
        from markup_ai import MarkupAI

        client = MarkupAI(
            token="YOUR_TOKEN",
        )
        client.terminology.update_term(
            term_set_id="term_set_id",
            term_id="term_id",
            term="term",
            type="preferred",
        )
        """
        _response = self._raw_client.update_term(
            term_set_id, term_id, term=term, type=type, request_options=request_options
        )
        return _response.data

    def delete_term(
        self, term_set_id: str, term_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> None:
        """
        Parameters
        ----------
        term_set_id : str
            UUID of the term set

        term_id : str
            UUID of the term

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from markup_ai import MarkupAI

        client = MarkupAI(
            token="YOUR_TOKEN",
        )
        client.terminology.delete_term(
            term_set_id="term_set_id",
            term_id="term_id",
        )
        """
        _response = self._raw_client.delete_term(term_set_id, term_id, request_options=request_options)
        return _response.data

    def list_domains(
        self,
        *,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        search: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> PaginatedDomainsResponse:
        """
        Parameters
        ----------
        page : typing.Optional[int]
            Page number (1-based)

        page_size : typing.Optional[int]
            Number of items per page

        search : typing.Optional[str]
            Optional name filter

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PaginatedDomainsResponse
            Successful Response

        Examples
        --------
        from markup_ai import MarkupAI

        client = MarkupAI(
            token="YOUR_TOKEN",
        )
        client.terminology.list_domains(
            page=1,
            page_size=1,
            search="search",
        )
        """
        _response = self._raw_client.list_domains(
            page=page, page_size=page_size, search=search, request_options=request_options
        )
        return _response.data

    def create_domain(
        self,
        *,
        name: str,
        description: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> DomainResponse:
        """
        Parameters
        ----------
        name : str

        description : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        DomainResponse
            Successful Response

        Examples
        --------
        from markup_ai import MarkupAI

        client = MarkupAI(
            token="YOUR_TOKEN",
        )
        client.terminology.create_domain(
            name="name",
        )
        """
        _response = self._raw_client.create_domain(name=name, description=description, request_options=request_options)
        return _response.data

    def get_domain(self, domain_id: str, *, request_options: typing.Optional[RequestOptions] = None) -> DomainResponse:
        """
        Parameters
        ----------
        domain_id : str
            UUID of the domain

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        DomainResponse
            Successful Response

        Examples
        --------
        from markup_ai import MarkupAI

        client = MarkupAI(
            token="YOUR_TOKEN",
        )
        client.terminology.get_domain(
            domain_id="domain_id",
        )
        """
        _response = self._raw_client.get_domain(domain_id, request_options=request_options)
        return _response.data

    def delete_domain(self, domain_id: str, *, request_options: typing.Optional[RequestOptions] = None) -> None:
        """
        Parameters
        ----------
        domain_id : str
            UUID of the domain

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from markup_ai import MarkupAI

        client = MarkupAI(
            token="YOUR_TOKEN",
        )
        client.terminology.delete_domain(
            domain_id="domain_id",
        )
        """
        _response = self._raw_client.delete_domain(domain_id, request_options=request_options)
        return _response.data

    def update_domain(
        self,
        domain_id: str,
        *,
        name: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> DomainResponse:
        """
        Parameters
        ----------
        domain_id : str
            UUID of the domain

        name : typing.Optional[str]

        description : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        DomainResponse
            Successful Response

        Examples
        --------
        from markup_ai import MarkupAI

        client = MarkupAI(
            token="YOUR_TOKEN",
        )
        client.terminology.update_domain(
            domain_id="domain_id",
        )
        """
        _response = self._raw_client.update_domain(
            domain_id, name=name, description=description, request_options=request_options
        )
        return _response.data


class AsyncTerminologyClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._raw_client = AsyncRawTerminologyClient(client_wrapper=client_wrapper)

    @property
    def with_raw_response(self) -> AsyncRawTerminologyClient:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        AsyncRawTerminologyClient
        """
        return self._raw_client

    async def export_terminology(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.Optional[typing.Any]:
        """
        Exports all term sets, terms and domains to CSV. The exported CSV follows the same format as the CSV import.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Optional[typing.Any]
            Successful Response

        Examples
        --------
        import asyncio

        from markup_ai import AsyncMarkupAI

        client = AsyncMarkupAI(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.terminology.export_terminology()


        asyncio.run(main())
        """
        _response = await self._raw_client.export_terminology(request_options=request_options)
        return _response.data

    async def import_terminology(
        self,
        *,
        file: core.File,
        delete_existing: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ImportSummary:
        """
        Uploads a CSV or ACTIF XML file and imports terminology.

        **CSV Format Requirements:**
        - CSV must include columns: Prohibited, Preferred, Context-Dependent, Instructions, Domains
        - The first row must contain the column headers in the exact same order as shown above
        - Multiple values within a single cell should be separated by semicolons with a space (e.g., term1; term2; term3)
        - Empty cells are allowed
        - The CSV import format is the same as the CSV export format.

        Parameters
        ----------
        file : core.File
            See core.File for more documentation

        delete_existing : typing.Optional[bool]
            Delete all existing terms, term sets and domains before importing

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ImportSummary
            Successful Response

        Examples
        --------
        import asyncio

        from markup_ai import AsyncMarkupAI

        client = AsyncMarkupAI(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.terminology.import_terminology(
                delete_existing=True,
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.import_terminology(
            file=file, delete_existing=delete_existing, request_options=request_options
        )
        return _response.data

    async def search_terminology(
        self,
        *,
        query: str,
        domain_ids: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TerminologySearchResponse:
        """
        Searches the text for relevant terminology and returns matched term sets.

        Term sets are matched if any word sequence (up to 5 words) in the text is similar to one of the terms of the term set.
        The similarity measure used is a trigram similarity of 0.5 or higher between the word sequence and the term.

        Parameters
        ----------
        query : str

        domain_ids : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Optional domain filter

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TerminologySearchResponse
            Successful Response

        Examples
        --------
        import asyncio

        from markup_ai import AsyncMarkupAI

        client = AsyncMarkupAI(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.terminology.search_terminology(
                query="query",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.search_terminology(
            query=query, domain_ids=domain_ids, request_options=request_options
        )
        return _response.data

    async def list_term_sets(
        self,
        *,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        search_term: typing.Optional[str] = None,
        domain_ids: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> PaginatedTermSetsResponse:
        """
        Get a pageable list of term sets with all their associated terms and domains.

        The search filter searches the term set instructions and term text fields.

        Parameters
        ----------
        page : typing.Optional[int]
            Page number (1-based)

        page_size : typing.Optional[int]
            Number of items per page

        search_term : typing.Optional[str]
            Optional search term to filter term sets

        domain_ids : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Optional domain filter (any of these domains)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PaginatedTermSetsResponse
            Successful Response

        Examples
        --------
        import asyncio

        from markup_ai import AsyncMarkupAI

        client = AsyncMarkupAI(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.terminology.list_term_sets(
                page=1,
                page_size=1,
                search_term="search_term",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.list_term_sets(
            page=page,
            page_size=page_size,
            search_term=search_term,
            domain_ids=domain_ids,
            request_options=request_options,
        )
        return _response.data

    async def create_term_set(
        self,
        *,
        instructions: str,
        terms: typing.Optional[typing.Sequence[TermCreateRequest]] = OMIT,
        domain_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TermSetResponse:
        """
        Create a new term set. Terms and domains are linked to term sets.
        The term set instructions text will be used to determine whether a term should be flagged in the text and what the term replacement should be.

        Parameters
        ----------
        instructions : str

        terms : typing.Optional[typing.Sequence[TermCreateRequest]]

        domain_ids : typing.Optional[typing.Sequence[str]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TermSetResponse
            Successful Response

        Examples
        --------
        import asyncio

        from markup_ai import AsyncMarkupAI

        client = AsyncMarkupAI(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.terminology.create_term_set(
                instructions="instructions",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.create_term_set(
            instructions=instructions, terms=terms, domain_ids=domain_ids, request_options=request_options
        )
        return _response.data

    async def get_term_set(
        self, term_set_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> TermSetWithTerms:
        """
        Parameters
        ----------
        term_set_id : str
            UUID of the term set

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TermSetWithTerms
            Successful Response

        Examples
        --------
        import asyncio

        from markup_ai import AsyncMarkupAI

        client = AsyncMarkupAI(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.terminology.get_term_set(
                term_set_id="term_set_id",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.get_term_set(term_set_id, request_options=request_options)
        return _response.data

    async def delete_term_set(
        self, term_set_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> None:
        """
        Parameters
        ----------
        term_set_id : str
            UUID of the term set

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from markup_ai import AsyncMarkupAI

        client = AsyncMarkupAI(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.terminology.delete_term_set(
                term_set_id="term_set_id",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.delete_term_set(term_set_id, request_options=request_options)
        return _response.data

    async def update_term_set(
        self,
        term_set_id: str,
        *,
        instructions: typing.Optional[str] = OMIT,
        domain_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TermSetResponse:
        """
        Parameters
        ----------
        term_set_id : str
            UUID of the term set

        instructions : typing.Optional[str]

        domain_ids : typing.Optional[typing.Sequence[str]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TermSetResponse
            Successful Response

        Examples
        --------
        import asyncio

        from markup_ai import AsyncMarkupAI

        client = AsyncMarkupAI(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.terminology.update_term_set(
                term_set_id="term_set_id",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.update_term_set(
            term_set_id, instructions=instructions, domain_ids=domain_ids, request_options=request_options
        )
        return _response.data

    async def create_term(
        self, term_set_id: str, *, term: str, type: TermType, request_options: typing.Optional[RequestOptions] = None
    ) -> TermResponse:
        """
        Create terms that should be matched in the text. The term types are:

        * **preferred**: this is the preferred term for the associated term set
        * **prohibited**: this term should not be used to talk about the term set
        * **context_dependent**: this term is correct in certain cases, but incorrect in others, the instructions field of the term set should explain when the term is correct and when it is incorrect

        Parameters
        ----------
        term_set_id : str
            UUID of the term set

        term : str

        type : TermType

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TermResponse
            Successful Response

        Examples
        --------
        import asyncio

        from markup_ai import AsyncMarkupAI

        client = AsyncMarkupAI(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.terminology.create_term(
                term_set_id="term_set_id",
                term="term",
                type="preferred",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.create_term(
            term_set_id, term=term, type=type, request_options=request_options
        )
        return _response.data

    async def get_term(
        self, term_set_id: str, term_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> TermResponse:
        """
        Parameters
        ----------
        term_set_id : str
            UUID of the term set

        term_id : str
            UUID of the term

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TermResponse
            Successful Response

        Examples
        --------
        import asyncio

        from markup_ai import AsyncMarkupAI

        client = AsyncMarkupAI(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.terminology.get_term(
                term_set_id="term_set_id",
                term_id="term_id",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.get_term(term_set_id, term_id, request_options=request_options)
        return _response.data

    async def update_term(
        self,
        term_set_id: str,
        term_id: str,
        *,
        term: str,
        type: TermType,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TermResponse:
        """
        Parameters
        ----------
        term_set_id : str
            UUID of the term set

        term_id : str
            UUID of the term

        term : str

        type : TermType

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TermResponse
            Successful Response

        Examples
        --------
        import asyncio

        from markup_ai import AsyncMarkupAI

        client = AsyncMarkupAI(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.terminology.update_term(
                term_set_id="term_set_id",
                term_id="term_id",
                term="term",
                type="preferred",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.update_term(
            term_set_id, term_id, term=term, type=type, request_options=request_options
        )
        return _response.data

    async def delete_term(
        self, term_set_id: str, term_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> None:
        """
        Parameters
        ----------
        term_set_id : str
            UUID of the term set

        term_id : str
            UUID of the term

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from markup_ai import AsyncMarkupAI

        client = AsyncMarkupAI(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.terminology.delete_term(
                term_set_id="term_set_id",
                term_id="term_id",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.delete_term(term_set_id, term_id, request_options=request_options)
        return _response.data

    async def list_domains(
        self,
        *,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        search: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> PaginatedDomainsResponse:
        """
        Parameters
        ----------
        page : typing.Optional[int]
            Page number (1-based)

        page_size : typing.Optional[int]
            Number of items per page

        search : typing.Optional[str]
            Optional name filter

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PaginatedDomainsResponse
            Successful Response

        Examples
        --------
        import asyncio

        from markup_ai import AsyncMarkupAI

        client = AsyncMarkupAI(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.terminology.list_domains(
                page=1,
                page_size=1,
                search="search",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.list_domains(
            page=page, page_size=page_size, search=search, request_options=request_options
        )
        return _response.data

    async def create_domain(
        self,
        *,
        name: str,
        description: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> DomainResponse:
        """
        Parameters
        ----------
        name : str

        description : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        DomainResponse
            Successful Response

        Examples
        --------
        import asyncio

        from markup_ai import AsyncMarkupAI

        client = AsyncMarkupAI(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.terminology.create_domain(
                name="name",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.create_domain(
            name=name, description=description, request_options=request_options
        )
        return _response.data

    async def get_domain(
        self, domain_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> DomainResponse:
        """
        Parameters
        ----------
        domain_id : str
            UUID of the domain

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        DomainResponse
            Successful Response

        Examples
        --------
        import asyncio

        from markup_ai import AsyncMarkupAI

        client = AsyncMarkupAI(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.terminology.get_domain(
                domain_id="domain_id",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.get_domain(domain_id, request_options=request_options)
        return _response.data

    async def delete_domain(self, domain_id: str, *, request_options: typing.Optional[RequestOptions] = None) -> None:
        """
        Parameters
        ----------
        domain_id : str
            UUID of the domain

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from markup_ai import AsyncMarkupAI

        client = AsyncMarkupAI(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.terminology.delete_domain(
                domain_id="domain_id",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.delete_domain(domain_id, request_options=request_options)
        return _response.data

    async def update_domain(
        self,
        domain_id: str,
        *,
        name: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> DomainResponse:
        """
        Parameters
        ----------
        domain_id : str
            UUID of the domain

        name : typing.Optional[str]

        description : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        DomainResponse
            Successful Response

        Examples
        --------
        import asyncio

        from markup_ai import AsyncMarkupAI

        client = AsyncMarkupAI(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.terminology.update_domain(
                domain_id="domain_id",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.update_domain(
            domain_id, name=name, description=description, request_options=request_options
        )
        return _response.data
