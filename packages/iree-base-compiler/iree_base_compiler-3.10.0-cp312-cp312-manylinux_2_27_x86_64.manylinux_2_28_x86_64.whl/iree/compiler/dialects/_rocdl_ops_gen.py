
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union, Optional as _Optional


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "rocdl"

@_ods_cext.register_operation(_Dialect)
class ROCDLCos(_ods_ir.OpView):
  r"""
  Note: In the general case, prefer the conventional `arith`, `math`, or `llvm` ops over this.
  Use this ROCDL-specific operation only when you fully understand its implication and
  when it is strictly necessary. This op is usually chosen when a small loss in precision is
  acceptable in exchange for higher execution speed.
  """

  OPERATION_NAME = "rocdl.cos"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, arg, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(arg)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def arg(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cos(res, arg, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ROCDLCos(res=res, arg=arg, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ROCDLExp(_ods_ir.OpView):
  r"""
  Note: In the general case, prefer the conventional `arith`, `math`, or `llvm` ops over this.
  Use this ROCDL-specific operation only when you fully understand its implication and
  when it is strictly necessary. This op is usually chosen when a small loss in precision is
  acceptable in exchange for higher execution speed.
  """

  OPERATION_NAME = "rocdl.exp"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, arg, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(arg)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def arg(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def exp(res, arg, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ROCDLExp(res=res, arg=arg, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ROCDLExp2(_ods_ir.OpView):
  r"""
  Note: In the general case, prefer the conventional `arith`, `math`, or `llvm` ops over this.
  Use this ROCDL-specific operation only when you fully understand its implication and
  when it is strictly necessary. This op is usually chosen when a small loss in precision is
  acceptable in exchange for higher execution speed.
  """

  OPERATION_NAME = "rocdl.exp2"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, arg, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(arg)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def arg(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def exp2(res, arg, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ROCDLExp2(res=res, arg=arg, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ROCDLLog(_ods_ir.OpView):
  r"""
  Note: In the general case, prefer the conventional `arith`, `math`, or `llvm` ops over this.
  Use this ROCDL-specific operation only when you fully understand its implication and
  when it is strictly necessary. This op is usually chosen when a small loss in precision is
  acceptable in exchange for higher execution speed.
  """

  OPERATION_NAME = "rocdl.log"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, arg, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(arg)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def arg(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def log(res, arg, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ROCDLLog(res=res, arg=arg, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ROCDLRcp(_ods_ir.OpView):
  r"""
  Note: In the general case, prefer the conventional `arith`, `math`, or `llvm` ops over this.
  Use this ROCDL-specific operation only when you fully understand its implication and
  when it is strictly necessary. This op is usually chosen when a small loss in precision is
  acceptable in exchange for higher execution speed.
  """

  OPERATION_NAME = "rocdl.rcp"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, arg, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(arg)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def arg(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def rcp(res, arg, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ROCDLRcp(res=res, arg=arg, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ROCDLSin(_ods_ir.OpView):
  r"""
  Note: In the general case, prefer the conventional `arith`, `math`, or `llvm` ops over this.
  Use this ROCDL-specific operation only when you fully understand its implication and
  when it is strictly necessary. This op is usually chosen when a small loss in precision is
  acceptable in exchange for higher execution speed.
  """

  OPERATION_NAME = "rocdl.sin"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, arg, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(arg)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def arg(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def sin(res, arg, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ROCDLSin(res=res, arg=arg, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ROCDLSqrt(_ods_ir.OpView):
  r"""
  Note: In the general case, prefer the conventional `arith`, `math`, or `llvm` ops over this.
  Use this ROCDL-specific operation only when you fully understand its implication and
  when it is strictly necessary. This op is usually chosen when a small loss in precision is
  acceptable in exchange for higher execution speed.
  """

  OPERATION_NAME = "rocdl.sqrt"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, arg, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(arg)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def arg(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def sqrt(res, arg, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ROCDLSqrt(res=res, arg=arg, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ROCDLTanh(_ods_ir.OpView):
  r"""
  Note: In the general case, prefer the conventional `arith`, `math`, or `llvm` ops over this.
  Use this ROCDL-specific operation only when you fully understand its implication and
  when it is strictly necessary. This op is usually chosen when a small loss in precision is
  acceptable in exchange for higher execution speed.
  """

  OPERATION_NAME = "rocdl.tanh"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, arg, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(arg)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def arg(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def tanh(res, arg, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ROCDLTanh(res=res, arg=arg, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BallotOp(_ods_ir.OpView):
  r"""
  Ballot provides a bit mask containing the 1-bit predicate value from each lane.
  The nth bit of the result contains the 1 bit contributed by the nth warp lane.
  """

  OPERATION_NAME = "rocdl.ballot"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, pred, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(pred)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def pred(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def ballot(res, pred, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return BallotOp(res=res, pred=pred, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BarrierInitOp(_ods_ir.OpView):
  r"""
  Available on gfx1250+.
  """

  OPERATION_NAME = "rocdl.s.barrier.init"

  _ODS_REGIONS = (0, True)

  def __init__(self, ptr, memberCnt, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(ptr)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["memberCnt"] = (memberCnt if (
    isinstance(memberCnt, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(memberCnt, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def ptr(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def memberCnt(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["memberCnt"]

  @memberCnt.setter
  def memberCnt(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memberCnt"] = value

def s_barrier_init(ptr, member_cnt, *, loc=None, ip=None) -> BarrierInitOp:
  return BarrierInitOp(ptr=ptr, memberCnt=member_cnt, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class BarrierJoinOp(_ods_ir.OpView):
  r"""
  Available on gfx1250+.
  """

  OPERATION_NAME = "rocdl.s.barrier.join"

  _ODS_REGIONS = (0, True)

  def __init__(self, ptr, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(ptr)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def ptr(self) -> _ods_ir.Value:
    return self.operation.operands[0]

def s_barrier_join(ptr, *, loc=None, ip=None) -> BarrierJoinOp:
  return BarrierJoinOp(ptr=ptr, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class BarrierLeaveOp(_ods_ir.OpView):
  r"""
  Available on gfx1250+.
  """

  OPERATION_NAME = "rocdl.s.barrier.leave"

  _ODS_REGIONS = (0, True)

  def __init__(self, id, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["id"] = (id if (
    isinstance(id, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I16Attr')) else
      _ods_ir.AttrBuilder.get('I16Attr')(id, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def id(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["id"]

  @id.setter
  def id(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["id"] = value

def s_barrier_leave(id, *, loc=None, ip=None) -> BarrierLeaveOp:
  return BarrierLeaveOp(id=id, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class BarrierOp(_ods_ir.OpView):
  r"""
  An operation with the same expansion as HIP's __synchthreads();
  
  **DEPRECATION NOTICE**: Use `gpu.barrier`, which will expand to these
  operations, instead.
  """

  OPERATION_NAME = "rocdl.barrier"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def barrier(*, loc=None, ip=None) -> BarrierOp:
  return BarrierOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class BarrierSignalIsfirstOp(_ods_ir.OpView):
  r"""
  Available on gfx1250+.
  """

  OPERATION_NAME = "rocdl.s.barrier.signal.isfirst"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, id, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["id"] = (id if (
    isinstance(id, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(id, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def id(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["id"]

  @id.setter
  def id(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["id"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def s_barrier_signal_isfirst(res, id, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return BarrierSignalIsfirstOp(res=res, id=id, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BarrierSignalOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.s.barrier.signal"

  _ODS_REGIONS = (0, True)

  def __init__(self, id, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["id"] = (id if (
    isinstance(id, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(id, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def id(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["id"]

  @id.setter
  def id(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["id"] = value

def s_barrier_signal(id, *, loc=None, ip=None) -> BarrierSignalOp:
  return BarrierSignalOp(id=id, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class BarrierSignalVarOp(_ods_ir.OpView):
  r"""
  Available on gfx1250+.
  """

  OPERATION_NAME = "rocdl.s.barrier.signal.var"

  _ODS_REGIONS = (0, True)

  def __init__(self, ptr, memberCnt, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(ptr)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["memberCnt"] = (memberCnt if (
    isinstance(memberCnt, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(memberCnt, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def ptr(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def memberCnt(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["memberCnt"]

  @memberCnt.setter
  def memberCnt(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memberCnt"] = value

def s_barrier_signal_var(ptr, member_cnt, *, loc=None, ip=None) -> BarrierSignalVarOp:
  return BarrierSignalVarOp(ptr=ptr, memberCnt=member_cnt, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class BarrierWaitOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.s.barrier.wait"

  _ODS_REGIONS = (0, True)

  def __init__(self, id, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["id"] = (id if (
    isinstance(id, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I16Attr')) else
      _ods_ir.AttrBuilder.get('I16Attr')(id, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def id(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["id"]

  @id.setter
  def id(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["id"] = value

def s_barrier_wait(id, *, loc=None, ip=None) -> BarrierWaitOp:
  return BarrierWaitOp(id=id, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class BlockDimXOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.workgroup.dim.x"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, *, range=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if range is not None: attributes["range"] = (range if (
        isinstance(range, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_ConstantRangeAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_ConstantRangeAttr')(range, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def range(self) -> _Optional[_ods_ir.Attribute]:
    if "range" not in self.operation.attributes:
      return None
    return self.operation.attributes["range"]

  @range.setter
  def range(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["range"] = value
    elif "range" in self.operation.attributes:
      del self.operation.attributes["range"]

  @range.deleter
  def range(self):
    del self.operation.attributes["range"]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def workgroup_dim_x(res, *, range=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BlockDimXOp(res=res, range=range, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BlockDimYOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.workgroup.dim.y"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, *, range=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if range is not None: attributes["range"] = (range if (
        isinstance(range, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_ConstantRangeAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_ConstantRangeAttr')(range, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def range(self) -> _Optional[_ods_ir.Attribute]:
    if "range" not in self.operation.attributes:
      return None
    return self.operation.attributes["range"]

  @range.setter
  def range(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["range"] = value
    elif "range" in self.operation.attributes:
      del self.operation.attributes["range"]

  @range.deleter
  def range(self):
    del self.operation.attributes["range"]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def workgroup_dim_y(res, *, range=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BlockDimYOp(res=res, range=range, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BlockDimZOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.workgroup.dim.z"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, *, range=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if range is not None: attributes["range"] = (range if (
        isinstance(range, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_ConstantRangeAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_ConstantRangeAttr')(range, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def range(self) -> _Optional[_ods_ir.Attribute]:
    if "range" not in self.operation.attributes:
      return None
    return self.operation.attributes["range"]

  @range.setter
  def range(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["range"] = value
    elif "range" in self.operation.attributes:
      del self.operation.attributes["range"]

  @range.deleter
  def range(self):
    del self.operation.attributes["range"]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def workgroup_dim_z(res, *, range=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BlockDimZOp(res=res, range=range, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BlockIdXOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.workgroup.id.x"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, *, range=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if range is not None: attributes["range"] = (range if (
        isinstance(range, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_ConstantRangeAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_ConstantRangeAttr')(range, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def range(self) -> _Optional[_ods_ir.Attribute]:
    if "range" not in self.operation.attributes:
      return None
    return self.operation.attributes["range"]

  @range.setter
  def range(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["range"] = value
    elif "range" in self.operation.attributes:
      del self.operation.attributes["range"]

  @range.deleter
  def range(self):
    del self.operation.attributes["range"]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def workgroup_id_x(res, *, range=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BlockIdXOp(res=res, range=range, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BlockIdYOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.workgroup.id.y"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, *, range=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if range is not None: attributes["range"] = (range if (
        isinstance(range, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_ConstantRangeAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_ConstantRangeAttr')(range, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def range(self) -> _Optional[_ods_ir.Attribute]:
    if "range" not in self.operation.attributes:
      return None
    return self.operation.attributes["range"]

  @range.setter
  def range(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["range"] = value
    elif "range" in self.operation.attributes:
      del self.operation.attributes["range"]

  @range.deleter
  def range(self):
    del self.operation.attributes["range"]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def workgroup_id_y(res, *, range=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BlockIdYOp(res=res, range=range, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BlockIdZOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.workgroup.id.z"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, *, range=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if range is not None: attributes["range"] = (range if (
        isinstance(range, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_ConstantRangeAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_ConstantRangeAttr')(range, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def range(self) -> _Optional[_ods_ir.Attribute]:
    if "range" not in self.operation.attributes:
      return None
    return self.operation.attributes["range"]

  @range.setter
  def range(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["range"] = value
    elif "range" in self.operation.attributes:
      del self.operation.attributes["range"]

  @range.deleter
  def range(self):
    del self.operation.attributes["range"]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def workgroup_id_z(res, *, range=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BlockIdZOp(res=res, range=range, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ClusterIdXOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.cluster.id.x"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, *, range=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if range is not None: attributes["range"] = (range if (
        isinstance(range, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_ConstantRangeAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_ConstantRangeAttr')(range, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def range(self) -> _Optional[_ods_ir.Attribute]:
    if "range" not in self.operation.attributes:
      return None
    return self.operation.attributes["range"]

  @range.setter
  def range(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["range"] = value
    elif "range" in self.operation.attributes:
      del self.operation.attributes["range"]

  @range.deleter
  def range(self):
    del self.operation.attributes["range"]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cluster_id_x(res, *, range=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ClusterIdXOp(res=res, range=range, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ClusterIdYOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.cluster.id.y"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, *, range=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if range is not None: attributes["range"] = (range if (
        isinstance(range, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_ConstantRangeAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_ConstantRangeAttr')(range, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def range(self) -> _Optional[_ods_ir.Attribute]:
    if "range" not in self.operation.attributes:
      return None
    return self.operation.attributes["range"]

  @range.setter
  def range(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["range"] = value
    elif "range" in self.operation.attributes:
      del self.operation.attributes["range"]

  @range.deleter
  def range(self):
    del self.operation.attributes["range"]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cluster_id_y(res, *, range=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ClusterIdYOp(res=res, range=range, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ClusterIdZOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.cluster.id.z"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, *, range=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if range is not None: attributes["range"] = (range if (
        isinstance(range, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_ConstantRangeAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_ConstantRangeAttr')(range, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def range(self) -> _Optional[_ods_ir.Attribute]:
    if "range" not in self.operation.attributes:
      return None
    return self.operation.attributes["range"]

  @range.setter
  def range(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["range"] = value
    elif "range" in self.operation.attributes:
      del self.operation.attributes["range"]

  @range.deleter
  def range(self):
    del self.operation.attributes["range"]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cluster_id_z(res, *, range=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ClusterIdZOp(res=res, range=range, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ClusterLoadAsyncToLDSB8Op(_ods_ir.OpView):
  r"""
  Broadcasts memory load of 8 bits of data for a cluster of workgroups.
  
  Available on gfx1250+.
  """

  OPERATION_NAME = "rocdl.cluster.load.async.to.lds.b8"

  _ODS_REGIONS = (0, True)

  def __init__(self, globalPtr, ldsPtr, offset, cpol, mask, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(globalPtr)
    operands.append(ldsPtr)
    operands.append(mask)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["offset"] = (offset if (
    isinstance(offset, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(offset, context=_ods_context))
    attributes["cpol"] = (cpol if (
    isinstance(cpol, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(cpol, context=_ods_context))
    if alias_scopes is not None: attributes["alias_scopes"] = (alias_scopes if (
        isinstance(alias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(alias_scopes, context=_ods_context))
    if noalias_scopes is not None: attributes["noalias_scopes"] = (noalias_scopes if (
        isinstance(noalias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(noalias_scopes, context=_ods_context))
    if tbaa is not None: attributes["tbaa"] = (tbaa if (
        isinstance(tbaa, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_TBAATagArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_TBAATagArrayAttr')(tbaa, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def globalPtr(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def ldsPtr(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def mask(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[2]

  @builtins.property
  def offset(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["offset"]

  @offset.setter
  def offset(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["offset"] = value

  @builtins.property
  def cpol(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["cpol"]

  @cpol.setter
  def cpol(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["cpol"] = value

  @builtins.property
  def alias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "alias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["alias_scopes"]

  @alias_scopes.setter
  def alias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["alias_scopes"] = value
    elif "alias_scopes" in self.operation.attributes:
      del self.operation.attributes["alias_scopes"]

  @alias_scopes.deleter
  def alias_scopes(self):
    del self.operation.attributes["alias_scopes"]

  @builtins.property
  def noalias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "noalias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["noalias_scopes"]

  @noalias_scopes.setter
  def noalias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["noalias_scopes"] = value
    elif "noalias_scopes" in self.operation.attributes:
      del self.operation.attributes["noalias_scopes"]

  @noalias_scopes.deleter
  def noalias_scopes(self):
    del self.operation.attributes["noalias_scopes"]

  @builtins.property
  def tbaa(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tbaa" not in self.operation.attributes:
      return None
    return self.operation.attributes["tbaa"]

  @tbaa.setter
  def tbaa(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tbaa"] = value
    elif "tbaa" in self.operation.attributes:
      del self.operation.attributes["tbaa"]

  @tbaa.deleter
  def tbaa(self):
    del self.operation.attributes["tbaa"]

def cluster_load_async_to_lds_b8(global_ptr, lds_ptr, offset, cpol, mask, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None) -> ClusterLoadAsyncToLDSB8Op:
  return ClusterLoadAsyncToLDSB8Op(globalPtr=global_ptr, ldsPtr=lds_ptr, offset=offset, cpol=cpol, mask=mask, alias_scopes=alias_scopes, noalias_scopes=noalias_scopes, tbaa=tbaa, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ClusterLoadAsyncToLDSB32Op(_ods_ir.OpView):
  r"""
  Broadcasts memory load of 32 bits of data for a cluster of workgroups.
  
  Available on gfx1250+.
  """

  OPERATION_NAME = "rocdl.cluster.load.async.to.lds.b32"

  _ODS_REGIONS = (0, True)

  def __init__(self, globalPtr, ldsPtr, offset, cpol, mask, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(globalPtr)
    operands.append(ldsPtr)
    operands.append(mask)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["offset"] = (offset if (
    isinstance(offset, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(offset, context=_ods_context))
    attributes["cpol"] = (cpol if (
    isinstance(cpol, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(cpol, context=_ods_context))
    if alias_scopes is not None: attributes["alias_scopes"] = (alias_scopes if (
        isinstance(alias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(alias_scopes, context=_ods_context))
    if noalias_scopes is not None: attributes["noalias_scopes"] = (noalias_scopes if (
        isinstance(noalias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(noalias_scopes, context=_ods_context))
    if tbaa is not None: attributes["tbaa"] = (tbaa if (
        isinstance(tbaa, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_TBAATagArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_TBAATagArrayAttr')(tbaa, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def globalPtr(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def ldsPtr(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def mask(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[2]

  @builtins.property
  def offset(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["offset"]

  @offset.setter
  def offset(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["offset"] = value

  @builtins.property
  def cpol(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["cpol"]

  @cpol.setter
  def cpol(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["cpol"] = value

  @builtins.property
  def alias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "alias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["alias_scopes"]

  @alias_scopes.setter
  def alias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["alias_scopes"] = value
    elif "alias_scopes" in self.operation.attributes:
      del self.operation.attributes["alias_scopes"]

  @alias_scopes.deleter
  def alias_scopes(self):
    del self.operation.attributes["alias_scopes"]

  @builtins.property
  def noalias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "noalias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["noalias_scopes"]

  @noalias_scopes.setter
  def noalias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["noalias_scopes"] = value
    elif "noalias_scopes" in self.operation.attributes:
      del self.operation.attributes["noalias_scopes"]

  @noalias_scopes.deleter
  def noalias_scopes(self):
    del self.operation.attributes["noalias_scopes"]

  @builtins.property
  def tbaa(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tbaa" not in self.operation.attributes:
      return None
    return self.operation.attributes["tbaa"]

  @tbaa.setter
  def tbaa(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tbaa"] = value
    elif "tbaa" in self.operation.attributes:
      del self.operation.attributes["tbaa"]

  @tbaa.deleter
  def tbaa(self):
    del self.operation.attributes["tbaa"]

def cluster_load_async_to_lds_b32(global_ptr, lds_ptr, offset, cpol, mask, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None) -> ClusterLoadAsyncToLDSB32Op:
  return ClusterLoadAsyncToLDSB32Op(globalPtr=global_ptr, ldsPtr=lds_ptr, offset=offset, cpol=cpol, mask=mask, alias_scopes=alias_scopes, noalias_scopes=noalias_scopes, tbaa=tbaa, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ClusterLoadAsyncToLDSB64Op(_ods_ir.OpView):
  r"""
  Broadcasts memory load of 64 bits of data for a cluster of workgroups.
  
  Available on gfx1250+.
  """

  OPERATION_NAME = "rocdl.cluster.load.async.to.lds.b64"

  _ODS_REGIONS = (0, True)

  def __init__(self, globalPtr, ldsPtr, offset, cpol, mask, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(globalPtr)
    operands.append(ldsPtr)
    operands.append(mask)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["offset"] = (offset if (
    isinstance(offset, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(offset, context=_ods_context))
    attributes["cpol"] = (cpol if (
    isinstance(cpol, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(cpol, context=_ods_context))
    if alias_scopes is not None: attributes["alias_scopes"] = (alias_scopes if (
        isinstance(alias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(alias_scopes, context=_ods_context))
    if noalias_scopes is not None: attributes["noalias_scopes"] = (noalias_scopes if (
        isinstance(noalias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(noalias_scopes, context=_ods_context))
    if tbaa is not None: attributes["tbaa"] = (tbaa if (
        isinstance(tbaa, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_TBAATagArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_TBAATagArrayAttr')(tbaa, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def globalPtr(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def ldsPtr(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def mask(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[2]

  @builtins.property
  def offset(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["offset"]

  @offset.setter
  def offset(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["offset"] = value

  @builtins.property
  def cpol(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["cpol"]

  @cpol.setter
  def cpol(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["cpol"] = value

  @builtins.property
  def alias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "alias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["alias_scopes"]

  @alias_scopes.setter
  def alias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["alias_scopes"] = value
    elif "alias_scopes" in self.operation.attributes:
      del self.operation.attributes["alias_scopes"]

  @alias_scopes.deleter
  def alias_scopes(self):
    del self.operation.attributes["alias_scopes"]

  @builtins.property
  def noalias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "noalias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["noalias_scopes"]

  @noalias_scopes.setter
  def noalias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["noalias_scopes"] = value
    elif "noalias_scopes" in self.operation.attributes:
      del self.operation.attributes["noalias_scopes"]

  @noalias_scopes.deleter
  def noalias_scopes(self):
    del self.operation.attributes["noalias_scopes"]

  @builtins.property
  def tbaa(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tbaa" not in self.operation.attributes:
      return None
    return self.operation.attributes["tbaa"]

  @tbaa.setter
  def tbaa(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tbaa"] = value
    elif "tbaa" in self.operation.attributes:
      del self.operation.attributes["tbaa"]

  @tbaa.deleter
  def tbaa(self):
    del self.operation.attributes["tbaa"]

def cluster_load_async_to_lds_b64(global_ptr, lds_ptr, offset, cpol, mask, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None) -> ClusterLoadAsyncToLDSB64Op:
  return ClusterLoadAsyncToLDSB64Op(globalPtr=global_ptr, ldsPtr=lds_ptr, offset=offset, cpol=cpol, mask=mask, alias_scopes=alias_scopes, noalias_scopes=noalias_scopes, tbaa=tbaa, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ClusterLoadAsyncToLDSB128Op(_ods_ir.OpView):
  r"""
  Broadcasts memory load of 128 bits of data for a cluster of workgroups.
  
  Available on gfx1250+.
  """

  OPERATION_NAME = "rocdl.cluster.load.async.to.lds.b128"

  _ODS_REGIONS = (0, True)

  def __init__(self, globalPtr, ldsPtr, offset, cpol, mask, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(globalPtr)
    operands.append(ldsPtr)
    operands.append(mask)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["offset"] = (offset if (
    isinstance(offset, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(offset, context=_ods_context))
    attributes["cpol"] = (cpol if (
    isinstance(cpol, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(cpol, context=_ods_context))
    if alias_scopes is not None: attributes["alias_scopes"] = (alias_scopes if (
        isinstance(alias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(alias_scopes, context=_ods_context))
    if noalias_scopes is not None: attributes["noalias_scopes"] = (noalias_scopes if (
        isinstance(noalias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(noalias_scopes, context=_ods_context))
    if tbaa is not None: attributes["tbaa"] = (tbaa if (
        isinstance(tbaa, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_TBAATagArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_TBAATagArrayAttr')(tbaa, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def globalPtr(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def ldsPtr(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def mask(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[2]

  @builtins.property
  def offset(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["offset"]

  @offset.setter
  def offset(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["offset"] = value

  @builtins.property
  def cpol(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["cpol"]

  @cpol.setter
  def cpol(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["cpol"] = value

  @builtins.property
  def alias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "alias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["alias_scopes"]

  @alias_scopes.setter
  def alias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["alias_scopes"] = value
    elif "alias_scopes" in self.operation.attributes:
      del self.operation.attributes["alias_scopes"]

  @alias_scopes.deleter
  def alias_scopes(self):
    del self.operation.attributes["alias_scopes"]

  @builtins.property
  def noalias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "noalias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["noalias_scopes"]

  @noalias_scopes.setter
  def noalias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["noalias_scopes"] = value
    elif "noalias_scopes" in self.operation.attributes:
      del self.operation.attributes["noalias_scopes"]

  @noalias_scopes.deleter
  def noalias_scopes(self):
    del self.operation.attributes["noalias_scopes"]

  @builtins.property
  def tbaa(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tbaa" not in self.operation.attributes:
      return None
    return self.operation.attributes["tbaa"]

  @tbaa.setter
  def tbaa(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tbaa"] = value
    elif "tbaa" in self.operation.attributes:
      del self.operation.attributes["tbaa"]

  @tbaa.deleter
  def tbaa(self):
    del self.operation.attributes["tbaa"]

def cluster_load_async_to_lds_b128(global_ptr, lds_ptr, offset, cpol, mask, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None) -> ClusterLoadAsyncToLDSB128Op:
  return ClusterLoadAsyncToLDSB128Op(globalPtr=global_ptr, ldsPtr=lds_ptr, offset=offset, cpol=cpol, mask=mask, alias_scopes=alias_scopes, noalias_scopes=noalias_scopes, tbaa=tbaa, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CvtF32Bf8Op(_ods_ir.OpView):
  r"""
  Convert 8-bit bf8 value from the `byteSel`th bit of `srcA` to fp32.
  """

  OPERATION_NAME = "rocdl.cvt.f32.bf8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, srcA, byteSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(srcA)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["byteSel"] = (byteSel if (
    isinstance(byteSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(byteSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def srcA(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def byteSel(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["byteSel"]

  @byteSel.setter
  def byteSel(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["byteSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_f32_bf8(res, src_a, byte_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtF32Bf8Op(res=res, srcA=src_a, byteSel=byte_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtF32Fp8Op(_ods_ir.OpView):
  r"""
  Convert 8-bit fp8 value from the `byteSel`th bit of `srcA` to fp32.
  """

  OPERATION_NAME = "rocdl.cvt.f32.fp8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, srcA, byteSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(srcA)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["byteSel"] = (byteSel if (
    isinstance(byteSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(byteSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def srcA(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def byteSel(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["byteSel"]

  @byteSel.setter
  def byteSel(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["byteSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_f32_fp8(res, src_a, byte_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtF32Fp8Op(res=res, srcA=src_a, byteSel=byte_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtPkBf8F32Op(_ods_ir.OpView):
  r"""
  Convert `srcA` and `srcB` to bf8 and store into the low/high word of
  `old`, preserving the other word.
  """

  OPERATION_NAME = "rocdl.cvt.pk.bf8.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, srcA, srcB, old, wordSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(srcA)
    operands.append(srcB)
    operands.append(old)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["wordSel"] = (wordSel if (
    isinstance(wordSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I1Attr')) else
      _ods_ir.AttrBuilder.get('I1Attr')(wordSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def srcA(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def srcB(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def old(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[2]

  @builtins.property
  def wordSel(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["wordSel"]

  @wordSel.setter
  def wordSel(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["wordSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_pk_bf8_f32(res, src_a, src_b, old, word_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtPkBf8F32Op(res=res, srcA=src_a, srcB=src_b, old=old, wordSel=word_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtPkF32Bf8Op(_ods_ir.OpView):
  r"""
  Convert `src` based on $wordSel to packed fp32,
  """

  OPERATION_NAME = "rocdl.cvt.pk.f32.bf8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, wordSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["wordSel"] = (wordSel if (
    isinstance(wordSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I1Attr')) else
      _ods_ir.AttrBuilder.get('I1Attr')(wordSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def wordSel(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["wordSel"]

  @wordSel.setter
  def wordSel(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["wordSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_pk_f32_bf8(res, src, word_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtPkF32Bf8Op(res=res, src=src, wordSel=word_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtPkF32Fp8Op(_ods_ir.OpView):
  r"""
  Convert `src` based on $wordSel to packed fp32.
  """

  OPERATION_NAME = "rocdl.cvt.pk.f32.fp8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, wordSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["wordSel"] = (wordSel if (
    isinstance(wordSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I1Attr')) else
      _ods_ir.AttrBuilder.get('I1Attr')(wordSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def wordSel(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["wordSel"]

  @wordSel.setter
  def wordSel(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["wordSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_pk_f32_fp8(res, src, word_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtPkF32Fp8Op(res=res, src=src, wordSel=word_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtPkFp8F32Op(_ods_ir.OpView):
  r"""
  Convert `srcA` and `srcB` to fp8 and store into the low/high word of
  `old`, preserving the other word.
  """

  OPERATION_NAME = "rocdl.cvt.pk.fp8.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, srcA, srcB, old, wordSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(srcA)
    operands.append(srcB)
    operands.append(old)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["wordSel"] = (wordSel if (
    isinstance(wordSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I1Attr')) else
      _ods_ir.AttrBuilder.get('I1Attr')(wordSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def srcA(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def srcB(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def old(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[2]

  @builtins.property
  def wordSel(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["wordSel"]

  @wordSel.setter
  def wordSel(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["wordSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_pk_fp8_f32(res, src_a, src_b, old, word_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtPkFp8F32Op(res=res, srcA=src_a, srcB=src_b, old=old, wordSel=word_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtPkRtz(_ods_ir.OpView):
  r"""
  Convert two f32 values into a packed vector<2xf16>.
  """

  OPERATION_NAME = "rocdl.cvt.pkrtz"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, srcA, srcB, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(srcA)
    operands.append(srcB)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def srcA(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def srcB(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_pkrtz(res, src_a, src_b, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtPkRtz(res=res, srcA=src_a, srcB=src_b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtPkScalePk8Bf16Bf8Op(_ods_ir.OpView):
  r"""
  Available on gfx1250+.
  """

  OPERATION_NAME = "rocdl.cvt.scale.pk8.bf16.bf8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, scaleSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scaleSel"] = (scaleSel if (
    isinstance(scaleSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(scaleSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def scaleSel(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["scaleSel"]

  @scaleSel.setter
  def scaleSel(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scaleSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scale_pk8_bf16_bf8(res, src, scale, scale_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtPkScalePk8Bf16Bf8Op(res=res, src=src, scale=scale, scaleSel=scale_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtPkScalePk8Bf16Fp4Op(_ods_ir.OpView):
  r"""
  Available on gfx1250+.
  """

  OPERATION_NAME = "rocdl.cvt.scale.pk8.bf16.fp4"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, scaleSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scaleSel"] = (scaleSel if (
    isinstance(scaleSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(scaleSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def scaleSel(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["scaleSel"]

  @scaleSel.setter
  def scaleSel(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scaleSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scale_pk8_bf16_fp4(res, src, scale, scale_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtPkScalePk8Bf16Fp4Op(res=res, src=src, scale=scale, scaleSel=scale_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtPkScalePk8Bf16Fp8Op(_ods_ir.OpView):
  r"""
  Available on gfx1250+.
  """

  OPERATION_NAME = "rocdl.cvt.scale.pk8.bf16.fp8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, scaleSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scaleSel"] = (scaleSel if (
    isinstance(scaleSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(scaleSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def scaleSel(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["scaleSel"]

  @scaleSel.setter
  def scaleSel(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scaleSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scale_pk8_bf16_fp8(res, src, scale, scale_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtPkScalePk8Bf16Fp8Op(res=res, src=src, scale=scale, scaleSel=scale_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtPkScalePk8F16Bf8Op(_ods_ir.OpView):
  r"""
  Available on gfx1250+.
  """

  OPERATION_NAME = "rocdl.cvt.scale.pk8.f16.bf8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, scaleSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scaleSel"] = (scaleSel if (
    isinstance(scaleSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(scaleSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def scaleSel(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["scaleSel"]

  @scaleSel.setter
  def scaleSel(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scaleSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scale_pk8_f16_bf8(res, src, scale, scale_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtPkScalePk8F16Bf8Op(res=res, src=src, scale=scale, scaleSel=scale_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtPkScalePk8F16Fp4Op(_ods_ir.OpView):
  r"""
  Available on gfx1250+.
  """

  OPERATION_NAME = "rocdl.cvt.scale.pk8.f16.fp4"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, scaleSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scaleSel"] = (scaleSel if (
    isinstance(scaleSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(scaleSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def scaleSel(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["scaleSel"]

  @scaleSel.setter
  def scaleSel(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scaleSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scale_pk8_f16_fp4(res, src, scale, scale_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtPkScalePk8F16Fp4Op(res=res, src=src, scale=scale, scaleSel=scale_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtPkScalePk8F16Fp8Op(_ods_ir.OpView):
  r"""
  Available on gfx1250+.
  """

  OPERATION_NAME = "rocdl.cvt.scale.pk8.f16.fp8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, scaleSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scaleSel"] = (scaleSel if (
    isinstance(scaleSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(scaleSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def scaleSel(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["scaleSel"]

  @scaleSel.setter
  def scaleSel(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scaleSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scale_pk8_f16_fp8(res, src, scale, scale_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtPkScalePk8F16Fp8Op(res=res, src=src, scale=scale, scaleSel=scale_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtPkScalePk8F32Bf8Op(_ods_ir.OpView):
  r"""
  Available on gfx1250+.
  """

  OPERATION_NAME = "rocdl.cvt.scale.pk8.f32.bf8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, scaleSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scaleSel"] = (scaleSel if (
    isinstance(scaleSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(scaleSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def scaleSel(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["scaleSel"]

  @scaleSel.setter
  def scaleSel(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scaleSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scale_pk8_f32_bf8(res, src, scale, scale_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtPkScalePk8F32Bf8Op(res=res, src=src, scale=scale, scaleSel=scale_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtPkScalePk8F32Fp4Op(_ods_ir.OpView):
  r"""
  Available on gfx1250+.
  """

  OPERATION_NAME = "rocdl.cvt.scale.pk8.f32.fp4"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, scaleSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scaleSel"] = (scaleSel if (
    isinstance(scaleSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(scaleSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def scaleSel(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["scaleSel"]

  @scaleSel.setter
  def scaleSel(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scaleSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scale_pk8_f32_fp4(res, src, scale, scale_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtPkScalePk8F32Fp4Op(res=res, src=src, scale=scale, scaleSel=scale_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtPkScalePk8F32Fp8Op(_ods_ir.OpView):
  r"""
  Available on gfx1250+.
  """

  OPERATION_NAME = "rocdl.cvt.scale.pk8.f32.fp8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, scaleSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scaleSel"] = (scaleSel if (
    isinstance(scaleSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(scaleSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def scaleSel(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["scaleSel"]

  @scaleSel.setter
  def scaleSel(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scaleSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scale_pk8_f32_fp8(res, src, scale, scale_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtPkScalePk8F32Fp8Op(res=res, src=src, scale=scale, scaleSel=scale_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtPkScalePk16Bf16Bf6Op(_ods_ir.OpView):
  r"""
  Available on gfx1250+.
  """

  OPERATION_NAME = "rocdl.cvt.scale.pk16.bf16.bf6"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, scaleSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scaleSel"] = (scaleSel if (
    isinstance(scaleSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(scaleSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def scaleSel(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["scaleSel"]

  @scaleSel.setter
  def scaleSel(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scaleSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scale_pk16_bf16_bf6(res, src, scale, scale_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtPkScalePk16Bf16Bf6Op(res=res, src=src, scale=scale, scaleSel=scale_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtPkScalePk16Bf16Fp6Op(_ods_ir.OpView):
  r"""
  Available on gfx1250+.
  """

  OPERATION_NAME = "rocdl.cvt.scale.pk16.bf16.fp6"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, scaleSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scaleSel"] = (scaleSel if (
    isinstance(scaleSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(scaleSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def scaleSel(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["scaleSel"]

  @scaleSel.setter
  def scaleSel(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scaleSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scale_pk16_bf16_fp6(res, src, scale, scale_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtPkScalePk16Bf16Fp6Op(res=res, src=src, scale=scale, scaleSel=scale_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtPkScalePk16F16Bf6Op(_ods_ir.OpView):
  r"""
  Available on gfx1250+.
  """

  OPERATION_NAME = "rocdl.cvt.scale.pk16.f16.bf6"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, scaleSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scaleSel"] = (scaleSel if (
    isinstance(scaleSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(scaleSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def scaleSel(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["scaleSel"]

  @scaleSel.setter
  def scaleSel(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scaleSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scale_pk16_f16_bf6(res, src, scale, scale_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtPkScalePk16F16Bf6Op(res=res, src=src, scale=scale, scaleSel=scale_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtPkScalePk16F16Fp6Op(_ods_ir.OpView):
  r"""
  Available on gfx1250+.
  """

  OPERATION_NAME = "rocdl.cvt.scale.pk16.f16.fp6"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, scaleSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scaleSel"] = (scaleSel if (
    isinstance(scaleSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(scaleSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def scaleSel(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["scaleSel"]

  @scaleSel.setter
  def scaleSel(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scaleSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scale_pk16_f16_fp6(res, src, scale, scale_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtPkScalePk16F16Fp6Op(res=res, src=src, scale=scale, scaleSel=scale_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtPkScalePk16F32Bf6Op(_ods_ir.OpView):
  r"""
  Available on gfx1250+.
  """

  OPERATION_NAME = "rocdl.cvt.scale.pk16.f32.bf6"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, scaleSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scaleSel"] = (scaleSel if (
    isinstance(scaleSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(scaleSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def scaleSel(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["scaleSel"]

  @scaleSel.setter
  def scaleSel(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scaleSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scale_pk16_f32_bf6(res, src, scale, scale_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtPkScalePk16F32Bf6Op(res=res, src=src, scale=scale, scaleSel=scale_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtPkScalePk16F32Fp6Op(_ods_ir.OpView):
  r"""
  Available on gfx1250+.
  """

  OPERATION_NAME = "rocdl.cvt.scale.pk16.f32.fp6"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, scaleSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scaleSel"] = (scaleSel if (
    isinstance(scaleSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(scaleSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def scaleSel(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["scaleSel"]

  @scaleSel.setter
  def scaleSel(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scaleSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scale_pk16_f32_fp6(res, src, scale, scale_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtPkScalePk16F32Fp6Op(res=res, src=src, scale=scale, scaleSel=scale_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32F16Bf8Op(_ods_ir.OpView):
  r"""
  Convert a bf8 byte from `src`, selected by
  `srcSelIndex`, to f16 while multiplying it by the expontent of `scale`,
  and place it into the `dstLoHiSel`th bit
  of `oldVdst` preserving the other element of that vector in
  the return value.
  
  The bytes are stored as an `i32` and not a `<4 x i8>`.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.f16.bf8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, oldVdst, src, scale, srcSelIndex, dstLoHiSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(oldVdst)
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["srcSelIndex"] = (srcSelIndex if (
    isinstance(srcSelIndex, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(srcSelIndex, context=_ods_context))
    attributes["dstLoHiSel"] = (dstLoHiSel if (
    isinstance(dstLoHiSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I1Attr')) else
      _ods_ir.AttrBuilder.get('I1Attr')(dstLoHiSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def oldVdst(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[2]

  @builtins.property
  def srcSelIndex(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["srcSelIndex"]

  @srcSelIndex.setter
  def srcSelIndex(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["srcSelIndex"] = value

  @builtins.property
  def dstLoHiSel(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["dstLoHiSel"]

  @dstLoHiSel.setter
  def dstLoHiSel(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dstLoHiSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_f16_bf8(res, old_vdst, src, scale, src_sel_index, dst_lo_hi_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32F16Bf8Op(res=res, oldVdst=old_vdst, src=src, scale=scale, srcSelIndex=src_sel_index, dstLoHiSel=dst_lo_hi_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32F16Fp8Op(_ods_ir.OpView):
  r"""
  Convert a fp8 byte from `src`, selected by
  `srcSelIndex`, to f16 while multiplying it by the expontent of `scale`,
  and place it into the `dstLoHiSel`th bit
  of `oldVdst` preserving the other element of that vector in
  the return value.
  
  The bytes are stored as an `i32` and not a `<4 x i8>`.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.f16.fp8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, oldVdst, src, scale, srcSelIndex, dstLoHiSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(oldVdst)
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["srcSelIndex"] = (srcSelIndex if (
    isinstance(srcSelIndex, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(srcSelIndex, context=_ods_context))
    attributes["dstLoHiSel"] = (dstLoHiSel if (
    isinstance(dstLoHiSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I1Attr')) else
      _ods_ir.AttrBuilder.get('I1Attr')(dstLoHiSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def oldVdst(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[2]

  @builtins.property
  def srcSelIndex(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["srcSelIndex"]

  @srcSelIndex.setter
  def srcSelIndex(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["srcSelIndex"] = value

  @builtins.property
  def dstLoHiSel(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["dstLoHiSel"]

  @dstLoHiSel.setter
  def dstLoHiSel(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dstLoHiSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_f16_fp8(res, old_vdst, src, scale, src_sel_index, dst_lo_hi_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32F16Fp8Op(res=res, oldVdst=old_vdst, src=src, scale=scale, srcSelIndex=src_sel_index, dstLoHiSel=dst_lo_hi_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32F32Bf8Op(_ods_ir.OpView):
  r"""
  Convert a bf8 byte from `src`, selected by
  `srcSelIndex`, to f32, multiplying it by the exponent of `scale`.
  
  The bytes are stored in an `i32`, not a `<4 x i8>`.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.f32.bf8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, srcSelIndex, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["srcSelIndex"] = (srcSelIndex if (
    isinstance(srcSelIndex, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(srcSelIndex, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def srcSelIndex(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["srcSelIndex"]

  @srcSelIndex.setter
  def srcSelIndex(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["srcSelIndex"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def cvt_scalef32_f32_bf8(res, src, scale, src_sel_index, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32F32Bf8Op(res=res, src=src, scale=scale, srcSelIndex=src_sel_index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32F32Fp8Op(_ods_ir.OpView):
  r"""
  Convert a fp8 byte from `src`, selected by
  `srcSelIndex`, to f32, multiplying it by the exponent of `scale`.
  
  The bytes are stored in an `i32`, not a `<4 x i8>`.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.f32.fp8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, srcSelIndex, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["srcSelIndex"] = (srcSelIndex if (
    isinstance(srcSelIndex, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(srcSelIndex, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def srcSelIndex(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["srcSelIndex"]

  @srcSelIndex.setter
  def srcSelIndex(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["srcSelIndex"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def cvt_scalef32_f32_fp8(res, src, scale, src_sel_index, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32F32Fp8Op(res=res, src=src, scale=scale, srcSelIndex=src_sel_index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32Pk8Bf8Bf16Op(_ods_ir.OpView):
  r"""
  Convert 8 packed bf16 values to packed bf8, multiplying by the exponent part of `scale`
  before doing so. This op is for gfx1250+ arch.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk8.bf8.bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_pk8_bf8_bf16(res, src, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32Pk8Bf8Bf16Op(res=res, src=src, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32Pk8Bf8F16Op(_ods_ir.OpView):
  r"""
  Convert 8 packed f16 values to packed bf8, multiplying by the exponent part of `scale`
  before doing so. This op is for gfx1250+ arch.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk8.bf8.f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_pk8_bf8_f16(res, src, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32Pk8Bf8F16Op(res=res, src=src, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32Pk8Bf8F32Op(_ods_ir.OpView):
  r"""
  Convert 8 packed f32 values to packed bf8, multiplying by the exponent part of `scale`
  before doing so. This op is for gfx1250+ arch.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk8.bf8.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_pk8_bf8_f32(res, src, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32Pk8Bf8F32Op(res=res, src=src, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32Pk8Fp4Bf16Op(_ods_ir.OpView):
  r"""
  Convert 8 packed bf16 values to packed fp4, multiplying by the exponent part of `scale`
  before doing so. This op is for gfx1250+ arch.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk8.fp4.bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cvt_scalef32_pk8_fp4_bf16(res, src, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32Pk8Fp4Bf16Op(res=res, src=src, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32Pk8Fp4F16Op(_ods_ir.OpView):
  r"""
  Convert 8 packed f16 values to packed fp4, multiplying by the exponent part of `scale`
  before doing so. This op is for gfx1250+ arch.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk8.fp4.f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cvt_scalef32_pk8_fp4_f16(res, src, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32Pk8Fp4F16Op(res=res, src=src, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32Pk8Fp4F32Op(_ods_ir.OpView):
  r"""
  Convert 8 packed f32 values to packed fp4, multiplying by the exponent part of `scale`
  before doing so. This op is for gfx1250+ arch.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk8.fp4.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cvt_scalef32_pk8_fp4_f32(res, src, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32Pk8Fp4F32Op(res=res, src=src, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32Pk8Fp8Bf16Op(_ods_ir.OpView):
  r"""
  Convert 8 packed bf16 values to packed fp8, multiplying by the exponent part of `scale`
  before doing so. This op is for gfx1250+ arch.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk8.fp8.bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_pk8_fp8_bf16(res, src, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32Pk8Fp8Bf16Op(res=res, src=src, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32Pk8Fp8F16Op(_ods_ir.OpView):
  r"""
  Convert 8 packed f16 values to packed fp8, multiplying by the exponent part of `scale`
  before doing so. This op is for gfx1250+ arch.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk8.fp8.f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_pk8_fp8_f16(res, src, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32Pk8Fp8F16Op(res=res, src=src, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32Pk8Fp8F32Op(_ods_ir.OpView):
  r"""
  Convert 8 packed f32 values to packed fp8, multiplying by the exponent part of `scale`
  before doing so. This op is for gfx1250+ arch.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk8.fp8.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_pk8_fp8_f32(res, src, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32Pk8Fp8F32Op(res=res, src=src, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32Pk16Bf6Bf16Op(_ods_ir.OpView):
  r"""
  Convert 8 packed bf16 values to packed bf6, multiplying by the exponent part of `scale`
  before doing so. This op is for gfx1250+ arch.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk16.bf6.bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_pk16_bf6_bf16(res, src, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32Pk16Bf6Bf16Op(res=res, src=src, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32Pk16Bf6F16Op(_ods_ir.OpView):
  r"""
  Convert 8 packed f16 values to packed bf6, multiplying by the exponent part of `scale`
  before doing so. This op is for gfx1250+ arch.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk16.bf6.f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_pk16_bf6_f16(res, src, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32Pk16Bf6F16Op(res=res, src=src, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32Pk16Bf6F32Op(_ods_ir.OpView):
  r"""
  Convert 8 packed f32 values to packed bf6, multiplying by the exponent part of `scale`
  before doing so. This op is for gfx1250+ arch.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk16.bf6.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_pk16_bf6_f32(res, src, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32Pk16Bf6F32Op(res=res, src=src, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32Pk16Fp6Bf16Op(_ods_ir.OpView):
  r"""
  Convert 8 packed bf16 values to packed fp6, multiplying by the exponent part of `scale`
  before doing so. This op is for gfx1250+ arch.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk16.fp6.bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_pk16_fp6_bf16(res, src, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32Pk16Fp6Bf16Op(res=res, src=src, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32Pk16Fp6F16Op(_ods_ir.OpView):
  r"""
  Convert 8 packed f16 values to packed fp6, multiplying by the exponent part of `scale`
  before doing so. This op is for gfx1250+ arch.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk16.fp6.f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_pk16_fp6_f16(res, src, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32Pk16Fp6F16Op(res=res, src=src, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32Pk16Fp6F32Op(_ods_ir.OpView):
  r"""
  Convert 8 packed f32 values to packed fp6, multiplying by the exponent part of `scale`
  before doing so. This op is for gfx1250+ arch.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk16.fp6.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_pk16_fp6_f32(res, src, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32Pk16Fp6F32Op(res=res, src=src, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32Pk32Bf6Bf16Op(_ods_ir.OpView):
  r"""
  Convert 32 packed bf16 values to packed bf6, dividing by the exponent part of `scale`
  before doing so.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk32.bf6.bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_pk32_bf6_bf16(res, src, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32Pk32Bf6Bf16Op(res=res, src=src, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32Pk32Bf6F16Op(_ods_ir.OpView):
  r"""
  Convert 32 packed f16 values to packed bf6, dividing by the exponent part of `scale`
  before doing so.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk32.bf6.f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_pk32_bf6_f16(res, src, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32Pk32Bf6F16Op(res=res, src=src, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32Pk32Bf16Bf6Op(_ods_ir.OpView):
  r"""
  Convert 32 packed bf6 values to packed bf16, multiplying by the exponent part of `scale`
  before doing so.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk32.bf16.bf6"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_pk32_bf16_bf6(res, src, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32Pk32Bf16Bf6Op(res=res, src=src, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32Pk32Bf16Fp6Op(_ods_ir.OpView):
  r"""
  Convert 32 packed fp6 values to packed bf16, multiplying by the exponent part of `scale`
  before doing so.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk32.bf16.fp6"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_pk32_bf16_fp6(res, src, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32Pk32Bf16Fp6Op(res=res, src=src, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32Pk32F16Bf6Op(_ods_ir.OpView):
  r"""
  Convert 32 packed bf6 values to packed f16, multiplying by the exponent part of `scale`
  before doing so.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk32.f16.bf6"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_pk32_f16_bf6(res, src, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32Pk32F16Bf6Op(res=res, src=src, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32Pk32F16Fp6Op(_ods_ir.OpView):
  r"""
  Convert 32 packed fp6 values to packed f16, multiplying by the exponent part of `scale`
  before doing so.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk32.f16.fp6"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_pk32_f16_fp6(res, src, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32Pk32F16Fp6Op(res=res, src=src, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32Pk32F32Bf6Op(_ods_ir.OpView):
  r"""
  Convert 32 packed bf6 values to packed f32, multiplying by the exponent part of `scale`
  before doing so.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk32.f32.bf6"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_pk32_f32_bf6(res, src, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32Pk32F32Bf6Op(res=res, src=src, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32Pk32F32Fp6Op(_ods_ir.OpView):
  r"""
  Convert 32 packed fp6 values to packed f32, multiplying by the exponent part of `scale`
  before doing so.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk32.f32.fp6"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_pk32_f32_fp6(res, src, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32Pk32F32Fp6Op(res=res, src=src, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32Pk32Fp6Bf16Op(_ods_ir.OpView):
  r"""
  Convert 32 packed bf16 values to packed fp6, dividing by the exponent part of `scale`
  before doing so.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk32.fp6.bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_pk32_fp6_bf16(res, src, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32Pk32Fp6Bf16Op(res=res, src=src, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32Pk32Fp6F16Op(_ods_ir.OpView):
  r"""
  Convert 32 packed f16 values to packed fp6, dividing by the exponent part of `scale`
  before doing so.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk32.fp6.f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_pk32_fp6_f16(res, src, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32Pk32Fp6F16Op(res=res, src=src, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32PkBf8Bf16Op(_ods_ir.OpView):
  r"""
  Convert two bf16 values in `src0` to two bf8 bytes, dividing by the exponent in `scale`. The bytes are
  packed into a 16-bit value which is inserted into `oldVdst` at the
  `dstLoHiSel` position, with the entire updated vector being returned.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk.bf8.bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, oldVdst, src0, scale, dstLoHiSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(oldVdst)
    operands.append(src0)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dstLoHiSel"] = (dstLoHiSel if (
    isinstance(dstLoHiSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I1Attr')) else
      _ods_ir.AttrBuilder.get('I1Attr')(dstLoHiSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def oldVdst(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def src0(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[2]

  @builtins.property
  def dstLoHiSel(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["dstLoHiSel"]

  @dstLoHiSel.setter
  def dstLoHiSel(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dstLoHiSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_pk_bf8_bf16(res, old_vdst, src0, scale, dst_lo_hi_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32PkBf8Bf16Op(res=res, oldVdst=old_vdst, src0=src0, scale=scale, dstLoHiSel=dst_lo_hi_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32PkBf8F16Op(_ods_ir.OpView):
  r"""
  Convert two f16 values in `src0` to two bf8 bytes, dividing by the exponent in `scale`. The bytes are
  packed into a 16-bit value which is inserted into `oldVdst` at the
  `dstLoHiSel` position, with the entire updated vector being returned.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk.bf8.f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, oldVdst, src0, scale, dstLoHiSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(oldVdst)
    operands.append(src0)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dstLoHiSel"] = (dstLoHiSel if (
    isinstance(dstLoHiSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I1Attr')) else
      _ods_ir.AttrBuilder.get('I1Attr')(dstLoHiSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def oldVdst(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def src0(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[2]

  @builtins.property
  def dstLoHiSel(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["dstLoHiSel"]

  @dstLoHiSel.setter
  def dstLoHiSel(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dstLoHiSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_pk_bf8_f16(res, old_vdst, src0, scale, dst_lo_hi_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32PkBf8F16Op(res=res, oldVdst=old_vdst, src0=src0, scale=scale, dstLoHiSel=dst_lo_hi_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32PkBf8F32Op(_ods_ir.OpView):
  r"""
  Convert two f32 values in `src0` and `src1` to two bf8 bytes,
  dividing by the exponent in `scale`. The bytes are packed into
  a 16-bit value which is inserted into `oldVdst` at the `dstLoHiSel`
  position, with the entire updated vector being returned.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk.bf8.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, oldVdst, src0, src1, scale, dstLoHiSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(oldVdst)
    operands.append(src0)
    operands.append(src1)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dstLoHiSel"] = (dstLoHiSel if (
    isinstance(dstLoHiSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I1Attr')) else
      _ods_ir.AttrBuilder.get('I1Attr')(dstLoHiSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def oldVdst(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def src0(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def src1(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[2]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[3]

  @builtins.property
  def dstLoHiSel(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["dstLoHiSel"]

  @dstLoHiSel.setter
  def dstLoHiSel(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dstLoHiSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_pk_bf8_f32(res, old_vdst, src0, src1, scale, dst_lo_hi_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32PkBf8F32Op(res=res, oldVdst=old_vdst, src0=src0, src1=src1, scale=scale, dstLoHiSel=dst_lo_hi_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32PkBf16Bf8Op(_ods_ir.OpView):
  r"""
  Convert two packed bf8 values in `src0` to two bf16 values, multiplying by the exponent in `scale`.
  The two values to be converted are selected from the low or high half
  of `src` (a packed vector represented as an `i32`)
  on the basis of `srcLoHiSel`.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk.bf16.bf8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, srcLoHiSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["srcLoHiSel"] = (srcLoHiSel if (
    isinstance(srcLoHiSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I1Attr')) else
      _ods_ir.AttrBuilder.get('I1Attr')(srcLoHiSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def srcLoHiSel(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["srcLoHiSel"]

  @srcLoHiSel.setter
  def srcLoHiSel(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["srcLoHiSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_pk_bf16_bf8(res, src, scale, src_lo_hi_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32PkBf16Bf8Op(res=res, src=src, scale=scale, srcLoHiSel=src_lo_hi_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32PkBf16Fp4Op(_ods_ir.OpView):
  r"""
  Convert two packed fp4 (f4E2M1) values  stored as one byte of a 32-bit integer
  to packed bf16, multiplying by the exponent part of `scale`
  before doing so.
  
  The byte to convert is chosen by `srcSelIndex`.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk.bf16.fp4"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, srcSelIndex, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["srcSelIndex"] = (srcSelIndex if (
    isinstance(srcSelIndex, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(srcSelIndex, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def srcSelIndex(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["srcSelIndex"]

  @srcSelIndex.setter
  def srcSelIndex(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["srcSelIndex"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_pk_bf16_fp4(res, src, scale, src_sel_index, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32PkBf16Fp4Op(res=res, src=src, scale=scale, srcSelIndex=src_sel_index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32PkBf16Fp8Op(_ods_ir.OpView):
  r"""
  Convert two packed fp8 values in `src0` to two bf16 values, multiplying by the exponent in `scale`.
  The two values to be converted are selected from the low or high half
  of `src` (a packed vector represented as an `i32`)
  on the basis of `srcLoHiSel`.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk.bf16.fp8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, srcLoHiSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["srcLoHiSel"] = (srcLoHiSel if (
    isinstance(srcLoHiSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I1Attr')) else
      _ods_ir.AttrBuilder.get('I1Attr')(srcLoHiSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def srcLoHiSel(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["srcLoHiSel"]

  @srcLoHiSel.setter
  def srcLoHiSel(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["srcLoHiSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_pk_bf16_fp8(res, src, scale, src_lo_hi_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32PkBf16Fp8Op(res=res, src=src, scale=scale, srcLoHiSel=src_lo_hi_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32PkF16Bf8Op(_ods_ir.OpView):
  r"""
  Convert two packed bf8 values in `src0` to two f16 values, multiplying by the exponent in `scale`.
  The two values to be converted are selected from the low or high half
  of `src` (a packed vector represented as an `i32`)
  on the basis of `srcLoHiSel`.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk.f16.bf8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, srcLoHiSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["srcLoHiSel"] = (srcLoHiSel if (
    isinstance(srcLoHiSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I1Attr')) else
      _ods_ir.AttrBuilder.get('I1Attr')(srcLoHiSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def srcLoHiSel(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["srcLoHiSel"]

  @srcLoHiSel.setter
  def srcLoHiSel(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["srcLoHiSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_pk_f16_bf8(res, src, scale, src_lo_hi_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32PkF16Bf8Op(res=res, src=src, scale=scale, srcLoHiSel=src_lo_hi_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32PkF16Fp4Op(_ods_ir.OpView):
  r"""
  Convert two packed fp4 (f4E2M1) values  stored as one byte of a 32-bit integer
  to packed f16, multiplying by the exponent part of `scale`
  before doing so.
  
  The byte to convert is chosen by `srcSelIndex`.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk.f16.fp4"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, srcSelIndex, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["srcSelIndex"] = (srcSelIndex if (
    isinstance(srcSelIndex, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(srcSelIndex, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def srcSelIndex(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["srcSelIndex"]

  @srcSelIndex.setter
  def srcSelIndex(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["srcSelIndex"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_pk_f16_fp4(res, src, scale, src_sel_index, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32PkF16Fp4Op(res=res, src=src, scale=scale, srcSelIndex=src_sel_index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32PkF16Fp8Op(_ods_ir.OpView):
  r"""
  Convert two packed fp8 values in `src0` to two f16 values, multiplying by the exponent in `scale`.
  The two values to be converted are selected from the low or high half
  of `src` (a packed vector represented as an `i32`)
  on the basis of `srcLoHiSel`.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk.f16.fp8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, srcLoHiSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["srcLoHiSel"] = (srcLoHiSel if (
    isinstance(srcLoHiSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I1Attr')) else
      _ods_ir.AttrBuilder.get('I1Attr')(srcLoHiSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def srcLoHiSel(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["srcLoHiSel"]

  @srcLoHiSel.setter
  def srcLoHiSel(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["srcLoHiSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_pk_f16_fp8(res, src, scale, src_lo_hi_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32PkF16Fp8Op(res=res, src=src, scale=scale, srcLoHiSel=src_lo_hi_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32PkF32Bf8Op(_ods_ir.OpView):
  r"""
  Convert two packed bf8 values in `src0` to two f32 values, multiplying by the exponent in `scale`.
  The two values to be converted are selected from the low or high half
  of `src` (a packed vector represented as an `i32`)
  on the basis of `srcLoHiSel`.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk.f32.bf8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, srcLoHiSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["srcLoHiSel"] = (srcLoHiSel if (
    isinstance(srcLoHiSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I1Attr')) else
      _ods_ir.AttrBuilder.get('I1Attr')(srcLoHiSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def srcLoHiSel(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["srcLoHiSel"]

  @srcLoHiSel.setter
  def srcLoHiSel(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["srcLoHiSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_pk_f32_bf8(res, src, scale, src_lo_hi_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32PkF32Bf8Op(res=res, src=src, scale=scale, srcLoHiSel=src_lo_hi_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32PkF32Fp4Op(_ods_ir.OpView):
  r"""
  Convert two packed fp4 (f4E2M1) values  stored as one byte of a 32-bit integer
  to packed f32, multiplying by the exponent part of `scale`
  before doing so.
  
  The byte to convert is chosen by `srcSelIndex`.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk.f32.fp4"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, srcSelIndex, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["srcSelIndex"] = (srcSelIndex if (
    isinstance(srcSelIndex, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(srcSelIndex, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def srcSelIndex(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["srcSelIndex"]

  @srcSelIndex.setter
  def srcSelIndex(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["srcSelIndex"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_pk_f32_fp4(res, src, scale, src_sel_index, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32PkF32Fp4Op(res=res, src=src, scale=scale, srcSelIndex=src_sel_index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32PkF32Fp8Op(_ods_ir.OpView):
  r"""
  Convert two packed fp8 values in `src0` to two f32 values, multiplying by the exponent in `scale`.
  The two values to be converted are selected from the low or high half
  of `src` (a packed vector represented as an `i32`)
  on the basis of `srcLoHiSel`.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk.f32.fp8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, srcLoHiSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["srcLoHiSel"] = (srcLoHiSel if (
    isinstance(srcLoHiSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I1Attr')) else
      _ods_ir.AttrBuilder.get('I1Attr')(srcLoHiSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def srcLoHiSel(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["srcLoHiSel"]

  @srcLoHiSel.setter
  def srcLoHiSel(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["srcLoHiSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_pk_f32_fp8(res, src, scale, src_lo_hi_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32PkF32Fp8Op(res=res, src=src, scale=scale, srcLoHiSel=src_lo_hi_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32PkFp4Bf16Op(_ods_ir.OpView):
  r"""
  Convert two packed bf16 values to packed
  fp4, dividing by the exponent part of `scale`
  before doing so.
  
  The two scaled values are packed  into a byte.
  That byte is used to update the `dstSelIndex`th
  byte of `oldVdst`, which is returned in its entirity.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk.fp4.bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, oldVdst, src, scale, dstSelIndex, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(oldVdst)
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dstSelIndex"] = (dstSelIndex if (
    isinstance(dstSelIndex, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(dstSelIndex, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def oldVdst(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[2]

  @builtins.property
  def dstSelIndex(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["dstSelIndex"]

  @dstSelIndex.setter
  def dstSelIndex(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dstSelIndex"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cvt_scalef32_pk_fp4_bf16(res, old_vdst, src, scale, dst_sel_index, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32PkFp4Bf16Op(res=res, oldVdst=old_vdst, src=src, scale=scale, dstSelIndex=dst_sel_index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32PkFp4F16Op(_ods_ir.OpView):
  r"""
  Convert two packed f16 values to packed
  fp4, dividing by the exponent part of `scale`
  before doing so.
  
  The two scaled values are packed  into a byte.
  That byte is used to update the `dstSelIndex`th
  byte of `oldVdst`, which is returned in its entirity.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk.fp4.f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, oldVdst, src, scale, dstSelIndex, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(oldVdst)
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dstSelIndex"] = (dstSelIndex if (
    isinstance(dstSelIndex, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(dstSelIndex, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def oldVdst(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[2]

  @builtins.property
  def dstSelIndex(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["dstSelIndex"]

  @dstSelIndex.setter
  def dstSelIndex(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dstSelIndex"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cvt_scalef32_pk_fp4_f16(res, old_vdst, src, scale, dst_sel_index, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32PkFp4F16Op(res=res, oldVdst=old_vdst, src=src, scale=scale, dstSelIndex=dst_sel_index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32PkFp4F32Op(_ods_ir.OpView):
  r"""
  Convert two single-precision float values, passed in `src0` and `src1`
  into two fp4 values, dividing them by the expontent part of `scale`
  before doing so.
  
  The two scaled values are packed  into a byte.
  That byte is used to update the `dstSelIndex`th
  byte of `oldVdst`, which is returned in its entirity.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk.fp4.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, oldVdst, src0, src1, scale, dstSelIndex, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(oldVdst)
    operands.append(src0)
    operands.append(src1)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dstSelIndex"] = (dstSelIndex if (
    isinstance(dstSelIndex, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(dstSelIndex, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def oldVdst(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def src0(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def src1(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[2]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[3]

  @builtins.property
  def dstSelIndex(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["dstSelIndex"]

  @dstSelIndex.setter
  def dstSelIndex(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dstSelIndex"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cvt_scalef32_pk_fp4_f32(res, old_vdst, src0, src1, scale, dst_sel_index, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32PkFp4F32Op(res=res, oldVdst=old_vdst, src0=src0, src1=src1, scale=scale, dstSelIndex=dst_sel_index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32PkFp8Bf16Op(_ods_ir.OpView):
  r"""
  Convert two bf16 values in `src0` to two fp8 bytes, dividing by the exponent in `scale`. The bytes are
  packed into a 16-bit value which is inserted into `oldVdst` at the
  `dstLoHiSel` position, with the entire updated vector being returned.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk.fp8.bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, oldVdst, src0, scale, dstLoHiSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(oldVdst)
    operands.append(src0)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dstLoHiSel"] = (dstLoHiSel if (
    isinstance(dstLoHiSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I1Attr')) else
      _ods_ir.AttrBuilder.get('I1Attr')(dstLoHiSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def oldVdst(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def src0(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[2]

  @builtins.property
  def dstLoHiSel(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["dstLoHiSel"]

  @dstLoHiSel.setter
  def dstLoHiSel(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dstLoHiSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_pk_fp8_bf16(res, old_vdst, src0, scale, dst_lo_hi_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32PkFp8Bf16Op(res=res, oldVdst=old_vdst, src0=src0, scale=scale, dstLoHiSel=dst_lo_hi_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32PkFp8F16Op(_ods_ir.OpView):
  r"""
  Convert two f16 values in `src0` to two fp8 bytes, dividing by the exponent in `scale`. The bytes are
  packed into a 16-bit value which is inserted into `oldVdst` at the
  `dstLoHiSel` position, with the entire updated vector being returned.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk.fp8.f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, oldVdst, src0, scale, dstLoHiSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(oldVdst)
    operands.append(src0)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dstLoHiSel"] = (dstLoHiSel if (
    isinstance(dstLoHiSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I1Attr')) else
      _ods_ir.AttrBuilder.get('I1Attr')(dstLoHiSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def oldVdst(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def src0(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[2]

  @builtins.property
  def dstLoHiSel(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["dstLoHiSel"]

  @dstLoHiSel.setter
  def dstLoHiSel(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dstLoHiSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_pk_fp8_f16(res, old_vdst, src0, scale, dst_lo_hi_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32PkFp8F16Op(res=res, oldVdst=old_vdst, src0=src0, scale=scale, dstLoHiSel=dst_lo_hi_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32PkFp8F32Op(_ods_ir.OpView):
  r"""
  Convert two f32 values in `src0` and `src1` to two fp8 bytes,
  dividing by the exponent in `scale`. The bytes are packed into
  a 16-bit value which is inserted into `oldVdst` at the `dstLoHiSel`
  position, with the entire updated vector being returned.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk.fp8.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, oldVdst, src0, src1, scale, dstLoHiSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(oldVdst)
    operands.append(src0)
    operands.append(src1)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dstLoHiSel"] = (dstLoHiSel if (
    isinstance(dstLoHiSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I1Attr')) else
      _ods_ir.AttrBuilder.get('I1Attr')(dstLoHiSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def oldVdst(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def src0(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def src1(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[2]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[3]

  @builtins.property
  def dstLoHiSel(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["dstLoHiSel"]

  @dstLoHiSel.setter
  def dstLoHiSel(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dstLoHiSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_pk_fp8_f32(res, old_vdst, src0, src1, scale, dst_lo_hi_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32PkFp8F32Op(res=res, oldVdst=old_vdst, src0=src0, src1=src1, scale=scale, dstLoHiSel=dst_lo_hi_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32SrBf8BF16Op(_ods_ir.OpView):
  r"""
  Convert a bf16 value in `src0` to a bf8 bytes, dividing by the exponent in `scale` and using `seed`
  for stochiastic rounding. Place the resulting byte in the
  `dstSelIndex`th bit of `oldVdst` and return the entire packed vector,
  which is stored as an `i32`.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.sr.bf8.bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, oldVdst, src0, seed, scale, dstSelIndex, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(oldVdst)
    operands.append(src0)
    operands.append(seed)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dstSelIndex"] = (dstSelIndex if (
    isinstance(dstSelIndex, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(dstSelIndex, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def oldVdst(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def src0(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def seed(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[2]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[3]

  @builtins.property
  def dstSelIndex(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["dstSelIndex"]

  @dstSelIndex.setter
  def dstSelIndex(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dstSelIndex"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cvt_scalef32_sr_bf8_bf16(res, old_vdst, src0, seed, scale, dst_sel_index, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32SrBf8BF16Op(res=res, oldVdst=old_vdst, src0=src0, seed=seed, scale=scale, dstSelIndex=dst_sel_index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32SrBf8F16Op(_ods_ir.OpView):
  r"""
  Convert a f16 value in `src0` to a bf8 bytes, dividing by the exponent in `scale` and using `seed`
  for stochiastic rounding. Place the resulting byte in the
  `dstSelIndex`th bit of `oldVdst` and return the entire packed vector,
  which is stored as an `i32`.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.sr.bf8.f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, oldVdst, src0, seed, scale, dstSelIndex, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(oldVdst)
    operands.append(src0)
    operands.append(seed)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dstSelIndex"] = (dstSelIndex if (
    isinstance(dstSelIndex, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(dstSelIndex, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def oldVdst(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def src0(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def seed(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[2]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[3]

  @builtins.property
  def dstSelIndex(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["dstSelIndex"]

  @dstSelIndex.setter
  def dstSelIndex(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dstSelIndex"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cvt_scalef32_sr_bf8_f16(res, old_vdst, src0, seed, scale, dst_sel_index, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32SrBf8F16Op(res=res, oldVdst=old_vdst, src0=src0, seed=seed, scale=scale, dstSelIndex=dst_sel_index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32SrBf8F32Op(_ods_ir.OpView):
  r"""
  Convert a f32 value in `src0` to a bf8 bytes, dividing by the exponent in `scale` and using `seed`
  for stochiastic rounding. Place the resulting byte in the
  `dstSelIndex`th bit of `oldVdst` and return the entire packed vector,
  which is stored as an `i32`.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.sr.bf8.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, oldVdst, src0, seed, scale, dstSelIndex, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(oldVdst)
    operands.append(src0)
    operands.append(seed)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dstSelIndex"] = (dstSelIndex if (
    isinstance(dstSelIndex, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(dstSelIndex, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def oldVdst(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def src0(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def seed(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[2]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[3]

  @builtins.property
  def dstSelIndex(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["dstSelIndex"]

  @dstSelIndex.setter
  def dstSelIndex(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dstSelIndex"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cvt_scalef32_sr_bf8_f32(res, old_vdst, src0, seed, scale, dst_sel_index, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32SrBf8F32Op(res=res, oldVdst=old_vdst, src0=src0, seed=seed, scale=scale, dstSelIndex=dst_sel_index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32SrFp8BF16Op(_ods_ir.OpView):
  r"""
  Convert a bf16 value in `src0` to a fp8 bytes, dividing by the exponent in `scale` and using `seed`
  for stochiastic rounding. Place the resulting byte in the
  `dstSelIndex`th bit of `oldVdst` and return the entire packed vector,
  which is stored as an `i32`.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.sr.fp8.bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, oldVdst, src0, seed, scale, dstSelIndex, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(oldVdst)
    operands.append(src0)
    operands.append(seed)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dstSelIndex"] = (dstSelIndex if (
    isinstance(dstSelIndex, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(dstSelIndex, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def oldVdst(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def src0(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def seed(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[2]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[3]

  @builtins.property
  def dstSelIndex(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["dstSelIndex"]

  @dstSelIndex.setter
  def dstSelIndex(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dstSelIndex"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cvt_scalef32_sr_fp8_bf16(res, old_vdst, src0, seed, scale, dst_sel_index, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32SrFp8BF16Op(res=res, oldVdst=old_vdst, src0=src0, seed=seed, scale=scale, dstSelIndex=dst_sel_index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32SrFp8F16Op(_ods_ir.OpView):
  r"""
  Convert a f16 value in `src0` to a fp8 bytes, dividing by the exponent in `scale` and using `seed`
  for stochiastic rounding. Place the resulting byte in the
  `dstSelIndex`th bit of `oldVdst` and return the entire packed vector,
  which is stored as an `i32`.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.sr.fp8.f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, oldVdst, src0, seed, scale, dstSelIndex, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(oldVdst)
    operands.append(src0)
    operands.append(seed)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dstSelIndex"] = (dstSelIndex if (
    isinstance(dstSelIndex, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(dstSelIndex, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def oldVdst(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def src0(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def seed(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[2]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[3]

  @builtins.property
  def dstSelIndex(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["dstSelIndex"]

  @dstSelIndex.setter
  def dstSelIndex(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dstSelIndex"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cvt_scalef32_sr_fp8_f16(res, old_vdst, src0, seed, scale, dst_sel_index, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32SrFp8F16Op(res=res, oldVdst=old_vdst, src0=src0, seed=seed, scale=scale, dstSelIndex=dst_sel_index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32SrFp8F32Op(_ods_ir.OpView):
  r"""
  Convert a f32 value in `src0` to a fp8 bytes, dividing by the exponent in `scale` and using `seed`
  for stochiastic rounding. Place the resulting byte in the
  `dstSelIndex`th bit of `oldVdst` and return the entire packed vector,
  which is stored as an `i32`.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.sr.fp8.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, oldVdst, src0, seed, scale, dstSelIndex, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(oldVdst)
    operands.append(src0)
    operands.append(seed)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dstSelIndex"] = (dstSelIndex if (
    isinstance(dstSelIndex, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(dstSelIndex, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def oldVdst(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def src0(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def seed(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[2]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[3]

  @builtins.property
  def dstSelIndex(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["dstSelIndex"]

  @dstSelIndex.setter
  def dstSelIndex(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dstSelIndex"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cvt_scalef32_sr_fp8_f32(res, old_vdst, src0, seed, scale, dst_sel_index, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32SrFp8F32Op(res=res, oldVdst=old_vdst, src0=src0, seed=seed, scale=scale, dstSelIndex=dst_sel_index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32SrPk8Bf8Bf16Op(_ods_ir.OpView):
  r"""
  Convert 8 packed bf16 values to packed bf8, multiplying by the exponent part of `scale`
  before doing so and apply stochastic rounding. This op is for gfx1250+ arch.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.sr.pk8.bf8.bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, seed, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(seed)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def seed(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[2]

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_sr_pk8_bf8_bf16(res, src, seed, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32SrPk8Bf8Bf16Op(res=res, src=src, seed=seed, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32SrPk8Bf8F16Op(_ods_ir.OpView):
  r"""
  Convert 8 packed f16 values to packed bf8, multiplying by the exponent part of `scale`
  before doing so and apply stochastic rounding. This op is for gfx1250+ arch.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.sr.pk8.bf8.f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, seed, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(seed)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def seed(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[2]

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_sr_pk8_bf8_f16(res, src, seed, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32SrPk8Bf8F16Op(res=res, src=src, seed=seed, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32SrPk8Bf8F32Op(_ods_ir.OpView):
  r"""
  Convert 8 packed f32 values to packed bf8, multiplying by the exponent part of `scale`
  before doing so and apply stochastic rounding. This op is for gfx1250+ arch.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.sr.pk8.bf8.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, seed, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(seed)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def seed(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[2]

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_sr_pk8_bf8_f32(res, src, seed, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32SrPk8Bf8F32Op(res=res, src=src, seed=seed, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32SrPk8Fp4Bf16Op(_ods_ir.OpView):
  r"""
  Convert 8 packed bf16 values to packed fp4, multiplying by the exponent part of `scale`
  before doing so and apply stochastic rounding. This op is for gfx1250+ arch.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.sr.pk8.fp4.bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, seed, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(seed)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def seed(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[2]

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cvt_scalef32_sr_pk8_fp4_bf16(res, src, seed, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32SrPk8Fp4Bf16Op(res=res, src=src, seed=seed, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32SrPk8Fp4F16Op(_ods_ir.OpView):
  r"""
  Convert 8 packed f16 values to packed fp4, multiplying by the exponent part of `scale`
  before doing so and apply stochastic rounding. This op is for gfx1250+ arch.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.sr.pk8.fp4.f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, seed, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(seed)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def seed(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[2]

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cvt_scalef32_sr_pk8_fp4_f16(res, src, seed, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32SrPk8Fp4F16Op(res=res, src=src, seed=seed, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32SrPk8Fp4F32Op(_ods_ir.OpView):
  r"""
  Convert 8 packed f32 values to packed fp4, multiplying by the exponent part of `scale`
  before doing so and apply stochastic rounding. This op is for gfx1250+ arch.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.sr.pk8.fp4.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, seed, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(seed)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def seed(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[2]

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cvt_scalef32_sr_pk8_fp4_f32(res, src, seed, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32SrPk8Fp4F32Op(res=res, src=src, seed=seed, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32SrPk8Fp8Bf16Op(_ods_ir.OpView):
  r"""
  Convert 8 packed bf16 values to packed fp8, multiplying by the exponent part of `scale`
  before doing so and apply stochastic rounding. This op is for gfx1250+ arch.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.sr.pk8.fp8.bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, seed, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(seed)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def seed(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[2]

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_sr_pk8_fp8_bf16(res, src, seed, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32SrPk8Fp8Bf16Op(res=res, src=src, seed=seed, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32SrPk8Fp8F16Op(_ods_ir.OpView):
  r"""
  Convert 8 packed f16 values to packed fp8, multiplying by the exponent part of `scale`
  before doing so and apply stochastic rounding. This op is for gfx1250+ arch.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.sr.pk8.fp8.f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, seed, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(seed)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def seed(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[2]

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_sr_pk8_fp8_f16(res, src, seed, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32SrPk8Fp8F16Op(res=res, src=src, seed=seed, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32SrPk8Fp8F32Op(_ods_ir.OpView):
  r"""
  Convert 8 packed f32 values to packed fp8, multiplying by the exponent part of `scale`
  before doing so and apply stochastic rounding. This op is for gfx1250+ arch.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.sr.pk8.fp8.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, seed, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(seed)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def seed(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[2]

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_sr_pk8_fp8_f32(res, src, seed, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32SrPk8Fp8F32Op(res=res, src=src, seed=seed, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32SrPk16Bf6Bf16Op(_ods_ir.OpView):
  r"""
  Convert 8 packed bf16 values to packed bf6, multiplying by the exponent part of `scale`
  before doing so and apply stochastic rounding. This op is for gfx1250+ arch.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.sr.pk16.bf6.bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, seed, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(seed)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def seed(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[2]

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_sr_pk16_bf6_bf16(res, src, seed, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32SrPk16Bf6Bf16Op(res=res, src=src, seed=seed, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32SrPk16Bf6F16Op(_ods_ir.OpView):
  r"""
  Convert 8 packed f16 values to packed bf6, multiplying by the exponent part of `scale`
  before doing so and apply stochastic rounding. This op is for gfx1250+ arch.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.sr.pk16.bf6.f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, seed, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(seed)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def seed(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[2]

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_sr_pk16_bf6_f16(res, src, seed, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32SrPk16Bf6F16Op(res=res, src=src, seed=seed, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32SrPk16Bf6F32Op(_ods_ir.OpView):
  r"""
  Convert 8 packed f32 values to packed bf6, multiplying by the exponent part of `scale`
  before doing so and apply stochastic rounding. This op is for gfx1250+ arch.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.sr.pk16.bf6.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, seed, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(seed)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def seed(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[2]

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_sr_pk16_bf6_f32(res, src, seed, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32SrPk16Bf6F32Op(res=res, src=src, seed=seed, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32SrPk16Fp6Bf16Op(_ods_ir.OpView):
  r"""
  Convert 8 packed bf16 values to packed fp6, multiplying by the exponent part of `scale`
  before doing so and apply stochastic rounding. This op is for gfx1250+ arch.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.sr.pk16.fp6.bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, seed, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(seed)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def seed(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[2]

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_sr_pk16_fp6_bf16(res, src, seed, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32SrPk16Fp6Bf16Op(res=res, src=src, seed=seed, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32SrPk16Fp6F16Op(_ods_ir.OpView):
  r"""
  Convert 8 packed f16 values to packed fp6, multiplying by the exponent part of `scale`
  before doing so and apply stochastic rounding. This op is for gfx1250+ arch.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.sr.pk16.fp6.f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, seed, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(seed)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def seed(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[2]

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_sr_pk16_fp6_f16(res, src, seed, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32SrPk16Fp6F16Op(res=res, src=src, seed=seed, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32SrPk16Fp6F32Op(_ods_ir.OpView):
  r"""
  Convert 8 packed f32 values to packed fp6, multiplying by the exponent part of `scale`
  before doing so and apply stochastic rounding. This op is for gfx1250+ arch.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.sr.pk16.fp6.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, seed, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(seed)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def seed(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[2]

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_sr_pk16_fp6_f32(res, src, seed, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32SrPk16Fp6F32Op(res=res, src=src, seed=seed, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32SrPk32Bf6Bf16Op(_ods_ir.OpView):
  r"""
  Convert 32 packed bf16 values to packed bf6, dividing by the exponent part of `scale`
  before doing so and applying random rounding derived from
  `seed`.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.sr.pk32.bf6.bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, seed, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(seed)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def seed(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[2]

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_sr_pk32_bf6_bf16(res, src, seed, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32SrPk32Bf6Bf16Op(res=res, src=src, seed=seed, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32SrPk32Bf6F16Op(_ods_ir.OpView):
  r"""
  Convert 32 packed f16 values to packed bf6, dividing by the exponent part of `scale`
  before doing so and applying random rounding derived from
  `seed`.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.sr.pk32.bf6.f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, seed, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(seed)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def seed(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[2]

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_sr_pk32_bf6_f16(res, src, seed, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32SrPk32Bf6F16Op(res=res, src=src, seed=seed, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32SrPk32Bf6F32Op(_ods_ir.OpView):
  r"""
  Convert 32 packed f32 values to packed bf6, dividing by the exponent part of `scale`
  before doing so and applying random rounding derived from
  `seed`.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.sr.pk32.bf6.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, seed, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(seed)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def seed(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[2]

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_sr_pk32_bf6_f32(res, src, seed, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32SrPk32Bf6F32Op(res=res, src=src, seed=seed, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32SrPk32Fp6Bf16Op(_ods_ir.OpView):
  r"""
  Convert 32 packed bf16 values to packed fp6, dividing by the exponent part of `scale`
  before doing so and applying random rounding derived from
  `seed`.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.sr.pk32.fp6.bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, seed, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(seed)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def seed(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[2]

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_sr_pk32_fp6_bf16(res, src, seed, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32SrPk32Fp6Bf16Op(res=res, src=src, seed=seed, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32SrPk32Fp6F16Op(_ods_ir.OpView):
  r"""
  Convert 32 packed f16 values to packed fp6, dividing by the exponent part of `scale`
  before doing so and applying random rounding derived from
  `seed`.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.sr.pk32.fp6.f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, seed, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(seed)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def seed(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[2]

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_sr_pk32_fp6_f16(res, src, seed, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32SrPk32Fp6F16Op(res=res, src=src, seed=seed, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32SrPk32Fp6F32Op(_ods_ir.OpView):
  r"""
  Convert 32 packed f32 values to packed fp6, dividing by the exponent part of `scale`
  before doing so and applying random rounding derived from
  `seed`.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.sr.pk32.fp6.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, seed, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(seed)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def seed(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[2]

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_sr_pk32_fp6_f32(res, src, seed, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32SrPk32Fp6F32Op(res=res, src=src, seed=seed, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32SrPkFp4Bf16Op(_ods_ir.OpView):
  r"""
  Convert two packed bf16 values to packed
  fp4, dividing by the exponent part of `scale`
  before doing so and using `seed` as the random seed for
  stochiastic rounding.
  
  The two scaled values are packed (little-endian)
  into a byte. That byte is used to update the `dstSelIndex`th
  byte of `oldVdst`, which is returned in its entirity.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.sr.pk.fp4.bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, oldVdst, src, seed, scale, dstSelIndex, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(oldVdst)
    operands.append(src)
    operands.append(seed)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dstSelIndex"] = (dstSelIndex if (
    isinstance(dstSelIndex, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(dstSelIndex, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def oldVdst(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[1]

  @builtins.property
  def seed(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[2]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[3]

  @builtins.property
  def dstSelIndex(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["dstSelIndex"]

  @dstSelIndex.setter
  def dstSelIndex(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dstSelIndex"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cvt_scalef32_sr_pk_fp4_bf16(res, old_vdst, src, seed, scale, dst_sel_index, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32SrPkFp4Bf16Op(res=res, oldVdst=old_vdst, src=src, seed=seed, scale=scale, dstSelIndex=dst_sel_index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32SrPkFp4F16Op(_ods_ir.OpView):
  r"""
  Convert two packed f16 values to packed
  fp4, dividing by the exponent part of `scale`
  before doing so and using `seed` as the random seed for
  stochiastic rounding.
  
  The two scaled values are packed (little-endian)
  into a byte. That byte is used to update the `dstSelIndex`th
  byte of `oldVdst`, which is returned in its entirity.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.sr.pk.fp4.f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, oldVdst, src, seed, scale, dstSelIndex, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(oldVdst)
    operands.append(src)
    operands.append(seed)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dstSelIndex"] = (dstSelIndex if (
    isinstance(dstSelIndex, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(dstSelIndex, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def oldVdst(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[1]

  @builtins.property
  def seed(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[2]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[3]

  @builtins.property
  def dstSelIndex(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["dstSelIndex"]

  @dstSelIndex.setter
  def dstSelIndex(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dstSelIndex"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cvt_scalef32_sr_pk_fp4_f16(res, old_vdst, src, seed, scale, dst_sel_index, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32SrPkFp4F16Op(res=res, oldVdst=old_vdst, src=src, seed=seed, scale=scale, dstSelIndex=dst_sel_index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32SrPkFp4F32Op(_ods_ir.OpView):
  r"""
  Convert two packed f32 values to packed
  fp4, dividing by the exponent part of `scale`
  before doing so and using `seed` as the random seed for
  stochiastic rounding.
  
  The two scaled values are packed (little-endian)
  into a byte. That byte is used to update the `dstSelIndex`th
  byte of `oldVdst`, which is returned in its entirity.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.sr.pk.fp4.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, oldVdst, src, seed, scale, dstSelIndex, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(oldVdst)
    operands.append(src)
    operands.append(seed)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dstSelIndex"] = (dstSelIndex if (
    isinstance(dstSelIndex, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(dstSelIndex, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def oldVdst(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[1]

  @builtins.property
  def seed(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[2]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[3]

  @builtins.property
  def dstSelIndex(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["dstSelIndex"]

  @dstSelIndex.setter
  def dstSelIndex(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dstSelIndex"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cvt_scalef32_sr_pk_fp4_f32(res, old_vdst, src, seed, scale, dst_sel_index, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32SrPkFp4F32Op(res=res, oldVdst=old_vdst, src=src, seed=seed, scale=scale, dstSelIndex=dst_sel_index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF322xPk16Bf6F32Op(_ods_ir.OpView):
  r"""
  Convert 32 single-precision float values, packed into two length-16
  vectors that will be logically concanenated, to packed bf6, dividing by the exponent part of `scale`
  before doing so.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.2xpk16.bf6.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src0, src1, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src0)
    operands.append(src1)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src0(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def src1(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[2]

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_2xpk16_bf6_f32(res, src0, src1, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF322xPk16Bf6F32Op(res=res, src0=src0, src1=src1, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF322xPk16Fp6F32Op(_ods_ir.OpView):
  r"""
  Convert 32 single-precision float values, packed into two length-16
  vectors that will be logically concanenated, to packed fp6, dividing by the exponent part of `scale`
  before doing so.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.2xpk16.fp6.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src0, src1, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src0)
    operands.append(src1)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src0(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def src1(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[2]

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.VectorType]:
    return self.operation.results[0]

def cvt_scalef32_2xpk16_fp6_f32(res, src0, src1, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF322xPk16Fp6F32Op(res=res, src0=src0, src1=src1, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtSrBf8F32Op(_ods_ir.OpView):
  r"""
  Convert `srcA` to bf8, adding the rounding factor from `srcB`,
  and store into the `byteSel`th byte of `old`, preserving the others.
  """

  OPERATION_NAME = "rocdl.cvt.sr.bf8.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, srcA, srcB, old, byteSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(srcA)
    operands.append(srcB)
    operands.append(old)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["byteSel"] = (byteSel if (
    isinstance(byteSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(byteSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def srcA(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def srcB(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def old(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[2]

  @builtins.property
  def byteSel(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["byteSel"]

  @byteSel.setter
  def byteSel(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["byteSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_sr_bf8_f32(res, src_a, src_b, old, byte_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtSrBf8F32Op(res=res, srcA=src_a, srcB=src_b, old=old, byteSel=byte_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtSrFp8F32Op(_ods_ir.OpView):
  r"""
  Convert `srcA` to fp8, adding the rounding factor from `srcB`,
  and store into the `byteSel`th byte of `old`, preserving the others.
  """

  OPERATION_NAME = "rocdl.cvt.sr.fp8.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, srcA, srcB, old, byteSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(srcA)
    operands.append(srcB)
    operands.append(old)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["byteSel"] = (byteSel if (
    isinstance(byteSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(byteSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def srcA(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def srcB(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def old(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[2]

  @builtins.property
  def byteSel(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["byteSel"]

  @byteSel.setter
  def byteSel(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["byteSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_sr_fp8_f32(res, src_a, src_b, old, byte_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtSrFp8F32Op(res=res, srcA=src_a, srcB=src_b, old=old, byteSel=byte_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DPPUpdateOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.update.dpp"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, old, src, dppCtrl, rowMask, bankMask, boundCtrl, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(old)
    operands.append(src)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dppCtrl"] = (dppCtrl if (
    isinstance(dppCtrl, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(dppCtrl, context=_ods_context))
    attributes["rowMask"] = (rowMask if (
    isinstance(rowMask, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(rowMask, context=_ods_context))
    attributes["bankMask"] = (bankMask if (
    isinstance(bankMask, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(bankMask, context=_ods_context))
    attributes["boundCtrl"] = (boundCtrl if (
    isinstance(boundCtrl, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I1Attr')) else
      _ods_ir.AttrBuilder.get('I1Attr')(boundCtrl, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def old(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def dppCtrl(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["dppCtrl"]

  @dppCtrl.setter
  def dppCtrl(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dppCtrl"] = value

  @builtins.property
  def rowMask(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["rowMask"]

  @rowMask.setter
  def rowMask(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["rowMask"] = value

  @builtins.property
  def bankMask(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["bankMask"]

  @bankMask.setter
  def bankMask(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["bankMask"] = value

  @builtins.property
  def boundCtrl(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["boundCtrl"]

  @boundCtrl.setter
  def boundCtrl(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["boundCtrl"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def update_dpp(res, old, src, dpp_ctrl, row_mask, bank_mask, bound_ctrl, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return DPPUpdateOp(res=res, old=old, src=src, dppCtrl=dpp_ctrl, rowMask=row_mask, bankMask=bank_mask, boundCtrl=bound_ctrl, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DsAtomicAsyncBarrierArriveOp(_ods_ir.OpView):
  r"""
  Waits on a given DS barrier and decrements pending count by -1.
  Stays in order with ASYNC loads to LDS, and uses ASYNCcnt to track its completion.
  Available on gfx1250+.
  """

  OPERATION_NAME = "rocdl.ds.atomic.async.barrier.arrive.b64"

  _ODS_REGIONS = (0, True)

  def __init__(self, barrierPtr, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(barrierPtr)
    _ods_context = _ods_get_default_loc_context(loc)
    if alias_scopes is not None: attributes["alias_scopes"] = (alias_scopes if (
        isinstance(alias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(alias_scopes, context=_ods_context))
    if noalias_scopes is not None: attributes["noalias_scopes"] = (noalias_scopes if (
        isinstance(noalias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(noalias_scopes, context=_ods_context))
    if tbaa is not None: attributes["tbaa"] = (tbaa if (
        isinstance(tbaa, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_TBAATagArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_TBAATagArrayAttr')(tbaa, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def barrierPtr(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def alias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "alias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["alias_scopes"]

  @alias_scopes.setter
  def alias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["alias_scopes"] = value
    elif "alias_scopes" in self.operation.attributes:
      del self.operation.attributes["alias_scopes"]

  @alias_scopes.deleter
  def alias_scopes(self):
    del self.operation.attributes["alias_scopes"]

  @builtins.property
  def noalias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "noalias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["noalias_scopes"]

  @noalias_scopes.setter
  def noalias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["noalias_scopes"] = value
    elif "noalias_scopes" in self.operation.attributes:
      del self.operation.attributes["noalias_scopes"]

  @noalias_scopes.deleter
  def noalias_scopes(self):
    del self.operation.attributes["noalias_scopes"]

  @builtins.property
  def tbaa(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tbaa" not in self.operation.attributes:
      return None
    return self.operation.attributes["tbaa"]

  @tbaa.setter
  def tbaa(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tbaa"] = value
    elif "tbaa" in self.operation.attributes:
      del self.operation.attributes["tbaa"]

  @tbaa.deleter
  def tbaa(self):
    del self.operation.attributes["tbaa"]

def ds_atomic_async_barrier_arrive_b64(barrier_ptr, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None) -> DsAtomicAsyncBarrierArriveOp:
  return DsAtomicAsyncBarrierArriveOp(barrierPtr=barrier_ptr, alias_scopes=alias_scopes, noalias_scopes=noalias_scopes, tbaa=tbaa, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class DsAtomicBarrierArriveRtnOp(_ods_ir.OpView):
  r"""
  Waits on a given DS barrier and decrements its pending count by a given value. Note, the barrier state
  is given as a 64-bit structure containing pending count, phase and init count. The op returns the old
  barrier state. The op is executed as an ordinary LDS operations and it is ordered with other LDS operations.
  Thus, check DSCNT to determine when this instruction has executed.
  Available on gfx1250+.
  """

  OPERATION_NAME = "rocdl.ds.atomic.barrier.arrive.rtn.b64"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, barrierPtr, val, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(barrierPtr)
    operands.append(val)
    _ods_context = _ods_get_default_loc_context(loc)
    if alias_scopes is not None: attributes["alias_scopes"] = (alias_scopes if (
        isinstance(alias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(alias_scopes, context=_ods_context))
    if noalias_scopes is not None: attributes["noalias_scopes"] = (noalias_scopes if (
        isinstance(noalias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(noalias_scopes, context=_ods_context))
    if tbaa is not None: attributes["tbaa"] = (tbaa if (
        isinstance(tbaa, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_TBAATagArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_TBAATagArrayAttr')(tbaa, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def barrierPtr(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def val(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def alias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "alias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["alias_scopes"]

  @alias_scopes.setter
  def alias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["alias_scopes"] = value
    elif "alias_scopes" in self.operation.attributes:
      del self.operation.attributes["alias_scopes"]

  @alias_scopes.deleter
  def alias_scopes(self):
    del self.operation.attributes["alias_scopes"]

  @builtins.property
  def noalias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "noalias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["noalias_scopes"]

  @noalias_scopes.setter
  def noalias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["noalias_scopes"] = value
    elif "noalias_scopes" in self.operation.attributes:
      del self.operation.attributes["noalias_scopes"]

  @noalias_scopes.deleter
  def noalias_scopes(self):
    del self.operation.attributes["noalias_scopes"]

  @builtins.property
  def tbaa(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tbaa" not in self.operation.attributes:
      return None
    return self.operation.attributes["tbaa"]

  @tbaa.setter
  def tbaa(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tbaa"] = value
    elif "tbaa" in self.operation.attributes:
      del self.operation.attributes["tbaa"]

  @tbaa.deleter
  def tbaa(self):
    del self.operation.attributes["tbaa"]

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def ds_atomic_barrier_arrive_rtn_b64(res, barrier_ptr, val, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return DsAtomicBarrierArriveRtnOp(res=res, barrierPtr=barrier_ptr, val=val, alias_scopes=alias_scopes, noalias_scopes=noalias_scopes, tbaa=tbaa, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DsBpermuteOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.ds_bpermute"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, index, src, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(index)
    operands.append(src)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def index(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def ds_bpermute(res, index, src, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return DsBpermuteOp(res=res, index=index, src=src, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DsLoadTr4_B64(_ods_ir.OpView):
  r"""
  Load a matrix of 4-bit data from the ds memory,
  transpose data between row-major and column-major order,
  and store the result into a 64-bit vector register.
  
  Available in gfx1250+.
  """

  OPERATION_NAME = "rocdl.ds.load.tr4.b64"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, ptr, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(ptr)
    _ods_context = _ods_get_default_loc_context(loc)
    if alias_scopes is not None: attributes["alias_scopes"] = (alias_scopes if (
        isinstance(alias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(alias_scopes, context=_ods_context))
    if noalias_scopes is not None: attributes["noalias_scopes"] = (noalias_scopes if (
        isinstance(noalias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(noalias_scopes, context=_ods_context))
    if tbaa is not None: attributes["tbaa"] = (tbaa if (
        isinstance(tbaa, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_TBAATagArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_TBAATagArrayAttr')(tbaa, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def ptr(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def alias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "alias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["alias_scopes"]

  @alias_scopes.setter
  def alias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["alias_scopes"] = value
    elif "alias_scopes" in self.operation.attributes:
      del self.operation.attributes["alias_scopes"]

  @alias_scopes.deleter
  def alias_scopes(self):
    del self.operation.attributes["alias_scopes"]

  @builtins.property
  def noalias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "noalias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["noalias_scopes"]

  @noalias_scopes.setter
  def noalias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["noalias_scopes"] = value
    elif "noalias_scopes" in self.operation.attributes:
      del self.operation.attributes["noalias_scopes"]

  @noalias_scopes.deleter
  def noalias_scopes(self):
    del self.operation.attributes["noalias_scopes"]

  @builtins.property
  def tbaa(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tbaa" not in self.operation.attributes:
      return None
    return self.operation.attributes["tbaa"]

  @tbaa.setter
  def tbaa(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tbaa"] = value
    elif "tbaa" in self.operation.attributes:
      del self.operation.attributes["tbaa"]

  @tbaa.deleter
  def tbaa(self):
    del self.operation.attributes["tbaa"]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def ds_load_tr4_b64(res, ptr, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return DsLoadTr4_B64(res=res, ptr=ptr, alias_scopes=alias_scopes, noalias_scopes=noalias_scopes, tbaa=tbaa, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DsLoadTr6_B96(_ods_ir.OpView):
  r"""
  Load a matrix of 6-bit data from the ds memory,
  transpose data between row-major and column-major order,
  and store the result into a 96-bit vector register.
  
  Available in gfx1250+.
  """

  OPERATION_NAME = "rocdl.ds.load.tr6.b96"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, ptr, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(ptr)
    _ods_context = _ods_get_default_loc_context(loc)
    if alias_scopes is not None: attributes["alias_scopes"] = (alias_scopes if (
        isinstance(alias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(alias_scopes, context=_ods_context))
    if noalias_scopes is not None: attributes["noalias_scopes"] = (noalias_scopes if (
        isinstance(noalias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(noalias_scopes, context=_ods_context))
    if tbaa is not None: attributes["tbaa"] = (tbaa if (
        isinstance(tbaa, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_TBAATagArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_TBAATagArrayAttr')(tbaa, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def ptr(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def alias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "alias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["alias_scopes"]

  @alias_scopes.setter
  def alias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["alias_scopes"] = value
    elif "alias_scopes" in self.operation.attributes:
      del self.operation.attributes["alias_scopes"]

  @alias_scopes.deleter
  def alias_scopes(self):
    del self.operation.attributes["alias_scopes"]

  @builtins.property
  def noalias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "noalias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["noalias_scopes"]

  @noalias_scopes.setter
  def noalias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["noalias_scopes"] = value
    elif "noalias_scopes" in self.operation.attributes:
      del self.operation.attributes["noalias_scopes"]

  @noalias_scopes.deleter
  def noalias_scopes(self):
    del self.operation.attributes["noalias_scopes"]

  @builtins.property
  def tbaa(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tbaa" not in self.operation.attributes:
      return None
    return self.operation.attributes["tbaa"]

  @tbaa.setter
  def tbaa(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tbaa"] = value
    elif "tbaa" in self.operation.attributes:
      del self.operation.attributes["tbaa"]

  @tbaa.deleter
  def tbaa(self):
    del self.operation.attributes["tbaa"]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def ds_load_tr6_b96(res, ptr, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return DsLoadTr6_B96(res=res, ptr=ptr, alias_scopes=alias_scopes, noalias_scopes=noalias_scopes, tbaa=tbaa, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DsLoadTr8_B64(_ods_ir.OpView):
  r"""
  Load a matrix of 8-bit data from the ds memory,
  transpose data between row-major and column-major order,
  and store the result into a 64-bit vector register.
  
  Available in gfx1250+.
  """

  OPERATION_NAME = "rocdl.ds.load.tr8.b64"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, ptr, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(ptr)
    _ods_context = _ods_get_default_loc_context(loc)
    if alias_scopes is not None: attributes["alias_scopes"] = (alias_scopes if (
        isinstance(alias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(alias_scopes, context=_ods_context))
    if noalias_scopes is not None: attributes["noalias_scopes"] = (noalias_scopes if (
        isinstance(noalias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(noalias_scopes, context=_ods_context))
    if tbaa is not None: attributes["tbaa"] = (tbaa if (
        isinstance(tbaa, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_TBAATagArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_TBAATagArrayAttr')(tbaa, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def ptr(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def alias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "alias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["alias_scopes"]

  @alias_scopes.setter
  def alias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["alias_scopes"] = value
    elif "alias_scopes" in self.operation.attributes:
      del self.operation.attributes["alias_scopes"]

  @alias_scopes.deleter
  def alias_scopes(self):
    del self.operation.attributes["alias_scopes"]

  @builtins.property
  def noalias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "noalias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["noalias_scopes"]

  @noalias_scopes.setter
  def noalias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["noalias_scopes"] = value
    elif "noalias_scopes" in self.operation.attributes:
      del self.operation.attributes["noalias_scopes"]

  @noalias_scopes.deleter
  def noalias_scopes(self):
    del self.operation.attributes["noalias_scopes"]

  @builtins.property
  def tbaa(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tbaa" not in self.operation.attributes:
      return None
    return self.operation.attributes["tbaa"]

  @tbaa.setter
  def tbaa(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tbaa"] = value
    elif "tbaa" in self.operation.attributes:
      del self.operation.attributes["tbaa"]

  @tbaa.deleter
  def tbaa(self):
    del self.operation.attributes["tbaa"]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def ds_load_tr8_b64(res, ptr, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return DsLoadTr8_B64(res=res, ptr=ptr, alias_scopes=alias_scopes, noalias_scopes=noalias_scopes, tbaa=tbaa, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DsLoadTr16_B128(_ods_ir.OpView):
  r"""
  Load a matrix of 16-bit data from the ds memory,
  transpose data between row-major and column-major order,
  and store the result into a 128-bit vector register.
  
  Available in gfx1250+.
  """

  OPERATION_NAME = "rocdl.ds.load.tr16.b128"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, ptr, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(ptr)
    _ods_context = _ods_get_default_loc_context(loc)
    if alias_scopes is not None: attributes["alias_scopes"] = (alias_scopes if (
        isinstance(alias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(alias_scopes, context=_ods_context))
    if noalias_scopes is not None: attributes["noalias_scopes"] = (noalias_scopes if (
        isinstance(noalias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(noalias_scopes, context=_ods_context))
    if tbaa is not None: attributes["tbaa"] = (tbaa if (
        isinstance(tbaa, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_TBAATagArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_TBAATagArrayAttr')(tbaa, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def ptr(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def alias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "alias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["alias_scopes"]

  @alias_scopes.setter
  def alias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["alias_scopes"] = value
    elif "alias_scopes" in self.operation.attributes:
      del self.operation.attributes["alias_scopes"]

  @alias_scopes.deleter
  def alias_scopes(self):
    del self.operation.attributes["alias_scopes"]

  @builtins.property
  def noalias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "noalias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["noalias_scopes"]

  @noalias_scopes.setter
  def noalias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["noalias_scopes"] = value
    elif "noalias_scopes" in self.operation.attributes:
      del self.operation.attributes["noalias_scopes"]

  @noalias_scopes.deleter
  def noalias_scopes(self):
    del self.operation.attributes["noalias_scopes"]

  @builtins.property
  def tbaa(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tbaa" not in self.operation.attributes:
      return None
    return self.operation.attributes["tbaa"]

  @tbaa.setter
  def tbaa(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tbaa"] = value
    elif "tbaa" in self.operation.attributes:
      del self.operation.attributes["tbaa"]

  @tbaa.deleter
  def tbaa(self):
    del self.operation.attributes["tbaa"]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def ds_load_tr16_b128(res, ptr, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return DsLoadTr16_B128(res=res, ptr=ptr, alias_scopes=alias_scopes, noalias_scopes=noalias_scopes, tbaa=tbaa, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DsSwizzleOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.ds_swizzle"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, offset, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(offset)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def offset(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def ds_swizzle(res, src, offset, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return DsSwizzleOp(res=res, src=src, offset=offset, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FMed3Op(_ods_ir.OpView):
  r"""
  Computes the median of three floating-point values using the AMDGPU fmed3 intrinsic.
  This operation is equivalent to `max(min(a, b), min(max(a, b), c))` but uses the
  hardware-accelerated V_MED3_F16/V_MED3_F32 instruction for better performance.
  
  The operation supports both scalar and vector floating-point types (f16, f32).
  
  Example:
  ```mlir
  // Scalar f32 median
  %result = rocdl.fmed3 %a, %b, %c : f32
  
  // Vector f16 median
  %result = rocdl.fmed3 %va, %vb, %vc : vector<4xf16>
  ```
  """

  OPERATION_NAME = "rocdl.fmed3"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src0, src1, src2, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src0)
    operands.append(src1)
    operands.append(src2)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src0(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def src1(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def src2(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def fmed3(res, src0, src1, src2, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return FMed3Op(res=res, src0=src0, src1=src1, src2=src2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FlatPrefetchOp(_ods_ir.OpView):
  r"""
  Prefetches 1 byte of data per lane using flat-memory addresses into the WGP-cache or L2-cache.
  Available on gfx1250+.
  """

  OPERATION_NAME = "rocdl.flat.prefetch"

  _ODS_REGIONS = (0, True)

  def __init__(self, ptr, scope, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(ptr)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scope"] = (scope if (
    isinstance(scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(scope, context=_ods_context))
    if alias_scopes is not None: attributes["alias_scopes"] = (alias_scopes if (
        isinstance(alias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(alias_scopes, context=_ods_context))
    if noalias_scopes is not None: attributes["noalias_scopes"] = (noalias_scopes if (
        isinstance(noalias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(noalias_scopes, context=_ods_context))
    if tbaa is not None: attributes["tbaa"] = (tbaa if (
        isinstance(tbaa, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_TBAATagArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_TBAATagArrayAttr')(tbaa, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def ptr(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def scope(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["scope"]

  @scope.setter
  def scope(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scope"] = value

  @builtins.property
  def alias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "alias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["alias_scopes"]

  @alias_scopes.setter
  def alias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["alias_scopes"] = value
    elif "alias_scopes" in self.operation.attributes:
      del self.operation.attributes["alias_scopes"]

  @alias_scopes.deleter
  def alias_scopes(self):
    del self.operation.attributes["alias_scopes"]

  @builtins.property
  def noalias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "noalias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["noalias_scopes"]

  @noalias_scopes.setter
  def noalias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["noalias_scopes"] = value
    elif "noalias_scopes" in self.operation.attributes:
      del self.operation.attributes["noalias_scopes"]

  @noalias_scopes.deleter
  def noalias_scopes(self):
    del self.operation.attributes["noalias_scopes"]

  @builtins.property
  def tbaa(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tbaa" not in self.operation.attributes:
      return None
    return self.operation.attributes["tbaa"]

  @tbaa.setter
  def tbaa(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tbaa"] = value
    elif "tbaa" in self.operation.attributes:
      del self.operation.attributes["tbaa"]

  @tbaa.deleter
  def tbaa(self):
    del self.operation.attributes["tbaa"]

def flat_prefetch(ptr, scope, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None) -> FlatPrefetchOp:
  return FlatPrefetchOp(ptr=ptr, scope=scope, alias_scopes=alias_scopes, noalias_scopes=noalias_scopes, tbaa=tbaa, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GetBarrierStateOp(_ods_ir.OpView):
  r"""
  Available on gfx1250+.
  """

  OPERATION_NAME = "rocdl.s.get.barrier.state"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, id, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["id"] = (id if (
    isinstance(id, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(id, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def id(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["id"]

  @id.setter
  def id(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["id"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def s_get_barrier_state(res, id, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return GetBarrierStateOp(res=res, id=id, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GetNamedBarrierStateOp(_ods_ir.OpView):
  r"""
  Available on gfx1250+.
  """

  OPERATION_NAME = "rocdl.s.get.named.barrier.state"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, ptr, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(ptr)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def ptr(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def s_get_named_barrier_state(res, ptr, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return GetNamedBarrierStateOp(res=res, ptr=ptr, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GlobalLoadAsyncToLDSB8Op(_ods_ir.OpView):
  r"""
  Asynchronously loads 8 bits of data from a global memory pointer
  to a Local Data Share (LDS) pointer.
  
  Available on gfx1250+.
  """

  OPERATION_NAME = "rocdl.global.load.async.to.lds.b8"

  _ODS_REGIONS = (0, True)

  def __init__(self, globalPtr, ldsPtr, offset, aux, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(globalPtr)
    operands.append(ldsPtr)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["offset"] = (offset if (
    isinstance(offset, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(offset, context=_ods_context))
    attributes["aux"] = (aux if (
    isinstance(aux, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(aux, context=_ods_context))
    if alias_scopes is not None: attributes["alias_scopes"] = (alias_scopes if (
        isinstance(alias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(alias_scopes, context=_ods_context))
    if noalias_scopes is not None: attributes["noalias_scopes"] = (noalias_scopes if (
        isinstance(noalias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(noalias_scopes, context=_ods_context))
    if tbaa is not None: attributes["tbaa"] = (tbaa if (
        isinstance(tbaa, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_TBAATagArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_TBAATagArrayAttr')(tbaa, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def globalPtr(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def ldsPtr(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def offset(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["offset"]

  @offset.setter
  def offset(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["offset"] = value

  @builtins.property
  def aux(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["aux"]

  @aux.setter
  def aux(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["aux"] = value

  @builtins.property
  def alias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "alias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["alias_scopes"]

  @alias_scopes.setter
  def alias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["alias_scopes"] = value
    elif "alias_scopes" in self.operation.attributes:
      del self.operation.attributes["alias_scopes"]

  @alias_scopes.deleter
  def alias_scopes(self):
    del self.operation.attributes["alias_scopes"]

  @builtins.property
  def noalias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "noalias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["noalias_scopes"]

  @noalias_scopes.setter
  def noalias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["noalias_scopes"] = value
    elif "noalias_scopes" in self.operation.attributes:
      del self.operation.attributes["noalias_scopes"]

  @noalias_scopes.deleter
  def noalias_scopes(self):
    del self.operation.attributes["noalias_scopes"]

  @builtins.property
  def tbaa(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tbaa" not in self.operation.attributes:
      return None
    return self.operation.attributes["tbaa"]

  @tbaa.setter
  def tbaa(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tbaa"] = value
    elif "tbaa" in self.operation.attributes:
      del self.operation.attributes["tbaa"]

  @tbaa.deleter
  def tbaa(self):
    del self.operation.attributes["tbaa"]

def global_load_async_to_lds_b8(global_ptr, lds_ptr, offset, aux, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None) -> GlobalLoadAsyncToLDSB8Op:
  return GlobalLoadAsyncToLDSB8Op(globalPtr=global_ptr, ldsPtr=lds_ptr, offset=offset, aux=aux, alias_scopes=alias_scopes, noalias_scopes=noalias_scopes, tbaa=tbaa, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GlobalLoadAsyncToLDSB32Op(_ods_ir.OpView):
  r"""
  Asynchronously loads 32 bits of data from a global memory pointer
  to a Local Data Share (LDS) pointer.
  
  Available on gfx1250+.
  """

  OPERATION_NAME = "rocdl.global.load.async.to.lds.b32"

  _ODS_REGIONS = (0, True)

  def __init__(self, globalPtr, ldsPtr, offset, aux, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(globalPtr)
    operands.append(ldsPtr)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["offset"] = (offset if (
    isinstance(offset, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(offset, context=_ods_context))
    attributes["aux"] = (aux if (
    isinstance(aux, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(aux, context=_ods_context))
    if alias_scopes is not None: attributes["alias_scopes"] = (alias_scopes if (
        isinstance(alias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(alias_scopes, context=_ods_context))
    if noalias_scopes is not None: attributes["noalias_scopes"] = (noalias_scopes if (
        isinstance(noalias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(noalias_scopes, context=_ods_context))
    if tbaa is not None: attributes["tbaa"] = (tbaa if (
        isinstance(tbaa, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_TBAATagArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_TBAATagArrayAttr')(tbaa, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def globalPtr(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def ldsPtr(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def offset(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["offset"]

  @offset.setter
  def offset(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["offset"] = value

  @builtins.property
  def aux(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["aux"]

  @aux.setter
  def aux(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["aux"] = value

  @builtins.property
  def alias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "alias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["alias_scopes"]

  @alias_scopes.setter
  def alias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["alias_scopes"] = value
    elif "alias_scopes" in self.operation.attributes:
      del self.operation.attributes["alias_scopes"]

  @alias_scopes.deleter
  def alias_scopes(self):
    del self.operation.attributes["alias_scopes"]

  @builtins.property
  def noalias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "noalias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["noalias_scopes"]

  @noalias_scopes.setter
  def noalias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["noalias_scopes"] = value
    elif "noalias_scopes" in self.operation.attributes:
      del self.operation.attributes["noalias_scopes"]

  @noalias_scopes.deleter
  def noalias_scopes(self):
    del self.operation.attributes["noalias_scopes"]

  @builtins.property
  def tbaa(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tbaa" not in self.operation.attributes:
      return None
    return self.operation.attributes["tbaa"]

  @tbaa.setter
  def tbaa(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tbaa"] = value
    elif "tbaa" in self.operation.attributes:
      del self.operation.attributes["tbaa"]

  @tbaa.deleter
  def tbaa(self):
    del self.operation.attributes["tbaa"]

def global_load_async_to_lds_b32(global_ptr, lds_ptr, offset, aux, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None) -> GlobalLoadAsyncToLDSB32Op:
  return GlobalLoadAsyncToLDSB32Op(globalPtr=global_ptr, ldsPtr=lds_ptr, offset=offset, aux=aux, alias_scopes=alias_scopes, noalias_scopes=noalias_scopes, tbaa=tbaa, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GlobalLoadAsyncToLDSB64Op(_ods_ir.OpView):
  r"""
  Asynchronously loads 64 bits of data from a global memory pointer
  to a Local Data Share (LDS) pointer.
  
  Available on gfx1250+.
  """

  OPERATION_NAME = "rocdl.global.load.async.to.lds.b64"

  _ODS_REGIONS = (0, True)

  def __init__(self, globalPtr, ldsPtr, offset, aux, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(globalPtr)
    operands.append(ldsPtr)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["offset"] = (offset if (
    isinstance(offset, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(offset, context=_ods_context))
    attributes["aux"] = (aux if (
    isinstance(aux, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(aux, context=_ods_context))
    if alias_scopes is not None: attributes["alias_scopes"] = (alias_scopes if (
        isinstance(alias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(alias_scopes, context=_ods_context))
    if noalias_scopes is not None: attributes["noalias_scopes"] = (noalias_scopes if (
        isinstance(noalias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(noalias_scopes, context=_ods_context))
    if tbaa is not None: attributes["tbaa"] = (tbaa if (
        isinstance(tbaa, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_TBAATagArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_TBAATagArrayAttr')(tbaa, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def globalPtr(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def ldsPtr(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def offset(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["offset"]

  @offset.setter
  def offset(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["offset"] = value

  @builtins.property
  def aux(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["aux"]

  @aux.setter
  def aux(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["aux"] = value

  @builtins.property
  def alias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "alias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["alias_scopes"]

  @alias_scopes.setter
  def alias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["alias_scopes"] = value
    elif "alias_scopes" in self.operation.attributes:
      del self.operation.attributes["alias_scopes"]

  @alias_scopes.deleter
  def alias_scopes(self):
    del self.operation.attributes["alias_scopes"]

  @builtins.property
  def noalias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "noalias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["noalias_scopes"]

  @noalias_scopes.setter
  def noalias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["noalias_scopes"] = value
    elif "noalias_scopes" in self.operation.attributes:
      del self.operation.attributes["noalias_scopes"]

  @noalias_scopes.deleter
  def noalias_scopes(self):
    del self.operation.attributes["noalias_scopes"]

  @builtins.property
  def tbaa(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tbaa" not in self.operation.attributes:
      return None
    return self.operation.attributes["tbaa"]

  @tbaa.setter
  def tbaa(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tbaa"] = value
    elif "tbaa" in self.operation.attributes:
      del self.operation.attributes["tbaa"]

  @tbaa.deleter
  def tbaa(self):
    del self.operation.attributes["tbaa"]

def global_load_async_to_lds_b64(global_ptr, lds_ptr, offset, aux, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None) -> GlobalLoadAsyncToLDSB64Op:
  return GlobalLoadAsyncToLDSB64Op(globalPtr=global_ptr, ldsPtr=lds_ptr, offset=offset, aux=aux, alias_scopes=alias_scopes, noalias_scopes=noalias_scopes, tbaa=tbaa, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GlobalLoadAsyncToLDSB128Op(_ods_ir.OpView):
  r"""
  Asynchronously loads 128 bits of data from a global memory pointer
  to a Local Data Share (LDS) pointer.
  
  Available on gfx1250+.
  """

  OPERATION_NAME = "rocdl.global.load.async.to.lds.b128"

  _ODS_REGIONS = (0, True)

  def __init__(self, globalPtr, ldsPtr, offset, aux, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(globalPtr)
    operands.append(ldsPtr)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["offset"] = (offset if (
    isinstance(offset, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(offset, context=_ods_context))
    attributes["aux"] = (aux if (
    isinstance(aux, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(aux, context=_ods_context))
    if alias_scopes is not None: attributes["alias_scopes"] = (alias_scopes if (
        isinstance(alias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(alias_scopes, context=_ods_context))
    if noalias_scopes is not None: attributes["noalias_scopes"] = (noalias_scopes if (
        isinstance(noalias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(noalias_scopes, context=_ods_context))
    if tbaa is not None: attributes["tbaa"] = (tbaa if (
        isinstance(tbaa, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_TBAATagArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_TBAATagArrayAttr')(tbaa, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def globalPtr(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def ldsPtr(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def offset(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["offset"]

  @offset.setter
  def offset(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["offset"] = value

  @builtins.property
  def aux(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["aux"]

  @aux.setter
  def aux(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["aux"] = value

  @builtins.property
  def alias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "alias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["alias_scopes"]

  @alias_scopes.setter
  def alias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["alias_scopes"] = value
    elif "alias_scopes" in self.operation.attributes:
      del self.operation.attributes["alias_scopes"]

  @alias_scopes.deleter
  def alias_scopes(self):
    del self.operation.attributes["alias_scopes"]

  @builtins.property
  def noalias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "noalias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["noalias_scopes"]

  @noalias_scopes.setter
  def noalias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["noalias_scopes"] = value
    elif "noalias_scopes" in self.operation.attributes:
      del self.operation.attributes["noalias_scopes"]

  @noalias_scopes.deleter
  def noalias_scopes(self):
    del self.operation.attributes["noalias_scopes"]

  @builtins.property
  def tbaa(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tbaa" not in self.operation.attributes:
      return None
    return self.operation.attributes["tbaa"]

  @tbaa.setter
  def tbaa(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tbaa"] = value
    elif "tbaa" in self.operation.attributes:
      del self.operation.attributes["tbaa"]

  @tbaa.deleter
  def tbaa(self):
    del self.operation.attributes["tbaa"]

def global_load_async_to_lds_b128(global_ptr, lds_ptr, offset, aux, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None) -> GlobalLoadAsyncToLDSB128Op:
  return GlobalLoadAsyncToLDSB128Op(globalPtr=global_ptr, ldsPtr=lds_ptr, offset=offset, aux=aux, alias_scopes=alias_scopes, noalias_scopes=noalias_scopes, tbaa=tbaa, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GlobalLoadLDSOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.global.load.lds"

  _ODS_REGIONS = (0, True)

  def __init__(self, globalPtr, ldsPtr, size, offset, aux, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(globalPtr)
    operands.append(ldsPtr)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["size"] = (size if (
    isinstance(size, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(size, context=_ods_context))
    attributes["offset"] = (offset if (
    isinstance(offset, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(offset, context=_ods_context))
    attributes["aux"] = (aux if (
    isinstance(aux, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(aux, context=_ods_context))
    if alias_scopes is not None: attributes["alias_scopes"] = (alias_scopes if (
        isinstance(alias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(alias_scopes, context=_ods_context))
    if noalias_scopes is not None: attributes["noalias_scopes"] = (noalias_scopes if (
        isinstance(noalias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(noalias_scopes, context=_ods_context))
    if tbaa is not None: attributes["tbaa"] = (tbaa if (
        isinstance(tbaa, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_TBAATagArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_TBAATagArrayAttr')(tbaa, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def globalPtr(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def ldsPtr(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def size(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["size"]

  @size.setter
  def size(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["size"] = value

  @builtins.property
  def offset(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["offset"]

  @offset.setter
  def offset(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["offset"] = value

  @builtins.property
  def aux(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["aux"]

  @aux.setter
  def aux(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["aux"] = value

  @builtins.property
  def alias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "alias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["alias_scopes"]

  @alias_scopes.setter
  def alias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["alias_scopes"] = value
    elif "alias_scopes" in self.operation.attributes:
      del self.operation.attributes["alias_scopes"]

  @alias_scopes.deleter
  def alias_scopes(self):
    del self.operation.attributes["alias_scopes"]

  @builtins.property
  def noalias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "noalias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["noalias_scopes"]

  @noalias_scopes.setter
  def noalias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["noalias_scopes"] = value
    elif "noalias_scopes" in self.operation.attributes:
      del self.operation.attributes["noalias_scopes"]

  @noalias_scopes.deleter
  def noalias_scopes(self):
    del self.operation.attributes["noalias_scopes"]

  @builtins.property
  def tbaa(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tbaa" not in self.operation.attributes:
      return None
    return self.operation.attributes["tbaa"]

  @tbaa.setter
  def tbaa(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tbaa"] = value
    elif "tbaa" in self.operation.attributes:
      del self.operation.attributes["tbaa"]

  @tbaa.deleter
  def tbaa(self):
    del self.operation.attributes["tbaa"]

def global_load_lds(global_ptr, lds_ptr, size, offset, aux, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None) -> GlobalLoadLDSOp:
  return GlobalLoadLDSOp(globalPtr=global_ptr, ldsPtr=lds_ptr, size=size, offset=offset, aux=aux, alias_scopes=alias_scopes, noalias_scopes=noalias_scopes, tbaa=tbaa, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GlobalLoadTr4_B64(_ods_ir.OpView):
  r"""
  Load a matrix of 4-bit data from the global memory,
  transpose data between row-major and column-major order,
  and store the result into a 64-bit vector register.
  
  Available in gfx1250+.
  """

  OPERATION_NAME = "rocdl.global.load.tr4.b64"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, ptr, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(ptr)
    _ods_context = _ods_get_default_loc_context(loc)
    if alias_scopes is not None: attributes["alias_scopes"] = (alias_scopes if (
        isinstance(alias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(alias_scopes, context=_ods_context))
    if noalias_scopes is not None: attributes["noalias_scopes"] = (noalias_scopes if (
        isinstance(noalias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(noalias_scopes, context=_ods_context))
    if tbaa is not None: attributes["tbaa"] = (tbaa if (
        isinstance(tbaa, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_TBAATagArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_TBAATagArrayAttr')(tbaa, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def ptr(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def alias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "alias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["alias_scopes"]

  @alias_scopes.setter
  def alias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["alias_scopes"] = value
    elif "alias_scopes" in self.operation.attributes:
      del self.operation.attributes["alias_scopes"]

  @alias_scopes.deleter
  def alias_scopes(self):
    del self.operation.attributes["alias_scopes"]

  @builtins.property
  def noalias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "noalias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["noalias_scopes"]

  @noalias_scopes.setter
  def noalias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["noalias_scopes"] = value
    elif "noalias_scopes" in self.operation.attributes:
      del self.operation.attributes["noalias_scopes"]

  @noalias_scopes.deleter
  def noalias_scopes(self):
    del self.operation.attributes["noalias_scopes"]

  @builtins.property
  def tbaa(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tbaa" not in self.operation.attributes:
      return None
    return self.operation.attributes["tbaa"]

  @tbaa.setter
  def tbaa(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tbaa"] = value
    elif "tbaa" in self.operation.attributes:
      del self.operation.attributes["tbaa"]

  @tbaa.deleter
  def tbaa(self):
    del self.operation.attributes["tbaa"]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def global_load_tr4_b64(res, ptr, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GlobalLoadTr4_B64(res=res, ptr=ptr, alias_scopes=alias_scopes, noalias_scopes=noalias_scopes, tbaa=tbaa, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GlobalLoadTr6_B96(_ods_ir.OpView):
  r"""
  Load a matrix of 6-bit data from the global memory,
  transpose data between row-major and column-major order,
  and store the result into a 96-bit vector register.
  
  Available in gfx1250+.
  """

  OPERATION_NAME = "rocdl.global.load.tr6.b96"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, ptr, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(ptr)
    _ods_context = _ods_get_default_loc_context(loc)
    if alias_scopes is not None: attributes["alias_scopes"] = (alias_scopes if (
        isinstance(alias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(alias_scopes, context=_ods_context))
    if noalias_scopes is not None: attributes["noalias_scopes"] = (noalias_scopes if (
        isinstance(noalias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(noalias_scopes, context=_ods_context))
    if tbaa is not None: attributes["tbaa"] = (tbaa if (
        isinstance(tbaa, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_TBAATagArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_TBAATagArrayAttr')(tbaa, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def ptr(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def alias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "alias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["alias_scopes"]

  @alias_scopes.setter
  def alias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["alias_scopes"] = value
    elif "alias_scopes" in self.operation.attributes:
      del self.operation.attributes["alias_scopes"]

  @alias_scopes.deleter
  def alias_scopes(self):
    del self.operation.attributes["alias_scopes"]

  @builtins.property
  def noalias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "noalias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["noalias_scopes"]

  @noalias_scopes.setter
  def noalias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["noalias_scopes"] = value
    elif "noalias_scopes" in self.operation.attributes:
      del self.operation.attributes["noalias_scopes"]

  @noalias_scopes.deleter
  def noalias_scopes(self):
    del self.operation.attributes["noalias_scopes"]

  @builtins.property
  def tbaa(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tbaa" not in self.operation.attributes:
      return None
    return self.operation.attributes["tbaa"]

  @tbaa.setter
  def tbaa(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tbaa"] = value
    elif "tbaa" in self.operation.attributes:
      del self.operation.attributes["tbaa"]

  @tbaa.deleter
  def tbaa(self):
    del self.operation.attributes["tbaa"]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def global_load_tr6_b96(res, ptr, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GlobalLoadTr6_B96(res=res, ptr=ptr, alias_scopes=alias_scopes, noalias_scopes=noalias_scopes, tbaa=tbaa, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GlobalLoadTr8_B64(_ods_ir.OpView):
  r"""
  Load a matrix of 8-bit data from the global memory,
  transpose data between row-major and column-major order,
  and store the result into a 64-bit vector register.
  
  Available in gfx1250+.
  """

  OPERATION_NAME = "rocdl.global.load.tr.b64"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, ptr, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(ptr)
    _ods_context = _ods_get_default_loc_context(loc)
    if alias_scopes is not None: attributes["alias_scopes"] = (alias_scopes if (
        isinstance(alias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(alias_scopes, context=_ods_context))
    if noalias_scopes is not None: attributes["noalias_scopes"] = (noalias_scopes if (
        isinstance(noalias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(noalias_scopes, context=_ods_context))
    if tbaa is not None: attributes["tbaa"] = (tbaa if (
        isinstance(tbaa, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_TBAATagArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_TBAATagArrayAttr')(tbaa, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def ptr(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def alias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "alias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["alias_scopes"]

  @alias_scopes.setter
  def alias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["alias_scopes"] = value
    elif "alias_scopes" in self.operation.attributes:
      del self.operation.attributes["alias_scopes"]

  @alias_scopes.deleter
  def alias_scopes(self):
    del self.operation.attributes["alias_scopes"]

  @builtins.property
  def noalias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "noalias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["noalias_scopes"]

  @noalias_scopes.setter
  def noalias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["noalias_scopes"] = value
    elif "noalias_scopes" in self.operation.attributes:
      del self.operation.attributes["noalias_scopes"]

  @noalias_scopes.deleter
  def noalias_scopes(self):
    del self.operation.attributes["noalias_scopes"]

  @builtins.property
  def tbaa(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tbaa" not in self.operation.attributes:
      return None
    return self.operation.attributes["tbaa"]

  @tbaa.setter
  def tbaa(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tbaa"] = value
    elif "tbaa" in self.operation.attributes:
      del self.operation.attributes["tbaa"]

  @tbaa.deleter
  def tbaa(self):
    del self.operation.attributes["tbaa"]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def global_load_tr_b64(res, ptr, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GlobalLoadTr8_B64(res=res, ptr=ptr, alias_scopes=alias_scopes, noalias_scopes=noalias_scopes, tbaa=tbaa, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GlobalLoadTr8_B128(_ods_ir.OpView):
  r"""
  Load a matrix of 16-bit data from the global memory,
  transpose data between row-major and column-major order,
  and store the result into a 128-bit vector register.
  
  Available in gfx1250+.
  """

  OPERATION_NAME = "rocdl.global.load.tr.b128"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, ptr, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(ptr)
    _ods_context = _ods_get_default_loc_context(loc)
    if alias_scopes is not None: attributes["alias_scopes"] = (alias_scopes if (
        isinstance(alias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(alias_scopes, context=_ods_context))
    if noalias_scopes is not None: attributes["noalias_scopes"] = (noalias_scopes if (
        isinstance(noalias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(noalias_scopes, context=_ods_context))
    if tbaa is not None: attributes["tbaa"] = (tbaa if (
        isinstance(tbaa, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_TBAATagArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_TBAATagArrayAttr')(tbaa, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def ptr(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def alias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "alias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["alias_scopes"]

  @alias_scopes.setter
  def alias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["alias_scopes"] = value
    elif "alias_scopes" in self.operation.attributes:
      del self.operation.attributes["alias_scopes"]

  @alias_scopes.deleter
  def alias_scopes(self):
    del self.operation.attributes["alias_scopes"]

  @builtins.property
  def noalias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "noalias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["noalias_scopes"]

  @noalias_scopes.setter
  def noalias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["noalias_scopes"] = value
    elif "noalias_scopes" in self.operation.attributes:
      del self.operation.attributes["noalias_scopes"]

  @noalias_scopes.deleter
  def noalias_scopes(self):
    del self.operation.attributes["noalias_scopes"]

  @builtins.property
  def tbaa(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tbaa" not in self.operation.attributes:
      return None
    return self.operation.attributes["tbaa"]

  @tbaa.setter
  def tbaa(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tbaa"] = value
    elif "tbaa" in self.operation.attributes:
      del self.operation.attributes["tbaa"]

  @tbaa.deleter
  def tbaa(self):
    del self.operation.attributes["tbaa"]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def global_load_tr_b128(res, ptr, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GlobalLoadTr8_B128(res=res, ptr=ptr, alias_scopes=alias_scopes, noalias_scopes=noalias_scopes, tbaa=tbaa, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GlobalPrefetchOp(_ods_ir.OpView):
  r"""
  Prefetches 1 byte of data per lane from global memory into the WGP-cache or L2-cache.
  Available on gfx1250+.
  """

  OPERATION_NAME = "rocdl.global.prefetch"

  _ODS_REGIONS = (0, True)

  def __init__(self, ptr, scope, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(ptr)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scope"] = (scope if (
    isinstance(scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(scope, context=_ods_context))
    if alias_scopes is not None: attributes["alias_scopes"] = (alias_scopes if (
        isinstance(alias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(alias_scopes, context=_ods_context))
    if noalias_scopes is not None: attributes["noalias_scopes"] = (noalias_scopes if (
        isinstance(noalias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(noalias_scopes, context=_ods_context))
    if tbaa is not None: attributes["tbaa"] = (tbaa if (
        isinstance(tbaa, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_TBAATagArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_TBAATagArrayAttr')(tbaa, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def ptr(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def scope(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["scope"]

  @scope.setter
  def scope(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scope"] = value

  @builtins.property
  def alias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "alias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["alias_scopes"]

  @alias_scopes.setter
  def alias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["alias_scopes"] = value
    elif "alias_scopes" in self.operation.attributes:
      del self.operation.attributes["alias_scopes"]

  @alias_scopes.deleter
  def alias_scopes(self):
    del self.operation.attributes["alias_scopes"]

  @builtins.property
  def noalias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "noalias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["noalias_scopes"]

  @noalias_scopes.setter
  def noalias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["noalias_scopes"] = value
    elif "noalias_scopes" in self.operation.attributes:
      del self.operation.attributes["noalias_scopes"]

  @noalias_scopes.deleter
  def noalias_scopes(self):
    del self.operation.attributes["noalias_scopes"]

  @builtins.property
  def tbaa(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tbaa" not in self.operation.attributes:
      return None
    return self.operation.attributes["tbaa"]

  @tbaa.setter
  def tbaa(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tbaa"] = value
    elif "tbaa" in self.operation.attributes:
      del self.operation.attributes["tbaa"]

  @tbaa.deleter
  def tbaa(self):
    del self.operation.attributes["tbaa"]

def global_prefetch(ptr, scope, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None) -> GlobalPrefetchOp:
  return GlobalPrefetchOp(ptr=ptr, scope=scope, alias_scopes=alias_scopes, noalias_scopes=noalias_scopes, tbaa=tbaa, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GridDimXOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.grid.dim.x"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, *, range=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if range is not None: attributes["range"] = (range if (
        isinstance(range, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_ConstantRangeAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_ConstantRangeAttr')(range, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def range(self) -> _Optional[_ods_ir.Attribute]:
    if "range" not in self.operation.attributes:
      return None
    return self.operation.attributes["range"]

  @range.setter
  def range(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["range"] = value
    elif "range" in self.operation.attributes:
      del self.operation.attributes["range"]

  @range.deleter
  def range(self):
    del self.operation.attributes["range"]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def grid_dim_x(res, *, range=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GridDimXOp(res=res, range=range, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GridDimYOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.grid.dim.y"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, *, range=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if range is not None: attributes["range"] = (range if (
        isinstance(range, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_ConstantRangeAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_ConstantRangeAttr')(range, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def range(self) -> _Optional[_ods_ir.Attribute]:
    if "range" not in self.operation.attributes:
      return None
    return self.operation.attributes["range"]

  @range.setter
  def range(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["range"] = value
    elif "range" in self.operation.attributes:
      del self.operation.attributes["range"]

  @range.deleter
  def range(self):
    del self.operation.attributes["range"]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def grid_dim_y(res, *, range=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GridDimYOp(res=res, range=range, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GridDimZOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.grid.dim.z"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, *, range=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if range is not None: attributes["range"] = (range if (
        isinstance(range, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_ConstantRangeAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_ConstantRangeAttr')(range, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def range(self) -> _Optional[_ods_ir.Attribute]:
    if "range" not in self.operation.attributes:
      return None
    return self.operation.attributes["range"]

  @range.setter
  def range(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["range"] = value
    elif "range" in self.operation.attributes:
      del self.operation.attributes["range"]

  @range.deleter
  def range(self):
    del self.operation.attributes["range"]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def grid_dim_z(res, *, range=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GridDimZOp(res=res, range=range, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class IglpOpt(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.iglp.opt"

  _ODS_REGIONS = (0, True)

  def __init__(self, variant, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["variant"] = (variant if (
    isinstance(variant, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(variant, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def variant(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["variant"]

  @variant.setter
  def variant(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["variant"] = value

def iglp_opt(variant, *, loc=None, ip=None) -> IglpOpt:
  return IglpOpt(variant=variant, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class LoadToLDSOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.load.to.lds"

  _ODS_REGIONS = (0, True)

  def __init__(self, globalPtr, ldsPtr, size, offset, aux, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(globalPtr)
    operands.append(ldsPtr)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["size"] = (size if (
    isinstance(size, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(size, context=_ods_context))
    attributes["offset"] = (offset if (
    isinstance(offset, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(offset, context=_ods_context))
    attributes["aux"] = (aux if (
    isinstance(aux, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(aux, context=_ods_context))
    if alias_scopes is not None: attributes["alias_scopes"] = (alias_scopes if (
        isinstance(alias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(alias_scopes, context=_ods_context))
    if noalias_scopes is not None: attributes["noalias_scopes"] = (noalias_scopes if (
        isinstance(noalias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(noalias_scopes, context=_ods_context))
    if tbaa is not None: attributes["tbaa"] = (tbaa if (
        isinstance(tbaa, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_TBAATagArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_TBAATagArrayAttr')(tbaa, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def globalPtr(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def ldsPtr(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def size(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["size"]

  @size.setter
  def size(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["size"] = value

  @builtins.property
  def offset(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["offset"]

  @offset.setter
  def offset(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["offset"] = value

  @builtins.property
  def aux(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["aux"]

  @aux.setter
  def aux(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["aux"] = value

  @builtins.property
  def alias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "alias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["alias_scopes"]

  @alias_scopes.setter
  def alias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["alias_scopes"] = value
    elif "alias_scopes" in self.operation.attributes:
      del self.operation.attributes["alias_scopes"]

  @alias_scopes.deleter
  def alias_scopes(self):
    del self.operation.attributes["alias_scopes"]

  @builtins.property
  def noalias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "noalias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["noalias_scopes"]

  @noalias_scopes.setter
  def noalias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["noalias_scopes"] = value
    elif "noalias_scopes" in self.operation.attributes:
      del self.operation.attributes["noalias_scopes"]

  @noalias_scopes.deleter
  def noalias_scopes(self):
    del self.operation.attributes["noalias_scopes"]

  @builtins.property
  def tbaa(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tbaa" not in self.operation.attributes:
      return None
    return self.operation.attributes["tbaa"]

  @tbaa.setter
  def tbaa(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tbaa"] = value
    elif "tbaa" in self.operation.attributes:
      del self.operation.attributes["tbaa"]

  @tbaa.deleter
  def tbaa(self):
    del self.operation.attributes["tbaa"]

def load_to_lds(global_ptr, lds_ptr, size, offset, aux, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None) -> LoadToLDSOp:
  return LoadToLDSOp(globalPtr=global_ptr, ldsPtr=lds_ptr, size=size, offset=offset, aux=aux, alias_scopes=alias_scopes, noalias_scopes=noalias_scopes, tbaa=tbaa, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class MakeBufferRsrcOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.make.buffer.rsrc"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, base, stride, numRecords, flags, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(base)
    operands.append(stride)
    operands.append(numRecords)
    operands.append(flags)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def base(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def stride(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def numRecords(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[2]

  @builtins.property
  def flags(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[3]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def make_buffer_rsrc(res, base, stride, num_records, flags, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return MakeBufferRsrcOp(res=res, base=base, stride=stride, numRecords=num_records, flags=flags, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MbcntHiOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mbcnt.hi"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, in0, in1, *, arg_attrs=None, res_attrs=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(in0)
    operands.append(in1)
    _ods_context = _ods_get_default_loc_context(loc)
    if arg_attrs is not None: attributes["arg_attrs"] = (arg_attrs if (
        isinstance(arg_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(arg_attrs, context=_ods_context))
    if res_attrs is not None: attributes["res_attrs"] = (res_attrs if (
        isinstance(res_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(res_attrs, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def in0(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def in1(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def arg_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "arg_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["arg_attrs"]

  @arg_attrs.setter
  def arg_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["arg_attrs"] = value
    elif "arg_attrs" in self.operation.attributes:
      del self.operation.attributes["arg_attrs"]

  @arg_attrs.deleter
  def arg_attrs(self):
    del self.operation.attributes["arg_attrs"]

  @builtins.property
  def res_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "res_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["res_attrs"]

  @res_attrs.setter
  def res_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["res_attrs"] = value
    elif "res_attrs" in self.operation.attributes:
      del self.operation.attributes["res_attrs"]

  @res_attrs.deleter
  def res_attrs(self):
    del self.operation.attributes["res_attrs"]

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def mbcnt_hi(res, in0, in1, *, arg_attrs=None, res_attrs=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MbcntHiOp(res=res, in0=in0, in1=in1, arg_attrs=arg_attrs, res_attrs=res_attrs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MbcntLoOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mbcnt.lo"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, in0, in1, *, arg_attrs=None, res_attrs=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(in0)
    operands.append(in1)
    _ods_context = _ods_get_default_loc_context(loc)
    if arg_attrs is not None: attributes["arg_attrs"] = (arg_attrs if (
        isinstance(arg_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(arg_attrs, context=_ods_context))
    if res_attrs is not None: attributes["res_attrs"] = (res_attrs if (
        isinstance(res_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(res_attrs, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def in0(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def in1(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def arg_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "arg_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["arg_attrs"]

  @arg_attrs.setter
  def arg_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["arg_attrs"] = value
    elif "arg_attrs" in self.operation.attributes:
      del self.operation.attributes["arg_attrs"]

  @arg_attrs.deleter
  def arg_attrs(self):
    del self.operation.attributes["arg_attrs"]

  @builtins.property
  def res_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "res_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["res_attrs"]

  @res_attrs.setter
  def res_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["res_attrs"] = value
    elif "res_attrs" in self.operation.attributes:
      del self.operation.attributes["res_attrs"]

  @res_attrs.deleter
  def res_attrs(self):
    del self.operation.attributes["res_attrs"]

  @builtins.property
  def res(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def mbcnt_lo(res, in0, in1, *, arg_attrs=None, res_attrs=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MbcntLoOp(res=res, in0=in0, in1=in1, arg_attrs=arg_attrs, res_attrs=res_attrs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Permlane16SwapOp(_ods_ir.OpView):
  r"""
  Performs a `permlane16.swap` operation with the given operands, applying the
  permutation specified by $fi to the provided inputs.
  """

  OPERATION_NAME = "rocdl.permlane16.swap"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, old, src, fi, boundControl, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(old)
    operands.append(src)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["fi"] = (fi if (
    isinstance(fi, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I1Attr')) else
      _ods_ir.AttrBuilder.get('I1Attr')(fi, context=_ods_context))
    attributes["boundControl"] = (boundControl if (
    isinstance(boundControl, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I1Attr')) else
      _ods_ir.AttrBuilder.get('I1Attr')(boundControl, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def old(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def fi(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["fi"]

  @fi.setter
  def fi(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fi"] = value

  @builtins.property
  def boundControl(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["boundControl"]

  @boundControl.setter
  def boundControl(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["boundControl"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def permlane16_swap(res, old, src, fi, bound_control, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return Permlane16SwapOp(res=res, old=old, src=src, fi=fi, boundControl=bound_control, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Permlane32SwapOp(_ods_ir.OpView):
  r"""
  Performs a `permlane32.swap` operation with the given operands, applying the
  permutation specified by $fi to the provided inputs.
  """

  OPERATION_NAME = "rocdl.permlane32.swap"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, old, src, fi, boundControl, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(old)
    operands.append(src)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["fi"] = (fi if (
    isinstance(fi, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I1Attr')) else
      _ods_ir.AttrBuilder.get('I1Attr')(fi, context=_ods_context))
    attributes["boundControl"] = (boundControl if (
    isinstance(boundControl, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I1Attr')) else
      _ods_ir.AttrBuilder.get('I1Attr')(boundControl, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def old(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def src(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def fi(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["fi"]

  @fi.setter
  def fi(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fi"] = value

  @builtins.property
  def boundControl(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["boundControl"]

  @boundControl.setter
  def boundControl(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["boundControl"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def permlane32_swap(res, old, src, fi, bound_control, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return Permlane32SwapOp(res=res, old=old, src=src, fi=fi, boundControl=bound_control, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PermlaneX16Op(_ods_ir.OpView):
  r"""
  Performs a `permlanex16` operation with the given operands, applying the
  permutation specified by $fi to the provided inputs.
  """

  OPERATION_NAME = "rocdl.permlanex16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, old, src0, src1, src2, fi, boundControl, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(old)
    operands.append(src0)
    operands.append(src1)
    operands.append(src2)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["fi"] = (fi if (
    isinstance(fi, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I1Attr')) else
      _ods_ir.AttrBuilder.get('I1Attr')(fi, context=_ods_context))
    attributes["boundControl"] = (boundControl if (
    isinstance(boundControl, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I1Attr')) else
      _ods_ir.AttrBuilder.get('I1Attr')(boundControl, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def old(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def src0(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def src1(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def src2(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def fi(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["fi"]

  @fi.setter
  def fi(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fi"] = value

  @builtins.property
  def boundControl(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["boundControl"]

  @boundControl.setter
  def boundControl(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["boundControl"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def permlanex16(res, old, src0, src1, src2, fi, bound_control, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return PermlaneX16Op(res=res, old=old, src0=src0, src1=src1, src2=src2, fi=fi, boundControl=bound_control, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RawBufferAtomicCmpSwap(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.raw.buffer.atomic.cmpswap"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, cmp, rsrc, offset, soffset, aux, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(cmp)
    operands.append(rsrc)
    operands.append(offset)
    operands.append(soffset)
    operands.append(aux)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def cmp(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def rsrc(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def offset(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[3]

  @builtins.property
  def soffset(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[4]

  @builtins.property
  def aux(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[5]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def raw_buffer_atomic_cmpswap(res, src, cmp, rsrc, offset, soffset, aux, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return RawBufferAtomicCmpSwap(res=res, src=src, cmp=cmp, rsrc=rsrc, offset=offset, soffset=soffset, aux=aux, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RawBufferAtomicFAddOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.raw.buffer.atomic.fadd"

  _ODS_REGIONS = (0, True)

  def __init__(self, vdata, rsrc, offset, soffset, aux, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(vdata)
    operands.append(rsrc)
    operands.append(offset)
    operands.append(soffset)
    operands.append(aux)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def vdata(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rsrc(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def offset(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def soffset(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def aux(self) -> _ods_ir.Value:
    return self.operation.operands[4]

def raw_buffer_atomic_fadd(vdata, rsrc, offset, soffset, aux, *, loc=None, ip=None) -> RawBufferAtomicFAddOp:
  return RawBufferAtomicFAddOp(vdata=vdata, rsrc=rsrc, offset=offset, soffset=soffset, aux=aux, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class RawBufferAtomicFMaxOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.raw.buffer.atomic.fmax"

  _ODS_REGIONS = (0, True)

  def __init__(self, vdata, rsrc, offset, soffset, aux, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(vdata)
    operands.append(rsrc)
    operands.append(offset)
    operands.append(soffset)
    operands.append(aux)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def vdata(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rsrc(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def offset(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def soffset(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def aux(self) -> _ods_ir.Value:
    return self.operation.operands[4]

def raw_buffer_atomic_fmax(vdata, rsrc, offset, soffset, aux, *, loc=None, ip=None) -> RawBufferAtomicFMaxOp:
  return RawBufferAtomicFMaxOp(vdata=vdata, rsrc=rsrc, offset=offset, soffset=soffset, aux=aux, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class RawBufferAtomicSMaxOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.raw.buffer.atomic.smax"

  _ODS_REGIONS = (0, True)

  def __init__(self, vdata, rsrc, offset, soffset, aux, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(vdata)
    operands.append(rsrc)
    operands.append(offset)
    operands.append(soffset)
    operands.append(aux)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def vdata(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rsrc(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def offset(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def soffset(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def aux(self) -> _ods_ir.Value:
    return self.operation.operands[4]

def raw_buffer_atomic_smax(vdata, rsrc, offset, soffset, aux, *, loc=None, ip=None) -> RawBufferAtomicSMaxOp:
  return RawBufferAtomicSMaxOp(vdata=vdata, rsrc=rsrc, offset=offset, soffset=soffset, aux=aux, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class RawBufferAtomicUMinOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.raw.buffer.atomic.umin"

  _ODS_REGIONS = (0, True)

  def __init__(self, vdata, rsrc, offset, soffset, aux, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(vdata)
    operands.append(rsrc)
    operands.append(offset)
    operands.append(soffset)
    operands.append(aux)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def vdata(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rsrc(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def offset(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def soffset(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def aux(self) -> _ods_ir.Value:
    return self.operation.operands[4]

def raw_buffer_atomic_umin(vdata, rsrc, offset, soffset, aux, *, loc=None, ip=None) -> RawBufferAtomicUMinOp:
  return RawBufferAtomicUMinOp(vdata=vdata, rsrc=rsrc, offset=offset, soffset=soffset, aux=aux, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class RawBufferLoadOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.raw.buffer.load"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, rsrc, offset, soffset, aux, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(rsrc)
    operands.append(offset)
    operands.append(soffset)
    operands.append(aux)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def rsrc(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def offset(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def soffset(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def aux(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def raw_buffer_load(res, rsrc, offset, soffset, aux, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return RawBufferLoadOp(res=res, rsrc=rsrc, offset=offset, soffset=soffset, aux=aux, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RawBufferStoreOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.raw.buffer.store"

  _ODS_REGIONS = (0, True)

  def __init__(self, vdata, rsrc, offset, soffset, aux, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(vdata)
    operands.append(rsrc)
    operands.append(offset)
    operands.append(soffset)
    operands.append(aux)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def vdata(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rsrc(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def offset(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def soffset(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def aux(self) -> _ods_ir.Value:
    return self.operation.operands[4]

def raw_buffer_store(vdata, rsrc, offset, soffset, aux, *, loc=None, ip=None) -> RawBufferStoreOp:
  return RawBufferStoreOp(vdata=vdata, rsrc=rsrc, offset=offset, soffset=soffset, aux=aux, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class RawPtrBufferAtomicCmpSwap(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.raw.ptr.buffer.atomic.cmpswap"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, cmp, rsrc, offset, soffset, aux, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(cmp)
    operands.append(rsrc)
    operands.append(offset)
    operands.append(soffset)
    operands.append(aux)
    _ods_context = _ods_get_default_loc_context(loc)
    if alias_scopes is not None: attributes["alias_scopes"] = (alias_scopes if (
        isinstance(alias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(alias_scopes, context=_ods_context))
    if noalias_scopes is not None: attributes["noalias_scopes"] = (noalias_scopes if (
        isinstance(noalias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(noalias_scopes, context=_ods_context))
    if tbaa is not None: attributes["tbaa"] = (tbaa if (
        isinstance(tbaa, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_TBAATagArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_TBAATagArrayAttr')(tbaa, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def cmp(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def rsrc(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def offset(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[3]

  @builtins.property
  def soffset(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[4]

  @builtins.property
  def aux(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[5]

  @builtins.property
  def alias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "alias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["alias_scopes"]

  @alias_scopes.setter
  def alias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["alias_scopes"] = value
    elif "alias_scopes" in self.operation.attributes:
      del self.operation.attributes["alias_scopes"]

  @alias_scopes.deleter
  def alias_scopes(self):
    del self.operation.attributes["alias_scopes"]

  @builtins.property
  def noalias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "noalias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["noalias_scopes"]

  @noalias_scopes.setter
  def noalias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["noalias_scopes"] = value
    elif "noalias_scopes" in self.operation.attributes:
      del self.operation.attributes["noalias_scopes"]

  @noalias_scopes.deleter
  def noalias_scopes(self):
    del self.operation.attributes["noalias_scopes"]

  @builtins.property
  def tbaa(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tbaa" not in self.operation.attributes:
      return None
    return self.operation.attributes["tbaa"]

  @tbaa.setter
  def tbaa(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tbaa"] = value
    elif "tbaa" in self.operation.attributes:
      del self.operation.attributes["tbaa"]

  @tbaa.deleter
  def tbaa(self):
    del self.operation.attributes["tbaa"]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def raw_ptr_buffer_atomic_cmpswap(res, src, cmp, rsrc, offset, soffset, aux, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return RawPtrBufferAtomicCmpSwap(res=res, src=src, cmp=cmp, rsrc=rsrc, offset=offset, soffset=soffset, aux=aux, alias_scopes=alias_scopes, noalias_scopes=noalias_scopes, tbaa=tbaa, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RawPtrBufferAtomicFaddOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.raw.ptr.buffer.atomic.fadd"

  _ODS_REGIONS = (0, True)

  def __init__(self, vdata, rsrc, offset, soffset, aux, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(vdata)
    operands.append(rsrc)
    operands.append(offset)
    operands.append(soffset)
    operands.append(aux)
    _ods_context = _ods_get_default_loc_context(loc)
    if alias_scopes is not None: attributes["alias_scopes"] = (alias_scopes if (
        isinstance(alias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(alias_scopes, context=_ods_context))
    if noalias_scopes is not None: attributes["noalias_scopes"] = (noalias_scopes if (
        isinstance(noalias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(noalias_scopes, context=_ods_context))
    if tbaa is not None: attributes["tbaa"] = (tbaa if (
        isinstance(tbaa, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_TBAATagArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_TBAATagArrayAttr')(tbaa, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def vdata(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rsrc(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def offset(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[2]

  @builtins.property
  def soffset(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[3]

  @builtins.property
  def aux(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[4]

  @builtins.property
  def alias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "alias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["alias_scopes"]

  @alias_scopes.setter
  def alias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["alias_scopes"] = value
    elif "alias_scopes" in self.operation.attributes:
      del self.operation.attributes["alias_scopes"]

  @alias_scopes.deleter
  def alias_scopes(self):
    del self.operation.attributes["alias_scopes"]

  @builtins.property
  def noalias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "noalias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["noalias_scopes"]

  @noalias_scopes.setter
  def noalias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["noalias_scopes"] = value
    elif "noalias_scopes" in self.operation.attributes:
      del self.operation.attributes["noalias_scopes"]

  @noalias_scopes.deleter
  def noalias_scopes(self):
    del self.operation.attributes["noalias_scopes"]

  @builtins.property
  def tbaa(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tbaa" not in self.operation.attributes:
      return None
    return self.operation.attributes["tbaa"]

  @tbaa.setter
  def tbaa(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tbaa"] = value
    elif "tbaa" in self.operation.attributes:
      del self.operation.attributes["tbaa"]

  @tbaa.deleter
  def tbaa(self):
    del self.operation.attributes["tbaa"]

def raw_ptr_buffer_atomic_fadd(vdata, rsrc, offset, soffset, aux, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None) -> RawPtrBufferAtomicFaddOp:
  return RawPtrBufferAtomicFaddOp(vdata=vdata, rsrc=rsrc, offset=offset, soffset=soffset, aux=aux, alias_scopes=alias_scopes, noalias_scopes=noalias_scopes, tbaa=tbaa, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class RawPtrBufferAtomicFmaxOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.raw.ptr.buffer.atomic.fmax"

  _ODS_REGIONS = (0, True)

  def __init__(self, vdata, rsrc, offset, soffset, aux, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(vdata)
    operands.append(rsrc)
    operands.append(offset)
    operands.append(soffset)
    operands.append(aux)
    _ods_context = _ods_get_default_loc_context(loc)
    if alias_scopes is not None: attributes["alias_scopes"] = (alias_scopes if (
        isinstance(alias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(alias_scopes, context=_ods_context))
    if noalias_scopes is not None: attributes["noalias_scopes"] = (noalias_scopes if (
        isinstance(noalias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(noalias_scopes, context=_ods_context))
    if tbaa is not None: attributes["tbaa"] = (tbaa if (
        isinstance(tbaa, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_TBAATagArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_TBAATagArrayAttr')(tbaa, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def vdata(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rsrc(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def offset(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[2]

  @builtins.property
  def soffset(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[3]

  @builtins.property
  def aux(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[4]

  @builtins.property
  def alias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "alias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["alias_scopes"]

  @alias_scopes.setter
  def alias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["alias_scopes"] = value
    elif "alias_scopes" in self.operation.attributes:
      del self.operation.attributes["alias_scopes"]

  @alias_scopes.deleter
  def alias_scopes(self):
    del self.operation.attributes["alias_scopes"]

  @builtins.property
  def noalias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "noalias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["noalias_scopes"]

  @noalias_scopes.setter
  def noalias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["noalias_scopes"] = value
    elif "noalias_scopes" in self.operation.attributes:
      del self.operation.attributes["noalias_scopes"]

  @noalias_scopes.deleter
  def noalias_scopes(self):
    del self.operation.attributes["noalias_scopes"]

  @builtins.property
  def tbaa(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tbaa" not in self.operation.attributes:
      return None
    return self.operation.attributes["tbaa"]

  @tbaa.setter
  def tbaa(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tbaa"] = value
    elif "tbaa" in self.operation.attributes:
      del self.operation.attributes["tbaa"]

  @tbaa.deleter
  def tbaa(self):
    del self.operation.attributes["tbaa"]

def raw_ptr_buffer_atomic_fmax(vdata, rsrc, offset, soffset, aux, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None) -> RawPtrBufferAtomicFmaxOp:
  return RawPtrBufferAtomicFmaxOp(vdata=vdata, rsrc=rsrc, offset=offset, soffset=soffset, aux=aux, alias_scopes=alias_scopes, noalias_scopes=noalias_scopes, tbaa=tbaa, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class RawPtrBufferAtomicSmaxOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.raw.ptr.buffer.atomic.smax"

  _ODS_REGIONS = (0, True)

  def __init__(self, vdata, rsrc, offset, soffset, aux, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(vdata)
    operands.append(rsrc)
    operands.append(offset)
    operands.append(soffset)
    operands.append(aux)
    _ods_context = _ods_get_default_loc_context(loc)
    if alias_scopes is not None: attributes["alias_scopes"] = (alias_scopes if (
        isinstance(alias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(alias_scopes, context=_ods_context))
    if noalias_scopes is not None: attributes["noalias_scopes"] = (noalias_scopes if (
        isinstance(noalias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(noalias_scopes, context=_ods_context))
    if tbaa is not None: attributes["tbaa"] = (tbaa if (
        isinstance(tbaa, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_TBAATagArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_TBAATagArrayAttr')(tbaa, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def vdata(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rsrc(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def offset(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[2]

  @builtins.property
  def soffset(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[3]

  @builtins.property
  def aux(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[4]

  @builtins.property
  def alias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "alias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["alias_scopes"]

  @alias_scopes.setter
  def alias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["alias_scopes"] = value
    elif "alias_scopes" in self.operation.attributes:
      del self.operation.attributes["alias_scopes"]

  @alias_scopes.deleter
  def alias_scopes(self):
    del self.operation.attributes["alias_scopes"]

  @builtins.property
  def noalias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "noalias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["noalias_scopes"]

  @noalias_scopes.setter
  def noalias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["noalias_scopes"] = value
    elif "noalias_scopes" in self.operation.attributes:
      del self.operation.attributes["noalias_scopes"]

  @noalias_scopes.deleter
  def noalias_scopes(self):
    del self.operation.attributes["noalias_scopes"]

  @builtins.property
  def tbaa(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tbaa" not in self.operation.attributes:
      return None
    return self.operation.attributes["tbaa"]

  @tbaa.setter
  def tbaa(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tbaa"] = value
    elif "tbaa" in self.operation.attributes:
      del self.operation.attributes["tbaa"]

  @tbaa.deleter
  def tbaa(self):
    del self.operation.attributes["tbaa"]

def raw_ptr_buffer_atomic_smax(vdata, rsrc, offset, soffset, aux, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None) -> RawPtrBufferAtomicSmaxOp:
  return RawPtrBufferAtomicSmaxOp(vdata=vdata, rsrc=rsrc, offset=offset, soffset=soffset, aux=aux, alias_scopes=alias_scopes, noalias_scopes=noalias_scopes, tbaa=tbaa, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class RawPtrBufferAtomicUminOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.raw.ptr.buffer.atomic.umin"

  _ODS_REGIONS = (0, True)

  def __init__(self, vdata, rsrc, offset, soffset, aux, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(vdata)
    operands.append(rsrc)
    operands.append(offset)
    operands.append(soffset)
    operands.append(aux)
    _ods_context = _ods_get_default_loc_context(loc)
    if alias_scopes is not None: attributes["alias_scopes"] = (alias_scopes if (
        isinstance(alias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(alias_scopes, context=_ods_context))
    if noalias_scopes is not None: attributes["noalias_scopes"] = (noalias_scopes if (
        isinstance(noalias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(noalias_scopes, context=_ods_context))
    if tbaa is not None: attributes["tbaa"] = (tbaa if (
        isinstance(tbaa, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_TBAATagArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_TBAATagArrayAttr')(tbaa, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def vdata(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rsrc(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def offset(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[2]

  @builtins.property
  def soffset(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[3]

  @builtins.property
  def aux(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[4]

  @builtins.property
  def alias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "alias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["alias_scopes"]

  @alias_scopes.setter
  def alias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["alias_scopes"] = value
    elif "alias_scopes" in self.operation.attributes:
      del self.operation.attributes["alias_scopes"]

  @alias_scopes.deleter
  def alias_scopes(self):
    del self.operation.attributes["alias_scopes"]

  @builtins.property
  def noalias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "noalias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["noalias_scopes"]

  @noalias_scopes.setter
  def noalias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["noalias_scopes"] = value
    elif "noalias_scopes" in self.operation.attributes:
      del self.operation.attributes["noalias_scopes"]

  @noalias_scopes.deleter
  def noalias_scopes(self):
    del self.operation.attributes["noalias_scopes"]

  @builtins.property
  def tbaa(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tbaa" not in self.operation.attributes:
      return None
    return self.operation.attributes["tbaa"]

  @tbaa.setter
  def tbaa(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tbaa"] = value
    elif "tbaa" in self.operation.attributes:
      del self.operation.attributes["tbaa"]

  @tbaa.deleter
  def tbaa(self):
    del self.operation.attributes["tbaa"]

def raw_ptr_buffer_atomic_umin(vdata, rsrc, offset, soffset, aux, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None) -> RawPtrBufferAtomicUminOp:
  return RawPtrBufferAtomicUminOp(vdata=vdata, rsrc=rsrc, offset=offset, soffset=soffset, aux=aux, alias_scopes=alias_scopes, noalias_scopes=noalias_scopes, tbaa=tbaa, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class RawPtrBufferLoadLdsOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.raw.ptr.buffer.load.lds"

  _ODS_REGIONS = (0, True)

  def __init__(self, rsrc, ldsPtr, size, voffset, soffset, offset, aux, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(rsrc)
    operands.append(ldsPtr)
    operands.append(size)
    operands.append(voffset)
    operands.append(soffset)
    operands.append(offset)
    operands.append(aux)
    _ods_context = _ods_get_default_loc_context(loc)
    if alias_scopes is not None: attributes["alias_scopes"] = (alias_scopes if (
        isinstance(alias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(alias_scopes, context=_ods_context))
    if noalias_scopes is not None: attributes["noalias_scopes"] = (noalias_scopes if (
        isinstance(noalias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(noalias_scopes, context=_ods_context))
    if tbaa is not None: attributes["tbaa"] = (tbaa if (
        isinstance(tbaa, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_TBAATagArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_TBAATagArrayAttr')(tbaa, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def rsrc(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def ldsPtr(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def size(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[2]

  @builtins.property
  def voffset(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[3]

  @builtins.property
  def soffset(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[4]

  @builtins.property
  def offset(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[5]

  @builtins.property
  def aux(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[6]

  @builtins.property
  def alias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "alias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["alias_scopes"]

  @alias_scopes.setter
  def alias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["alias_scopes"] = value
    elif "alias_scopes" in self.operation.attributes:
      del self.operation.attributes["alias_scopes"]

  @alias_scopes.deleter
  def alias_scopes(self):
    del self.operation.attributes["alias_scopes"]

  @builtins.property
  def noalias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "noalias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["noalias_scopes"]

  @noalias_scopes.setter
  def noalias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["noalias_scopes"] = value
    elif "noalias_scopes" in self.operation.attributes:
      del self.operation.attributes["noalias_scopes"]

  @noalias_scopes.deleter
  def noalias_scopes(self):
    del self.operation.attributes["noalias_scopes"]

  @builtins.property
  def tbaa(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tbaa" not in self.operation.attributes:
      return None
    return self.operation.attributes["tbaa"]

  @tbaa.setter
  def tbaa(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tbaa"] = value
    elif "tbaa" in self.operation.attributes:
      del self.operation.attributes["tbaa"]

  @tbaa.deleter
  def tbaa(self):
    del self.operation.attributes["tbaa"]

def raw_ptr_buffer_load_lds(rsrc, lds_ptr, size, voffset, soffset, offset, aux, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None) -> RawPtrBufferLoadLdsOp:
  return RawPtrBufferLoadLdsOp(rsrc=rsrc, ldsPtr=lds_ptr, size=size, voffset=voffset, soffset=soffset, offset=offset, aux=aux, alias_scopes=alias_scopes, noalias_scopes=noalias_scopes, tbaa=tbaa, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class RawPtrBufferLoadOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.raw.ptr.buffer.load"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, rsrc, offset, soffset, aux, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(rsrc)
    operands.append(offset)
    operands.append(soffset)
    operands.append(aux)
    _ods_context = _ods_get_default_loc_context(loc)
    if alias_scopes is not None: attributes["alias_scopes"] = (alias_scopes if (
        isinstance(alias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(alias_scopes, context=_ods_context))
    if noalias_scopes is not None: attributes["noalias_scopes"] = (noalias_scopes if (
        isinstance(noalias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(noalias_scopes, context=_ods_context))
    if tbaa is not None: attributes["tbaa"] = (tbaa if (
        isinstance(tbaa, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_TBAATagArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_TBAATagArrayAttr')(tbaa, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def rsrc(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def offset(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def soffset(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[2]

  @builtins.property
  def aux(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[3]

  @builtins.property
  def alias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "alias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["alias_scopes"]

  @alias_scopes.setter
  def alias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["alias_scopes"] = value
    elif "alias_scopes" in self.operation.attributes:
      del self.operation.attributes["alias_scopes"]

  @alias_scopes.deleter
  def alias_scopes(self):
    del self.operation.attributes["alias_scopes"]

  @builtins.property
  def noalias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "noalias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["noalias_scopes"]

  @noalias_scopes.setter
  def noalias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["noalias_scopes"] = value
    elif "noalias_scopes" in self.operation.attributes:
      del self.operation.attributes["noalias_scopes"]

  @noalias_scopes.deleter
  def noalias_scopes(self):
    del self.operation.attributes["noalias_scopes"]

  @builtins.property
  def tbaa(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tbaa" not in self.operation.attributes:
      return None
    return self.operation.attributes["tbaa"]

  @tbaa.setter
  def tbaa(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tbaa"] = value
    elif "tbaa" in self.operation.attributes:
      del self.operation.attributes["tbaa"]

  @tbaa.deleter
  def tbaa(self):
    del self.operation.attributes["tbaa"]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def raw_ptr_buffer_load(res, rsrc, offset, soffset, aux, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return RawPtrBufferLoadOp(res=res, rsrc=rsrc, offset=offset, soffset=soffset, aux=aux, alias_scopes=alias_scopes, noalias_scopes=noalias_scopes, tbaa=tbaa, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RawPtrBufferStoreOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.raw.ptr.buffer.store"

  _ODS_REGIONS = (0, True)

  def __init__(self, vdata, rsrc, offset, soffset, aux, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(vdata)
    operands.append(rsrc)
    operands.append(offset)
    operands.append(soffset)
    operands.append(aux)
    _ods_context = _ods_get_default_loc_context(loc)
    if alias_scopes is not None: attributes["alias_scopes"] = (alias_scopes if (
        isinstance(alias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(alias_scopes, context=_ods_context))
    if noalias_scopes is not None: attributes["noalias_scopes"] = (noalias_scopes if (
        isinstance(noalias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(noalias_scopes, context=_ods_context))
    if tbaa is not None: attributes["tbaa"] = (tbaa if (
        isinstance(tbaa, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_TBAATagArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_TBAATagArrayAttr')(tbaa, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def vdata(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rsrc(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def offset(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[2]

  @builtins.property
  def soffset(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[3]

  @builtins.property
  def aux(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[4]

  @builtins.property
  def alias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "alias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["alias_scopes"]

  @alias_scopes.setter
  def alias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["alias_scopes"] = value
    elif "alias_scopes" in self.operation.attributes:
      del self.operation.attributes["alias_scopes"]

  @alias_scopes.deleter
  def alias_scopes(self):
    del self.operation.attributes["alias_scopes"]

  @builtins.property
  def noalias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "noalias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["noalias_scopes"]

  @noalias_scopes.setter
  def noalias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["noalias_scopes"] = value
    elif "noalias_scopes" in self.operation.attributes:
      del self.operation.attributes["noalias_scopes"]

  @noalias_scopes.deleter
  def noalias_scopes(self):
    del self.operation.attributes["noalias_scopes"]

  @builtins.property
  def tbaa(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tbaa" not in self.operation.attributes:
      return None
    return self.operation.attributes["tbaa"]

  @tbaa.setter
  def tbaa(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tbaa"] = value
    elif "tbaa" in self.operation.attributes:
      del self.operation.attributes["tbaa"]

  @tbaa.deleter
  def tbaa(self):
    del self.operation.attributes["tbaa"]

def raw_ptr_buffer_store(vdata, rsrc, offset, soffset, aux, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None) -> RawPtrBufferStoreOp:
  return RawPtrBufferStoreOp(vdata=vdata, rsrc=rsrc, offset=offset, soffset=soffset, aux=aux, alias_scopes=alias_scopes, noalias_scopes=noalias_scopes, tbaa=tbaa, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ReadfirstlaneOp(_ods_ir.OpView):
  r"""
  Returns the value in the lowest active lane of the input operand.
  """

  OPERATION_NAME = "rocdl.readfirstlane"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def readfirstlane(res, src, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ReadfirstlaneOp(res=res, src=src, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ReadlaneOp(_ods_ir.OpView):
  r"""
  Get the value in lane `src1` from input `src0`.
  """

  OPERATION_NAME = "rocdl.readlane"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src0, src1, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src0)
    operands.append(src1)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src0(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def src1(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def readlane(res, src0, src1, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ReadlaneOp(res=res, src0=src0, src1=src1, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SBarrierOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.s.barrier"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def s_barrier(*, loc=None, ip=None) -> SBarrierOp:
  return SBarrierOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class SNopOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.s.nop"

  _ODS_REGIONS = (0, True)

  def __init__(self, count, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["count"] = (count if (
    isinstance(count, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I16Attr')) else
      _ods_ir.AttrBuilder.get('I16Attr')(count, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def count(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["count"]

  @count.setter
  def count(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["count"] = value

def s_nop(count, *, loc=None, ip=None) -> SNopOp:
  return SNopOp(count=count, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class SSleepOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.s.sleep"

  _ODS_REGIONS = (0, True)

  def __init__(self, count, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["count"] = (count if (
    isinstance(count, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(count, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def count(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["count"]

  @count.setter
  def count(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["count"] = value

def s_sleep(count, *, loc=None, ip=None) -> SSleepOp:
  return SSleepOp(count=count, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class SWaitcntOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.s.waitcnt"

  _ODS_REGIONS = (0, True)

  def __init__(self, bitfield, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["bitfield"] = (bitfield if (
    isinstance(bitfield, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(bitfield, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def bitfield(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["bitfield"]

  @bitfield.setter
  def bitfield(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["bitfield"] = value

def s_waitcnt(bitfield, *, loc=None, ip=None) -> SWaitcntOp:
  return SWaitcntOp(bitfield=bitfield, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class SchedBarrier(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.sched.barrier"

  _ODS_REGIONS = (0, True)

  def __init__(self, mask, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["mask"] = (mask if (
    isinstance(mask, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(mask, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def mask(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["mask"]

  @mask.setter
  def mask(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mask"] = value

def sched_barrier(mask, *, loc=None, ip=None) -> SchedBarrier:
  return SchedBarrier(mask=mask, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class SchedGroupBarrier(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.sched.group.barrier"

  _ODS_REGIONS = (0, True)

  def __init__(self, mask, size, groupId, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["mask"] = (mask if (
    isinstance(mask, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(mask, context=_ods_context))
    attributes["size"] = (size if (
    isinstance(size, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(size, context=_ods_context))
    attributes["groupId"] = (groupId if (
    isinstance(groupId, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(groupId, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def mask(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["mask"]

  @mask.setter
  def mask(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mask"] = value

  @builtins.property
  def size(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["size"]

  @size.setter
  def size(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["size"] = value

  @builtins.property
  def groupId(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["groupId"]

  @groupId.setter
  def groupId(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["groupId"] = value

def sched_group_barrier(mask, size, group_id, *, loc=None, ip=None) -> SchedGroupBarrier:
  return SchedGroupBarrier(mask=mask, size=size, groupId=group_id, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class SetPrioOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.s.setprio"

  _ODS_REGIONS = (0, True)

  def __init__(self, priority, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["priority"] = (priority if (
    isinstance(priority, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I16Attr')) else
      _ods_ir.AttrBuilder.get('I16Attr')(priority, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def priority(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["priority"]

  @priority.setter
  def priority(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["priority"] = value

def s_setprio(priority, *, loc=None, ip=None) -> SetPrioOp:
  return SetPrioOp(priority=priority, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class TensorLoadToLDSD2Op(_ods_ir.OpView):
  r"""
  Moves tiles of tensor data between global memory and LDS. The tile is
  described by the $dgroup descriptors. 2 $dgroup descriptors allows for
  movement of up to 2D tensors. $cachePolicy describes the memory scope and an
  indicator of expected data re-use.
  
  This op is for gfx1250+ architectures.
  """

  OPERATION_NAME = "rocdl.tensor.load.to.lds.d2"

  _ODS_REGIONS = (0, True)

  def __init__(self, dgroup0, dgroup1, cachePolicy, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(dgroup0)
    operands.append(dgroup1)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["cachePolicy"] = (cachePolicy if (
    isinstance(cachePolicy, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(cachePolicy, context=_ods_context))
    if alias_scopes is not None: attributes["alias_scopes"] = (alias_scopes if (
        isinstance(alias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(alias_scopes, context=_ods_context))
    if noalias_scopes is not None: attributes["noalias_scopes"] = (noalias_scopes if (
        isinstance(noalias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(noalias_scopes, context=_ods_context))
    if tbaa is not None: attributes["tbaa"] = (tbaa if (
        isinstance(tbaa, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_TBAATagArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_TBAATagArrayAttr')(tbaa, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def dgroup0(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def dgroup1(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[1]

  @builtins.property
  def cachePolicy(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["cachePolicy"]

  @cachePolicy.setter
  def cachePolicy(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["cachePolicy"] = value

  @builtins.property
  def alias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "alias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["alias_scopes"]

  @alias_scopes.setter
  def alias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["alias_scopes"] = value
    elif "alias_scopes" in self.operation.attributes:
      del self.operation.attributes["alias_scopes"]

  @alias_scopes.deleter
  def alias_scopes(self):
    del self.operation.attributes["alias_scopes"]

  @builtins.property
  def noalias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "noalias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["noalias_scopes"]

  @noalias_scopes.setter
  def noalias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["noalias_scopes"] = value
    elif "noalias_scopes" in self.operation.attributes:
      del self.operation.attributes["noalias_scopes"]

  @noalias_scopes.deleter
  def noalias_scopes(self):
    del self.operation.attributes["noalias_scopes"]

  @builtins.property
  def tbaa(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tbaa" not in self.operation.attributes:
      return None
    return self.operation.attributes["tbaa"]

  @tbaa.setter
  def tbaa(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tbaa"] = value
    elif "tbaa" in self.operation.attributes:
      del self.operation.attributes["tbaa"]

  @tbaa.deleter
  def tbaa(self):
    del self.operation.attributes["tbaa"]

def tensor_load_to_lds_d2(dgroup0, dgroup1, cache_policy, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None) -> TensorLoadToLDSD2Op:
  return TensorLoadToLDSD2Op(dgroup0=dgroup0, dgroup1=dgroup1, cachePolicy=cache_policy, alias_scopes=alias_scopes, noalias_scopes=noalias_scopes, tbaa=tbaa, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class TensorLoadToLDSOp(_ods_ir.OpView):
  r"""
  Moves tiles of tensor data between global memory and LDS. The tile is
  described by the $dgroup descriptors. 4 $dgroup descriptors allows for
  movement of up to 5D tensors. $cachePolicy describes the memory scope and an
  indicator of expected data re-use.
  
  This op is for gfx1250+ architectures.
  """

  OPERATION_NAME = "rocdl.tensor.load.to.lds"

  _ODS_REGIONS = (0, True)

  def __init__(self, dgroup0, dgroup1, dgroup2, dgroup3, cachePolicy, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(dgroup0)
    operands.append(dgroup1)
    operands.append(dgroup2)
    operands.append(dgroup3)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["cachePolicy"] = (cachePolicy if (
    isinstance(cachePolicy, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(cachePolicy, context=_ods_context))
    if alias_scopes is not None: attributes["alias_scopes"] = (alias_scopes if (
        isinstance(alias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(alias_scopes, context=_ods_context))
    if noalias_scopes is not None: attributes["noalias_scopes"] = (noalias_scopes if (
        isinstance(noalias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(noalias_scopes, context=_ods_context))
    if tbaa is not None: attributes["tbaa"] = (tbaa if (
        isinstance(tbaa, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_TBAATagArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_TBAATagArrayAttr')(tbaa, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def dgroup0(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def dgroup1(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[1]

  @builtins.property
  def dgroup2(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[2]

  @builtins.property
  def dgroup3(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[3]

  @builtins.property
  def cachePolicy(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["cachePolicy"]

  @cachePolicy.setter
  def cachePolicy(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["cachePolicy"] = value

  @builtins.property
  def alias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "alias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["alias_scopes"]

  @alias_scopes.setter
  def alias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["alias_scopes"] = value
    elif "alias_scopes" in self.operation.attributes:
      del self.operation.attributes["alias_scopes"]

  @alias_scopes.deleter
  def alias_scopes(self):
    del self.operation.attributes["alias_scopes"]

  @builtins.property
  def noalias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "noalias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["noalias_scopes"]

  @noalias_scopes.setter
  def noalias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["noalias_scopes"] = value
    elif "noalias_scopes" in self.operation.attributes:
      del self.operation.attributes["noalias_scopes"]

  @noalias_scopes.deleter
  def noalias_scopes(self):
    del self.operation.attributes["noalias_scopes"]

  @builtins.property
  def tbaa(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tbaa" not in self.operation.attributes:
      return None
    return self.operation.attributes["tbaa"]

  @tbaa.setter
  def tbaa(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tbaa"] = value
    elif "tbaa" in self.operation.attributes:
      del self.operation.attributes["tbaa"]

  @tbaa.deleter
  def tbaa(self):
    del self.operation.attributes["tbaa"]

def tensor_load_to_lds(dgroup0, dgroup1, dgroup2, dgroup3, cache_policy, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None) -> TensorLoadToLDSOp:
  return TensorLoadToLDSOp(dgroup0=dgroup0, dgroup1=dgroup1, dgroup2=dgroup2, dgroup3=dgroup3, cachePolicy=cache_policy, alias_scopes=alias_scopes, noalias_scopes=noalias_scopes, tbaa=tbaa, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class TensorStoreFromLDSD2Op(_ods_ir.OpView):
  r"""
  Moves tiles of tensor data between global memory and LDS. The tile is
  described by the $dgroup descriptors. 2 $dgroup descriptors allows for
  movement of up to 2D tensors. $cachePolicy describes the memory scope and an
  indicator of expected data re-use.
  
  This op is for gfx1250+ architectures.
  """

  OPERATION_NAME = "rocdl.tensor.store.from.lds.d2"

  _ODS_REGIONS = (0, True)

  def __init__(self, dgroup0, dgroup1, cachePolicy, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(dgroup0)
    operands.append(dgroup1)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["cachePolicy"] = (cachePolicy if (
    isinstance(cachePolicy, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(cachePolicy, context=_ods_context))
    if alias_scopes is not None: attributes["alias_scopes"] = (alias_scopes if (
        isinstance(alias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(alias_scopes, context=_ods_context))
    if noalias_scopes is not None: attributes["noalias_scopes"] = (noalias_scopes if (
        isinstance(noalias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(noalias_scopes, context=_ods_context))
    if tbaa is not None: attributes["tbaa"] = (tbaa if (
        isinstance(tbaa, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_TBAATagArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_TBAATagArrayAttr')(tbaa, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def dgroup0(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def dgroup1(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[1]

  @builtins.property
  def cachePolicy(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["cachePolicy"]

  @cachePolicy.setter
  def cachePolicy(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["cachePolicy"] = value

  @builtins.property
  def alias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "alias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["alias_scopes"]

  @alias_scopes.setter
  def alias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["alias_scopes"] = value
    elif "alias_scopes" in self.operation.attributes:
      del self.operation.attributes["alias_scopes"]

  @alias_scopes.deleter
  def alias_scopes(self):
    del self.operation.attributes["alias_scopes"]

  @builtins.property
  def noalias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "noalias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["noalias_scopes"]

  @noalias_scopes.setter
  def noalias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["noalias_scopes"] = value
    elif "noalias_scopes" in self.operation.attributes:
      del self.operation.attributes["noalias_scopes"]

  @noalias_scopes.deleter
  def noalias_scopes(self):
    del self.operation.attributes["noalias_scopes"]

  @builtins.property
  def tbaa(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tbaa" not in self.operation.attributes:
      return None
    return self.operation.attributes["tbaa"]

  @tbaa.setter
  def tbaa(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tbaa"] = value
    elif "tbaa" in self.operation.attributes:
      del self.operation.attributes["tbaa"]

  @tbaa.deleter
  def tbaa(self):
    del self.operation.attributes["tbaa"]

def tensor_store_from_lds_d2(dgroup0, dgroup1, cache_policy, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None) -> TensorStoreFromLDSD2Op:
  return TensorStoreFromLDSD2Op(dgroup0=dgroup0, dgroup1=dgroup1, cachePolicy=cache_policy, alias_scopes=alias_scopes, noalias_scopes=noalias_scopes, tbaa=tbaa, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class TensorStoreFromLDSOp(_ods_ir.OpView):
  r"""
  Moves tiles of tensor data between global memory and LDS. The tile is
  described by the $dgroup descriptors. 4 $dgroup descriptors allows for
  movement of up to 5D tensors. $cachePolicy describes the memory scope and an
  indicator of expected data re-use.
  
  This op is for gfx1250+ architectures.
  """

  OPERATION_NAME = "rocdl.tensor.store.from.lds"

  _ODS_REGIONS = (0, True)

  def __init__(self, dgroup0, dgroup1, dgroup2, dgroup3, cachePolicy, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(dgroup0)
    operands.append(dgroup1)
    operands.append(dgroup2)
    operands.append(dgroup3)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["cachePolicy"] = (cachePolicy if (
    isinstance(cachePolicy, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(cachePolicy, context=_ods_context))
    if alias_scopes is not None: attributes["alias_scopes"] = (alias_scopes if (
        isinstance(alias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(alias_scopes, context=_ods_context))
    if noalias_scopes is not None: attributes["noalias_scopes"] = (noalias_scopes if (
        isinstance(noalias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(noalias_scopes, context=_ods_context))
    if tbaa is not None: attributes["tbaa"] = (tbaa if (
        isinstance(tbaa, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_TBAATagArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_TBAATagArrayAttr')(tbaa, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def dgroup0(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[0]

  @builtins.property
  def dgroup1(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[1]

  @builtins.property
  def dgroup2(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[2]

  @builtins.property
  def dgroup3(self) -> _ods_ir.Value[_ods_ir.VectorType]:
    return self.operation.operands[3]

  @builtins.property
  def cachePolicy(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["cachePolicy"]

  @cachePolicy.setter
  def cachePolicy(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["cachePolicy"] = value

  @builtins.property
  def alias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "alias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["alias_scopes"]

  @alias_scopes.setter
  def alias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["alias_scopes"] = value
    elif "alias_scopes" in self.operation.attributes:
      del self.operation.attributes["alias_scopes"]

  @alias_scopes.deleter
  def alias_scopes(self):
    del self.operation.attributes["alias_scopes"]

  @builtins.property
  def noalias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "noalias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["noalias_scopes"]

  @noalias_scopes.setter
  def noalias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["noalias_scopes"] = value
    elif "noalias_scopes" in self.operation.attributes:
      del self.operation.attributes["noalias_scopes"]

  @noalias_scopes.deleter
  def noalias_scopes(self):
    del self.operation.attributes["noalias_scopes"]

  @builtins.property
  def tbaa(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tbaa" not in self.operation.attributes:
      return None
    return self.operation.attributes["tbaa"]

  @tbaa.setter
  def tbaa(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tbaa"] = value
    elif "tbaa" in self.operation.attributes:
      del self.operation.attributes["tbaa"]

  @tbaa.deleter
  def tbaa(self):
    del self.operation.attributes["tbaa"]

def tensor_store_from_lds(dgroup0, dgroup1, dgroup2, dgroup3, cache_policy, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None) -> TensorStoreFromLDSOp:
  return TensorStoreFromLDSOp(dgroup0=dgroup0, dgroup1=dgroup1, dgroup2=dgroup2, dgroup3=dgroup3, cachePolicy=cache_policy, alias_scopes=alias_scopes, noalias_scopes=noalias_scopes, tbaa=tbaa, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ThreadIdXOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.workitem.id.x"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, *, range=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if range is not None: attributes["range"] = (range if (
        isinstance(range, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_ConstantRangeAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_ConstantRangeAttr')(range, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def range(self) -> _Optional[_ods_ir.Attribute]:
    if "range" not in self.operation.attributes:
      return None
    return self.operation.attributes["range"]

  @range.setter
  def range(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["range"] = value
    elif "range" in self.operation.attributes:
      del self.operation.attributes["range"]

  @range.deleter
  def range(self):
    del self.operation.attributes["range"]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def workitem_id_x(res, *, range=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ThreadIdXOp(res=res, range=range, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ThreadIdYOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.workitem.id.y"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, *, range=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if range is not None: attributes["range"] = (range if (
        isinstance(range, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_ConstantRangeAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_ConstantRangeAttr')(range, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def range(self) -> _Optional[_ods_ir.Attribute]:
    if "range" not in self.operation.attributes:
      return None
    return self.operation.attributes["range"]

  @range.setter
  def range(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["range"] = value
    elif "range" in self.operation.attributes:
      del self.operation.attributes["range"]

  @range.deleter
  def range(self):
    del self.operation.attributes["range"]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def workitem_id_y(res, *, range=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ThreadIdYOp(res=res, range=range, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ThreadIdZOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.workitem.id.z"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, *, range=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if range is not None: attributes["range"] = (range if (
        isinstance(range, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_ConstantRangeAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_ConstantRangeAttr')(range, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def range(self) -> _Optional[_ods_ir.Attribute]:
    if "range" not in self.operation.attributes:
      return None
    return self.operation.attributes["range"]

  @range.setter
  def range(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["range"] = value
    elif "range" in self.operation.attributes:
      del self.operation.attributes["range"]

  @range.deleter
  def range(self):
    del self.operation.attributes["range"]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def workitem_id_z(res, *, range=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ThreadIdZOp(res=res, range=range, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class WaitAsynccntOp(_ods_ir.OpView):
  r"""
  Wait for the counter specified to be less-than or equal-to the `count`
  before continuing.
  
  Available on gfx1250+.
  """

  OPERATION_NAME = "rocdl.s.wait.asynccnt"

  _ODS_REGIONS = (0, True)

  def __init__(self, count, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["count"] = (count if (
    isinstance(count, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I16Attr')) else
      _ods_ir.AttrBuilder.get('I16Attr')(count, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def count(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["count"]

  @count.setter
  def count(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["count"] = value

def s_wait_asynccnt(count, *, loc=None, ip=None) -> WaitAsynccntOp:
  return WaitAsynccntOp(count=count, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class WaitDscntOp(_ods_ir.OpView):
  r"""
  Wait for the counter specified to be less-than or equal-to the `count`
  before continuing.
  
  Available on gfx12+.
  """

  OPERATION_NAME = "rocdl.s.wait.dscnt"

  _ODS_REGIONS = (0, True)

  def __init__(self, count, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["count"] = (count if (
    isinstance(count, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I16Attr')) else
      _ods_ir.AttrBuilder.get('I16Attr')(count, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def count(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["count"]

  @count.setter
  def count(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["count"] = value

def s_wait_dscnt(count, *, loc=None, ip=None) -> WaitDscntOp:
  return WaitDscntOp(count=count, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class WaitExpcntOp(_ods_ir.OpView):
  r"""
  Wait for the counter specified to be less-than or equal-to the `count`
  before continuing.
  
  Available on gfx12+.
  """

  OPERATION_NAME = "rocdl.s.wait.expcnt"

  _ODS_REGIONS = (0, True)

  def __init__(self, count, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["count"] = (count if (
    isinstance(count, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I16Attr')) else
      _ods_ir.AttrBuilder.get('I16Attr')(count, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def count(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["count"]

  @count.setter
  def count(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["count"] = value

def s_wait_expcnt(count, *, loc=None, ip=None) -> WaitExpcntOp:
  return WaitExpcntOp(count=count, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class WaitLoadcntOp(_ods_ir.OpView):
  r"""
  Wait for the counter specified to be less-than or equal-to the `count`
  before continuing.
  
  Available on gfx12+.
  """

  OPERATION_NAME = "rocdl.s.wait.loadcnt"

  _ODS_REGIONS = (0, True)

  def __init__(self, count, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["count"] = (count if (
    isinstance(count, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I16Attr')) else
      _ods_ir.AttrBuilder.get('I16Attr')(count, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def count(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["count"]

  @count.setter
  def count(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["count"] = value

def s_wait_loadcnt(count, *, loc=None, ip=None) -> WaitLoadcntOp:
  return WaitLoadcntOp(count=count, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class WaitStorecntOp(_ods_ir.OpView):
  r"""
  Wait for the counter specified to be less-than or equal-to the `count`
  before continuing.
  
  Available on gfx12+.
  """

  OPERATION_NAME = "rocdl.s.wait.storecnt"

  _ODS_REGIONS = (0, True)

  def __init__(self, count, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["count"] = (count if (
    isinstance(count, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I16Attr')) else
      _ods_ir.AttrBuilder.get('I16Attr')(count, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def count(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["count"]

  @count.setter
  def count(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["count"] = value

def s_wait_storecnt(count, *, loc=None, ip=None) -> WaitStorecntOp:
  return WaitStorecntOp(count=count, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class WaitTensorcntOp(_ods_ir.OpView):
  r"""
  Wait for the counter specified to be less-than or equal-to the `count`
  before continuing.
  
  Available on gfx1250+.
  """

  OPERATION_NAME = "rocdl.s.wait.tensorcnt"

  _ODS_REGIONS = (0, True)

  def __init__(self, count, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["count"] = (count if (
    isinstance(count, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I16Attr')) else
      _ods_ir.AttrBuilder.get('I16Attr')(count, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def count(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["count"]

  @count.setter
  def count(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["count"] = value

def s_wait_tensorcnt(count, *, loc=None, ip=None) -> WaitTensorcntOp:
  return WaitTensorcntOp(count=count, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class WakeupBarrierOp(_ods_ir.OpView):
  r"""
  Wakes up waves associated with a given named barrier. Note, This op does not release waves waiting
  at the barrier. It just signal other waves in the same work-group waiting on the indicated named barrier
  to wake up.
  Available on gfx1250+.
  """

  OPERATION_NAME = "rocdl.s.wakeup.barrier"

  _ODS_REGIONS = (0, True)

  def __init__(self, ptr, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(ptr)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def ptr(self) -> _ods_ir.Value:
    return self.operation.operands[0]

def s_wakeup_barrier(ptr, *, loc=None, ip=None) -> WakeupBarrierOp:
  return WakeupBarrierOp(ptr=ptr, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class WavefrontSizeOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.wavefrontsize"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, *, range=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if range is not None: attributes["range"] = (range if (
        isinstance(range, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_ConstantRangeAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_ConstantRangeAttr')(range, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def range(self) -> _Optional[_ods_ir.Attribute]:
    if "range" not in self.operation.attributes:
      return None
    return self.operation.attributes["range"]

  @range.setter
  def range(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["range"] = value
    elif "range" in self.operation.attributes:
      del self.operation.attributes["range"]

  @range.deleter
  def range(self):
    del self.operation.attributes["range"]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def wavefrontsize(res, *, range=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return WavefrontSizeOp(res=res, range=range, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ds_read_tr4_b64(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.ds.read.tr4.b64"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, ptr, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(ptr)
    _ods_context = _ods_get_default_loc_context(loc)
    if alias_scopes is not None: attributes["alias_scopes"] = (alias_scopes if (
        isinstance(alias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(alias_scopes, context=_ods_context))
    if noalias_scopes is not None: attributes["noalias_scopes"] = (noalias_scopes if (
        isinstance(noalias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(noalias_scopes, context=_ods_context))
    if tbaa is not None: attributes["tbaa"] = (tbaa if (
        isinstance(tbaa, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_TBAATagArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_TBAATagArrayAttr')(tbaa, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def ptr(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def alias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "alias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["alias_scopes"]

  @alias_scopes.setter
  def alias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["alias_scopes"] = value
    elif "alias_scopes" in self.operation.attributes:
      del self.operation.attributes["alias_scopes"]

  @alias_scopes.deleter
  def alias_scopes(self):
    del self.operation.attributes["alias_scopes"]

  @builtins.property
  def noalias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "noalias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["noalias_scopes"]

  @noalias_scopes.setter
  def noalias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["noalias_scopes"] = value
    elif "noalias_scopes" in self.operation.attributes:
      del self.operation.attributes["noalias_scopes"]

  @noalias_scopes.deleter
  def noalias_scopes(self):
    del self.operation.attributes["noalias_scopes"]

  @builtins.property
  def tbaa(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tbaa" not in self.operation.attributes:
      return None
    return self.operation.attributes["tbaa"]

  @tbaa.setter
  def tbaa(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tbaa"] = value
    elif "tbaa" in self.operation.attributes:
      del self.operation.attributes["tbaa"]

  @tbaa.deleter
  def tbaa(self):
    del self.operation.attributes["tbaa"]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def ds_read_tr4_b64_(res, ptr, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ds_read_tr4_b64(res=res, ptr=ptr, alias_scopes=alias_scopes, noalias_scopes=noalias_scopes, tbaa=tbaa, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ds_read_tr6_b96(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.ds.read.tr6.b96"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, ptr, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(ptr)
    _ods_context = _ods_get_default_loc_context(loc)
    if alias_scopes is not None: attributes["alias_scopes"] = (alias_scopes if (
        isinstance(alias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(alias_scopes, context=_ods_context))
    if noalias_scopes is not None: attributes["noalias_scopes"] = (noalias_scopes if (
        isinstance(noalias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(noalias_scopes, context=_ods_context))
    if tbaa is not None: attributes["tbaa"] = (tbaa if (
        isinstance(tbaa, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_TBAATagArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_TBAATagArrayAttr')(tbaa, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def ptr(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def alias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "alias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["alias_scopes"]

  @alias_scopes.setter
  def alias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["alias_scopes"] = value
    elif "alias_scopes" in self.operation.attributes:
      del self.operation.attributes["alias_scopes"]

  @alias_scopes.deleter
  def alias_scopes(self):
    del self.operation.attributes["alias_scopes"]

  @builtins.property
  def noalias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "noalias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["noalias_scopes"]

  @noalias_scopes.setter
  def noalias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["noalias_scopes"] = value
    elif "noalias_scopes" in self.operation.attributes:
      del self.operation.attributes["noalias_scopes"]

  @noalias_scopes.deleter
  def noalias_scopes(self):
    del self.operation.attributes["noalias_scopes"]

  @builtins.property
  def tbaa(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tbaa" not in self.operation.attributes:
      return None
    return self.operation.attributes["tbaa"]

  @tbaa.setter
  def tbaa(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tbaa"] = value
    elif "tbaa" in self.operation.attributes:
      del self.operation.attributes["tbaa"]

  @tbaa.deleter
  def tbaa(self):
    del self.operation.attributes["tbaa"]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def ds_read_tr6_b96_(res, ptr, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ds_read_tr6_b96(res=res, ptr=ptr, alias_scopes=alias_scopes, noalias_scopes=noalias_scopes, tbaa=tbaa, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ds_read_tr8_b64(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.ds.read.tr8.b64"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, ptr, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(ptr)
    _ods_context = _ods_get_default_loc_context(loc)
    if alias_scopes is not None: attributes["alias_scopes"] = (alias_scopes if (
        isinstance(alias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(alias_scopes, context=_ods_context))
    if noalias_scopes is not None: attributes["noalias_scopes"] = (noalias_scopes if (
        isinstance(noalias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(noalias_scopes, context=_ods_context))
    if tbaa is not None: attributes["tbaa"] = (tbaa if (
        isinstance(tbaa, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_TBAATagArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_TBAATagArrayAttr')(tbaa, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def ptr(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def alias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "alias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["alias_scopes"]

  @alias_scopes.setter
  def alias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["alias_scopes"] = value
    elif "alias_scopes" in self.operation.attributes:
      del self.operation.attributes["alias_scopes"]

  @alias_scopes.deleter
  def alias_scopes(self):
    del self.operation.attributes["alias_scopes"]

  @builtins.property
  def noalias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "noalias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["noalias_scopes"]

  @noalias_scopes.setter
  def noalias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["noalias_scopes"] = value
    elif "noalias_scopes" in self.operation.attributes:
      del self.operation.attributes["noalias_scopes"]

  @noalias_scopes.deleter
  def noalias_scopes(self):
    del self.operation.attributes["noalias_scopes"]

  @builtins.property
  def tbaa(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tbaa" not in self.operation.attributes:
      return None
    return self.operation.attributes["tbaa"]

  @tbaa.setter
  def tbaa(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tbaa"] = value
    elif "tbaa" in self.operation.attributes:
      del self.operation.attributes["tbaa"]

  @tbaa.deleter
  def tbaa(self):
    del self.operation.attributes["tbaa"]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def ds_read_tr8_b64_(res, ptr, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ds_read_tr8_b64(res=res, ptr=ptr, alias_scopes=alias_scopes, noalias_scopes=noalias_scopes, tbaa=tbaa, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ds_read_tr16_b64(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.ds.read.tr16.b64"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, ptr, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(ptr)
    _ods_context = _ods_get_default_loc_context(loc)
    if alias_scopes is not None: attributes["alias_scopes"] = (alias_scopes if (
        isinstance(alias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(alias_scopes, context=_ods_context))
    if noalias_scopes is not None: attributes["noalias_scopes"] = (noalias_scopes if (
        isinstance(noalias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(noalias_scopes, context=_ods_context))
    if tbaa is not None: attributes["tbaa"] = (tbaa if (
        isinstance(tbaa, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_TBAATagArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_TBAATagArrayAttr')(tbaa, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def ptr(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def alias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "alias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["alias_scopes"]

  @alias_scopes.setter
  def alias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["alias_scopes"] = value
    elif "alias_scopes" in self.operation.attributes:
      del self.operation.attributes["alias_scopes"]

  @alias_scopes.deleter
  def alias_scopes(self):
    del self.operation.attributes["alias_scopes"]

  @builtins.property
  def noalias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "noalias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["noalias_scopes"]

  @noalias_scopes.setter
  def noalias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["noalias_scopes"] = value
    elif "noalias_scopes" in self.operation.attributes:
      del self.operation.attributes["noalias_scopes"]

  @noalias_scopes.deleter
  def noalias_scopes(self):
    del self.operation.attributes["noalias_scopes"]

  @builtins.property
  def tbaa(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tbaa" not in self.operation.attributes:
      return None
    return self.operation.attributes["tbaa"]

  @tbaa.setter
  def tbaa(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tbaa"] = value
    elif "tbaa" in self.operation.attributes:
      del self.operation.attributes["tbaa"]

  @tbaa.deleter
  def tbaa(self):
    del self.operation.attributes["tbaa"]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def ds_read_tr16_b64_(res, ptr, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ds_read_tr16_b64(res=res, ptr=ptr, alias_scopes=alias_scopes, noalias_scopes=noalias_scopes, tbaa=tbaa, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_4x4x1f32(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.4x4x1f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_4x4x1f32_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_4x4x1f32(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_4x4x2bf16(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.4x4x2bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_4x4x2bf16_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_4x4x2bf16(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_4x4x4bf16_1k(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.4x4x4bf16.1k"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_4x4x4bf16_1k_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_4x4x4bf16_1k(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_4x4x4f16(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.4x4x4f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_4x4x4f16_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_4x4x4f16(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_16x16x1f32(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.16x16x1f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_16x16x1f32_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_16x16x1f32(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_16x16x2bf16(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.16x16x2bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_16x16x2bf16_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_16x16x2bf16(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_16x16x4bf16_1k(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.16x16x4bf16.1k"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_16x16x4bf16_1k_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_16x16x4bf16_1k(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_16x16x4f16(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.16x16x4f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_16x16x4f16_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_16x16x4f16(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_16x16x4f32(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.16x16x4f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_16x16x4f32_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_16x16x4f32(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_16x16x8_xf32(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.16x16x8.xf32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_16x16x8_xf32_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_16x16x8_xf32(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_16x16x8bf16(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.16x16x8bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_16x16x8bf16_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_16x16x8bf16(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_16x16x16bf16_1k(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.16x16x16bf16.1k"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_16x16x16bf16_1k_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_16x16x16bf16_1k(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_16x16x16f16(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.16x16x16f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_16x16x16f16_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_16x16x16f16(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_16x16x32_bf8_bf8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.16x16x32.bf8.bf8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_16x16x32_bf8_bf8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_16x16x32_bf8_bf8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_16x16x32_bf8_fp8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.16x16x32.bf8.fp8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_16x16x32_bf8_fp8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_16x16x32_bf8_fp8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_16x16x32_bf16(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.16x16x32.bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_16x16x32_bf16_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_16x16x32_bf16(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_16x16x32_f16(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.16x16x32.f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_16x16x32_f16_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_16x16x32_f16(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_16x16x32_fp8_bf8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.16x16x32.fp8.bf8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_16x16x32_fp8_bf8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_16x16x32_fp8_bf8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_16x16x32_fp8_fp8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.16x16x32.fp8.fp8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_16x16x32_fp8_fp8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_16x16x32_fp8_fp8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_32x32x1f32(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.32x32x1f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_32x32x1f32_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_32x32x1f32(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_32x32x2bf16(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.32x32x2bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_32x32x2bf16_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_32x32x2bf16(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_32x32x2f32(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.32x32x2f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_32x32x2f32_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_32x32x2f32(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_32x32x4_xf32(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.32x32x4.xf32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_32x32x4_xf32_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_32x32x4_xf32(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_32x32x4bf16(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.32x32x4bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_32x32x4bf16_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_32x32x4bf16(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_32x32x4bf16_1k(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.32x32x4bf16.1k"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_32x32x4bf16_1k_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_32x32x4bf16_1k(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_32x32x4f16(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.32x32x4f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_32x32x4f16_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_32x32x4f16(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_32x32x8bf16_1k(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.32x32x8bf16.1k"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_32x32x8bf16_1k_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_32x32x8bf16_1k(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_32x32x8f16(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.32x32x8f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_32x32x8f16_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_32x32x8f16(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_32x32x16_bf8_bf8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.32x32x16.bf8.bf8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_32x32x16_bf8_bf8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_32x32x16_bf8_bf8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_32x32x16_bf8_fp8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.32x32x16.bf8.fp8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_32x32x16_bf8_fp8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_32x32x16_bf8_fp8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_32x32x16_bf16(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.32x32x16.bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_32x32x16_bf16_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_32x32x16_bf16(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_32x32x16_f16(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.32x32x16.f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_32x32x16_f16_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_32x32x16_f16(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_32x32x16_fp8_bf8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.32x32x16.fp8.bf8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_32x32x16_fp8_bf8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_32x32x16_fp8_bf8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_32x32x16_fp8_fp8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.32x32x16.fp8.fp8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_32x32x16_fp8_fp8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_32x32x16_fp8_fp8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f64_4x4x4f64(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f64.4x4x4f64"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f64_4x4x4f64_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f64_4x4x4f64(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f64_16x16x4f64(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f64.16x16x4f64"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f64_16x16x4f64_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f64_16x16x4f64(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_i32_4x4x4i8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.i32.4x4x4i8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_i32_4x4x4i8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_i32_4x4x4i8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_i32_16x16x4i8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.i32.16x16x4i8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_i32_16x16x4i8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_i32_16x16x4i8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_i32_16x16x16i8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.i32.16x16x16i8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_i32_16x16x16i8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_i32_16x16x16i8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_i32_16x16x32_i8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.i32.16x16x32.i8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_i32_16x16x32_i8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_i32_16x16x32_i8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_i32_16x16x64_i8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.i32.16x16x64.i8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_i32_16x16x64_i8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_i32_16x16x64_i8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_i32_32x32x4i8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.i32.32x32x4i8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_i32_32x32x4i8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_i32_32x32x4i8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_i32_32x32x8i8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.i32.32x32x8i8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_i32_32x32x8i8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_i32_32x32x8i8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_i32_32x32x16_i8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.i32.32x32x16.i8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_i32_32x32x16_i8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_i32_32x32x16_i8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_i32_32x32x32_i8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.i32.32x32x32.i8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_i32_32x32x32_i8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_i32_32x32x32_i8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_scale_f32_16x16x128_f8f6f4(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.scale.f32.16x16x128.f8f6f4"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_scale_f32_16x16x128_f8f6f4_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_scale_f32_16x16x128_f8f6f4(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_scale_f32_32x32x64_f8f6f4(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.scale.f32.32x32x64.f8f6f4"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_scale_f32_32x32x64_f8f6f4_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_scale_f32_32x32x64_f8f6f4(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class smfmac_f32_16x16x32_bf16(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.smfmac.f32.16x16x32.bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def smfmac_f32_16x16x32_bf16_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return smfmac_f32_16x16x32_bf16(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class smfmac_f32_16x16x32_f16(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.smfmac.f32.16x16x32.f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def smfmac_f32_16x16x32_f16_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return smfmac_f32_16x16x32_f16(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class smfmac_f32_16x16x64_bf8_bf8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.smfmac.f32.16x16x64.bf8.bf8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def smfmac_f32_16x16x64_bf8_bf8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return smfmac_f32_16x16x64_bf8_bf8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class smfmac_f32_16x16x64_bf8_fp8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.smfmac.f32.16x16x64.bf8.fp8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def smfmac_f32_16x16x64_bf8_fp8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return smfmac_f32_16x16x64_bf8_fp8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class smfmac_f32_16x16x64_bf16(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.smfmac.f32.16x16x64.bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def smfmac_f32_16x16x64_bf16_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return smfmac_f32_16x16x64_bf16(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class smfmac_f32_16x16x64_f16(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.smfmac.f32.16x16x64.f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def smfmac_f32_16x16x64_f16_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return smfmac_f32_16x16x64_f16(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class smfmac_f32_16x16x64_fp8_bf8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.smfmac.f32.16x16x64.fp8.bf8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def smfmac_f32_16x16x64_fp8_bf8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return smfmac_f32_16x16x64_fp8_bf8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class smfmac_f32_16x16x64_fp8_fp8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.smfmac.f32.16x16x64.fp8.fp8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def smfmac_f32_16x16x64_fp8_fp8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return smfmac_f32_16x16x64_fp8_fp8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class smfmac_f32_16x16x128_bf8_bf8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.smfmac.f32.16x16x128.bf8.bf8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def smfmac_f32_16x16x128_bf8_bf8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return smfmac_f32_16x16x128_bf8_bf8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class smfmac_f32_16x16x128_bf8_fp8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.smfmac.f32.16x16x128.bf8.fp8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def smfmac_f32_16x16x128_bf8_fp8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return smfmac_f32_16x16x128_bf8_fp8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class smfmac_f32_16x16x128_fp8_bf8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.smfmac.f32.16x16x128.fp8.bf8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def smfmac_f32_16x16x128_fp8_bf8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return smfmac_f32_16x16x128_fp8_bf8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class smfmac_f32_16x16x128_fp8_fp8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.smfmac.f32.16x16x128.fp8.fp8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def smfmac_f32_16x16x128_fp8_fp8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return smfmac_f32_16x16x128_fp8_fp8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class smfmac_f32_32x32x16_bf16(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.smfmac.f32.32x32x16.bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def smfmac_f32_32x32x16_bf16_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return smfmac_f32_32x32x16_bf16(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class smfmac_f32_32x32x16_f16(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.smfmac.f32.32x32x16.f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def smfmac_f32_32x32x16_f16_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return smfmac_f32_32x32x16_f16(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class smfmac_f32_32x32x32_bf8_bf8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.smfmac.f32.32x32x32.bf8.bf8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def smfmac_f32_32x32x32_bf8_bf8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return smfmac_f32_32x32x32_bf8_bf8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class smfmac_f32_32x32x32_bf8_fp8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.smfmac.f32.32x32x32.bf8.fp8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def smfmac_f32_32x32x32_bf8_fp8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return smfmac_f32_32x32x32_bf8_fp8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class smfmac_f32_32x32x32_bf16(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.smfmac.f32.32x32x32.bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def smfmac_f32_32x32x32_bf16_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return smfmac_f32_32x32x32_bf16(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class smfmac_f32_32x32x32_f16(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.smfmac.f32.32x32x32.f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def smfmac_f32_32x32x32_f16_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return smfmac_f32_32x32x32_f16(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class smfmac_f32_32x32x32_fp8_bf8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.smfmac.f32.32x32x32.fp8.bf8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def smfmac_f32_32x32x32_fp8_bf8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return smfmac_f32_32x32x32_fp8_bf8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class smfmac_f32_32x32x32_fp8_fp8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.smfmac.f32.32x32x32.fp8.fp8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def smfmac_f32_32x32x32_fp8_fp8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return smfmac_f32_32x32x32_fp8_fp8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class smfmac_f32_32x32x64_bf8_bf8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.smfmac.f32.32x32x64.bf8.bf8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def smfmac_f32_32x32x64_bf8_bf8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return smfmac_f32_32x32x64_bf8_bf8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class smfmac_f32_32x32x64_bf8_fp8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.smfmac.f32.32x32x64.bf8.fp8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def smfmac_f32_32x32x64_bf8_fp8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return smfmac_f32_32x32x64_bf8_fp8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class smfmac_f32_32x32x64_fp8_bf8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.smfmac.f32.32x32x64.fp8.bf8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def smfmac_f32_32x32x64_fp8_bf8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return smfmac_f32_32x32x64_fp8_bf8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class smfmac_f32_32x32x64_fp8_fp8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.smfmac.f32.32x32x64.fp8.fp8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def smfmac_f32_32x32x64_fp8_fp8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return smfmac_f32_32x32x64_fp8_fp8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class smfmac_i32_16x16x64_i8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.smfmac.i32.16x16x64.i8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def smfmac_i32_16x16x64_i8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return smfmac_i32_16x16x64_i8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class smfmac_i32_16x16x128_i8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.smfmac.i32.16x16x128.i8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def smfmac_i32_16x16x128_i8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return smfmac_i32_16x16x128_i8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class smfmac_i32_32x32x32_i8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.smfmac.i32.32x32x32.i8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def smfmac_i32_32x32x32_i8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return smfmac_i32_32x32x32_i8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class smfmac_i32_32x32x64_i8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.smfmac.i32.32x32x64.i8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def smfmac_i32_32x32x64_i8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return smfmac_i32_32x32x64_i8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class wmma_bf16_16x16x16_bf16(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.wmma.bf16.16x16x16.bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, a, b, c, *, opsel=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    operands.append(c)
    _ods_context = _ods_get_default_loc_context(loc)
    if opsel is not None: attributes["opsel"] = (opsel if (
        isinstance(opsel, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(opsel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def b(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def c(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def opsel(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["opsel"]

  @opsel.setter
  def opsel(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["opsel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def wmma_bf16_16x16x16_bf16_(res, a, b, c, *, opsel=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return wmma_bf16_16x16x16_bf16(res=res, a=a, b=b, c=c, opsel=opsel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class wmma_bf16_16x16x32_bf16(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.wmma.bf16.16x16x32.bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, a, b, c, *, signA=None, signB=None, modC=None, reuseA=None, reuseB=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    operands.append(c)
    _ods_context = _ods_get_default_loc_context(loc)
    if signA is not None: attributes["signA"] = (signA if (
        isinstance(signA, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(signA, context=_ods_context))
    if signB is not None: attributes["signB"] = (signB if (
        isinstance(signB, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(signB, context=_ods_context))
    if modC is not None: attributes["modC"] = (modC if (
        isinstance(modC, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I16Attr')) else
          _ods_ir.AttrBuilder.get('I16Attr')(modC, context=_ods_context))
    if reuseA is not None: attributes["reuseA"] = (reuseA if (
        isinstance(reuseA, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(reuseA, context=_ods_context))
    if reuseB is not None: attributes["reuseB"] = (reuseB if (
        isinstance(reuseB, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(reuseB, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def b(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def c(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def signA(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["signA"]

  @signA.setter
  def signA(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["signA"] = value

  @builtins.property
  def signB(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["signB"]

  @signB.setter
  def signB(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["signB"] = value

  @builtins.property
  def modC(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["modC"]

  @modC.setter
  def modC(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["modC"] = value

  @builtins.property
  def reuseA(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["reuseA"]

  @reuseA.setter
  def reuseA(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reuseA"] = value

  @builtins.property
  def reuseB(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["reuseB"]

  @reuseB.setter
  def reuseB(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reuseB"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def wmma_bf16_16x16x32_bf16_(res, a, b, c, *, sign_a=None, sign_b=None, mod_c=None, reuse_a=None, reuse_b=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return wmma_bf16_16x16x32_bf16(res=res, a=a, b=b, c=c, signA=sign_a, signB=sign_b, modC=mod_c, reuseA=reuse_a, reuseB=reuse_b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class wmma_bf16f32_16x16x32_bf16(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.wmma.bf16f32.16x16x32.bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, a, b, c, *, signA=None, signB=None, modC=None, reuseA=None, reuseB=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    operands.append(c)
    _ods_context = _ods_get_default_loc_context(loc)
    if signA is not None: attributes["signA"] = (signA if (
        isinstance(signA, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(signA, context=_ods_context))
    if signB is not None: attributes["signB"] = (signB if (
        isinstance(signB, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(signB, context=_ods_context))
    if modC is not None: attributes["modC"] = (modC if (
        isinstance(modC, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I16Attr')) else
          _ods_ir.AttrBuilder.get('I16Attr')(modC, context=_ods_context))
    if reuseA is not None: attributes["reuseA"] = (reuseA if (
        isinstance(reuseA, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(reuseA, context=_ods_context))
    if reuseB is not None: attributes["reuseB"] = (reuseB if (
        isinstance(reuseB, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(reuseB, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def b(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def c(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def signA(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["signA"]

  @signA.setter
  def signA(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["signA"] = value

  @builtins.property
  def signB(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["signB"]

  @signB.setter
  def signB(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["signB"] = value

  @builtins.property
  def modC(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["modC"]

  @modC.setter
  def modC(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["modC"] = value

  @builtins.property
  def reuseA(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["reuseA"]

  @reuseA.setter
  def reuseA(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reuseA"] = value

  @builtins.property
  def reuseB(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["reuseB"]

  @reuseB.setter
  def reuseB(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reuseB"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def wmma_bf16f32_16x16x32_bf16_(res, a, b, c, *, sign_a=None, sign_b=None, mod_c=None, reuse_a=None, reuse_b=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return wmma_bf16f32_16x16x32_bf16(res=res, a=a, b=b, c=c, signA=sign_a, signB=sign_b, modC=mod_c, reuseA=reuse_a, reuseB=reuse_b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class wmma_f16_16x16x16_f16(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.wmma.f16.16x16x16.f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, a, b, c, *, opsel=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    operands.append(c)
    _ods_context = _ods_get_default_loc_context(loc)
    if opsel is not None: attributes["opsel"] = (opsel if (
        isinstance(opsel, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(opsel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def b(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def c(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def opsel(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["opsel"]

  @opsel.setter
  def opsel(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["opsel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def wmma_f16_16x16x16_f16_(res, a, b, c, *, opsel=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return wmma_f16_16x16x16_f16(res=res, a=a, b=b, c=c, opsel=opsel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class wmma_f16_16x16x32_f16(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.wmma.f16.16x16x32.f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, a, b, c, *, signA=None, signB=None, modC=None, reuseA=None, reuseB=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    operands.append(c)
    _ods_context = _ods_get_default_loc_context(loc)
    if signA is not None: attributes["signA"] = (signA if (
        isinstance(signA, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(signA, context=_ods_context))
    if signB is not None: attributes["signB"] = (signB if (
        isinstance(signB, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(signB, context=_ods_context))
    if modC is not None: attributes["modC"] = (modC if (
        isinstance(modC, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I16Attr')) else
          _ods_ir.AttrBuilder.get('I16Attr')(modC, context=_ods_context))
    if reuseA is not None: attributes["reuseA"] = (reuseA if (
        isinstance(reuseA, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(reuseA, context=_ods_context))
    if reuseB is not None: attributes["reuseB"] = (reuseB if (
        isinstance(reuseB, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(reuseB, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def b(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def c(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def signA(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["signA"]

  @signA.setter
  def signA(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["signA"] = value

  @builtins.property
  def signB(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["signB"]

  @signB.setter
  def signB(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["signB"] = value

  @builtins.property
  def modC(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["modC"]

  @modC.setter
  def modC(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["modC"] = value

  @builtins.property
  def reuseA(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["reuseA"]

  @reuseA.setter
  def reuseA(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reuseA"] = value

  @builtins.property
  def reuseB(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["reuseB"]

  @reuseB.setter
  def reuseB(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reuseB"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def wmma_f16_16x16x32_f16_(res, a, b, c, *, sign_a=None, sign_b=None, mod_c=None, reuse_a=None, reuse_b=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return wmma_f16_16x16x32_f16(res=res, a=a, b=b, c=c, signA=sign_a, signB=sign_b, modC=mod_c, reuseA=reuse_a, reuseB=reuse_b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class wmma_f16_16x16x64_bf8_bf8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.wmma.f16.16x16x64.bf8_bf8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, a, b, c, *, modC=None, reuseA=None, reuseB=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    operands.append(c)
    _ods_context = _ods_get_default_loc_context(loc)
    if modC is not None: attributes["modC"] = (modC if (
        isinstance(modC, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I16Attr')) else
          _ods_ir.AttrBuilder.get('I16Attr')(modC, context=_ods_context))
    if reuseA is not None: attributes["reuseA"] = (reuseA if (
        isinstance(reuseA, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(reuseA, context=_ods_context))
    if reuseB is not None: attributes["reuseB"] = (reuseB if (
        isinstance(reuseB, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(reuseB, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def b(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def c(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def modC(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["modC"]

  @modC.setter
  def modC(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["modC"] = value

  @builtins.property
  def reuseA(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["reuseA"]

  @reuseA.setter
  def reuseA(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reuseA"] = value

  @builtins.property
  def reuseB(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["reuseB"]

  @reuseB.setter
  def reuseB(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reuseB"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def wmma_f16_16x16x64_bf8_bf8_(res, a, b, c, *, mod_c=None, reuse_a=None, reuse_b=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return wmma_f16_16x16x64_bf8_bf8(res=res, a=a, b=b, c=c, modC=mod_c, reuseA=reuse_a, reuseB=reuse_b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class wmma_f16_16x16x64_bf8_fp8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.wmma.f16.16x16x64.bf8_fp8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, a, b, c, *, modC=None, reuseA=None, reuseB=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    operands.append(c)
    _ods_context = _ods_get_default_loc_context(loc)
    if modC is not None: attributes["modC"] = (modC if (
        isinstance(modC, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I16Attr')) else
          _ods_ir.AttrBuilder.get('I16Attr')(modC, context=_ods_context))
    if reuseA is not None: attributes["reuseA"] = (reuseA if (
        isinstance(reuseA, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(reuseA, context=_ods_context))
    if reuseB is not None: attributes["reuseB"] = (reuseB if (
        isinstance(reuseB, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(reuseB, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def b(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def c(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def modC(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["modC"]

  @modC.setter
  def modC(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["modC"] = value

  @builtins.property
  def reuseA(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["reuseA"]

  @reuseA.setter
  def reuseA(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reuseA"] = value

  @builtins.property
  def reuseB(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["reuseB"]

  @reuseB.setter
  def reuseB(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reuseB"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def wmma_f16_16x16x64_bf8_fp8_(res, a, b, c, *, mod_c=None, reuse_a=None, reuse_b=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return wmma_f16_16x16x64_bf8_fp8(res=res, a=a, b=b, c=c, modC=mod_c, reuseA=reuse_a, reuseB=reuse_b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class wmma_f16_16x16x64_fp8_bf8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.wmma.f16.16x16x64.fp8_bf8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, a, b, c, *, modC=None, reuseA=None, reuseB=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    operands.append(c)
    _ods_context = _ods_get_default_loc_context(loc)
    if modC is not None: attributes["modC"] = (modC if (
        isinstance(modC, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I16Attr')) else
          _ods_ir.AttrBuilder.get('I16Attr')(modC, context=_ods_context))
    if reuseA is not None: attributes["reuseA"] = (reuseA if (
        isinstance(reuseA, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(reuseA, context=_ods_context))
    if reuseB is not None: attributes["reuseB"] = (reuseB if (
        isinstance(reuseB, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(reuseB, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def b(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def c(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def modC(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["modC"]

  @modC.setter
  def modC(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["modC"] = value

  @builtins.property
  def reuseA(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["reuseA"]

  @reuseA.setter
  def reuseA(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reuseA"] = value

  @builtins.property
  def reuseB(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["reuseB"]

  @reuseB.setter
  def reuseB(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reuseB"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def wmma_f16_16x16x64_fp8_bf8_(res, a, b, c, *, mod_c=None, reuse_a=None, reuse_b=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return wmma_f16_16x16x64_fp8_bf8(res=res, a=a, b=b, c=c, modC=mod_c, reuseA=reuse_a, reuseB=reuse_b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class wmma_f16_16x16x64_fp8_fp8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.wmma.f16.16x16x64.fp8_fp8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, a, b, c, *, modC=None, reuseA=None, reuseB=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    operands.append(c)
    _ods_context = _ods_get_default_loc_context(loc)
    if modC is not None: attributes["modC"] = (modC if (
        isinstance(modC, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I16Attr')) else
          _ods_ir.AttrBuilder.get('I16Attr')(modC, context=_ods_context))
    if reuseA is not None: attributes["reuseA"] = (reuseA if (
        isinstance(reuseA, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(reuseA, context=_ods_context))
    if reuseB is not None: attributes["reuseB"] = (reuseB if (
        isinstance(reuseB, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(reuseB, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def b(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def c(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def modC(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["modC"]

  @modC.setter
  def modC(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["modC"] = value

  @builtins.property
  def reuseA(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["reuseA"]

  @reuseA.setter
  def reuseA(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reuseA"] = value

  @builtins.property
  def reuseB(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["reuseB"]

  @reuseB.setter
  def reuseB(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reuseB"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def wmma_f16_16x16x64_fp8_fp8_(res, a, b, c, *, mod_c=None, reuse_a=None, reuse_b=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return wmma_f16_16x16x64_fp8_fp8(res=res, a=a, b=b, c=c, modC=mod_c, reuseA=reuse_a, reuseB=reuse_b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class wmma_f16_16x16x128_bf8_bf8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.wmma.f16.16x16x128.bf8_bf8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, a, b, c, *, modC=None, reuseA=None, reuseB=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    operands.append(c)
    _ods_context = _ods_get_default_loc_context(loc)
    if modC is not None: attributes["modC"] = (modC if (
        isinstance(modC, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I16Attr')) else
          _ods_ir.AttrBuilder.get('I16Attr')(modC, context=_ods_context))
    if reuseA is not None: attributes["reuseA"] = (reuseA if (
        isinstance(reuseA, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(reuseA, context=_ods_context))
    if reuseB is not None: attributes["reuseB"] = (reuseB if (
        isinstance(reuseB, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(reuseB, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def b(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def c(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def modC(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["modC"]

  @modC.setter
  def modC(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["modC"] = value

  @builtins.property
  def reuseA(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["reuseA"]

  @reuseA.setter
  def reuseA(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reuseA"] = value

  @builtins.property
  def reuseB(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["reuseB"]

  @reuseB.setter
  def reuseB(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reuseB"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def wmma_f16_16x16x128_bf8_bf8_(res, a, b, c, *, mod_c=None, reuse_a=None, reuse_b=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return wmma_f16_16x16x128_bf8_bf8(res=res, a=a, b=b, c=c, modC=mod_c, reuseA=reuse_a, reuseB=reuse_b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class wmma_f16_16x16x128_bf8_fp8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.wmma.f16.16x16x128.bf8_fp8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, a, b, c, *, modC=None, reuseA=None, reuseB=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    operands.append(c)
    _ods_context = _ods_get_default_loc_context(loc)
    if modC is not None: attributes["modC"] = (modC if (
        isinstance(modC, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I16Attr')) else
          _ods_ir.AttrBuilder.get('I16Attr')(modC, context=_ods_context))
    if reuseA is not None: attributes["reuseA"] = (reuseA if (
        isinstance(reuseA, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(reuseA, context=_ods_context))
    if reuseB is not None: attributes["reuseB"] = (reuseB if (
        isinstance(reuseB, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(reuseB, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def b(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def c(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def modC(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["modC"]

  @modC.setter
  def modC(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["modC"] = value

  @builtins.property
  def reuseA(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["reuseA"]

  @reuseA.setter
  def reuseA(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reuseA"] = value

  @builtins.property
  def reuseB(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["reuseB"]

  @reuseB.setter
  def reuseB(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reuseB"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def wmma_f16_16x16x128_bf8_fp8_(res, a, b, c, *, mod_c=None, reuse_a=None, reuse_b=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return wmma_f16_16x16x128_bf8_fp8(res=res, a=a, b=b, c=c, modC=mod_c, reuseA=reuse_a, reuseB=reuse_b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class wmma_f16_16x16x128_fp8_bf8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.wmma.f16.16x16x128.fp8_bf8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, a, b, c, *, modC=None, reuseA=None, reuseB=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    operands.append(c)
    _ods_context = _ods_get_default_loc_context(loc)
    if modC is not None: attributes["modC"] = (modC if (
        isinstance(modC, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I16Attr')) else
          _ods_ir.AttrBuilder.get('I16Attr')(modC, context=_ods_context))
    if reuseA is not None: attributes["reuseA"] = (reuseA if (
        isinstance(reuseA, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(reuseA, context=_ods_context))
    if reuseB is not None: attributes["reuseB"] = (reuseB if (
        isinstance(reuseB, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(reuseB, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def b(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def c(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def modC(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["modC"]

  @modC.setter
  def modC(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["modC"] = value

  @builtins.property
  def reuseA(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["reuseA"]

  @reuseA.setter
  def reuseA(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reuseA"] = value

  @builtins.property
  def reuseB(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["reuseB"]

  @reuseB.setter
  def reuseB(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reuseB"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def wmma_f16_16x16x128_fp8_bf8_(res, a, b, c, *, mod_c=None, reuse_a=None, reuse_b=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return wmma_f16_16x16x128_fp8_bf8(res=res, a=a, b=b, c=c, modC=mod_c, reuseA=reuse_a, reuseB=reuse_b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class wmma_f16_16x16x128_fp8_fp8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.wmma.f16.16x16x128.fp8_fp8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, a, b, c, *, modC=None, reuseA=None, reuseB=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    operands.append(c)
    _ods_context = _ods_get_default_loc_context(loc)
    if modC is not None: attributes["modC"] = (modC if (
        isinstance(modC, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I16Attr')) else
          _ods_ir.AttrBuilder.get('I16Attr')(modC, context=_ods_context))
    if reuseA is not None: attributes["reuseA"] = (reuseA if (
        isinstance(reuseA, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(reuseA, context=_ods_context))
    if reuseB is not None: attributes["reuseB"] = (reuseB if (
        isinstance(reuseB, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(reuseB, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def b(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def c(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def modC(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["modC"]

  @modC.setter
  def modC(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["modC"] = value

  @builtins.property
  def reuseA(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["reuseA"]

  @reuseA.setter
  def reuseA(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reuseA"] = value

  @builtins.property
  def reuseB(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["reuseB"]

  @reuseB.setter
  def reuseB(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reuseB"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def wmma_f16_16x16x128_fp8_fp8_(res, a, b, c, *, mod_c=None, reuse_a=None, reuse_b=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return wmma_f16_16x16x128_fp8_fp8(res=res, a=a, b=b, c=c, modC=mod_c, reuseA=reuse_a, reuseB=reuse_b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class wmma_f32_16x16x4_f32(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.wmma.f32.16x16x4.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, a, b, c, *, signA=None, signB=None, modC=None, reuseA=None, reuseB=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    operands.append(c)
    _ods_context = _ods_get_default_loc_context(loc)
    if signA is not None: attributes["signA"] = (signA if (
        isinstance(signA, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(signA, context=_ods_context))
    if signB is not None: attributes["signB"] = (signB if (
        isinstance(signB, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(signB, context=_ods_context))
    if modC is not None: attributes["modC"] = (modC if (
        isinstance(modC, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I16Attr')) else
          _ods_ir.AttrBuilder.get('I16Attr')(modC, context=_ods_context))
    if reuseA is not None: attributes["reuseA"] = (reuseA if (
        isinstance(reuseA, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(reuseA, context=_ods_context))
    if reuseB is not None: attributes["reuseB"] = (reuseB if (
        isinstance(reuseB, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(reuseB, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def b(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def c(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def signA(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["signA"]

  @signA.setter
  def signA(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["signA"] = value

  @builtins.property
  def signB(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["signB"]

  @signB.setter
  def signB(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["signB"] = value

  @builtins.property
  def modC(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["modC"]

  @modC.setter
  def modC(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["modC"] = value

  @builtins.property
  def reuseA(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["reuseA"]

  @reuseA.setter
  def reuseA(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reuseA"] = value

  @builtins.property
  def reuseB(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["reuseB"]

  @reuseB.setter
  def reuseB(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reuseB"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def wmma_f32_16x16x4_f32_(res, a, b, c, *, sign_a=None, sign_b=None, mod_c=None, reuse_a=None, reuse_b=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return wmma_f32_16x16x4_f32(res=res, a=a, b=b, c=c, signA=sign_a, signB=sign_b, modC=mod_c, reuseA=reuse_a, reuseB=reuse_b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class wmma_f32_16x16x16_bf8_bf8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.wmma.f32.16x16x16.bf8_bf8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, a, b, c, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    operands.append(c)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def b(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def c(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def wmma_f32_16x16x16_bf8_bf8_(res, a, b, c, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return wmma_f32_16x16x16_bf8_bf8(res=res, a=a, b=b, c=c, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class wmma_f32_16x16x16_bf8_fp8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.wmma.f32.16x16x16.bf8_fp8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, a, b, c, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    operands.append(c)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def b(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def c(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def wmma_f32_16x16x16_bf8_fp8_(res, a, b, c, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return wmma_f32_16x16x16_bf8_fp8(res=res, a=a, b=b, c=c, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class wmma_f32_16x16x16_bf16(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.wmma.f32.16x16x16.bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, a, b, c, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    operands.append(c)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def b(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def c(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def wmma_f32_16x16x16_bf16_(res, a, b, c, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return wmma_f32_16x16x16_bf16(res=res, a=a, b=b, c=c, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class wmma_f32_16x16x16_f16(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.wmma.f32.16x16x16.f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, a, b, c, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    operands.append(c)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def b(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def c(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def wmma_f32_16x16x16_f16_(res, a, b, c, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return wmma_f32_16x16x16_f16(res=res, a=a, b=b, c=c, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class wmma_f32_16x16x16_fp8_bf8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.wmma.f32.16x16x16.fp8_bf8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, a, b, c, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    operands.append(c)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def b(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def c(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def wmma_f32_16x16x16_fp8_bf8_(res, a, b, c, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return wmma_f32_16x16x16_fp8_bf8(res=res, a=a, b=b, c=c, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class wmma_f32_16x16x16_fp8_fp8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.wmma.f32.16x16x16.fp8_fp8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, a, b, c, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    operands.append(c)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def b(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def c(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def wmma_f32_16x16x16_fp8_fp8_(res, a, b, c, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return wmma_f32_16x16x16_fp8_fp8(res=res, a=a, b=b, c=c, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class wmma_f32_16x16x32_bf16(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.wmma.f32.16x16x32.bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, a, b, c, *, signA=None, signB=None, modC=None, reuseA=None, reuseB=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    operands.append(c)
    _ods_context = _ods_get_default_loc_context(loc)
    if signA is not None: attributes["signA"] = (signA if (
        isinstance(signA, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(signA, context=_ods_context))
    if signB is not None: attributes["signB"] = (signB if (
        isinstance(signB, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(signB, context=_ods_context))
    if modC is not None: attributes["modC"] = (modC if (
        isinstance(modC, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I16Attr')) else
          _ods_ir.AttrBuilder.get('I16Attr')(modC, context=_ods_context))
    if reuseA is not None: attributes["reuseA"] = (reuseA if (
        isinstance(reuseA, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(reuseA, context=_ods_context))
    if reuseB is not None: attributes["reuseB"] = (reuseB if (
        isinstance(reuseB, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(reuseB, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def b(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def c(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def signA(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["signA"]

  @signA.setter
  def signA(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["signA"] = value

  @builtins.property
  def signB(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["signB"]

  @signB.setter
  def signB(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["signB"] = value

  @builtins.property
  def modC(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["modC"]

  @modC.setter
  def modC(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["modC"] = value

  @builtins.property
  def reuseA(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["reuseA"]

  @reuseA.setter
  def reuseA(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reuseA"] = value

  @builtins.property
  def reuseB(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["reuseB"]

  @reuseB.setter
  def reuseB(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reuseB"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def wmma_f32_16x16x32_bf16_(res, a, b, c, *, sign_a=None, sign_b=None, mod_c=None, reuse_a=None, reuse_b=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return wmma_f32_16x16x32_bf16(res=res, a=a, b=b, c=c, signA=sign_a, signB=sign_b, modC=mod_c, reuseA=reuse_a, reuseB=reuse_b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class wmma_f32_16x16x32_f16(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.wmma.f32.16x16x32.f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, a, b, c, *, signA=None, signB=None, modC=None, reuseA=None, reuseB=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    operands.append(c)
    _ods_context = _ods_get_default_loc_context(loc)
    if signA is not None: attributes["signA"] = (signA if (
        isinstance(signA, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(signA, context=_ods_context))
    if signB is not None: attributes["signB"] = (signB if (
        isinstance(signB, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(signB, context=_ods_context))
    if modC is not None: attributes["modC"] = (modC if (
        isinstance(modC, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I16Attr')) else
          _ods_ir.AttrBuilder.get('I16Attr')(modC, context=_ods_context))
    if reuseA is not None: attributes["reuseA"] = (reuseA if (
        isinstance(reuseA, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(reuseA, context=_ods_context))
    if reuseB is not None: attributes["reuseB"] = (reuseB if (
        isinstance(reuseB, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(reuseB, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def b(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def c(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def signA(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["signA"]

  @signA.setter
  def signA(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["signA"] = value

  @builtins.property
  def signB(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["signB"]

  @signB.setter
  def signB(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["signB"] = value

  @builtins.property
  def modC(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["modC"]

  @modC.setter
  def modC(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["modC"] = value

  @builtins.property
  def reuseA(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["reuseA"]

  @reuseA.setter
  def reuseA(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reuseA"] = value

  @builtins.property
  def reuseB(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["reuseB"]

  @reuseB.setter
  def reuseB(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reuseB"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def wmma_f32_16x16x32_f16_(res, a, b, c, *, sign_a=None, sign_b=None, mod_c=None, reuse_a=None, reuse_b=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return wmma_f32_16x16x32_f16(res=res, a=a, b=b, c=c, signA=sign_a, signB=sign_b, modC=mod_c, reuseA=reuse_a, reuseB=reuse_b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class wmma_f32_16x16x64_bf8_bf8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.wmma.f32.16x16x64.bf8_bf8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, a, b, c, *, modC=None, reuseA=None, reuseB=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    operands.append(c)
    _ods_context = _ods_get_default_loc_context(loc)
    if modC is not None: attributes["modC"] = (modC if (
        isinstance(modC, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I16Attr')) else
          _ods_ir.AttrBuilder.get('I16Attr')(modC, context=_ods_context))
    if reuseA is not None: attributes["reuseA"] = (reuseA if (
        isinstance(reuseA, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(reuseA, context=_ods_context))
    if reuseB is not None: attributes["reuseB"] = (reuseB if (
        isinstance(reuseB, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(reuseB, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def b(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def c(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def modC(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["modC"]

  @modC.setter
  def modC(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["modC"] = value

  @builtins.property
  def reuseA(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["reuseA"]

  @reuseA.setter
  def reuseA(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reuseA"] = value

  @builtins.property
  def reuseB(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["reuseB"]

  @reuseB.setter
  def reuseB(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reuseB"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def wmma_f32_16x16x64_bf8_bf8_(res, a, b, c, *, mod_c=None, reuse_a=None, reuse_b=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return wmma_f32_16x16x64_bf8_bf8(res=res, a=a, b=b, c=c, modC=mod_c, reuseA=reuse_a, reuseB=reuse_b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class wmma_f32_16x16x64_bf8_fp8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.wmma.f32.16x16x64.bf8_fp8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, a, b, c, *, modC=None, reuseA=None, reuseB=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    operands.append(c)
    _ods_context = _ods_get_default_loc_context(loc)
    if modC is not None: attributes["modC"] = (modC if (
        isinstance(modC, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I16Attr')) else
          _ods_ir.AttrBuilder.get('I16Attr')(modC, context=_ods_context))
    if reuseA is not None: attributes["reuseA"] = (reuseA if (
        isinstance(reuseA, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(reuseA, context=_ods_context))
    if reuseB is not None: attributes["reuseB"] = (reuseB if (
        isinstance(reuseB, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(reuseB, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def b(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def c(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def modC(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["modC"]

  @modC.setter
  def modC(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["modC"] = value

  @builtins.property
  def reuseA(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["reuseA"]

  @reuseA.setter
  def reuseA(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reuseA"] = value

  @builtins.property
  def reuseB(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["reuseB"]

  @reuseB.setter
  def reuseB(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reuseB"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def wmma_f32_16x16x64_bf8_fp8_(res, a, b, c, *, mod_c=None, reuse_a=None, reuse_b=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return wmma_f32_16x16x64_bf8_fp8(res=res, a=a, b=b, c=c, modC=mod_c, reuseA=reuse_a, reuseB=reuse_b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class wmma_f32_16x16x64_fp8_bf8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.wmma.f32.16x16x64.fp8_bf8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, a, b, c, *, modC=None, reuseA=None, reuseB=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    operands.append(c)
    _ods_context = _ods_get_default_loc_context(loc)
    if modC is not None: attributes["modC"] = (modC if (
        isinstance(modC, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I16Attr')) else
          _ods_ir.AttrBuilder.get('I16Attr')(modC, context=_ods_context))
    if reuseA is not None: attributes["reuseA"] = (reuseA if (
        isinstance(reuseA, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(reuseA, context=_ods_context))
    if reuseB is not None: attributes["reuseB"] = (reuseB if (
        isinstance(reuseB, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(reuseB, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def b(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def c(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def modC(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["modC"]

  @modC.setter
  def modC(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["modC"] = value

  @builtins.property
  def reuseA(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["reuseA"]

  @reuseA.setter
  def reuseA(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reuseA"] = value

  @builtins.property
  def reuseB(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["reuseB"]

  @reuseB.setter
  def reuseB(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reuseB"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def wmma_f32_16x16x64_fp8_bf8_(res, a, b, c, *, mod_c=None, reuse_a=None, reuse_b=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return wmma_f32_16x16x64_fp8_bf8(res=res, a=a, b=b, c=c, modC=mod_c, reuseA=reuse_a, reuseB=reuse_b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class wmma_f32_16x16x64_fp8_fp8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.wmma.f32.16x16x64.fp8_fp8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, a, b, c, *, modC=None, reuseA=None, reuseB=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    operands.append(c)
    _ods_context = _ods_get_default_loc_context(loc)
    if modC is not None: attributes["modC"] = (modC if (
        isinstance(modC, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I16Attr')) else
          _ods_ir.AttrBuilder.get('I16Attr')(modC, context=_ods_context))
    if reuseA is not None: attributes["reuseA"] = (reuseA if (
        isinstance(reuseA, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(reuseA, context=_ods_context))
    if reuseB is not None: attributes["reuseB"] = (reuseB if (
        isinstance(reuseB, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(reuseB, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def b(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def c(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def modC(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["modC"]

  @modC.setter
  def modC(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["modC"] = value

  @builtins.property
  def reuseA(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["reuseA"]

  @reuseA.setter
  def reuseA(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reuseA"] = value

  @builtins.property
  def reuseB(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["reuseB"]

  @reuseB.setter
  def reuseB(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reuseB"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def wmma_f32_16x16x64_fp8_fp8_(res, a, b, c, *, mod_c=None, reuse_a=None, reuse_b=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return wmma_f32_16x16x64_fp8_fp8(res=res, a=a, b=b, c=c, modC=mod_c, reuseA=reuse_a, reuseB=reuse_b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class wmma_f32_16x16x128_bf8_bf8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.wmma.f32.16x16x128.bf8_bf8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, a, b, c, *, modC=None, reuseA=None, reuseB=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    operands.append(c)
    _ods_context = _ods_get_default_loc_context(loc)
    if modC is not None: attributes["modC"] = (modC if (
        isinstance(modC, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I16Attr')) else
          _ods_ir.AttrBuilder.get('I16Attr')(modC, context=_ods_context))
    if reuseA is not None: attributes["reuseA"] = (reuseA if (
        isinstance(reuseA, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(reuseA, context=_ods_context))
    if reuseB is not None: attributes["reuseB"] = (reuseB if (
        isinstance(reuseB, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(reuseB, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def b(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def c(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def modC(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["modC"]

  @modC.setter
  def modC(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["modC"] = value

  @builtins.property
  def reuseA(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["reuseA"]

  @reuseA.setter
  def reuseA(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reuseA"] = value

  @builtins.property
  def reuseB(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["reuseB"]

  @reuseB.setter
  def reuseB(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reuseB"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def wmma_f32_16x16x128_bf8_bf8_(res, a, b, c, *, mod_c=None, reuse_a=None, reuse_b=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return wmma_f32_16x16x128_bf8_bf8(res=res, a=a, b=b, c=c, modC=mod_c, reuseA=reuse_a, reuseB=reuse_b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class wmma_f32_16x16x128_bf8_fp8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.wmma.f32.16x16x128.bf8_fp8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, a, b, c, *, modC=None, reuseA=None, reuseB=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    operands.append(c)
    _ods_context = _ods_get_default_loc_context(loc)
    if modC is not None: attributes["modC"] = (modC if (
        isinstance(modC, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I16Attr')) else
          _ods_ir.AttrBuilder.get('I16Attr')(modC, context=_ods_context))
    if reuseA is not None: attributes["reuseA"] = (reuseA if (
        isinstance(reuseA, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(reuseA, context=_ods_context))
    if reuseB is not None: attributes["reuseB"] = (reuseB if (
        isinstance(reuseB, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(reuseB, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def b(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def c(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def modC(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["modC"]

  @modC.setter
  def modC(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["modC"] = value

  @builtins.property
  def reuseA(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["reuseA"]

  @reuseA.setter
  def reuseA(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reuseA"] = value

  @builtins.property
  def reuseB(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["reuseB"]

  @reuseB.setter
  def reuseB(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reuseB"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def wmma_f32_16x16x128_bf8_fp8_(res, a, b, c, *, mod_c=None, reuse_a=None, reuse_b=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return wmma_f32_16x16x128_bf8_fp8(res=res, a=a, b=b, c=c, modC=mod_c, reuseA=reuse_a, reuseB=reuse_b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class wmma_f32_16x16x128_fp8_bf8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.wmma.f32.16x16x128.fp8_bf8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, a, b, c, *, modC=None, reuseA=None, reuseB=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    operands.append(c)
    _ods_context = _ods_get_default_loc_context(loc)
    if modC is not None: attributes["modC"] = (modC if (
        isinstance(modC, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I16Attr')) else
          _ods_ir.AttrBuilder.get('I16Attr')(modC, context=_ods_context))
    if reuseA is not None: attributes["reuseA"] = (reuseA if (
        isinstance(reuseA, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(reuseA, context=_ods_context))
    if reuseB is not None: attributes["reuseB"] = (reuseB if (
        isinstance(reuseB, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(reuseB, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def b(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def c(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def modC(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["modC"]

  @modC.setter
  def modC(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["modC"] = value

  @builtins.property
  def reuseA(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["reuseA"]

  @reuseA.setter
  def reuseA(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reuseA"] = value

  @builtins.property
  def reuseB(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["reuseB"]

  @reuseB.setter
  def reuseB(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reuseB"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def wmma_f32_16x16x128_fp8_bf8_(res, a, b, c, *, mod_c=None, reuse_a=None, reuse_b=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return wmma_f32_16x16x128_fp8_bf8(res=res, a=a, b=b, c=c, modC=mod_c, reuseA=reuse_a, reuseB=reuse_b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class wmma_f32_16x16x128_fp8_fp8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.wmma.f32.16x16x128.fp8_fp8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, a, b, c, *, modC=None, reuseA=None, reuseB=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    operands.append(c)
    _ods_context = _ods_get_default_loc_context(loc)
    if modC is not None: attributes["modC"] = (modC if (
        isinstance(modC, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I16Attr')) else
          _ods_ir.AttrBuilder.get('I16Attr')(modC, context=_ods_context))
    if reuseA is not None: attributes["reuseA"] = (reuseA if (
        isinstance(reuseA, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(reuseA, context=_ods_context))
    if reuseB is not None: attributes["reuseB"] = (reuseB if (
        isinstance(reuseB, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(reuseB, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def b(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def c(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def modC(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["modC"]

  @modC.setter
  def modC(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["modC"] = value

  @builtins.property
  def reuseA(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["reuseA"]

  @reuseA.setter
  def reuseA(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reuseA"] = value

  @builtins.property
  def reuseB(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["reuseB"]

  @reuseB.setter
  def reuseB(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reuseB"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def wmma_f32_16x16x128_fp8_fp8_(res, a, b, c, *, mod_c=None, reuse_a=None, reuse_b=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return wmma_f32_16x16x128_fp8_fp8(res=res, a=a, b=b, c=c, modC=mod_c, reuseA=reuse_a, reuseB=reuse_b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class wmma_i32_16x16x16_iu4(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.wmma.i32.16x16x16.iu4"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, a, b, c, *, signA=None, signB=None, clamp=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    operands.append(c)
    _ods_context = _ods_get_default_loc_context(loc)
    if signA is not None: attributes["signA"] = (signA if (
        isinstance(signA, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(signA, context=_ods_context))
    if signB is not None: attributes["signB"] = (signB if (
        isinstance(signB, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(signB, context=_ods_context))
    if clamp is not None: attributes["clamp"] = (clamp if (
        isinstance(clamp, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(clamp, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def b(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def c(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def signA(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["signA"]

  @signA.setter
  def signA(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["signA"] = value

  @builtins.property
  def signB(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["signB"]

  @signB.setter
  def signB(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["signB"] = value

  @builtins.property
  def clamp(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["clamp"]

  @clamp.setter
  def clamp(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["clamp"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def wmma_i32_16x16x16_iu4_(res, a, b, c, *, sign_a=None, sign_b=None, clamp=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return wmma_i32_16x16x16_iu4(res=res, a=a, b=b, c=c, signA=sign_a, signB=sign_b, clamp=clamp, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class wmma_i32_16x16x16_iu8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.wmma.i32.16x16x16.iu8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, a, b, c, *, signA=None, signB=None, clamp=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    operands.append(c)
    _ods_context = _ods_get_default_loc_context(loc)
    if signA is not None: attributes["signA"] = (signA if (
        isinstance(signA, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(signA, context=_ods_context))
    if signB is not None: attributes["signB"] = (signB if (
        isinstance(signB, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(signB, context=_ods_context))
    if clamp is not None: attributes["clamp"] = (clamp if (
        isinstance(clamp, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(clamp, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def b(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def c(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def signA(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["signA"]

  @signA.setter
  def signA(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["signA"] = value

  @builtins.property
  def signB(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["signB"]

  @signB.setter
  def signB(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["signB"] = value

  @builtins.property
  def clamp(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["clamp"]

  @clamp.setter
  def clamp(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["clamp"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def wmma_i32_16x16x16_iu8_(res, a, b, c, *, sign_a=None, sign_b=None, clamp=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return wmma_i32_16x16x16_iu8(res=res, a=a, b=b, c=c, signA=sign_a, signB=sign_b, clamp=clamp, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class wmma_i32_16x16x32_iu4(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.wmma.i32.16x16x32.iu4"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, a, b, c, *, signA=None, signB=None, clamp=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    operands.append(c)
    _ods_context = _ods_get_default_loc_context(loc)
    if signA is not None: attributes["signA"] = (signA if (
        isinstance(signA, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(signA, context=_ods_context))
    if signB is not None: attributes["signB"] = (signB if (
        isinstance(signB, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(signB, context=_ods_context))
    if clamp is not None: attributes["clamp"] = (clamp if (
        isinstance(clamp, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(clamp, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def b(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def c(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def signA(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["signA"]

  @signA.setter
  def signA(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["signA"] = value

  @builtins.property
  def signB(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["signB"]

  @signB.setter
  def signB(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["signB"] = value

  @builtins.property
  def clamp(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["clamp"]

  @clamp.setter
  def clamp(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["clamp"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def wmma_i32_16x16x32_iu4_(res, a, b, c, *, sign_a=None, sign_b=None, clamp=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return wmma_i32_16x16x32_iu4(res=res, a=a, b=b, c=c, signA=sign_a, signB=sign_b, clamp=clamp, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class wmma_i32_16x16x64_iu8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.wmma.i32.16x16x64.iu8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, a, b, c, *, signA=None, signB=None, reuseA=None, reuseB=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    operands.append(c)
    _ods_context = _ods_get_default_loc_context(loc)
    if signA is not None: attributes["signA"] = (signA if (
        isinstance(signA, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(signA, context=_ods_context))
    if signB is not None: attributes["signB"] = (signB if (
        isinstance(signB, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(signB, context=_ods_context))
    if reuseA is not None: attributes["reuseA"] = (reuseA if (
        isinstance(reuseA, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(reuseA, context=_ods_context))
    if reuseB is not None: attributes["reuseB"] = (reuseB if (
        isinstance(reuseB, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(reuseB, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def b(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def c(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def signA(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["signA"]

  @signA.setter
  def signA(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["signA"] = value

  @builtins.property
  def signB(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["signB"]

  @signB.setter
  def signB(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["signB"] = value

  @builtins.property
  def reuseA(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["reuseA"]

  @reuseA.setter
  def reuseA(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reuseA"] = value

  @builtins.property
  def reuseB(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["reuseB"]

  @reuseB.setter
  def reuseB(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reuseB"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def wmma_i32_16x16x64_iu8_(res, a, b, c, *, sign_a=None, sign_b=None, reuse_a=None, reuse_b=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return wmma_i32_16x16x64_iu8(res=res, a=a, b=b, c=c, signA=sign_a, signB=sign_b, reuseA=reuse_a, reuseB=reuse_b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class wmma_scale16_f32_16x16x128_f8f6f4(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.wmma.scale16.f32.16x16x128.f8f6f4"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, a, b, c, scaleA, scaleB, *, fmtA=None, fmtB=None, modC=None, scaleAType=None, fmtScaleA=None, scaleBType=None, fmtScaleB=None, reuseA=None, reuseB=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    operands.append(c)
    operands.append(scaleA)
    operands.append(scaleB)
    _ods_context = _ods_get_default_loc_context(loc)
    if fmtA is not None: attributes["fmtA"] = (fmtA if (
        isinstance(fmtA, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(fmtA, context=_ods_context))
    if fmtB is not None: attributes["fmtB"] = (fmtB if (
        isinstance(fmtB, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(fmtB, context=_ods_context))
    if modC is not None: attributes["modC"] = (modC if (
        isinstance(modC, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I16Attr')) else
          _ods_ir.AttrBuilder.get('I16Attr')(modC, context=_ods_context))
    if scaleAType is not None: attributes["scaleAType"] = (scaleAType if (
        isinstance(scaleAType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(scaleAType, context=_ods_context))
    if fmtScaleA is not None: attributes["fmtScaleA"] = (fmtScaleA if (
        isinstance(fmtScaleA, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(fmtScaleA, context=_ods_context))
    if scaleBType is not None: attributes["scaleBType"] = (scaleBType if (
        isinstance(scaleBType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(scaleBType, context=_ods_context))
    if fmtScaleB is not None: attributes["fmtScaleB"] = (fmtScaleB if (
        isinstance(fmtScaleB, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(fmtScaleB, context=_ods_context))
    if reuseA is not None: attributes["reuseA"] = (reuseA if (
        isinstance(reuseA, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(reuseA, context=_ods_context))
    if reuseB is not None: attributes["reuseB"] = (reuseB if (
        isinstance(reuseB, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(reuseB, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def b(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def c(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def scaleA(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[3]

  @builtins.property
  def scaleB(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[4]

  @builtins.property
  def fmtA(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["fmtA"]

  @fmtA.setter
  def fmtA(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fmtA"] = value

  @builtins.property
  def fmtB(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["fmtB"]

  @fmtB.setter
  def fmtB(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fmtB"] = value

  @builtins.property
  def modC(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["modC"]

  @modC.setter
  def modC(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["modC"] = value

  @builtins.property
  def scaleAType(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["scaleAType"]

  @scaleAType.setter
  def scaleAType(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scaleAType"] = value

  @builtins.property
  def fmtScaleA(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["fmtScaleA"]

  @fmtScaleA.setter
  def fmtScaleA(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fmtScaleA"] = value

  @builtins.property
  def scaleBType(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["scaleBType"]

  @scaleBType.setter
  def scaleBType(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scaleBType"] = value

  @builtins.property
  def fmtScaleB(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["fmtScaleB"]

  @fmtScaleB.setter
  def fmtScaleB(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fmtScaleB"] = value

  @builtins.property
  def reuseA(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["reuseA"]

  @reuseA.setter
  def reuseA(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reuseA"] = value

  @builtins.property
  def reuseB(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["reuseB"]

  @reuseB.setter
  def reuseB(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reuseB"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def wmma_scale16_f32_16x16x128_f8f6f4_(res, a, b, c, scale_a, scale_b, *, fmt_a=None, fmt_b=None, mod_c=None, scale_a_type=None, fmt_scale_a=None, scale_b_type=None, fmt_scale_b=None, reuse_a=None, reuse_b=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return wmma_scale16_f32_16x16x128_f8f6f4(res=res, a=a, b=b, c=c, scaleA=scale_a, scaleB=scale_b, fmtA=fmt_a, fmtB=fmt_b, modC=mod_c, scaleAType=scale_a_type, fmtScaleA=fmt_scale_a, scaleBType=scale_b_type, fmtScaleB=fmt_scale_b, reuseA=reuse_a, reuseB=reuse_b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class wmma_scale16_f32_32x16x128_f4(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.wmma.scale16.f32.32x16x128.f4"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, a, b, c, scaleA, scaleB, *, modC=None, scaleAType=None, fmtScaleA=None, scaleBType=None, fmtScaleB=None, reuseA=None, reuseB=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    operands.append(c)
    operands.append(scaleA)
    operands.append(scaleB)
    _ods_context = _ods_get_default_loc_context(loc)
    if modC is not None: attributes["modC"] = (modC if (
        isinstance(modC, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I16Attr')) else
          _ods_ir.AttrBuilder.get('I16Attr')(modC, context=_ods_context))
    if scaleAType is not None: attributes["scaleAType"] = (scaleAType if (
        isinstance(scaleAType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(scaleAType, context=_ods_context))
    if fmtScaleA is not None: attributes["fmtScaleA"] = (fmtScaleA if (
        isinstance(fmtScaleA, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(fmtScaleA, context=_ods_context))
    if scaleBType is not None: attributes["scaleBType"] = (scaleBType if (
        isinstance(scaleBType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(scaleBType, context=_ods_context))
    if fmtScaleB is not None: attributes["fmtScaleB"] = (fmtScaleB if (
        isinstance(fmtScaleB, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(fmtScaleB, context=_ods_context))
    if reuseA is not None: attributes["reuseA"] = (reuseA if (
        isinstance(reuseA, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(reuseA, context=_ods_context))
    if reuseB is not None: attributes["reuseB"] = (reuseB if (
        isinstance(reuseB, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(reuseB, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def b(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def c(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def scaleA(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[3]

  @builtins.property
  def scaleB(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[4]

  @builtins.property
  def modC(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["modC"]

  @modC.setter
  def modC(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["modC"] = value

  @builtins.property
  def scaleAType(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["scaleAType"]

  @scaleAType.setter
  def scaleAType(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scaleAType"] = value

  @builtins.property
  def fmtScaleA(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["fmtScaleA"]

  @fmtScaleA.setter
  def fmtScaleA(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fmtScaleA"] = value

  @builtins.property
  def scaleBType(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["scaleBType"]

  @scaleBType.setter
  def scaleBType(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scaleBType"] = value

  @builtins.property
  def fmtScaleB(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["fmtScaleB"]

  @fmtScaleB.setter
  def fmtScaleB(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fmtScaleB"] = value

  @builtins.property
  def reuseA(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["reuseA"]

  @reuseA.setter
  def reuseA(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reuseA"] = value

  @builtins.property
  def reuseB(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["reuseB"]

  @reuseB.setter
  def reuseB(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reuseB"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def wmma_scale16_f32_32x16x128_f4_(res, a, b, c, scale_a, scale_b, *, mod_c=None, scale_a_type=None, fmt_scale_a=None, scale_b_type=None, fmt_scale_b=None, reuse_a=None, reuse_b=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return wmma_scale16_f32_32x16x128_f4(res=res, a=a, b=b, c=c, scaleA=scale_a, scaleB=scale_b, modC=mod_c, scaleAType=scale_a_type, fmtScaleA=fmt_scale_a, scaleBType=scale_b_type, fmtScaleB=fmt_scale_b, reuseA=reuse_a, reuseB=reuse_b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class wmma_scale_f32_16x16x128_f8f6f4(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.wmma.scale.f32.16x16x128.f8f6f4"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, a, b, c, scaleA, scaleB, *, fmtA=None, fmtB=None, modC=None, scaleAType=None, fmtScaleA=None, scaleBType=None, fmtScaleB=None, reuseA=None, reuseB=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    operands.append(c)
    operands.append(scaleA)
    operands.append(scaleB)
    _ods_context = _ods_get_default_loc_context(loc)
    if fmtA is not None: attributes["fmtA"] = (fmtA if (
        isinstance(fmtA, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(fmtA, context=_ods_context))
    if fmtB is not None: attributes["fmtB"] = (fmtB if (
        isinstance(fmtB, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(fmtB, context=_ods_context))
    if modC is not None: attributes["modC"] = (modC if (
        isinstance(modC, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I16Attr')) else
          _ods_ir.AttrBuilder.get('I16Attr')(modC, context=_ods_context))
    if scaleAType is not None: attributes["scaleAType"] = (scaleAType if (
        isinstance(scaleAType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(scaleAType, context=_ods_context))
    if fmtScaleA is not None: attributes["fmtScaleA"] = (fmtScaleA if (
        isinstance(fmtScaleA, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(fmtScaleA, context=_ods_context))
    if scaleBType is not None: attributes["scaleBType"] = (scaleBType if (
        isinstance(scaleBType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(scaleBType, context=_ods_context))
    if fmtScaleB is not None: attributes["fmtScaleB"] = (fmtScaleB if (
        isinstance(fmtScaleB, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(fmtScaleB, context=_ods_context))
    if reuseA is not None: attributes["reuseA"] = (reuseA if (
        isinstance(reuseA, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(reuseA, context=_ods_context))
    if reuseB is not None: attributes["reuseB"] = (reuseB if (
        isinstance(reuseB, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(reuseB, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def b(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def c(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def scaleA(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[3]

  @builtins.property
  def scaleB(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[4]

  @builtins.property
  def fmtA(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["fmtA"]

  @fmtA.setter
  def fmtA(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fmtA"] = value

  @builtins.property
  def fmtB(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["fmtB"]

  @fmtB.setter
  def fmtB(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fmtB"] = value

  @builtins.property
  def modC(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["modC"]

  @modC.setter
  def modC(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["modC"] = value

  @builtins.property
  def scaleAType(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["scaleAType"]

  @scaleAType.setter
  def scaleAType(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scaleAType"] = value

  @builtins.property
  def fmtScaleA(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["fmtScaleA"]

  @fmtScaleA.setter
  def fmtScaleA(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fmtScaleA"] = value

  @builtins.property
  def scaleBType(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["scaleBType"]

  @scaleBType.setter
  def scaleBType(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scaleBType"] = value

  @builtins.property
  def fmtScaleB(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["fmtScaleB"]

  @fmtScaleB.setter
  def fmtScaleB(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fmtScaleB"] = value

  @builtins.property
  def reuseA(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["reuseA"]

  @reuseA.setter
  def reuseA(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reuseA"] = value

  @builtins.property
  def reuseB(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["reuseB"]

  @reuseB.setter
  def reuseB(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reuseB"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def wmma_scale_f32_16x16x128_f8f6f4_(res, a, b, c, scale_a, scale_b, *, fmt_a=None, fmt_b=None, mod_c=None, scale_a_type=None, fmt_scale_a=None, scale_b_type=None, fmt_scale_b=None, reuse_a=None, reuse_b=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return wmma_scale_f32_16x16x128_f8f6f4(res=res, a=a, b=b, c=c, scaleA=scale_a, scaleB=scale_b, fmtA=fmt_a, fmtB=fmt_b, modC=mod_c, scaleAType=scale_a_type, fmtScaleA=fmt_scale_a, scaleBType=scale_b_type, fmtScaleB=fmt_scale_b, reuseA=reuse_a, reuseB=reuse_b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class wmma_scale_f32_32x16x128_f4(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.wmma.scale.f32.32x16x128.f4"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, a, b, c, scaleA, scaleB, *, modC=None, scaleAType=None, fmtScaleA=None, scaleBType=None, fmtScaleB=None, reuseA=None, reuseB=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    operands.append(c)
    operands.append(scaleA)
    operands.append(scaleB)
    _ods_context = _ods_get_default_loc_context(loc)
    if modC is not None: attributes["modC"] = (modC if (
        isinstance(modC, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I16Attr')) else
          _ods_ir.AttrBuilder.get('I16Attr')(modC, context=_ods_context))
    if scaleAType is not None: attributes["scaleAType"] = (scaleAType if (
        isinstance(scaleAType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(scaleAType, context=_ods_context))
    if fmtScaleA is not None: attributes["fmtScaleA"] = (fmtScaleA if (
        isinstance(fmtScaleA, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(fmtScaleA, context=_ods_context))
    if scaleBType is not None: attributes["scaleBType"] = (scaleBType if (
        isinstance(scaleBType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(scaleBType, context=_ods_context))
    if fmtScaleB is not None: attributes["fmtScaleB"] = (fmtScaleB if (
        isinstance(fmtScaleB, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(fmtScaleB, context=_ods_context))
    if reuseA is not None: attributes["reuseA"] = (reuseA if (
        isinstance(reuseA, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(reuseA, context=_ods_context))
    if reuseB is not None: attributes["reuseB"] = (reuseB if (
        isinstance(reuseB, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I1Attr')) else
          _ods_ir.AttrBuilder.get('I1Attr')(reuseB, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def b(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def c(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def scaleA(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[3]

  @builtins.property
  def scaleB(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[4]

  @builtins.property
  def modC(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["modC"]

  @modC.setter
  def modC(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["modC"] = value

  @builtins.property
  def scaleAType(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["scaleAType"]

  @scaleAType.setter
  def scaleAType(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scaleAType"] = value

  @builtins.property
  def fmtScaleA(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["fmtScaleA"]

  @fmtScaleA.setter
  def fmtScaleA(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fmtScaleA"] = value

  @builtins.property
  def scaleBType(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["scaleBType"]

  @scaleBType.setter
  def scaleBType(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scaleBType"] = value

  @builtins.property
  def fmtScaleB(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["fmtScaleB"]

  @fmtScaleB.setter
  def fmtScaleB(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fmtScaleB"] = value

  @builtins.property
  def reuseA(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["reuseA"]

  @reuseA.setter
  def reuseA(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reuseA"] = value

  @builtins.property
  def reuseB(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["reuseB"]

  @reuseB.setter
  def reuseB(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reuseB"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def wmma_scale_f32_32x16x128_f4_(res, a, b, c, scale_a, scale_b, *, mod_c=None, scale_a_type=None, fmt_scale_a=None, scale_b_type=None, fmt_scale_b=None, reuse_a=None, reuse_b=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return wmma_scale_f32_32x16x128_f4(res=res, a=a, b=b, c=c, scaleA=scale_a, scaleB=scale_b, modC=mod_c, scaleAType=scale_a_type, fmtScaleA=fmt_scale_a, scaleBType=scale_b_type, fmtScaleB=fmt_scale_b, reuseA=reuse_a, reuseB=reuse_b, loc=loc, ip=ip).result
