"""Jenkins API client wrapper using api4jenkins."""

import os
import sys
from typing import Optional, Dict, Any
from api4jenkins import Jenkins


def get_env_file_path() -> str:
    """Get the path to the .env file."""
    home = os.path.expanduser("~")
    ngen_j_dir = os.path.join(home, ".ngen-japi")
    return os.path.join(ngen_j_dir, ".env")


def load_env_file() -> dict:
    """Load environment variables from ~/.ngen-japi/.env file."""
    env_file = get_env_file_path()
    env_vars = {}

    if os.path.exists(env_file):
        try:
            with open(env_file, 'r') as f:
                for line in f:
                    line = line.strip()
                    if line and not line.startswith('#'):
                        if '=' in line:
                            key, value = line.split('=', 1)
                            env_vars[key.strip()] = value.strip()
        except Exception as e:
            print(f"Warning: Could not read .env file: {e}", file=sys.stderr)

    return env_vars


def save_env_file(env_vars: dict) -> bool:
    """Save environment variables to ~/.ngen-japi/.env file."""
    env_file = get_env_file_path()

    try:
        # Create directory if it doesn't exist
        os.makedirs(os.path.dirname(env_file), exist_ok=True)

        with open(env_file, 'w') as f:
            f.write("# ngen-japi Jenkins credentials\n")
            f.write("# Generated by: japi login\n")
            f.write("\n")
            for key, value in env_vars.items():
                f.write(f"{key}={value}\n")

        # Set restrictive permissions (readable only by owner)
        os.chmod(env_file, 0o600)
        return True
    except Exception as e:
        print(f"Error: Could not save .env file: {e}", file=sys.stderr)
        return False


class JenkinsClient:
    """Jenkins API client wrapper."""

    def __init__(self):
        """Initialize Jenkins client from environment variables."""
        # Load from .env file first, then override with current env vars
        env_vars = load_env_file()
        self.url = os.getenv("JENKINS_URL") or env_vars.get("JENKINS_URL")
        self.user = os.getenv("JENKINS_USER") or env_vars.get("JENKINS_USER")
        self.token = os.getenv("JENKINS_TOKEN") or env_vars.get("JENKINS_TOKEN")
        self.auth = os.getenv("JENKINS_AUTH") or env_vars.get("JENKINS_AUTH")

        if not self.url:
            print("Error: JENKINS_URL environment variable is required", file=sys.stderr)
            print("Use 'japi login' to set credentials", file=sys.stderr)
            sys.exit(1)

        # Determine authentication method
        auth_tuple = None
        if self.auth:
            # Use JENKINS_AUTH if provided (base64 encoded user:token)
            import base64
            try:
                decoded = base64.b64decode(self.auth).decode('utf-8')
                if ':' in decoded:
                    user, token = decoded.split(':', 1)
                    auth_tuple = (user, token)
            except Exception as e:
                print(f"Warning: Could not decode JENKINS_AUTH: {e}", file=sys.stderr)

        if not auth_tuple and self.user and self.token:
            auth_tuple = (self.user, self.token)

        if not auth_tuple:
            print("Error: Jenkins authentication required. Set JENKINS_USER and JENKINS_TOKEN, or JENKINS_AUTH", file=sys.stderr)
            print("Use 'japi login' to set credentials", file=sys.stderr)
            sys.exit(1)

        try:
            self.client = Jenkins(self.url, auth=auth_tuple)
        except Exception as e:
            print(f"Error connecting to Jenkins: {e}", file=sys.stderr)
            sys.exit(1)
    
    def list_jobs(self) -> list:
        """List all Jenkins jobs."""
        try:
            jobs = []
            # Use the correct API method for api4jenkins
            for job in self.client.iter():
                jobs.append({
                    'name': job.name,
                    'url': job.url
                })
            return jobs
        except Exception as e:
            print(f"Error listing jobs: {e}", file=sys.stderr)
            sys.exit(1)
    
    def get_job(self, job_name: str) -> Dict[str, Any]:
        """Get job details with recent build history."""
        try:
            job = self.client[job_name]
            if job is None:
                raise KeyError(f"Job '{job_name}' not found")

            # Get basic job info
            job_info = {
                'name': getattr(job, 'name', job_name),
                'url': getattr(job, 'url', f"{self.url}/job/{job_name}/"),
                'description': getattr(job, 'description', ''),
                'buildable': getattr(job, 'buildable', False),
            }

            # Get recent builds (up to 3, starting from most recent)
            recent_builds = []
            try:
                # Try to get builds using different methods
                builds = []
                if hasattr(job, 'builds'):
                    # Use builds attribute if available (usually most recent first)
                    builds = list(job.builds)[:3]
                elif hasattr(job, 'iter_builds'):
                    # Use iter_builds method if available
                    builds = list(job.iter_builds())[:3]
                else:
                    # Fallback: try to get recent builds by trying higher numbers first
                    # Jenkins typically numbers builds sequentially, so we'll try recent numbers
                    max_attempts = 500  # Try up to build number 500 to find recent builds
                    found_builds = []

                    for build_num in range(max_attempts, 0, -1):  # Start from highest number
                        try:
                            build = job[build_num]
                            if build:
                                found_builds.append(build)
                                if len(found_builds) >= 3:
                                    break
                        except (KeyError, IndexError):
                            continue  # Build number doesn't exist, try lower number

                    builds = found_builds

                # Sort builds by number (highest first) to ensure most recent are shown first
                builds.sort(key=lambda b: getattr(b, 'number', 0), reverse=True)

                for build in builds[:3]:  # Take only first 3 (most recent)
                    if build:
                        build_info = {
                            'number': getattr(build, 'number', 'N/A'),
                            'url': getattr(build, 'url', f"{job_info['url']}{getattr(build, 'number', '')}/"),
                            'status': self._get_build_status(build),
                            'start_time': self._get_build_start_time(build),
                            'duration': self._get_build_duration(build),
                        }
                        recent_builds.append(build_info)

            except Exception as e:
                # If we can't get build history, continue without it
                pass

            job_info['recent_builds'] = recent_builds
            return job_info

        except KeyError:
            print(f"Error: Job '{job_name}' not found", file=sys.stderr)
            sys.exit(1)
        except Exception as e:
            print(f"Error getting job: {e}", file=sys.stderr)
            sys.exit(1)

    def get_recent_jobs_by_status(self, status: str, limit: int = 10) -> list:
        """Get recent jobs filtered by last build status (SUCCESS or FAILURE)."""
        try:
            jobs_info = []
            # Use direct API call to get jobs with build information
            import httpx
            # Try to get jobs without tree specification first to avoid server errors
            api_url = f"{self.url}/api/json?tree=jobs[name,url,lastBuild[number,result,timestamp,duration],lastCompletedBuild[number,result,timestamp,duration]]"

            response = httpx.get(api_url, auth=self.client._auth)
            response.raise_for_status()
            data = response.json()

            all_jobs_data = data.get('jobs', [])


            for job_data in all_jobs_data:
                try:
                    # Get the last completed build info
                    last_build_data = job_data.get('lastCompletedBuild') or job_data.get('lastBuild')

                    if last_build_data and last_build_data.get('result') == status.upper():
                        try:
                            # Create a simple build object for helper methods
                            class SimpleBuild:
                                def __init__(self, data, job_name, jenkins_url):
                                    self.number = data.get('number')
                                    self.result = data.get('result')
                                    self.timestamp = data.get('timestamp')
                                    self.duration = data.get('duration')
                                    self.url = f"{jenkins_url}/job/{job_name}/{data.get('number', '')}/"

                            last_build = SimpleBuild(last_build_data, job_data['name'], self.url) if last_build_data else None

                            job_name = job_data['name']
                            job_info = {
                                'name': job_name,
                                'url': job_data.get('url', f"{self.url}/job/{job_name}/"),
                                'description': '',  # Not available in this API call
                                'buildable': True,  # Assume buildable
                                'last_build': {
                                    'number': getattr(last_build, 'number', 'N/A') if last_build else 'N/A',
                                    'status': status.upper(),
                                    'url': getattr(last_build, 'url', f"{self.url}/job/{job_name}/{getattr(last_build, 'number', 'N/A')}/") if last_build else '',
                                    'start_time': self._get_build_start_time(last_build) if last_build else 'N/A',
                                    'duration': self._get_build_duration(last_build) if last_build else 'N/A',
                                }
                            }
                            jobs_info.append(job_info)

                            if len(jobs_info) >= limit:
                                break
                        except Exception as e:
                            # Skip jobs that cause errors in processing
                            continue

                except Exception as e:
                    # Skip jobs that cause errors
                    continue

            # Sort by last build number (most recent first)
            jobs_info.sort(key=lambda j: j['last_build'].get('number', 0) if isinstance(j['last_build'], dict) else 0, reverse=True)
            return jobs_info[:limit]

        except Exception as e:
            print(f"Error getting recent jobs: {e}", file=sys.stderr)
            sys.exit(1)
            return jobs_info[:limit]

        except Exception as e:
            print(f"Error getting recent jobs: {e}", file=sys.stderr)
            sys.exit(1)

    def _get_build_status(self, build) -> str:
        """Get build status from build object."""
        try:
            # Try different ways to get build status
            if hasattr(build, 'result'):
                result = build.result
                if result is not None:
                    return str(result).upper()
            elif hasattr(build, 'status'):
                return str(build.status).upper()

            # Check if build is building
            if hasattr(build, 'building') and build.building:
                return "BUILDING"

            # Default to UNKNOWN
            return "UNKNOWN"
        except:
            return "UNKNOWN"

    def _get_build_start_time(self, build) -> str:
        """Get build start time from build object."""
        try:
            if hasattr(build, 'timestamp'):
                import datetime
                # Jenkins timestamp is in milliseconds
                timestamp_ms = build.timestamp
                dt = datetime.datetime.fromtimestamp(timestamp_ms / 1000)
                return dt.strftime('%Y-%m-%d %H:%M:%S')
            else:
                return "Unknown"
        except:
            return "Unknown"

    def _get_build_duration(self, build) -> str:
        """Get build duration from build object."""
        try:
            if hasattr(build, 'duration'):
                duration_ms = build.duration
                if duration_ms == 0:
                    # Build might still be running
                    return "Still running"
                else:
                    # Convert milliseconds to human readable format
                    total_seconds = duration_ms // 1000
                    hours, remainder = divmod(total_seconds, 3600)
                    minutes, seconds = divmod(remainder, 60)

                    if hours > 0:
                        return f"{hours}h {minutes}m {seconds}s"
                    elif minutes > 0:
                        return f"{minutes}m {seconds}s"
                    else:
                        return f"{seconds}s"
            else:
                return "Unknown"
        except:
            return "Unknown"
    
    def trigger_build(self, job_name: str, parameters: Optional[Dict[str, str]] = None) -> Dict[str, Any]:
        """Trigger a build for a job."""
        try:
            job = self.client[job_name]
            if parameters:
                queue_item = job.build(**parameters)
            else:
                queue_item = job.build()

            # api4jenkins returns a QueueItem, not a Build
            return {
                'queue_id': getattr(queue_item, 'id', 'unknown'),
                'url': getattr(queue_item, 'url', 'unknown'),
                'status': 'triggered'
            }
        except KeyError:
            print(f"Error: Job '{job_name}' not found", file=sys.stderr)
            sys.exit(1)
        except Exception as e:
            print(f"Error triggering build: {e}", file=sys.stderr)
            sys.exit(1)

    def get_job_xml(self, job_name: str) -> str:
        """Get job configuration in XML format."""
        try:
            job = self.client[job_name]
            # Try to get XML config using api4jenkins method if available
            if hasattr(job, 'config_xml'):
                return job.config_xml()
            elif hasattr(job, 'get_config_xml'):
                return job.get_config_xml()
            else:
                # Fallback: use direct HTTP request to config.xml endpoint
                config_url = f"{self.url}/job/{job_name}/config.xml"
                import httpx
                response = httpx.get(config_url, auth=self.client._auth)
                response.raise_for_status()
                return response.text
        except Exception as e:
            print(f"Error getting job XML: {e}", file=sys.stderr)
            sys.exit(1)

    def create_job_from_xml(self, job_name: str, xml_content: str, force: bool = False) -> dict:
        """Create or update job from XML configuration."""
        import httpx
        
        try:
            # Check if job already exists using direct API call for reliability
            job_exists = False
            try:
                job = self.client[job_name]
                # Verify job actually exists by checking if it has a valid url attribute
                if job is not None and hasattr(job, 'url') and job.url:
                    # Double-check by making a direct API call
                    check_url = f"{self.url}/job/{job_name}/api/json"
                    check_response = httpx.get(check_url, auth=self.client._auth)
                    if check_response.status_code == 200:
                        job_exists = True
                        print(f"Job '{job_name}' already exists.")
            except (KeyError, Exception):
                job_exists = False

            if job_exists and not force:
                # Ask for confirmation
                response = input(f"Do you want to update the existing job '{job_name}'? (y/N): ").strip().lower()
                if response not in ['y', 'yes']:
                    return {
                        'status': 'cancelled',
                        'message': 'Job creation cancelled by user'
                    }

            if job_exists:
                # Try to update existing job
                try:
                    url = f"{self.url}/job/{job_name}/config.xml"
                    headers = {'Content-Type': 'application/xml'}
                    response = httpx.post(url, content=xml_content, headers=headers, auth=self.client._auth)
                    response.raise_for_status()
                    action = 'updated'
                except httpx.HTTPStatusError as e:
                    if e.response.status_code == 404:
                        # Job doesn't actually exist (false positive from initial check)
                        # Fall back to creating the job
                        print(f"Job '{job_name}' not found, creating new job instead...")
                        job_exists = False
                    else:
                        raise
            
            if not job_exists:
                # Create new job
                url = f"{self.url}/createItem"
                params = {'name': job_name}
                headers = {'Content-Type': 'application/xml'}
                response = httpx.post(url, params=params, content=xml_content,
                                    headers=headers, auth=self.client._auth)
                response.raise_for_status()
                action = 'created'

            return {
                'status': 'success',
                'action': action,
                'job_name': job_name,
                'url': f"{self.url}/job/{job_name}/"
            }

        except Exception as e:
            error_msg = str(e)
            if '403' in error_msg or 'Forbidden' in error_msg:
                print(f"Error: Permission denied. Make sure your Jenkins user has permission to create/update jobs.", file=sys.stderr)
                print("Required permissions: Job/Create, Job/Update, Job/Configure", file=sys.stderr)
            else:
                print(f"Error creating/updating job: {e}", file=sys.stderr)
            return {
                'status': 'error',
                'error': str(e)
            }

    def get_build_logs(self, job_name: str, build_number: int) -> str:
        """Get console output/logs from a specific build."""
        try:
            job = self.client[job_name]
            build = job[build_number]

            # Try to get console output using different methods
            if hasattr(build, 'console'):
                return build.console()
            elif hasattr(build, 'get_console_output'):
                return build.get_console_output()
            else:
                # Fallback: use direct HTTP request to consoleText endpoint
                console_url = f"{self.url}/job/{job_name}/{build_number}/consoleText"
                import httpx
                response = httpx.get(console_url, auth=self.client._auth)
                response.raise_for_status()
                return response.text

        except KeyError:
            print(f"Error: Build {build_number} not found for job '{job_name}'", file=sys.stderr)
            sys.exit(1)
        except Exception as e:
            print(f"Error getting build logs: {e}", file=sys.stderr)
            sys.exit(1)

    def delete_job(self, job_name: str, force: bool = False) -> dict:
        """Delete a Jenkins job."""
        import httpx

        try:
            # Check if job exists first
            try:
                job = self.client[job_name]
                job_url = getattr(job, 'url', f"{self.url}/job/{job_name}/")
                print(f"ðŸ“‹ Job found: {job_url}", file=sys.stderr)
            except KeyError:
                print(f"âŒ Job '{job_name}' not found at {self.url}", file=sys.stderr)
                return {
                    'status': 'error',
                    'error': f"Job '{job_name}' not found"
                }

            if not force:
                # Ask for confirmation
                response = input(f"Are you sure you want to delete job '{job_name}'? This action cannot be undone. (y/N): ").strip().lower()
                if response not in ['y', 'yes']:
                    return {
                        'status': 'cancelled',
                        'message': 'Job deletion cancelled by user'
                    }

            # Test basic authentication and connectivity first
            print(f"ðŸ” Testing Jenkins connection and permissions...", file=sys.stderr)
            test_url = f"{self.url}/api/json?tree=jobs[name]"
            try:
                test_response = httpx.get(test_url, auth=self.client._auth)
                test_response.raise_for_status()
                print(f"âœ… Connection and basic authentication successful", file=sys.stderr)
            except Exception as e:
                print(f"âŒ Connection or authentication failed: {e}", file=sys.stderr)
                return {
                    'status': 'error',
                    'error': f"Connection or authentication failed: {e}"
                }

            # Try to get CSRF crumb if available (required by some Jenkins instances)
            crumb = None
            try:
                crumb_url = f"{self.url}/crumbIssuer/api/json"
                crumb_response = httpx.get(crumb_url, auth=self.client._auth)
                if crumb_response.status_code == 200:
                    crumb_data = crumb_response.json()
                    crumb = crumb_data.get('crumb')
                    print(f"ðŸ”’ CSRF protection detected, using crumb for authentication", file=sys.stderr)
            except:
                # CSRF crumb not required or not available, continue without it
                pass

            # Use direct HTTP request to delete job
            delete_url = f"{self.url}/job/{job_name}/doDelete"

            # Prepare headers and data
            headers = {}
            if crumb:
                headers[crumb_data.get('crumbRequestField', 'Jenkins-Crumb')] = crumb

            print(f"ðŸ—‘ï¸  Deleting job '{job_name}'...", file=sys.stderr)
            response = httpx.post(delete_url, auth=self.client._auth, headers=headers)
            response.raise_for_status()

            return {
                'status': 'success',
                'job_name': job_name,
                'message': f"Job '{job_name}' has been deleted successfully"
            }

        except Exception as e:
            error_msg = str(e)
            if '403' in error_msg or 'Forbidden' in error_msg:
                print(f"âŒ Permission denied. Cannot delete job '{job_name}'.", file=sys.stderr)
                print(f"\nðŸ”§ Troubleshooting steps:", file=sys.stderr)
                print(f"1. Check Jenkins user permissions: Go to Jenkins â†’ Manage Jenkins â†’ Manage Users", file=sys.stderr)
                print(f"2. Ensure your user has 'Job/Delete' permission", file=sys.stderr)
                print(f"3. For Matrix Authorization: Check 'Delete Jobs' permission", file=sys.stderr)
                print(f"4. For Role-Based Access: Ensure your role has 'Job' â†’ 'Delete' permission", file=sys.stderr)
                print(f"5. If using API token, ensure it's valid and has delete permissions", file=sys.stderr)
                print(f"\nðŸ’¡ Alternative solutions:", file=sys.stderr)
                print(f"â€¢ Use Jenkins Web UI: {self.url}/job/{job_name} â†’ Delete Job", file=sys.stderr)
                print(f"â€¢ Manual API call: curl -X POST '{self.url}/job/{job_name}/doDelete' -u 'username:token'", file=sys.stderr)
            elif '404' in error_msg or 'Not Found' in error_msg:
                print(f"âŒ Job '{job_name}' not found", file=sys.stderr)
            else:
                print(f"âŒ Error deleting job: {e}", file=sys.stderr)
            return {
                'status': 'error',
                'error': str(e)
            }

    def list_plugins(self) -> list:
        """List all installed Jenkins plugins."""
        try:
            plugins = []
            for plugin in self.client.plugins:
                plugin_info = {
                    'name': getattr(plugin, 'short_name', getattr(plugin, 'name', 'Unknown')),
                    'version': getattr(plugin, 'version', 'Unknown'),
                    'enabled': getattr(plugin, 'enabled', True),
                    'display_name': getattr(plugin, 'display_name', getattr(plugin, 'name', 'Unknown')),
                    'url': getattr(plugin, 'url', ''),
                }
                # Try to get more details from API
                try:
                    plugin_json = plugin.api_json()
                    plugin_info['version'] = plugin_json.get('version', plugin_info['version'])
                    plugin_info['enabled'] = plugin_json.get('enabled', plugin_info['enabled'])
                    plugin_info['display_name'] = plugin_json.get('displayName', plugin_info['display_name'])
                    plugin_info['description'] = plugin_json.get('longName', plugin_json.get('displayName', ''))
                except:
                    pass
                plugins.append(plugin_info)
            return plugins
        except Exception as e:
            print(f"Error listing plugins: {e}", file=sys.stderr)
            sys.exit(1)

    def install_plugins(self, plugin_names: list, block: bool = False) -> dict:
        """Install one or more Jenkins plugins."""
        try:
            plugins_manager = self.client.plugins
            plugins_manager.install(*plugin_names, block=block)
            
            return {
                'status': 'success',
                'plugins': plugin_names,
                'message': f"Plugins installation initiated: {', '.join(plugin_names)}"
            }
        except Exception as e:
            error_msg = str(e)
            if '403' in error_msg or 'Forbidden' in error_msg:
                print(f"Error: Permission denied. Make sure your Jenkins user has permission to install plugins.", file=sys.stderr)
                print("Required permissions: Overall/Administer or Plugin/Install", file=sys.stderr)
            else:
                print(f"Error installing plugins: {e}", file=sys.stderr)
            return {
                'status': 'error',
                'error': str(e)
            }

    def uninstall_plugins(self, plugin_names: list) -> dict:
        """Uninstall one or more Jenkins plugins."""
        try:
            plugins_manager = self.client.plugins
            plugins_manager.uninstall(*plugin_names)
            
            return {
                'status': 'success',
                'plugins': plugin_names,
                'message': f"Plugins uninstallation initiated: {', '.join(plugin_names)}"
            }
        except Exception as e:
            error_msg = str(e)
            if '403' in error_msg or 'Forbidden' in error_msg:
                print(f"Error: Permission denied. Make sure your Jenkins user has permission to uninstall plugins.", file=sys.stderr)
                print("Required permissions: Overall/Administer or Plugin/Uninstall", file=sys.stderr)
            else:
                print(f"Error uninstalling plugins: {e}", file=sys.stderr)
            return {
                'status': 'error',
                'error': str(e)
            }

    def backup_plugins(self, output_file: str, format_type: str = 'json') -> dict:
        """Backup all installed Jenkins plugins to a file.
        
        Args:
            output_file: Path to the output file
            format_type: 'json' for full backup or 'txt' for plugins.txt format (name:version)
        """
        try:
            import json
            from datetime import datetime
            
            plugins = self.list_plugins()
            
            if format_type == 'txt':
                # Generate plugins.txt format: name:version
                lines = []
                for plugin in plugins:
                    name = plugin.get('name', '')
                    version = plugin.get('version', '')
                    if name:
                        lines.append(f"{name}:{version}")
                
                with open(output_file, 'w', encoding='utf-8') as f:
                    f.write('\n'.join(sorted(lines)))
                
                return {
                    'status': 'success',
                    'count': len(plugins),
                    'file': output_file,
                    'format': 'txt',
                    'message': f"Successfully backed up {len(plugins)} plugins to {output_file} (plugins.txt format)"
                }
            else:
                # JSON format with full details
                backup_data = {
                    'timestamp': datetime.now().isoformat(),
                    'jenkins_url': self.url,
                    'plugins': plugins
                }
                
                with open(output_file, 'w', encoding='utf-8') as f:
                    json.dump(backup_data, f, indent=2)
                
                return {
                    'status': 'success',
                    'count': len(plugins),
                    'file': output_file,
                    'format': 'json',
                    'message': f"Successfully backed up {len(plugins)} plugins to {output_file}"
                }
        except Exception as e:
            return {'status': 'error', 'error': str(e)}

    def restore_plugins(self, input_file: str, block: bool = False) -> dict:
        """Restore/install Jenkins plugins from a backup file.
        
        Args:
            input_file: Path to backup file (JSON or TXT format)
            block: If True, wait for installation to complete
        """
        try:
            import json
            
            if not os.path.exists(input_file):
                return {'status': 'error', 'error': f"Backup file not found: {input_file}"}
            
            plugins_to_install = []
            
            # Detect format based on file extension or content
            with open(input_file, 'r', encoding='utf-8') as f:
                content = f.read().strip()
            
            if input_file.endswith('.txt') or (not content.startswith('{')):
                # TXT format: name:version per line
                for line in content.split('\n'):
                    line = line.strip()
                    if line and not line.startswith('#'):
                        # Parse name:version format
                        if ':' in line:
                            name, version = line.split(':', 1)
                            plugins_to_install.append(f"{name}@{version}")
                        else:
                            plugins_to_install.append(line)
            else:
                # JSON format
                backup_data = json.loads(content)
                plugins = backup_data.get('plugins', [])
                for plugin in plugins:
                    name = plugin.get('name', '')
                    version = plugin.get('version', '')
                    if name:
                        if version and version != 'Unknown':
                            plugins_to_install.append(f"{name}@{version}")
                        else:
                            plugins_to_install.append(name)
            
            if not plugins_to_install:
                return {'status': 'success', 'count': 0, 'message': "No plugins found in backup file."}
            
            # Install plugins
            print(f"Installing {len(plugins_to_install)} plugins...")
            result = self.install_plugins(plugins_to_install, block=block)
            
            if result['status'] == 'success':
                return {
                    'status': 'success',
                    'count': len(plugins_to_install),
                    'plugins': plugins_to_install,
                    'message': f"Successfully initiated installation of {len(plugins_to_install)} plugins."
                }
            else:
                return result
        except Exception as e:
            return {'status': 'error', 'error': str(e)}

    def list_credentials(self) -> list:
        """List all credentials from Jenkins global credentials store."""
        try:
            import httpx
            import json
            
            # Jenkins Credentials API endpoint for global domain
            # Use depth=2 to get full credential details including typeName
            api_url = f"{self.url}/credentials/store/system/domain/_/api/json?depth=2"
            
            response = httpx.get(api_url, auth=self.client._auth)
            response.raise_for_status()
            data = response.json()
            
            credentials = []
            creds_list = data.get('credentials', [])
            
            for cred in creds_list:
                # Handle response structure based on actual Jenkins API response
                if isinstance(cred, dict):
                    # Get ID (required field)
                    cred_id = cred.get('id', 'N/A')
                    
                    # Get description (may be empty string)
                    description = cred.get('description', '')
                    
                    # Get type name
                    cred_type = cred.get('typeName', 'Unknown')
                    
                    # Get display name
                    display_name = cred.get('displayName', cred_id)
                    
                    # Scope is typically GLOBAL for system domain
                    scope = cred.get('scope', 'GLOBAL')
                    
                    # Normalize type name to readable format
                    if cred_type and cred_type != 'Unknown':
                        type_lower = cred_type.lower()
                        if 'username' in type_lower and 'password' in type_lower:
                            cred_type = 'Username/Password'
                        elif 'string' in type_lower or 'secret' in type_lower:
                            cred_type = 'Secret Text'
                        elif 'ssh' in type_lower or 'private' in type_lower:
                            cred_type = 'SSH Key'
                        elif 'certificate' in type_lower:
                            cred_type = 'Certificate'
                        elif 'file' in type_lower:
                            cred_type = 'Secret File'
                        # Keep original if no match
                    
                    cred_info = {
                        'id': cred_id,
                        'description': description,
                        'type': cred_type,
                        'scope': scope,
                        'display_name': display_name
                    }
                    credentials.append(cred_info)
            
            return credentials
        except Exception as e:
            error_msg = str(e)
            if '403' in error_msg or 'Forbidden' in error_msg:
                print(f"Error: Permission denied. Make sure your Jenkins user has permission to view credentials.", file=sys.stderr)
                print("Required permissions: Credentials/View or Overall/Read", file=sys.stderr)
            elif '404' in error_msg:
                print(f"Error: Credentials API not found. Make sure Credentials Plugin is installed.", file=sys.stderr)
            else:
                print(f"Error listing credentials: {e}", file=sys.stderr)
            return []

    def create_credential(self, cred_type: str, cred_id: str, description: str = "", 
                         username: str = None, password: str = None, secret: str = None,
                         private_key: str = None, private_key_file: str = None, 
                         passphrase: str = None, force: bool = False) -> dict:
        """Create a new credential in Jenkins global credentials store."""
        try:
            import httpx
            import xml.etree.ElementTree as ET
            
            # Check if credential already exists
            existing_creds = self.list_credentials()
            cred_exists = any(c.get('id') == cred_id for c in existing_creds)
            
            if cred_exists and not force:
                return {
                    'status': 'exists',
                    'message': f"Credential with ID '{cred_id}' already exists. Use --force to overwrite."
                }
            
            # Get CSRF crumb
            crumb = None
            crumb_field = None
            try:
                crumb_url = f"{self.url}/crumbIssuer/api/json"
                crumb_response = httpx.get(crumb_url, auth=self.client._auth)
                if crumb_response.status_code == 200:
                    crumb_data = crumb_response.json()
                    crumb = crumb_data.get('crumb')
                    crumb_field = crumb_data.get('crumbRequestField', 'Jenkins-Crumb')
            except:
                pass
            
            # Build XML based on credential type
            if cred_type in ['username_password', 'username-password']:
                root = ET.Element('com.cloudbees.plugins.credentials.impl.UsernamePasswordCredentialsImpl')
                root.set('plugin', 'credentials')
                
                scope = ET.SubElement(root, 'scope')
                scope.text = 'GLOBAL'
                
                id_elem = ET.SubElement(root, 'id')
                id_elem.text = cred_id
                
                desc_elem = ET.SubElement(root, 'description')
                desc_elem.text = description
                
                username_elem = ET.SubElement(root, 'username')
                username_elem.text = username or ''
                
                password_elem = ET.SubElement(root, 'password')
                password_elem.text = password or ''
                
            elif cred_type in ['secret_text', 'secret-text']:
                root = ET.Element('org.jenkinsci.plugins.plaincredentials.impl.StringCredentialsImpl')
                root.set('plugin', 'plain-credentials')
                
                scope = ET.SubElement(root, 'scope')
                scope.text = 'GLOBAL'
                
                id_elem = ET.SubElement(root, 'id')
                id_elem.text = cred_id
                
                desc_elem = ET.SubElement(root, 'description')
                desc_elem.text = description
                
                secret_elem = ET.SubElement(root, 'secret')
                secret_elem.text = secret or ''
                
            elif cred_type in ['ssh_key', 'ssh-key']:
                root = ET.Element('com.cloudbees.jenkins.plugins.sshcredentials.impl.BasicSSHUserPrivateKey')
                root.set('plugin', 'ssh-credentials')
                
                scope = ET.SubElement(root, 'scope')
                scope.text = 'GLOBAL'
                
                id_elem = ET.SubElement(root, 'id')
                id_elem.text = cred_id
                
                desc_elem = ET.SubElement(root, 'description')
                desc_elem.text = description
                
                username_elem = ET.SubElement(root, 'username')
                username_elem.text = username or ''
                
                # Handle private key (from string or file)
                private_key_content = private_key
                if private_key_file:
                    try:
                        with open(private_key_file, 'r') as f:
                            private_key_content = f.read()
                    except Exception as e:
                        return {
                            'status': 'error',
                            'error': f"Could not read private key file: {e}"
                        }
                
                private_key_source = ET.SubElement(root, 'privateKeySource')
                direct_entry = ET.SubElement(private_key_source, 'class')
                direct_entry.text = 'com.cloudbees.jenkins.plugins.sshcredentials.impl.BasicSSHUserPrivateKey$DirectEntryPrivateKeySource'
                private_key_elem = ET.SubElement(private_key_source, 'privateKey')
                private_key_elem.text = private_key_content or ''
                
                if passphrase:
                    passphrase_elem = ET.SubElement(root, 'passphrase')
                    passphrase_elem.text = passphrase
                
            else:
                return {
                    'status': 'error',
                    'error': f"Unsupported credential type: {cred_type}. Supported types: username_password, secret_text, ssh_key"
                }
            
            # Convert to XML string
            xml_str = ET.tostring(root, encoding='unicode')
            
            # Create credential via API
            create_url = f"{self.url}/credentials/store/system/domain/_/createCredentials"
            
            headers = {'Content-Type': 'application/xml'}
            if crumb and crumb_field:
                headers[crumb_field] = crumb
            
            params = {}
            if cred_exists:
                # If credential exists and force is True, we need to delete first
                delete_result = self.delete_credential(cred_id, force=True)
                if delete_result.get('status') != 'success':
                    return {
                        'status': 'error',
                        'error': f"Could not delete existing credential: {delete_result.get('error', 'Unknown error')}"
                    }
            
            response = httpx.post(create_url, content=xml_str, headers=headers, 
                                auth=self.client._auth, params=params)
            response.raise_for_status()
            
            return {
                'status': 'success',
                'credential_id': cred_id,
                'message': f"Credential '{cred_id}' created successfully"
            }
            
        except Exception as e:
            error_msg = str(e)
            if '403' in error_msg or 'Forbidden' in error_msg:
                print(f"Error: Permission denied. Make sure your Jenkins user has permission to create credentials.", file=sys.stderr)
                print("Required permissions: Credentials/Create or Overall/Administer", file=sys.stderr)
            elif '404' in error_msg:
                print(f"Error: Credentials API not found. Make sure Credentials Plugin is installed.", file=sys.stderr)
            else:
                print(f"Error creating credential: {e}", file=sys.stderr)
            return {
                'status': 'error',
                'error': str(e)
            }

    def delete_credential(self, cred_id: str, force: bool = False) -> dict:
        """Delete a credential from Jenkins global credentials store."""
        try:
            import httpx
            
            # Check if credential exists
            existing_creds = self.list_credentials()
            cred_exists = any(c.get('id') == cred_id for c in existing_creds)
            
            if not cred_exists:
                return {
                    'status': 'error',
                    'error': f"Credential with ID '{cred_id}' not found"
                }
            
            if not force:
                # Ask for confirmation (handled in CLI)
                pass
            
            # Get CSRF crumb
            crumb = None
            crumb_field = None
            try:
                crumb_url = f"{self.url}/crumbIssuer/api/json"
                crumb_response = httpx.get(crumb_url, auth=self.client._auth)
                if crumb_response.status_code == 200:
                    crumb_data = crumb_response.json()
                    crumb = crumb_data.get('crumb')
                    crumb_field = crumb_data.get('crumbRequestField', 'Jenkins-Crumb')
            except:
                pass
            
            # Delete credential via API
            delete_url = f"{self.url}/credentials/store/system/domain/_/credential/{cred_id}/doDelete"
            
            headers = {}
            if crumb and crumb_field:
                headers[crumb_field] = crumb
            
            response = httpx.post(delete_url, headers=headers, auth=self.client._auth)
            response.raise_for_status()
            
            return {
                'status': 'success',
                'credential_id': cred_id,
                'message': f"Credential '{cred_id}' deleted successfully"
            }
            
        except Exception as e:
            error_msg = str(e)
            if '403' in error_msg or 'Forbidden' in error_msg:
                print(f"Error: Permission denied. Make sure your Jenkins user has permission to delete credentials.", file=sys.stderr)
                print("Required permissions: Credentials/Delete or Overall/Administer", file=sys.stderr)
            elif '404' in error_msg:
                return {
                    'status': 'success',
                    'credential_id': cred_id,
                    'message': f"Credential '{cred_id}' not found (may have been already deleted)"
                }
            else:
                print(f"Error deleting credential: {e}", file=sys.stderr)
            return {
                'status': 'error',
                'error': str(e)
            }

    def get_credential_xml(self, cred_id: str, domain: str = "_") -> Optional[str]:
        """Get the XML configuration for a specific credential."""
        try:
            import httpx
            # Jenkins Credentials API endpoint for specified domain
            api_url = f"{self.url}/credentials/store/system/domain/{domain}/credential/{cred_id}/config.xml"
            response = httpx.get(api_url, auth=self.client._auth)
            response.raise_for_status()
            return response.text
        except Exception as e:
            # Handle potential 404 if direct XML access is not allowed or ID is wrong
            if '404' not in str(e):
                print(f"Error getting XML for credential '{cred_id}' in domain '{domain}': {e}", file=sys.stderr)
            return None

    def backup_credentials(self, output_file: str) -> dict:
        """Backup all global credentials to a JSON file."""
        try:
            import json
            from datetime import datetime
            import httpx
            
            # 1. Get List of Domains
            # Default to global domain if we can't get others
            domains = ['_']
            try:
                domains_url = f"{self.url}/credentials/store/system/api/json?depth=1"
                resp = httpx.get(domains_url, auth=self.client._auth)
                if resp.status_code == 200:
                    domain_data = resp.json()
                    domains = [d.get('name', '_') for d in domain_data.get('domains', {}).values()]
                    if not domains: domains = ['_']
            except:
                pass

            backup_data = {
                'timestamp': datetime.now().isoformat(),
                'jenkins_url': self.url,
                'credentials': {} # domain -> {id -> xml}
            }
            
            total_count = 0
            for domain in domains:
                print(f"Backing up domain '{domain}'...")
                backup_data['credentials'][domain] = {}
                
                # List creds for this domain
                api_url = f"{self.url}/credentials/store/system/domain/{domain}/api/json?depth=2"
                try:
                    res = httpx.get(api_url, auth=self.client._auth)
                    res.raise_for_status()
                    creds = res.json().get('credentials', [])
                except:
                    continue

                for cred in creds:
                    cred_id = cred.get('id')
                    if not cred_id or cred_id == 'N/A':
                        continue
                        
                    print(f"  - {cred_id}...", end="", flush=True)
                    xml = self.get_credential_xml(cred_id, domain)
                    if xml:
                        backup_data['credentials'][domain][cred_id] = xml
                        total_count += 1
                        print(" OK")
                    else:
                        print(" FAILED")
            
            with open(output_file, 'w', encoding='utf-8') as f:
                json.dump(backup_data, f, indent=2)
                
            return {
                'status': 'success',
                'count': total_count,
                'file': output_file,
                'message': f"Successfully backed up {total_count} credentials from {len(domains)} domains to {output_file}"
            }
        except Exception as e:
            return {'status': 'error', 'error': str(e)}

    def restore_credentials(self, input_file: str, force: bool = False) -> dict:
        """Restore global credentials from a JSON backup file."""
        try:
            import json
            import httpx
            
            if not os.path.exists(input_file):
                return {'status': 'error', 'error': f"Backup file not found: {input_file}"}
                
            with open(input_file, 'r', encoding='utf-8') as f:
                backup_data = json.load(f)
                
            creds_data = backup_data.get('credentials', {})
            if not creds_data:
                return {'status': 'success', 'count': 0, 'message': "No credentials found in backup file."}
            
            # Check if it's the old flat format (pre domains support) or new domain-nested format
            # If the first value is a string, it's the old format (flat)
            is_flat_format = False
            if creds_data:
                first_val = next(iter(creds_data.values()))
                if isinstance(first_val, str):
                    is_flat_format = True
            
            if is_flat_format:
                # Convert to domain-nested format for consistent processing
                creds_data = {'_': creds_data}

            # Get CSRF crumb
            crumb = None
            crumb_field = None
            try:
                crumb_url = f"{self.url}/crumbIssuer/api/json"
                crumb_response = httpx.get(crumb_url, auth=self.client._auth)
                if crumb_response.status_code == 200:
                    crumb_data = crumb_response.json()
                    crumb = crumb_data.get('crumb')
                    crumb_field = crumb_data.get('crumbRequestField', 'Jenkins-Crumb')
            except:
                pass
            
            headers = {'Content-Type': 'application/xml'}
            if crumb and crumb_field:
                headers[crumb_field] = crumb
            
            success_count = 0
            failed_count = 0
            skipped_count = 0
            
            total_items = sum(len(c) for c in creds_data.values())
            print(f"Restoring {total_items} credentials from {len(creds_data)} domains...")
            
            for domain, credentials in creds_data.items():
                print(f"Processing domain '{domain}'...")
                
                # Get existing IDs for this domain if not forcing
                existing_ids = []
                try:
                    domain_creds_url = f"{self.url}/credentials/store/system/domain/{domain}/api/json?depth=1"
                    res = httpx.get(domain_creds_url, auth=self.client._auth)
                    if res.status_code == 200:
                        existing_ids = [c.get('id') for c in res.json().get('credentials', [])]
                except:
                    pass

                for cred_id, xml_str in credentials.items():
                    print(f"  - {cred_id}...", end="", flush=True)
                    
                    if cred_id in existing_ids and not force:
                        skipped_count += 1
                        print(" SKIPPED (already exists)")
                        continue
                    
                    if cred_id in existing_ids and force:
                        # Try to delete if exists
                        self.delete_credential_in_domain(cred_id, domain)
                    
                    create_url = f"{self.url}/credentials/store/system/domain/{domain}/createCredentials"
                    try:
                        response = httpx.post(create_url, content=xml_str, headers=headers, 
                                            auth=self.client._auth)
                        response.raise_for_status()
                        success_count += 1
                        print(" OK")
                    except Exception as e:
                        failed_count += 1
                        print(f" FAILED: {e}")
            
            return {
                'status': 'success',
                'success_count': success_count,
                'failed_count': failed_count,
                'skipped_count': skipped_count,
                'message': f"Restore completed. Successfully restored {success_count} credentials."
            }
        except Exception as e:
            return {'status': 'error', 'error': str(e)}

    def delete_credential_in_domain(self, cred_id: str, domain: str = "_") -> bool:
        """Delete a credential from a specific domain."""
        try:
            import httpx
            # Get CSRF crumb
            crumb = None
            crumb_field = None
            try:
                crumb_url = f"{self.url}/crumbIssuer/api/json"
                crumb_response = httpx.get(crumb_url, auth=self.client._auth)
                if crumb_response.status_code == 200:
                    crumb_data = crumb_response.json()
                    crumb = crumb_data.get('crumb')
                    crumb_field = crumb_data.get('crumbRequestField', 'Jenkins-Crumb')
            except:
                pass
            
            delete_url = f"{self.url}/credentials/store/system/domain/{domain}/credential/{cred_id}/doDelete"
            headers = {}
            if crumb and crumb_field:
                headers[crumb_field] = crumb
            
            response = httpx.post(delete_url, headers=headers, auth=self.client._auth)
            return response.status_code < 400
        except:
            return False

    def run_groovy_script(self, script: str) -> str:
        """Execute a Groovy script on Jenkins and return the output."""
        import httpx
        
        # Get CSRF crumb
        crumb = None
        crumb_field = None
        try:
            crumb_url = f"{self.url}/crumbIssuer/api/json"
            crumb_response = httpx.get(crumb_url, auth=self.client._auth)
            if crumb_response.status_code == 200:
                crumb_data = crumb_response.json()
                crumb = crumb_data.get('crumb')
                crumb_field = crumb_data.get('crumbRequestField', 'Jenkins-Crumb')
        except:
            pass
        
        script_url = f"{self.url}/scriptText"
        headers = {'Content-Type': 'application/x-www-form-urlencoded'}
        if crumb and crumb_field:
            headers[crumb_field] = crumb
        
        response = httpx.post(script_url, data={'script': script}, headers=headers, 
                            auth=self.client._auth)
        response.raise_for_status()
        return response.text

    def list_users(self) -> list:
        """List all Jenkins users."""
        try:
            groovy_script = '''
import jenkins.model.Jenkins
import hudson.model.User
import groovy.json.JsonOutput

def users = []
User.getAll().each { user ->
    def properties = [:]
    user.getAllProperties().each { prop ->
        if (prop.class.simpleName == 'Mailer$UserProperty') {
            properties['email'] = prop.getAddress()
        }
    }
    users << [
        id: user.getId(),
        fullName: user.getFullName(),
        email: properties.email ?: '',
        description: user.getDescription() ?: ''
    ]
}
println JsonOutput.toJson(users)
'''
            result = self.run_groovy_script(groovy_script)
            import json
            return json.loads(result.strip())
        except Exception as e:
            print(f"Error listing users: {e}", file=sys.stderr)
            return []

    def backup_users(self, output_file: str) -> dict:
        """Backup all Jenkins users to a JSON file."""
        try:
            import json
            from datetime import datetime
            
            # Get user list with details using Groovy
            groovy_script = '''
import jenkins.model.Jenkins
import hudson.model.User
import hudson.security.HudsonPrivateSecurityRealm
import groovy.json.JsonOutput

def users = []
def securityRealm = Jenkins.instance.getSecurityRealm()

User.getAll().each { user ->
    def userData = [
        id: user.getId(),
        fullName: user.getFullName(),
        description: user.getDescription() ?: ''
    ]
    
    // Get email
    user.getAllProperties().each { prop ->
        if (prop.class.simpleName == 'Mailer$UserProperty') {
            userData['email'] = prop.getAddress()
        }
    }
    
    // Check if using internal user database
    if (securityRealm instanceof HudsonPrivateSecurityRealm) {
        try {
            def details = securityRealm.loadUserByUsername(user.getId())
            userData['hasPassword'] = true
        } catch (e) {
            userData['hasPassword'] = false
        }
    }
    
    users << userData
}
println JsonOutput.toJson(users)
'''
            print("Fetching Jenkins users...")
            result = self.run_groovy_script(groovy_script)
            import json
            users = json.loads(result.strip())
            
            backup_data = {
                'timestamp': datetime.now().isoformat(),
                'jenkins_url': self.url,
                'users': users
            }
            
            with open(output_file, 'w', encoding='utf-8') as f:
                json.dump(backup_data, f, indent=2)
            
            return {
                'status': 'success',
                'count': len(users),
                'file': output_file,
                'message': f"Successfully backed up {len(users)} users to {output_file}"
            }
        except Exception as e:
            return {'status': 'error', 'error': str(e)}

    def restore_users(self, input_file: str, default_password: str = "changeme", force: bool = False) -> dict:
        """Restore Jenkins users from a JSON backup file."""
        try:
            import json
            
            if not os.path.exists(input_file):
                return {'status': 'error', 'error': f"Backup file not found: {input_file}"}
            
            with open(input_file, 'r', encoding='utf-8') as f:
                backup_data = json.load(f)
            
            users = backup_data.get('users', [])
            if not users:
                return {'status': 'success', 'count': 0, 'message': "No users found in backup file."}
            
            # Get existing users
            existing_users = self.list_users()
            existing_ids = [u['id'] for u in existing_users]
            
            success_count = 0
            skipped_count = 0
            failed_count = 0
            
            print(f"Restoring {len(users)} users...")
            for user in users:
                user_id = user.get('id')
                full_name = user.get('fullName', user_id)
                email = user.get('email', '')
                description = user.get('description', '')
                
                print(f"  - {user_id}...", end="", flush=True)
                
                if user_id in existing_ids and not force:
                    skipped_count += 1
                    print(" SKIPPED (already exists)")
                    continue
                
                # Create/update user using Groovy script
                groovy_script = f'''
import jenkins.model.Jenkins
import hudson.model.User
import hudson.security.HudsonPrivateSecurityRealm
import hudson.tasks.Mailer

def securityRealm = Jenkins.instance.getSecurityRealm()
def userId = "{user_id}"
def fullName = "{full_name}"
def email = "{email}"
def password = "{default_password}"

try {{
    if (securityRealm instanceof HudsonPrivateSecurityRealm) {{
        // Create user in internal database
        def existingUser = User.get(userId, false, [:])
        if (existingUser != null && {str(force).lower()}) {{
            // Delete existing user first if force
            existingUser.delete()
        }}
        
        securityRealm.createAccount(userId, password)
    }}
    
    // Set user properties
    def user = User.get(userId, true, [:])
    user.setFullName(fullName)
    
    if (email) {{
        def mailProperty = new Mailer.UserProperty(email)
        user.addProperty(mailProperty)
    }}
    
    user.save()
    println "SUCCESS"
}} catch (Exception e) {{
    println "ERROR: " + e.getMessage()
}}
'''
                try:
                    result = self.run_groovy_script(groovy_script)
                    if "SUCCESS" in result:
                        success_count += 1
                        print(" OK")
                    else:
                        failed_count += 1
                        print(f" FAILED: {result.strip()}")
                except Exception as e:
                    failed_count += 1
                    print(f" FAILED: {e}")
            
            return {
                'status': 'success',
                'success_count': success_count,
                'failed_count': failed_count,
                'skipped_count': skipped_count,
                'message': f"Restore completed. Successfully restored {success_count} users."
            }
        except Exception as e:
            return {'status': 'error', 'error': str(e)}

