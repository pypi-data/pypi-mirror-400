//
// Copyright 2025 Formata, Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//


/*!
 * Function tests.
 * Scope: root.Lang.Funcs
 */

import './init' as self.Init;
import './return' as self.Return;


#[test]
fn arrow_function() {
    let func = (): int => {
        return 53;
    };
    assert_eq(func(), 53);
}

somescope: {
    // Arrow function as a field!
    fn func: (a: int, b: int) -> int => a + b;

    // Arrow functions set the self stack
    stacked: () -> str => {
        super.exists
    }

    // Arena pattern with a field
    arenas: (arena?: obj) => {
        if (arena) arena.done = true;
    }
}

#[test]
fn scoped() {
    let x = self.somescope.func;
    assert_eq(x(40, 2), 42);

    // Can call fields just like normal functions
    assert_eq(self.somescope.func(b = 30, a = 12), 42);
}

#[test]
fn stacked() {
    self.exists = 'stacked';
    let res = self.somescope.stacked();
    assert_eq(res, 'stacked');
}

arena: {}

#[test]
fn test_arenas() {
    self.somescope.arenas(self.arena);
    assert(self.arena.done);
}

#[test]
fn cast_on_return() {
    let func = async (): kg => 45;
    let res: g = func(); // can cast promises with normal types
    assert_eq(typeof res, 'Promise<g>');
    assert_eq(typeof await res, 'g');
}

fn takes_fn(pointer: fn) -> int {
    pointer()
}
#[test]
fn pass_function_pointer() {
    // Can pass async here because promise types work with normal types
    let res = self.takes_fn(async ():int => 42);
    assert_eq(await res, 42);
}

#[test]
fn expr_call() {
    const res = (
        (a: int):int => a + 42
    )(10);

    assert_eq(res, 52);
}

#[test]
fn expr_lib_call() {
    const res = (
        (a: int):int => a + 42
    ).call(10);
    
    assert_eq(res, 52);
}

#[test]
fn recursive() {
    const res = self.fibonacci(4);
    assert_eq(res, 3);
}
fn fibonacci(n: int) -> int {
    if (n <= 1) {
        n
    } else {
        // can also of course use "self.fibonacci(..)", but this is slower
        this.call(n - 1) + this(n - 2)
    }
}


#[type]
StaticFnType: {
    fn addition(a: unknown, b: unknown) -> unknown {
        a + b
    }
}

#[test]
fn static_fn_via_variable() {
    const addition = <StaticFnType>.addition;
    assert_eq(addition(30, 12), 42);
    assert_eq(addition('hello', ', world'), 'hello, world');
}

#[test]
fn arrow_scoped() {
    const created = new {
        visit: ():obj => self;
    };
    assert_eq(created.visit(), created);
}
