// This file is auto-generated by @hey-api/openapi-ts

import type { Options as ClientOptions, TDataShape, Client } from '@hey-api/client-axios';
import type { ProjectDeleteProjectSessionData, ProjectDeleteProjectSessionResponse, ProjectDeleteProjectSessionError, ProjectGetProjectData, ProjectGetProjectResponse, ProjectGetProjectError, ProjectPostProjectData, ProjectPostProjectResponse, ProjectPostProjectError, ProjectGetGlobalConfigStatusData, ProjectGetGlobalConfigStatusResponse, ProjectPostInitProjectData, ProjectPostInitProjectResponse, ProjectPostInitProjectError, ProjectPostGlobalConfigData, ProjectPostGlobalConfigResponse, ProjectPostLockAcquireData, ProjectPostLockAcquireResponse, ProjectPostLockAcquireError, ProjectPostLockRefreshData, ProjectPostLockRefreshResponse, ProjectPostLockRefreshError, ProjectGetLockStatusData, ProjectGetLockStatusResponse, ProjectGetLockStatusError, ProjectPatchMasterdataData, ProjectPatchMasterdataResponse, ProjectPatchMasterdataError, ProjectPatchModelData, ProjectPatchModelResponse, ProjectPatchModelError, ProjectPatchAccessData, ProjectPatchAccessResponse, ProjectPatchAccessError, ProjectGetRmsProjectsData, ProjectGetRmsProjectsResponse, ProjectGetRmsProjectsError, ProjectPatchRmsData, ProjectPatchRmsResponse, ProjectPatchRmsError, ProjectPatchRmsCoordinateSystemData, ProjectPatchRmsCoordinateSystemResponse, ProjectPatchRmsZonesData, ProjectPatchRmsZonesResponse, ProjectPatchRmsHorizonsData, ProjectPatchRmsHorizonsResponse, ProjectPatchRmsWellsData, ProjectPatchRmsWellsResponse, UserGetUserData, UserGetUserResponse, UserGetUserError, UserPatchApiKeyData, UserPatchApiKeyResponse, UserPatchApiKeyError, SessionGetSessionData, SessionGetSessionResponse, SessionGetSessionError, SessionPostSessionData, SessionPostSessionResponse, SessionPostSessionError, SessionPatchAccessTokenData, SessionPatchAccessTokenResponse, SessionPatchAccessTokenError, RmsDeleteRmsProjectData, RmsDeleteRmsProjectResponse, RmsDeleteRmsProjectError, RmsPostRmsProjectData, RmsPostRmsProjectResponse, RmsPostRmsProjectError, RmsGetZonesData, RmsGetZonesResponse, RmsGetZonesError, RmsGetHorizonsData, RmsGetHorizonsResponse, RmsGetHorizonsError, RmsGetWellsData, RmsGetWellsResponse, RmsGetWellsError, RmsGetCoordinateSystemData, RmsGetCoordinateSystemResponse, RmsGetCoordinateSystemError, SmdaGetHealthData, SmdaGetHealthResponse, SmdaGetHealthError, SmdaPostFieldData, SmdaPostFieldResponse, SmdaPostFieldError, SmdaPostMasterdataData, SmdaPostMasterdataResponse, SmdaPostMasterdataError, SmdaPostStratUnitsData, SmdaPostStratUnitsResponse, SmdaPostStratUnitsError, HealthV1HealthCheckData, HealthV1HealthCheckResponse, HealthV1HealthCheckError, HealthHealthCheckData, HealthHealthCheckResponse } from './types.gen';
import { client as _heyApiClient } from './client.gen';

export type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = ClientOptions<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};

/**
 * Removes a project .fmu directory from a session
 * This route simply removes (closes) a project .fmu directory from a session.
 * This has no other side effects on the session.
 */
export const projectDeleteProjectSession = <ThrowOnError extends boolean = false>(options?: Options<ProjectDeleteProjectSessionData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).delete<ProjectDeleteProjectSessionResponse, ProjectDeleteProjectSessionError, ThrowOnError>({
        url: '/api/v1/project/',
        ...options
    });
};

/**
 * Returns the paths and configuration of the nearest project .fmu directory
 * If a project is not already attached to the session id it will be
 * attached after a call to this route. If one is already attached this
 * route will return data for the project .fmu directory again.
 */
export const projectGetProject = <ThrowOnError extends boolean = false>(options?: Options<ProjectGetProjectData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<ProjectGetProjectResponse, ProjectGetProjectError, ThrowOnError>({
        url: '/api/v1/project/',
        ...options
    });
};

/**
 * Returns the path and configuration of the project .fmu directory at 'path'
 * Used for when a user selects a project .fmu directory in a directory not
 * found above the user's current working directory. Will overwrite the
 * project .fmu directory attached to a session if one exists. If not, it is
 * added to the session.
 */
export const projectPostProject = <ThrowOnError extends boolean = false>(options: Options<ProjectPostProjectData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ProjectPostProjectResponse, ProjectPostProjectError, ThrowOnError>({
        url: '/api/v1/project/',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Checks if a valid global config exists at the default location.
 * Checks the global config at the default project location. If the global config
 * does not validate, or is not found, a failed status code is returned.
 */
export const projectGetGlobalConfigStatus = <ThrowOnError extends boolean = false>(options?: Options<ProjectGetGlobalConfigStatusData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<ProjectGetGlobalConfigStatusResponse, unknown, ThrowOnError>({
        url: '/api/v1/project/global_config_status',
        ...options
    });
};

/**
 * Initializes a project .fmu directory at 'path' and returns its paths and configuration
 * If a project .fmu directory is already attached to the session, this will
 * switch to use the newly created .fmu directory.
 */
export const projectPostInitProject = <ThrowOnError extends boolean = false>(options: Options<ProjectPostInitProjectData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ProjectPostInitProjectResponse, ProjectPostInitProjectError, ThrowOnError>({
        url: '/api/v1/project/init',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Loads the global config into the project masterdata.
 * Loads the global config into the project masterdata. If the global config does
 * not validate, or is not found, a failed status code is returned. The endpoint
 * takes an optional parameter, `path` as input: This should be given as a relative
 * path, relative to the project root. If provided, the global config is searched
 * for at this path. If not, the default project path will be used.
 */
export const projectPostGlobalConfig = <ThrowOnError extends boolean = false>(options?: Options<ProjectPostGlobalConfigData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<ProjectPostGlobalConfigResponse, unknown, ThrowOnError>({
        url: '/api/v1/project/global_config',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Attempts to acquire the project lock for editing
 * Tries to upgrade the project session from read-only to editable by acquiring
 * the project lock. If the lock cannot be acquired the project remains read-only
 * and the last lock acquire error is recorded in the session.
 */
export const projectPostLockAcquire = <ThrowOnError extends boolean = false>(options?: Options<ProjectPostLockAcquireData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<ProjectPostLockAcquireResponse, ProjectPostLockAcquireError, ThrowOnError>({
        url: '/api/v1/project/lock_acquire',
        ...options
    });
};

/**
 * Refreshes the project lock timeout
 * Explicitly refreshes the project lock timeout if the current session
 * holds the lock. This should be called when the user actively indicates they
 * want to continue editing (e.g., pressing an 'Edit' button in the GUI).
 *
 * Returns a message indicating whether the lock was successfully refreshed.
 */
export const projectPostLockRefresh = <ThrowOnError extends boolean = false>(options?: Options<ProjectPostLockRefreshData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<ProjectPostLockRefreshResponse, ProjectPostLockRefreshError, ThrowOnError>({
        url: '/api/v1/project/lock_refresh',
        ...options
    });
};

/**
 * Returns the lock status and lock file contents
 * Returns information about the project lock including whether the current
 * session holds the lock and the contents of the lock file if it exists.
 * This is useful for debugging lock conflicts and showing users who has
 * the project locked.
 */
export const projectGetLockStatus = <ThrowOnError extends boolean = false>(options?: Options<ProjectGetLockStatusData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<ProjectGetLockStatusResponse, ProjectGetLockStatusError, ThrowOnError>({
        url: '/api/v1/project/lock_status',
        ...options
    });
};

/**
 * Saves SMDA masterdata to the project .fmu directory
 * Saves masterdata from SMDA to the project .fmu directory.
 * If existing masterdata is present, it will be updated with the new masterdata.
 */
export const projectPatchMasterdata = <ThrowOnError extends boolean = false>(options: Options<ProjectPatchMasterdataData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).patch<ProjectPatchMasterdataResponse, ProjectPatchMasterdataError, ThrowOnError>({
        url: '/api/v1/project/masterdata',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Saves model data to the project .fmu directory
 * Saves model data to the project .fmu directory.
 * If existing model data is present, it will be replaced by the new
 * model data.
 */
export const projectPatchModel = <ThrowOnError extends boolean = false>(options: Options<ProjectPatchModelData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).patch<ProjectPatchModelResponse, ProjectPatchModelError, ThrowOnError>({
        url: '/api/v1/project/model',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Saves access data to the project .fmu directory
 * Saves access data to the project .fmu directory.
 * If existing access data is present, it will be replaced by the new
 * access data.
 */
export const projectPatchAccess = <ThrowOnError extends boolean = false>(options: Options<ProjectPatchAccessData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).patch<ProjectPatchAccessResponse, ProjectPatchAccessError, ThrowOnError>({
        url: '/api/v1/project/access',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Gets the paths of RMS projects in this project directory
 * Returns a list of paths to RMS projects found in the current project directory.
 */
export const projectGetRmsProjects = <ThrowOnError extends boolean = false>(options?: Options<ProjectGetRmsProjectsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<ProjectGetRmsProjectsResponse, ProjectGetRmsProjectsError, ThrowOnError>({
        url: '/api/v1/project/rms_projects',
        ...options
    });
};

/**
 * Saves the RMS project path and version in the project .fmu directory
 * Saves the RMS project path and version to the project .fmu directory.
 * The RMS version is set automatically based on the provided RMS project path.
 * If existing RMS project path and version are present, they will be
 * replaced by the new RMS project path and version.
 */
export const projectPatchRms = <ThrowOnError extends boolean = false>(options: Options<ProjectPatchRmsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).patch<ProjectPatchRmsResponse, ProjectPatchRmsError, ThrowOnError>({
        url: '/api/v1/project/rms',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Saves the RMS coordinate system in the project .fmu directory
 * Saves the RMS coordinate system to the project .fmu directory.
 * Requires that the RMS project path has been set first via PATCH /project/rms.
 * If an existing coordinate system is present, it will be replaced.
 */
export const projectPatchRmsCoordinateSystem = <ThrowOnError extends boolean = false>(options: Options<ProjectPatchRmsCoordinateSystemData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).patch<ProjectPatchRmsCoordinateSystemResponse, unknown, ThrowOnError>({
        url: '/api/v1/project/rms/coordinate_system',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Saves the RMS stratigraphic zones in the project .fmu directory
 * Saves the RMS stratigraphic zones to the project .fmu directory.
 * Requires that the RMS project path has been set first via PATCH /project/rms.
 * If existing zones are present, they will be replaced.
 */
export const projectPatchRmsZones = <ThrowOnError extends boolean = false>(options: Options<ProjectPatchRmsZonesData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).patch<ProjectPatchRmsZonesResponse, unknown, ThrowOnError>({
        url: '/api/v1/project/rms/zones',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Saves the RMS horizons in the project .fmu directory
 * Saves the RMS horizons to the project .fmu directory.
 * Requires that the RMS project path has been set first via PATCH /project/rms.
 * If existing horizons are present, they will be replaced.
 */
export const projectPatchRmsHorizons = <ThrowOnError extends boolean = false>(options: Options<ProjectPatchRmsHorizonsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).patch<ProjectPatchRmsHorizonsResponse, unknown, ThrowOnError>({
        url: '/api/v1/project/rms/horizons',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Saves the RMS wells in the project .fmu directory
 * Saves the RMS wells to the project .fmu directory.
 * Requires that the RMS project path has been set first via PATCH /project/rms.
 * If existing wells are present, they will be replaced.
 */
export const projectPatchRmsWells = <ThrowOnError extends boolean = false>(options: Options<ProjectPatchRmsWellsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).patch<ProjectPatchRmsWellsResponse, unknown, ThrowOnError>({
        url: '/api/v1/project/rms/wells',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Returns the user .fmu configuration
 * The user configuration can store API subscription keys or tokens. These are
 * obfuscated as '**********' when returned.
 */
export const userGetUser = <ThrowOnError extends boolean = false>(options?: Options<UserGetUserData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<UserGetUserResponse, UserGetUserError, ThrowOnError>({
        url: '/api/v1/user/',
        ...options
    });
};

/**
 * Saves an API key/token to the user .fmu configuration
 * Currently only known API's can be saved to the user .fmu configuration.
 * Arbitrary API key-value pairs cannot be saved. The currently known APIs are:
 *
 * smda_subscription
 */
export const userPatchApiKey = <ThrowOnError extends boolean = false>(options: Options<UserPatchApiKeyData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).patch<UserPatchApiKeyResponse, UserPatchApiKeyError, ThrowOnError>({
        url: '/api/v1/user/api_key',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Fetches the current session state
 * Retrieves the latest session metadata.
 */
export const sessionGetSession = <ThrowOnError extends boolean = false>(options?: Options<SessionGetSessionData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<SessionGetSessionResponse, SessionGetSessionError, ThrowOnError>({
        url: '/api/v1/session/',
        ...options
    });
};

/**
 * Creates a session for the user
 * When creating a session the application will ensure that the user
 * .fmu directory exists by creating it if it does not.
 *
 * If a session already exists when POSTing to this route, the new session
 * will preserve the access tokens from the old session. If the old session
 * had a project .fmu directory, it will also be added to the new session.
 * After migrating the state, the old session is destroyed.
 *
 * If no previous session exists, the application will attempt to find the
 * nearest project .fmu directory above the current working directory and
 * add it to the session if found. If not found, no project will be associated.
 *
 * The session cookie set by this route is required for all other
 * routes. Sessions are not persisted when the API is shut down.
 */
export const sessionPostSession = <ThrowOnError extends boolean = false>(options?: Options<SessionPostSessionData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<SessionPostSessionResponse, SessionPostSessionError, ThrowOnError>({
        security: [
            {
                name: 'x-fmu-settings-api',
                type: 'apiKey'
            }
        ],
        url: '/api/v1/session/',
        ...options
    });
};

/**
 * Adds a known access token to the session
 * This route should be used to add a scoped access token to the current
 * session. The token applied via this route is typically a dependency for
 * other routes.
 */
export const sessionPatchAccessToken = <ThrowOnError extends boolean = false>(options: Options<SessionPatchAccessTokenData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).patch<SessionPatchAccessTokenResponse, SessionPatchAccessTokenError, ThrowOnError>({
        url: '/api/v1/session/access_token',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Close the RMS project in the session
 * Close the RMS project that is currently open in the session.
 *
 * This removes the RMS project reference from the session. The project
 * should be closed when it is no longer needed to free up resources.
 */
export const rmsDeleteRmsProject = <ThrowOnError extends boolean = false>(options?: Options<RmsDeleteRmsProjectData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).delete<RmsDeleteRmsProjectResponse, RmsDeleteRmsProjectError, ThrowOnError>({
        url: '/api/v1/rms/',
        ...options
    });
};

/**
 * Open an RMS project and store it in the session
 * Open an RMS project and store it in the session.
 *
 * The RMS project path must be configured in the project's .fmu config file.
 * Once opened, the project remains open in the session until explicitly closed
 * or the session expires. This allows for efficient repeated access without
 * reopening the project each time.
 */
export const rmsPostRmsProject = <ThrowOnError extends boolean = false>(options?: Options<RmsPostRmsProjectData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<RmsPostRmsProjectResponse, RmsPostRmsProjectError, ThrowOnError>({
        url: '/api/v1/rms/',
        ...options
    });
};

/**
 * Get the zones from the open RMS project
 * Retrieve the zones from the currently open RMS project.
 *
 * This endpoint requires an RMS project to be open in the session.
 * Use the POST / endpoint first to open an RMS project.
 */
export const rmsGetZones = <ThrowOnError extends boolean = false>(options?: Options<RmsGetZonesData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<RmsGetZonesResponse, RmsGetZonesError, ThrowOnError>({
        url: '/api/v1/rms/zones',
        ...options
    });
};

/**
 * Get all horizons from the open RMS project
 * Retrieve all horizons from the currently open RMS project.
 *
 * This endpoint requires an RMS project to be open in the session.
 * Use the POST / endpoint first to open an RMS project.
 */
export const rmsGetHorizons = <ThrowOnError extends boolean = false>(options?: Options<RmsGetHorizonsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<RmsGetHorizonsResponse, RmsGetHorizonsError, ThrowOnError>({
        url: '/api/v1/rms/horizons',
        ...options
    });
};

/**
 * Get all wells from the open RMS project
 * Retrieve all wells from the currently open RMS project.
 *
 * This endpoint requires an RMS project to be open in the session.
 * Use the POST / endpoint first to open an RMS project.
 */
export const rmsGetWells = <ThrowOnError extends boolean = false>(options?: Options<RmsGetWellsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<RmsGetWellsResponse, RmsGetWellsError, ThrowOnError>({
        url: '/api/v1/rms/wells',
        ...options
    });
};

/**
 * Get the project coordinate system from the open RMS project
 * Retrieve the project coordinate system from the currently open RMS project.
 *
 * This endpoint requires an RMS project to be open in the session.
 * Use the POST / endpoint first to open an RMS project.
 */
export const rmsGetCoordinateSystem = <ThrowOnError extends boolean = false>(options?: Options<RmsGetCoordinateSystemData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<RmsGetCoordinateSystemResponse, RmsGetCoordinateSystemError, ThrowOnError>({
        url: '/api/v1/rms/coordinate_system',
        ...options
    });
};

/**
 * Checks whether or not the current session is capable of querying SMDA
 * A route to check whether the client is capable of querying SMDA APIs
 * with their current session. The requirements for querying the SMDA API via
 * this API are:
 *
 * 1. A valid session
 * 2. An SMDA subscription key in the user's .fmu API key configuration
 * 3. A valid SMDA access token scoped to SMDA's user_impersonation scope
 *
 * A successful response from this route indicates that all other routes on the
 * SMDA router can be used.
 */
export const smdaGetHealth = <ThrowOnError extends boolean = false>(options?: Options<SmdaGetHealthData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<SmdaGetHealthResponse, SmdaGetHealthError, ThrowOnError>({
        url: '/api/v1/smda/health',
        ...options
    });
};

/**
 * Searches for a field identifier in SMDA
 * A route to search SMDA for an field (asset) by its named identifier.
 *
 * This endpoint applies a projection to the SMDA query so that only the relevant
 * data is returned: an identifier known by SMDA and its corresponding UUID. The
 * UUID should be used by other endpoints required the collection of data by a
 * field, i.e. this route is a dependency for most other routes.
 *
 * The number of results (hits) and number of pages those results span over is also
 * returned in the result. This endpoint does not implement pagination. The
 * current expectation is that a user would refine their search rather than page
 * through different results.
 */
export const smdaPostField = <ThrowOnError extends boolean = false>(options: Options<SmdaPostFieldData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<SmdaPostFieldResponse, SmdaPostFieldError, ThrowOnError>({
        url: '/api/v1/smda/field',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Retrieves masterdata for fields to be confirmed in the GUI
 * A route to gather prospective SMDA masterdata relevant to FMU.
 *
 * This route receives a list of valid field names and returns masterdata that
 * pertains to them. The field names should be valid as return from from the
 * `smda/field` routes.
 *
 * The data returned from this endpoint is meant to be confirmed by the user who
 * may need to do some additional selection or pruning based upon the model they
 * are working from.
 *
 * One example of this is changing the coordinate system. A model may use a
 * coordinate system different from the one set as the field's default coordinate
 * system in SMDA. To match the way this works on SMDA, every coordinate system
 * known to SMDA is returned.
 *
 * This endpoint does multiple calls to the SMDA API, any of which may possibly
 * fail. In any of these calls fails incomplete data will _not_ be returned; that
 * is, a successful code with partial data will not be returned.
 */
export const smdaPostMasterdata = <ThrowOnError extends boolean = false>(options: Options<SmdaPostMasterdataData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<SmdaPostMasterdataResponse, SmdaPostMasterdataError, ThrowOnError>({
        url: '/api/v1/smda/masterdata',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Retrieves stratigraphic units for a stratigraphic column
 * A route to gather stratigraphic units from SMDA for a specified
 * stratigraphic column.
 *
 * This route receives a valid stratigraphic column identifier
 * and returns stratigraphic units associated with it. The identifier
 * should be obtained from the `stratigraphic_columns` field in the
 * `smda/masterdata` response.
 */
export const smdaPostStratUnits = <ThrowOnError extends boolean = false>(options: Options<SmdaPostStratUnitsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<SmdaPostStratUnitsResponse, SmdaPostStratUnitsError, ThrowOnError>({
        url: '/api/v1/smda/strat_units',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * A health check on the /v1 routes.
 * This route requires a valid session to return 200 OK. it can used to check if the user has a valid session.
 */
export const healthV1HealthCheck = <ThrowOnError extends boolean = false>(options?: Options<HealthV1HealthCheckData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<HealthV1HealthCheckResponse, HealthV1HealthCheckError, ThrowOnError>({
        url: '/api/v1/health',
        ...options
    });
};

/**
 * A health check on the application
 * This route requires no form of authentication or authorization. It can be used to check if the application is running and responsive.
 */
export const healthHealthCheck = <ThrowOnError extends boolean = false>(options?: Options<HealthHealthCheckData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<HealthHealthCheckResponse, unknown, ThrowOnError>({
        url: '/health',
        ...options
    });
};