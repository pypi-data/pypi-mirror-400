import typing, clr, abc
from PalmSens.Plottables import Curve
from PalmSens.Data import EnumDirection
from System import DateTime, Array_1, Progress_1, IDisposable, Exception, ValueTuple_2
from PalmSens.DataFiles import JsonBag
from System.Collections.Generic import IList_1, List_1, Dictionary_2, IEnumerator_1, IEnumerable_1
from System.Threading.Tasks import Task_1, Task
from System.Threading import CancellationToken
from PalmSens.Calculations import PolyCurve
from Newtonsoft.Json import JsonReader
from PalmSens import ScanMethod

class AutoPeak(Peak):
    @typing.overload
    def __init__(self, curve: Curve, index: int, notes: str) -> None: ...
    @typing.overload
    def __init__(self, curve: Curve, left: int, peak: int, right: int, isign: EnumDirection) -> None: ...
    Direction : EnumDirection
    @property
    def AnalyteName(self) -> str: ...
    @AnalyteName.setter
    def AnalyteName(self, value: str) -> str: ...
    @property
    def Area(self) -> float: ...
    @property
    def Curve(self) -> Curve: ...
    @property
    def DateTime(self) -> typing.Optional[DateTime]: ...
    @property
    def Label(self) -> str: ...
    @property
    def LeftIndex(self) -> int: ...
    @property
    def LeftX(self) -> float: ...
    @property
    def LeftY(self) -> float: ...
    @property
    def MaximumOfDerivativeNeg(self) -> float: ...
    @property
    def MaximumOfDerivativePos(self) -> float: ...
    @property
    def MaximumOfDerivativeSum(self) -> float: ...
    @property
    def Notes(self) -> str: ...
    @Notes.setter
    def Notes(self, value: str) -> str: ...
    @property
    def OffsetY(self) -> float: ...
    @property
    def PeakIndex(self) -> int: ...
    @property
    def PeakType(self) -> PeakType: ...
    @property
    def PeakValue(self) -> float: ...
    @property
    def PeakX(self) -> float: ...
    @property
    def PeakY(self) -> float: ...
    @property
    def RightIndex(self) -> int: ...
    @property
    def RightX(self) -> float: ...
    @property
    def RightY(self) -> float: ...
    @property
    def ToJsonBag(self) -> JsonBag: ...
    @property
    def Width(self) -> float: ...


class BaselineCorrection(abc.ABC):
    @staticmethod
    def GetMovingAverageBaselineCorrected(curve: Curve, nWindowSize: int, maxNSweeps: int, baseline: bool) -> Curve: ...


class CFALevelList(IList_1[Level]):
    @typing.overload
    def __init__(self, c: Curve) -> None: ...
    @typing.overload
    def __init__(self, c: Curve, pxmin: float, pymin: float) -> None: ...
    @typing.overload
    def __init__(self, jsonBags: Array_1[JsonBag], curve: Curve) -> None: ...
    @property
    def Count(self) -> int: ...
    @property
    def Curve(self) -> Curve: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def Item(self) -> Level: ...
    @Item.setter
    def Item(self, value: Level) -> Level: ...
    @property
    def nLevels(self) -> int: ...
    def Add(self, item: Level) -> None: ...
    def Clear(self) -> None: ...
    def Contains(self, item: Level) -> bool: ...
    def CopyTo(self, array: Array_1[Level], arrayIndex: int) -> None: ...
    def FindLevels(self, pxmin: float, pymin: float, levelDetectProgress: LevelDetectProgress) -> List_1[Level]: ...
    def FindLevelsAsync(self, pxmin: float, pymin: float, levelDetectProgress: LevelDetectProgress = ...) -> Task_1[List_1[Level]]: ...
    def FindLevelsInCurves(self, curves: Dictionary_2[Curve, Array_1[float]], levelDetectProgress: LevelDetectProgress) -> None: ...
    def GetEnumerator(self) -> IEnumerator_1[Level]: ...
    def IndexOf(self, item: Level) -> int: ...
    def Insert(self, index: int, item: Level) -> None: ...
    def Remove(self, level: Level) -> None: ...
    def RemoveAt(self, index: int) -> None: ...
    def ToJsonBag(self) -> Array_1[JsonBag]: ...
    def ToJsonBagAsync(self, cancellationToken: CancellationToken) -> Task_1[Array_1[JsonBag]]: ...


class EnumLevelDetectProgress(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...

    # Values:
    Started : EnumLevelDetectProgress # 0
    InitialisedBins : EnumLevelDetectProgress # 1
    ProcessingCurve : EnumLevelDetectProgress # 2
    CurveProcessed : EnumLevelDetectProgress # 3
    MergingPossibleLevels : EnumLevelDetectProgress # 4
    PossibleLevelDetected : EnumLevelDetectProgress # 5
    Cancelled : EnumLevelDetectProgress # 6
    Finished : EnumLevelDetectProgress # 7
    Error : EnumLevelDetectProgress # 8


class EnumPeakDetectProgress(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...

    # Values:
    Started : EnumPeakDetectProgress # 0
    PeakDetected : EnumPeakDetectProgress # 1
    ProcessingCurve : EnumPeakDetectProgress # 2
    CurveProcessed : EnumPeakDetectProgress # 3
    Cancelled : EnumPeakDetectProgress # 4
    Finished : EnumPeakDetectProgress # 5


class GetManualPeak(abc.ABC):
    @staticmethod
    def GetNearestIndex(curve: Curve, x: float, y: float, anodicCurve: typing.Optional[bool], index: clr.Reference[int]) -> Curve: ...
    @staticmethod
    def GetNearestXandY(curve: Curve, x: clr.Reference[float], y: clr.Reference[float], anodicCurve: typing.Optional[bool]) -> Curve: ...
    @staticmethod
    def GetPeak(Curve: Curve, xleft: float, yleft: float, xright: float, yright: float, hasarea: bool, anodicCurve: typing.Optional[bool] = ...) -> ManualPeak: ...


class Level:
    @typing.overload
    def __init__(self, curve: Curve, bag: JsonBag) -> None: ...
    @typing.overload
    def __init__(self, curve: Curve, l: int, p: int, r: int, val: float) -> None: ...
    @typing.overload
    def __init__(self, curve: Curve, p: int, concentration: float, unit: str, notes: str) -> None: ...
    @property
    def Concentration(self) -> float: ...
    @property
    def Curve(self) -> Curve: ...
    @property
    def DateTime(self) -> typing.Optional[DateTime]: ...
    @property
    def IsManual(self) -> bool: ...
    @property
    def Label(self) -> str: ...
    @property
    def LeftX(self) -> float: ...
    @property
    def LeftY(self) -> float: ...
    @property
    def LevelX(self) -> float: ...
    @property
    def LevelY(self) -> float: ...
    @property
    def Notes(self) -> str: ...
    @Notes.setter
    def Notes(self, value: str) -> str: ...
    @property
    def RightX(self) -> float: ...
    @property
    def RightY(self) -> float: ...
    @property
    def ToJsonBag(self) -> JsonBag: ...
    @property
    def Unit(self) -> str: ...


class LevelDetectProgress(Progress_1[LevelDetectProgressUpdate], IDisposable):
    def __init__(self) -> None: ...
    @property
    def IsCancelled(self) -> bool: ...
    def Cancel(self) -> None: ...
    def Dispose(self) -> None: ...


class LevelDetectProgressUpdate:
    CurveTitle : str
    LevelsFound : int
    NCurves : int
    NRemainingCurves : int
    Progress : EnumLevelDetectProgress
    @property
    def Error(self) -> Exception: ...


class ManualPeak(Peak):
    @typing.overload
    def __init__(self, curve: Curve, ileft: int, ipeak: int, iright: int, hasArea: bool = ..., isign: EnumDirection = ...) -> None: ...
    @typing.overload
    def __init__(self, curve: Curve, leftx: float, lefty: float, peak: int, rightx: float, righty: float, HasArea: bool) -> None: ...
    @typing.overload
    def __init__(self, curve: Curve, leftx: float, lefty: float, peakx: float, peaky: float, rightx: float, righty: float, hasArea: bool) -> None: ...
    Direction : EnumDirection
    @property
    def AnalyteName(self) -> str: ...
    @AnalyteName.setter
    def AnalyteName(self, value: str) -> str: ...
    @property
    def Area(self) -> float: ...
    @property
    def Curve(self) -> Curve: ...
    @property
    def DateTime(self) -> typing.Optional[DateTime]: ...
    @property
    def Label(self) -> str: ...
    @property
    def LeftIndex(self) -> int: ...
    @property
    def LeftX(self) -> float: ...
    @property
    def LeftY(self) -> float: ...
    @property
    def MaximumOfDerivativeNeg(self) -> float: ...
    @property
    def MaximumOfDerivativePos(self) -> float: ...
    @property
    def MaximumOfDerivativeSum(self) -> float: ...
    @property
    def Notes(self) -> str: ...
    @Notes.setter
    def Notes(self, value: str) -> str: ...
    @property
    def OffsetY(self) -> float: ...
    @property
    def PeakIndex(self) -> int: ...
    @property
    def PeakType(self) -> PeakType: ...
    @property
    def PeakValue(self) -> float: ...
    @property
    def PeakX(self) -> float: ...
    @property
    def PeakY(self) -> float: ...
    @property
    def RightIndex(self) -> int: ...
    @property
    def RightX(self) -> float: ...
    @property
    def RightY(self) -> float: ...
    @property
    def ToJsonBag(self) -> JsonBag: ...
    @property
    def Width(self) -> float: ...


class NonLinearBaseLinePeak(Peak):
    def __init__(self, curveWithPeak: Curve, polyBaseline: PolyCurve, x1: float, x2: float, iStart: int, iEnd: int, reindexedCopy: Curve = ...) -> None: ...
    NlBlineX : Array_1[float]
    NlBlineY : Array_1[float]
    @property
    def AnalyteName(self) -> str: ...
    @AnalyteName.setter
    def AnalyteName(self, value: str) -> str: ...
    @property
    def Area(self) -> float: ...
    @property
    def Curve(self) -> Curve: ...
    @property
    def DateTime(self) -> typing.Optional[DateTime]: ...
    @property
    def Label(self) -> str: ...
    @property
    def LeftIndex(self) -> int: ...
    @property
    def LeftX(self) -> float: ...
    @property
    def LeftY(self) -> float: ...
    @property
    def MaximumOfDerivativeNeg(self) -> float: ...
    @property
    def MaximumOfDerivativePos(self) -> float: ...
    @property
    def MaximumOfDerivativeSum(self) -> float: ...
    @property
    def Notes(self) -> str: ...
    @Notes.setter
    def Notes(self, value: str) -> str: ...
    @property
    def OffsetY(self) -> float: ...
    @property
    def PeakIndex(self) -> int: ...
    @property
    def PeakType(self) -> PeakType: ...
    @property
    def PeakValue(self) -> float: ...
    @property
    def PeakX(self) -> float: ...
    @property
    def PeakY(self) -> float: ...
    @property
    def RightIndex(self) -> int: ...
    @property
    def RightX(self) -> float: ...
    @property
    def RightY(self) -> float: ...
    @property
    def ToJsonBag(self) -> JsonBag: ...
    @property
    def Width(self) -> float: ...


class Peak(typing.Protocol):
    @property
    def AnalyteName(self) -> str: ...
    @AnalyteName.setter
    def AnalyteName(self, value: str) -> str: ...
    @property
    def Area(self) -> float: ...
    @property
    def Curve(self) -> Curve: ...
    @property
    def DateTime(self) -> typing.Optional[DateTime]: ...
    @property
    def Label(self) -> str: ...
    @property
    def LeftIndex(self) -> int: ...
    @property
    def LeftX(self) -> float: ...
    @property
    def LeftY(self) -> float: ...
    @property
    def MaximumOfDerivativeNeg(self) -> float: ...
    @property
    def MaximumOfDerivativePos(self) -> float: ...
    @property
    def MaximumOfDerivativeSum(self) -> float: ...
    @property
    def Notes(self) -> str: ...
    @Notes.setter
    def Notes(self, value: str) -> str: ...
    @property
    def OffsetY(self) -> float: ...
    @property
    def PeakIndex(self) -> int: ...
    @property
    def PeakType(self) -> PeakType: ...
    @property
    def PeakValue(self) -> float: ...
    @property
    def PeakX(self) -> float: ...
    @property
    def PeakY(self) -> float: ...
    @property
    def RightIndex(self) -> int: ...
    @property
    def RightX(self) -> float: ...
    @property
    def RightY(self) -> float: ...
    @property
    def ToJsonBag(self) -> JsonBag: ...
    @property
    def Width(self) -> float: ...


class PeakDetectProgress(Progress_1[PeakDetectProgressUpdate]):
    def __init__(self) -> None: ...
    def Cancel(self) -> None: ...


class PeakDetectProgressUpdate:
    CurveTitle : str
    NCurves : int
    NPeaksFound : int
    NRemainingCurves : int
    Progress : EnumPeakDetectProgress


class PeakExtensions(abc.ABC):
    @staticmethod
    def GetFullWidthHalfMaximumIndices(p: Peak) -> ValueTuple_2[int, int]: ...


class PeakList(IEnumerable_1[Peak]):
    @typing.overload
    def __init__(self, c: Curve) -> None: ...
    @typing.overload
    def __init__(self, c: Curve, MinPeakWidth: float, MinPeakHeight: float) -> None: ...
    @typing.overload
    def __init__(self, c: Curve, MinPeakWidth: float, MinPeakHeight: float, peakdir: EnumDirection, peakShoulders: bool = ..., mergeOverlappingPeaks: bool = ...) -> None: ...
    @typing.overload
    def __init__(self, c: Curve, MinPeakWidth: float, MinPeakHeight: float, Start: int, End: int, peakShoulders: bool = ..., mergeOverlappingPeaks: bool = ...) -> None: ...

    class enumAnalytePeakType(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...

        # Values:
        auto : PeakList.enumAnalytePeakType # 0
        fix : PeakList.enumAnalytePeakType # 1
        manual : PeakList.enumAnalytePeakType # 2


    class JsonFields(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...

        # Values:
        peaktype : PeakList.JsonFields # 0
        left : PeakList.JsonFields # 1
        peak : PeakList.JsonFields # 2
        right : PeakList.JsonFields # 3
        isign : PeakList.JsonFields # 4
        AnalyteName : PeakList.JsonFields # 5
        leftx : PeakList.JsonFields # 6
        lefty : PeakList.JsonFields # 7
        rightx : PeakList.JsonFields # 8
        righty : PeakList.JsonFields # 9
        hasarea : PeakList.JsonFields # 10
        iStart : PeakList.JsonFields # 11
        iEnd : PeakList.JsonFields # 12
        pointsx : PeakList.JsonFields # 13
        pointsy : PeakList.JsonFields # 14
        pointsi : PeakList.JsonFields # 15
        x1 : PeakList.JsonFields # 16
        x2 : PeakList.JsonFields # 17
        globalo : PeakList.JsonFields # 18
        notes : PeakList.JsonFields # 19
        datetime : PeakList.JsonFields # 20

    Curve : Curve
    MinPeakHeight : float
    MinPeakWidth : float
    @property
    def Item(self) -> Peak: ...
    @Item.setter
    def Item(self, value: Peak) -> Peak: ...
    @property
    def nPeaks(self) -> int: ...
    def AddManualPeak(self, xleft: float, yleft: float, xright: float, yright: float, anodicCurve: typing.Optional[bool] = ...) -> ManualPeak: ...
    def AddManualPeakFree(self, xleft: float, yleft: float, xright: float, yright: float, HasArea: bool, anodicCurve: typing.Optional[bool] = ...) -> ManualPeak: ...
    def Clear(self) -> None: ...
    @staticmethod
    def FromJsonBag(bags: Array_1[JsonBag], c: Curve) -> PeakList: ...
    def GetEnumerator(self) -> IEnumerator_1[Peak]: ...
    def InitAnalytePeaks(self) -> None: ...
    @staticmethod
    def PeakFromJson(jr: JsonReader, c: Curve) -> Task_1[Peak]: ...
    @staticmethod
    def PeakWithinWindow(p: Peak, m: ScanMethod, iAnalyte: int) -> bool: ...
    def Remove(self, p: Peak) -> None: ...
    def SortPeaksByXValue(self) -> None: ...
    def ToJsonBag(self) -> Array_1[JsonBag]: ...
    def ToJsonBagAsync(self, cancellationToken: CancellationToken) -> Task_1[Array_1[JsonBag]]: ...
    # Skipped AddPeak due to it being static, abstract and generic.

    AddPeak : AddPeak_MethodGroup
    class AddPeak_MethodGroup:
        @typing.overload
        def __call__(self, p: Peak) -> None:...
        @typing.overload
        def __call__(self, xleft: float, yleft: float, iymax: int, xright: float, yright: float, HasArea: bool) -> ManualPeak:...
        @typing.overload
        def __call__(self, xleft: float, yleft: float, xmax: float, ymax: float, xright: float, yright: float, HasArea: bool) -> None:...



class PeakType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...

    # Values:
    AutoPeak : PeakType # 0
    ManualPeak : PeakType # 1
    NonLinearBaselinePeak : PeakType # 2


class SemiDerivativePeakDetection(IDisposable):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, c: Curve, minPeakHeight: float) -> None: ...
    def Dispose(self) -> None: ...
    @staticmethod
    def GetMovingAverage(c: Curve, windowSize: int, cancellationToken: CancellationToken) -> Curve: ...
    def GetNonOverlappingPeaksAsync(self, curves: Dictionary_2[Curve, float], peakDetectProgress: PeakDetectProgress = ...) -> Task: ...
    # Skipped GetNonOverlappingPeaks due to it being static, abstract and generic.

    GetNonOverlappingPeaks : GetNonOverlappingPeaks_MethodGroup
    class GetNonOverlappingPeaks_MethodGroup:
        @typing.overload
        def __call__(self, curves: Dictionary_2[Curve, float]) -> None:...
        @typing.overload
        def __call__(self, curves: Dictionary_2[Curve, float], peakDetectProgress: PeakDetectProgress) -> None:...

    # Skipped GetSemiDerivative due to it being static, abstract and generic.

    GetSemiDerivative : GetSemiDerivative_MethodGroup
    class GetSemiDerivative_MethodGroup:
        @typing.overload
        def __call__(self, c: Curve, order: float) -> Curve:...
        @typing.overload
        def __call__(self, c: Curve, order: float, cancellationToken: CancellationToken) -> Curve:...

    # Skipped SeparateCurves due to it being static, abstract and generic.

    SeparateCurves : SeparateCurves_MethodGroup
    class SeparateCurves_MethodGroup:
        @typing.overload
        def __call__(self, peaks: List_1[int], order: float, windowSize: int, reversible: bool) -> Array_1[Curve]:...
        @typing.overload
        def __call__(self, peaks: List_1[int], order: float, windowSize: int, reversible: bool, cancellationToken: CancellationToken) -> Array_1[Curve]:...
