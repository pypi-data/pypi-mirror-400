"""Arcade Starter Tools for Intercom

DO NOT EDIT THIS MODULE DIRECTLY.

THIS MODULE WAS AUTO-GENERATED BY TRANSPILING THE API STARTER TOOL JSON DEFINITIONS
IN THE ../wrapper_tools DIRECTORY INTO PYTHON CODE. ANY CHANGES TO THIS MODULE WILL
BE OVERWRITTEN BY THE TRANSPILER.
"""

import asyncio
import json
import jsonschema
from enum import Enum
from typing import Annotated, Any

import httpx

from arcade_tdk import tool, ToolContext
from arcade_tdk.errors import RetryableToolError
from arcade_tdk.auth import OAuth2

from .request_body_schemas import REQUEST_BODY_SCHEMAS

# Retry configuration
INITIAL_RETRY_DELAY = 0.5  # seconds

HTTP_CLIENT = httpx.AsyncClient(
    timeout=httpx.Timeout(60.0, connect=10.0),
    limits=httpx.Limits(max_keepalive_connections=20, max_connections=100),
    transport=httpx.AsyncHTTPTransport(retries=3),
    http2=True,
    follow_redirects=True,
)


class ToolMode(str, Enum):
    """Mode for tools with complex request bodies."""

    GET_REQUEST_SCHEMA = "get_request_schema"
    EXECUTE = "execute"


def remove_none_values(data: dict[str, Any]) -> dict[str, Any]:
    return {k: v for k, v in data.items() if v is not None}


async def make_request(
    url: str,
    method: str,
    params: dict[str, Any] | None = None,
    headers: dict[str, Any] | None = None,
    content: str | None = None,
    data: dict[str, Any] | None = None,
    auth: tuple[str, str] | None = None,
    max_retries: int = 3,
) -> httpx.Response:
    """Make an HTTP request with retry logic for 5xx server errors."""
    for attempt in range(max_retries):
        try:
            response = await HTTP_CLIENT.request(
                url=url,
                auth=auth,
                method=method,
                params=params,
                headers=headers,
                content=content,
            )
            response.raise_for_status()
        except httpx.HTTPStatusError as e:
            # Only retry on 5xx server errors
            if e.response.status_code >= 500 and attempt < max_retries - 1:
                # Exponential backoff: 0.5s, 1s, 2s
                await asyncio.sleep(INITIAL_RETRY_DELAY * (2**attempt))
                continue
            # Re-raise for 4xx errors or if max retries reached
            raise
        except httpx.RequestError:
            # Don't retry request errors (network issues are handled by transport)
            raise
        else:
            return response

    # This should never be reached, but satisfies type checker
    raise httpx.RequestError("Max retries exceeded")  # noqa: TRY003


async def make_request_with_schema_validation(
    url: str,
    method: str,
    request_data: dict[str, Any],
    schema: dict[str, Any] | str,
    auth: tuple[str, str] | None = None,
    params: dict[str, Any] | None = None,
    headers: dict[str, Any] | None = None,
    max_retries: int = 3,
) -> httpx.Response:
    """Make an HTTP request with schema validation on format errors."""
    # Parse schema if it's a string, skip validation if parsing fails
    parsed_schema = None
    if isinstance(schema, str):
        try:
            parsed_schema = json.loads(schema)
        except Exception:
            # If schema parsing fails, just skip validation
            parsed_schema = None
    else:
        parsed_schema = schema

    try:
        response = await make_request(
            url=url,
            auth=auth,
            method=method,
            params=params,
            headers=headers,
            content=json.dumps(request_data),
            max_retries=max_retries,
        )
    except httpx.HTTPStatusError as e:
        # Only provide schema validation for format-related errors
        if e.response.status_code in (400, 422):
            api_error_details = f"API returned {e.response.status_code}: {e.response.text}"

            # Only run validation if we have a valid parsed schema
            if parsed_schema is not None:
                # Run validation to provide additional context
                is_valid, validation_error = validate_json_against_schema(
                    request_data, parsed_schema
                )

                if not is_valid:
                    # Schema validation found issues - additional context
                    additional_context = (
                        f"{api_error_details}\n\n"
                        f"Schema validation found the following issues:\n"
                        f"{validation_error}"
                    )
                else:
                    # Schema validation passed - just show API error
                    additional_context = api_error_details
            else:
                # No valid schema - just show API error
                additional_context = api_error_details

            raise RetryableToolError(
                message=(f"API request failed with validation error: {e.response.status_code}"),
                developer_message=api_error_details,
                additional_prompt_content=additional_context,
            ) from e
        else:
            # For non-validation errors, re-raise as-is
            raise
    else:
        return response


def validate_json_against_schema(
    json_data: dict[str, Any], schema: dict[str, Any]
) -> tuple[bool, str | None]:
    """Validate JSON data against an OpenAPI/JSON Schema.

    This provides full JSON Schema Draft 7 validation including:
    - Required fields, types, enums
    - Pattern validation (regex)
    - Format validation (email, uuid, date-time, etc.)
    - Min/max length and values
    - oneOf, anyOf, allOf
    - And all other JSON Schema features

    Args:
        json_data: The JSON data to validate
        schema: The JSON Schema to validate against

    Returns:
        Tuple of (is_valid, error_messages). If valid, error_messages is None.
        If invalid, error_messages contains all validation errors.
    """
    try:
        validator = jsonschema.Draft7Validator(
            schema, format_checker=jsonschema.Draft7Validator.FORMAT_CHECKER
        )
        # Collect ALL validation errors
        errors = list(validator.iter_errors(json_data))
        if errors:
            # Format all errors with their paths
            error_messages = []
            for error in errors:
                error_path = ".".join(str(p) for p in error.path) if error.path else "root"
                error_messages.append(f"{error.message} at {error_path}")
            # Join all errors with newlines
            return False, "\n".join(error_messages)
        else:
            return True, None
    except jsonschema.SchemaError as e:
        return False, f"Invalid schema: {e.message}"
    except Exception as e:
        return False, f"Validation error: {e!s}"


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def get_current_admin_info(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'identifyAdmin'."]:
    """Retrieve details of the currently authorized Intercom admin.

    Call this tool to obtain information about the currently authorized admin along with the workspace details. Useful for understanding who is logged in and their associated workspace. Ensure email addresses of users in custom SSO flows are verified to avoid impersonation risks."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/me".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN")
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def set_admin_away(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    admin_id: Annotated[
        int | None,
        "The unique identifier for the admin to set as away in the Intercom Inbox.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'setAwayAdmin'."]:
    """Mark an admin as away in the Intercom Inbox.

    This tool is used to set an admin's status to away in the Intercom Inbox. It should be called when there is a need to update an admin's availability status to unavailable or offline.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["SETADMINAWAY"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not admin_id:
        missing_params.append(("admin_id", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(f"Required parameters validation failed: {param_details}"),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["SETADMINAWAY"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["SETADMINAWAY"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://{intercom_api_subdomain}.intercom.io/admins/{id}/away".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            id=admin_id,
        ),
        method="PUT",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["SETADMINAWAY"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def get_admin_activity_logs(
    context: ToolContext,
    start_date_unix_timestamp: Annotated[
        str, "The start date for requested data, formatted as a UNIX timestamp."
    ],
    end_date_unix_timestamp: Annotated[
        str | None,
        "The end date for data retrieval in UNIX timestamp format. Determines the latest logs to include.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listActivityLogs'."]:
    """Retrieve a log of activities by all admins in an app.

    Use this tool to get detailed logs of all activities performed by admins within the application. It provides insights into the actions and events conducted by administrative users."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/admins/activity_logs".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN")
        ),
        method="GET",
        params=remove_none_values({
            "created_at_after": start_date_unix_timestamp,
            "created_at_before": end_date_unix_timestamp,
        }),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def fetch_workspace_admins(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listAdmins'."]:
    """Retrieve a list of admins in a workspace.

    Use this tool to fetch and list all administrators associated with a specific workspace."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/admins".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN")
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def retrieve_admin_details(
    context: ToolContext,
    admin_id: Annotated[
        int,
        "The unique identifier for the admin. Provide an integer value to retrieve the admin's details.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'retrieveAdmin'."]:
    """Retrieve details of a specific admin from Intercom.

    Use this tool to get information about a specific admin in your Intercom system by providing the admin ID. It returns relevant data about the admin."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/admins/{id}".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            id=admin_id,
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def list_recent_articles(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listArticles'."]:
    """Fetches a list of all articles from Intercom.

    Use this tool to obtain a list of articles from Intercom, sorted by the most recently updated. Ideal for retrieving the latest content updates."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/articles".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN")
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def create_intercom_article(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'createArticle'."]:
    """Create a new article in Intercom.

    Use this tool to create a new article within the Intercom platform. It should be called when a new knowledge base article is needed.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["CREATEINTERCOMARTICLE"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATEINTERCOMARTICLE"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATEINTERCOMARTICLE"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://{intercom_api_subdomain}.intercom.io/articles".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN")
        ),
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["CREATEINTERCOMARTICLE"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def fetch_intercom_article(
    context: ToolContext,
    article_id: Annotated[
        int,
        "The unique identifier for the article provided by Intercom. Use this to fetch article details.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'retrieveArticle'."]:
    """Fetch details of a specific Intercom article by ID.

    Use this tool to retrieve information about a single article from Intercom by providing the article ID."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/articles/{id}".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            id=article_id,
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def update_article_details(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    article_identifier: Annotated[
        int | None,
        "The unique identifier for the article on Intercom.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'updateArticle'."]:
    """Update details of a specific article on Intercom.

    This tool updates the details of a specific article on Intercom. It should be called when you need to modify an existing article's information.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["UPDATEARTICLEDETAILS"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not article_identifier:
        missing_params.append(("article_identifier", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(f"Required parameters validation failed: {param_details}"),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPDATEARTICLEDETAILS"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPDATEARTICLEDETAILS"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://{intercom_api_subdomain}.intercom.io/articles/{id}".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            id=article_identifier,
        ),
        method="PUT",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["UPDATEARTICLEDETAILS"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def delete_intercom_article(
    context: ToolContext,
    article_id: Annotated[
        int,
        "The unique identifier for the article to be deleted, provided by Intercom.",
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteArticle'."]:
    """Deletes a specified article in Intercom.

    Use this tool to delete an article by providing its unique ID on Intercom. It's useful for managing and removing outdated or incorrect articles from the Intercom system."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/articles/{id}".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            id=article_id,
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def list_collections(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listAllCollections'."]:
    """Retrieve a list of all collections sorted by update date.

    Fetches all collections from Intercom's help center, ordered by the most recent update. Useful for accessing the latest changes."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/help_center/collections".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN")
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def create_help_center_collection(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'createCollection'."]:
    """Create a new collection in the Intercom Help Center.

    This tool allows you to create a new collection in the Intercom Help Center by sending a POST request. Use it when you need to organize content into a new collection.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["CREATEHELPCENTERCOLLECTION"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["CREATEHELPCENTERCOLLECTION"]
                + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["CREATEHELPCENTERCOLLECTION"]
                + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://{intercom_api_subdomain}.intercom.io/help_center/collections".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN")
        ),
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["CREATEHELPCENTERCOLLECTION"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def fetch_intercom_collection_details(
    context: ToolContext,
    collection_id: Annotated[
        int,
        "The unique identifier for the collection provided by Intercom. It is required to fetch a specific collection's details.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'retrieveCollection'."]:
    """Fetches details of a specific Intercom collection.

    Use this tool to fetch and retrieve details about a specific collection from Intercom by providing the collection ID."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/help_center/collections/{id}".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            id=collection_id,
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def update_collection_details(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    collection_id: Annotated[
        int | None,
        "The unique identifier for the collection in Intercom.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'updateCollection'."]:
    """Update the details of a single collection.

    This tool updates the details of a specified collection in Intercom's database by making a PUT request. It should be called when you need to modify existing collection information.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["UPDATECOLLECTIONDETAILS"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not collection_id:
        missing_params.append(("collection_id", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(f"Required parameters validation failed: {param_details}"),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPDATECOLLECTIONDETAILS"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPDATECOLLECTIONDETAILS"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://{intercom_api_subdomain}.intercom.io/help_center/collections/{id}".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            id=collection_id,
        ),
        method="PUT",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["UPDATECOLLECTIONDETAILS"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def delete_collection(
    context: ToolContext,
    collection_id: Annotated[
        int,
        "The unique identifier for the collection provided by Intercom, required to delete it.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteCollection'."]:
    """Delete a specified collection in Intercom.

    Use this tool to delete a specific collection from Intercom by providing the collection ID. This action is irreversible, so ensure you want to permanently remove the collection."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/help_center/collections/{id}".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            id=collection_id,
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def get_help_center_details(
    context: ToolContext,
    help_center_id: Annotated[
        int,
        "The unique identifier for the Help Center collection provided by Intercom.",
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'retrieveHelpCenter'."]:
    """Retrieve detailed information about a specific Help Center.

    This tool fetches details of a single Help Center using its ID, making it useful for obtaining specific information about the Help Center structure and contents."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/help_center/help_centers/{id}".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            id=help_center_id,
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def list_help_centers(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listHelpCenters'."]:
    """Retrieve a list of all Help Centers from Intercom.

    Use this tool to access and retrieve all available Help Centers from Intercom's API. This can be useful for users needing to manage or review the Help Centers associated with their Intercom account."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/help_center/help_centers".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN")
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def get_recent_help_center_sections(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listAllSections'."]:
    """Fetches a list of all help center sections sorted by recent updates.

    This tool retrieves all help center sections from Intercom, sorted in descending order by their last update. It is useful for accessing the most recently updated sections first."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/help_center/sections".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN")
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def create_help_center_section(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'createSection'."]:
    """Create a new section in the help center.

    This tool calls the Intercom API to create a new section in the help center by making a POST request. Use this when you need to organize help center content into a new section.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["CREATEHELPCENTERSECTION"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATEHELPCENTERSECTION"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATEHELPCENTERSECTION"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://{intercom_api_subdomain}.intercom.io/help_center/sections".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN")
        ),
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["CREATEHELPCENTERSECTION"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def get_section_details(
    context: ToolContext,
    section_id: Annotated[
        int, "The unique identifier for the help center section provided by Intercom."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'retrieveSection'."]:
    """Fetch details of a specific help center section by ID.

    Use this tool to obtain information about a particular section within the help center. Provide the specific section ID to retrieve its details."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/help_center/sections/{id}".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            id=section_id,
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def update_help_center_section(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    section_id: Annotated[
        int | None,
        "The unique identifier for the section assigned by Intercom.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'updateSection'."]:
    """Update the details of a help center section.

    Use this tool to update the information of a specific section in the help center by specifying the section ID.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["UPDATEHELPCENTERSECTION"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not section_id:
        missing_params.append(("section_id", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(f"Required parameters validation failed: {param_details}"),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPDATEHELPCENTERSECTION"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPDATEHELPCENTERSECTION"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://{intercom_api_subdomain}.intercom.io/help_center/sections/{id}".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            id=section_id,
        ),
        method="PUT",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["UPDATEHELPCENTERSECTION"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def delete_intercom_section(
    context: ToolContext,
    section_id: Annotated[
        int,
        "The unique identifier for the section to be deleted from Intercom. Provided by Intercom.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteSection'."]:
    """Delete a section from Intercom Help Center.

    Use this tool to delete a specific section from the Intercom Help Center by providing the section ID. It is helpful when managing help center content and removing sections that are no longer needed."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/help_center/sections/{id}".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            id=section_id,
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def create_or_update_company(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'createOrUpdateCompany'."]:
    """Create or update a company in Intercom.

    This tool is used to create or update a company in Intercom. The company is identified by a unique `company_id`. If a company with the given `company_id` exists, it will be updated; otherwise, a new company will be created. Note that a company will only be visible when associated with at least one user.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["CREATEORUPDATECOMPANY"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATEORUPDATECOMPANY"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATEORUPDATECOMPANY"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://{intercom_api_subdomain}.intercom.io/companies".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN")
        ),
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["CREATEORUPDATECOMPANY"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def fetch_company_details(
    context: ToolContext,
    company_id: Annotated[
        str | None, "The unique identifier for the company to retrieve details for."
    ] = None,
    company_name: Annotated[
        str | None, "The exact name of the company to filter and retrieve details for."
    ] = None,
    company_segment_id: Annotated[
        str | None,
        "The segment ID to filter companies by. Use this to retrieve companies associated with a specific segment.",  # noqa: E501
    ] = None,
    company_tag_id: Annotated[
        str | None,
        "The tag ID used to filter and retrieve specific companies by their associated tag.",  # noqa: E501
    ] = None,
    result_page_number: Annotated[
        int | None, "The page number of results to fetch. Defaults to the first page."
    ] = None,
    results_per_page: Annotated[
        int | None, "Number of results to display per page. Defaults to 15."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'retrieveCompany'."]:
    """Fetch detailed information about a single company.

    Use this tool to retrieve information about a company by providing its `company_id` or `name`. Additionally, it can fetch all companies filtered by `segment_id` or `tag_id`. Ideal for obtaining comprehensive company data."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/companies".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN")
        ),
        method="GET",
        params=remove_none_values({
            "name": company_name,
            "company_id": company_id,
            "tag_id": company_tag_id,
            "segment_id": company_segment_id,
            "page": result_page_number,
            "per_page": results_per_page,
        }),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def get_company_details(
    context: ToolContext,
    company_id: Annotated[str, "The unique identifier for the company provided by Intercom."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'RetrieveACompanyById'."]:
    """Retrieve detailed information about a specific company.

    This tool fetches details for a single company using its unique ID. Use it to obtain comprehensive information about a specific company, including any related data available."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/companies/{id}".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            id=company_id,
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def update_company_info(
    context: ToolContext,
    company_identifier: Annotated[
        str,
        "The unique identifier assigned by Intercom for the company. Required to update company details.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'UpdateCompany'."]:
    """Update company information by ID in Intercom.

    This tool updates a company's information using the Intercom provisioned ID. Note that the `company_id` cannot be changed after creation. Use this tool when you need to modify details of an existing company in Intercom."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/companies/{id}".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            id=company_identifier,
        ),
        method="PUT",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def delete_company(
    context: ToolContext,
    company_id: Annotated[str, "The unique identifier for the company to be deleted in Intercom."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteCompany'."]:
    """Deletes a single company by its ID.

    Use this tool to remove a company from the Intercom system. It should be called when you need to delete a company identified by a specific ID."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/companies/{id}".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            id=company_id,
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def fetch_company_contacts(
    context: ToolContext,
    company_id: Annotated[
        str,
        "The unique identifier for the company, provided by Intercom, to fetch associated contacts.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'ListAttachedContacts'."]:
    """Fetch a list of contacts for a specific company.

    Call this tool to retrieve all contacts associated with a specific company using the company ID."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/companies/{id}/contacts".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            id=company_id,
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def list_company_segments(
    context: ToolContext,
    company_id: Annotated[str, "The unique identifier for the company provided by Intercom."],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'ListAttachedSegmentsForCompanies'."
]:
    """Fetch segments belonging to a specific company.

    Use this tool to retrieve a list of all segments attached to a specific company in Intercom. This is useful for understanding how a company is categorized or segmented within Intercom."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/companies/{id}/segments".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            id=company_id,
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def list_companies_intercom(
    context: ToolContext,
    page_number: Annotated[
        int | None,
        "The page number of results to retrieve, starting from the first page by default.",  # noqa: E501
    ] = None,
    results_per_page: Annotated[
        int | None, "Number of results to return per page. The default is 15."
    ] = None,
    sort_order: Annotated[
        str | None,
        "Specify 'asc' for ascending or 'desc' for descending order when listing companies. Defaults to 'desc'.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listAllCompanies'."]:
    """Retrieve a sorted list of companies from Intercom.

    This tool retrieves a list of companies from Intercom, sorted by the most recent request date. Use this to access companies associated with users. Supports pagination for result control."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/companies/list".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN")
        ),
        method="POST",
        params=remove_none_values({
            "page": page_number,
            "per_page": results_per_page,
            "order": sort_order,
        }),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def scroll_through_all_companies(
    context: ToolContext,
    scroll_page_identifier: Annotated[
        str | None,
        "The paging identifier returned in the response to continue fetching the next set of companies. Use the initial API response for the first request and subsequent responses for the next requests.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'scrollOverAllCompanies'."]:
    """Efficiently iterate over all companies using the scroll API.

    This tool should be used when you need to retrieve a large dataset of companies without encountering errors or performance issues. It utilizes the Scroll API to efficiently fetch companies in a dataset. The tool handles the scroll parameter to continue fetching data sequentially. Beware of scroll expirations and network timeouts, which require restarting the scroll operation."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/companies/scroll".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN")
        ),
        method="GET",
        params=remove_none_values({"scroll_param": scroll_page_identifier}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def attach_company_to_contact(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    contact_unique_identifier: Annotated[
        str | None,
        "The unique identifier for the contact as provided by Intercom. This is required to attach a company to the specified contact.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'attachContactToACompany'."]:
    """Attach a company to a single contact in Intercom.

    Use this tool to associate a specific company with a contact in the Intercom platform. It should be called when you need to link a contact to a company, enabling better organization and tracking within the system.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["ATTACHCOMPANYTOCONTACT"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not contact_unique_identifier:
        missing_params.append(("contact_unique_identifier", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(f"Required parameters validation failed: {param_details}"),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["ATTACHCOMPANYTOCONTACT"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["ATTACHCOMPANYTOCONTACT"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://{intercom_api_subdomain}.intercom.io/contacts/{id}/companies".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            id=contact_unique_identifier,
        ),
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["ATTACHCOMPANYTOCONTACT"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def fetch_contact_companies(
    context: ToolContext,
    contact_identifier: Annotated[
        str,
        "The unique identifier for the contact provided by Intercom, required to fetch associated companies.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listCompaniesForAContact'."]:
    """Fetches a list of companies associated with a contact.

    Use this tool to retrieve a list of companies linked to a specific contact. It's useful for understanding the companies that a particular contact is associated with."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/contacts/{id}/companies".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            id=contact_identifier,
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def detach_company_from_contact(
    context: ToolContext,
    company_id: Annotated[str, "The unique identifier for the company provided by Intercom."],
    contact_identifier: Annotated[
        str, "The unique identifier for the contact provided by Intercom."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'detachContactFromACompany'."]:
    """Detach a company from a specified contact in Intercom.

    This tool is used to remove the association between a contact and a company within the Intercom platform. Call this tool when a contact needs to be unlinked from a company."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/contacts/{contact_id}/companies/{id}".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            contact_id=contact_identifier,
            id=company_id,
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def fetch_contact_notes(
    context: ToolContext,
    contact_id: Annotated[int, "The unique ID of the contact whose notes you want to fetch."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listNotes'."]:
    """Fetches notes associated with a specific contact.

    Use this tool to retrieve all notes linked to a particular contact identified by their ID. It is useful for accessing and reviewing notes related to specific contacts."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/contacts/{id}/notes".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            id=contact_id,
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def add_note_to_contact(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    contact_id: Annotated[
        int | None,
        "The unique identifier for the contact to whom the note will be added.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'createNote'."]:
    """Add a note to a contact in Intercom.

    Use this tool to add a note to a specific contact in Intercom by specifying the contact's ID.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["ADDNOTETOCONTACT"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not contact_id:
        missing_params.append(("contact_id", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(f"Required parameters validation failed: {param_details}"),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["ADDNOTETOCONTACT"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["ADDNOTETOCONTACT"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://{intercom_api_subdomain}.intercom.io/contacts/{id}/notes".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            id=contact_id,
        ),
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["ADDNOTETOCONTACT"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def get_contact_segments(
    context: ToolContext,
    contact_unique_identifier: Annotated[
        str,
        "The unique identifier for the contact provided by Intercom. This is required to fetch associated segments.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listSegmentsForAContact'."]:
    """Fetch segments associated with a contact.

    Use this tool to retrieve a list of segments linked to a specific contact in Intercom. Call this when you need to understand segment associations for a given contact ID."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/contacts/{contact_id}/segments".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            contact_id=contact_unique_identifier,
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def list_contact_subscriptions(
    context: ToolContext,
    contact_identifier: Annotated[
        str, "The unique identifier provided by Intercom for the contact."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listSubscriptionsForAContact'."]:
    """Retrieve subscription types associated with a contact.

    Fetch a list of subscription types associated with a contact, including both opt-in and opt-out types."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/contacts/{contact_id}/subscriptions".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            contact_id=contact_identifier,
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def manage_contact_subscription(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    contact_identifier: Annotated[
        str | None,
        "The unique identifier assigned to the contact by Intercom. This is required to specify which contact you want to manage the subscription for.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'attachSubscriptionTypeToContact'."]:
    """Manage a contact's subscription preferences in Intercom.

    Use this tool to add a subscription type to a contact in Intercom. You can opt the contact in or out based on the subscription type selected. It returns the updated subscription type for the contact.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["MANAGECONTACTSUBSCRIPTION"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not contact_identifier:
        missing_params.append(("contact_identifier", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(f"Required parameters validation failed: {param_details}"),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["MANAGECONTACTSUBSCRIPTION"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["MANAGECONTACTSUBSCRIPTION"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://{intercom_api_subdomain}.intercom.io/contacts/{contact_id}/subscriptions".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            contact_id=contact_identifier,
        ),
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["MANAGECONTACTSUBSCRIPTION"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def remove_subscription_from_contact(
    context: ToolContext,
    contact_identifier: Annotated[
        str,
        "The unique identifier for the contact in Intercom. Required to specify which contact's subscription should be removed.",  # noqa: E501
    ],
    subscription_type_id: Annotated[
        str,
        "The unique identifier for the subscription type to remove from a contact in Intercom.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'detachSubscriptionTypeToContact'."]:
    """Remove a specific subscription from a contact.

    Use this tool to remove a subscription type from a specific contact in Intercom. It returns details about the subscription type that was removed."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/contacts/{contact_id}/subscriptions/{id}".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            contact_id=contact_identifier,
            id=subscription_type_id,
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def get_contact_tags(
    context: ToolContext,
    contact_unique_identifier: Annotated[
        str,
        "The unique identifier for the contact, provided by Intercom, used to fetch associated tags.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listTagsForAContact'."]:
    """Fetches tags attached to a specific contact.

    Use this tool to retrieve a list of all tags associated with a given contact in the Intercom system."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/contacts/{contact_id}/tags".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            contact_id=contact_unique_identifier,
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def tag_contact(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    contact_id: Annotated[
        str | None,
        "The unique identifier for the contact in Intercom.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'attachTagToContact'."]:
    """Attach a tag to a specific contact.

    Use this tool to tag a specific contact in your Intercom system. It helps organize and categorize contacts by attaching a tag, returning information about the tag added.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["TAGCONTACT"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not contact_id:
        missing_params.append(("contact_id", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(f"Required parameters validation failed: {param_details}"),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["TAGCONTACT"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["TAGCONTACT"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://{intercom_api_subdomain}.intercom.io/contacts/{contact_id}/tags".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            contact_id=contact_id,
        ),
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["TAGCONTACT"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def remove_tag_from_contact(
    context: ToolContext,
    contact_id: Annotated[
        str,
        "The unique identifier for the contact in Intercom. This ID is necessary to specify which contact to remove the tag from.",  # noqa: E501
    ],
    tag_identifier: Annotated[
        str,
        "The unique identifier for the tag assigned by Intercom. Used to specify which tag to remove from a contact.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'detachTagFromContact'."]:
    """Remove a tag from a specific contact.

    This tool removes a specified tag from a given contact in Intercom, returning the details of the tag that was removed."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/contacts/{contact_id}/tags/{id}".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            contact_id=contact_id,
            id=tag_identifier,
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def update_intercom_contact(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    contact_id: Annotated[
        str | None,
        "The unique identifier of the contact to update in Intercom.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'UpdateContact'."]:
    """Update an existing Intercom contact's details.

    Use this tool to update information for a user or lead in Intercom. Call this tool when you need to modify existing contact details.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["UPDATEINTERCOMCONTACT"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not contact_id:
        missing_params.append(("contact_id", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(f"Required parameters validation failed: {param_details}"),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPDATEINTERCOMCONTACT"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPDATEINTERCOMCONTACT"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://{intercom_api_subdomain}.intercom.io/contacts/{id}".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            id=contact_id,
        ),
        method="PUT",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["UPDATEINTERCOMCONTACT"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def fetch_contact_details(
    context: ToolContext,
    contact_id: Annotated[
        str, "The unique identifier of the contact you want to fetch details for."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'ShowContact'."]:
    """Fetch the details of a specific contact.

    Use this tool to obtain detailed information about a contact by providing their unique ID."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/contacts/{id}".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            id=contact_id,
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def delete_contact(
    context: ToolContext,
    contact_id: Annotated[str, "The unique identifier of the contact to be deleted."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'DeleteContact'."]:
    """Deletes a specified contact from the system.

    Use this tool to permanently delete a contact when you no longer need their information."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/contacts/{id}".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            id=contact_id,
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def merge_contact_intercom(
    context: ToolContext,
    lead_contact_id: Annotated[
        str | None,
        "The unique identifier of the contact to merge away from. It must be a lead.",
    ] = None,
    merge_into_user_id: Annotated[
        str | None,
        "Unique identifier for the contact to merge into. Must be a user contact ID.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'MergeContact'."]:
    """Merge a lead contact into a user contact in Intercom.

    Use this tool to merge a contact with a role of 'lead' into another contact with a role of 'user' on the Intercom platform. This is useful for unifying contact information and maintaining a clean contact database."""  # noqa: E501
    request_data: Any = {"from": lead_contact_id, "into": merge_into_user_id}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/contacts/merge".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN")
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def search_intercom_contacts(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'SearchContacts'."]:
    """Search for contacts by their attributes.

    Allows searching for multiple Intercom contacts using attribute-based filters. Supports combining filters with AND/OR operators to refine search results. Useful for retrieving specific contact data based on defined criteria.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["SEARCHINTERCOMCONTACTS"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["SEARCHINTERCOMCONTACTS"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["SEARCHINTERCOMCONTACTS"] + "\n```"
            ),
        ) from e

    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/contacts/search".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN")
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=json.dumps(request_data),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def fetch_all_contacts(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'ListContacts'."]:
    """Fetch a list of all contacts in your workspace.

    This tool retrieves a list of all contacts, including users or leads, in your Intercom workspace. It supports pagination to manage large datasets, defaulting to 50 results per page."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/contacts".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN")
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def create_new_contact(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'CreateContact'."]:
    """Create a new contact in the Intercom system.

    Use this tool to add a new contact, either a user or a lead, to the Intercom database.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["CREATENEWCONTACT"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATENEWCONTACT"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATENEWCONTACT"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://{intercom_api_subdomain}.intercom.io/contacts".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN")
        ),
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["CREATENEWCONTACT"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def archive_contact(
    context: ToolContext,
    contact_id: Annotated[str, "The unique identifier of the contact to be archived in Intercom."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'ArchiveContact'."]:
    """Archive a single contact in Intercom.

    Use this tool to archive a contact in Intercom by providing the contact's ID. This is helpful when managing contact lists and decluttering inactive contacts."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/contacts/{id}/archive".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            id=contact_id,
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def unarchive_contact(
    context: ToolContext,
    contact_id: Annotated[str, "The unique identifier of the contact to unarchive in Intercom."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'UnarchiveContact'."]:
    """Unarchive a single contact in Intercom.

    Use this tool to unarchive a contact in Intercom by providing the contact ID. It allows reactivation of previously archived contacts."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/contacts/{id}/unarchive".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            id=contact_id,
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def tag_conversation(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    conversation_id: Annotated[
        str | None,
        "The unique identifier of the conversation to which a tag will be attached.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'attachTagToConversation'."]:
    """Attach a tag to a specific conversation.

    Use this tool to add a tag to a particular conversation. It returns a confirmation along with details about the tag added.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["TAGCONVERSATION"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not conversation_id:
        missing_params.append(("conversation_id", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(f"Required parameters validation failed: {param_details}"),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["TAGCONVERSATION"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["TAGCONVERSATION"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://{intercom_api_subdomain}.intercom.io/conversations/{conversation_id}/tags".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            conversation_id=conversation_id,
        ),
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["TAGCONVERSATION"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def remove_tag_from_conversation(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    conversation_id: Annotated[
        str | None,
        "The unique identifier of the conversation from which the tag will be removed.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    tag_id: Annotated[
        str | None,
        "The unique identifier of the tag to be removed from the conversation.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'detachTagFromConversation'."]:
    """Remove a tag from a specific conversation.

    Use this tool to remove a tag from a conversation on Intercom. It detaches the specified tag from the given conversation and returns information about the tag that was removed.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["REMOVETAGFROMCONVERSATION"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not conversation_id:
        missing_params.append(("conversation_id", "path"))
    if not tag_id:
        missing_params.append(("tag_id", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(f"Required parameters validation failed: {param_details}"),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["REMOVETAGFROMCONVERSATION"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["REMOVETAGFROMCONVERSATION"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://{intercom_api_subdomain}.intercom.io/conversations/{conversation_id}/tags/{id}".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            conversation_id=conversation_id,
            id=tag_id,
        ),
        method="DELETE",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["REMOVETAGFROMCONVERSATION"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def fetch_conversation_list(
    context: ToolContext,
    pagination_starting_cursor: Annotated[
        str | None,
        "Cursor string to fetch the next page of conversations for pagination.",
    ] = None,
    results_per_page: Annotated[
        int | None,
        "Number of conversation results to display per page. Default is 20 if not specified.",  # noqa: E501
    ] = 20,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listConversations'."]:
    """Retrieve a list of conversations with optional pagination options.

    Use this tool to fetch a list of all conversations. It supports optional pagination by allowing you to specify the page size and a starting cursor."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/conversations".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN")
        ),
        method="GET",
        params=remove_none_values({
            "per_page": results_per_page,
            "starting_after": pagination_starting_cursor,
        }),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def create_contact_conversation(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'createConversation'."]:
    """Create a conversation initiated by a contact.

    This tool creates a conversation that has been initiated by a contact, which can be a user or a lead. It supports in-app messages and can handle visitors by converting them to contacts with a lead role. Use this tool to initiate communication with contacts effectively.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["CREATECONTACTCONVERSATION"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATECONTACTCONVERSATION"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATECONTACTCONVERSATION"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://{intercom_api_subdomain}.intercom.io/conversations".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN")
        ),
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["CREATECONTACTCONVERSATION"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def get_conversation_details(
    context: ToolContext,
    conversation_id: Annotated[
        int,
        "The ID of the conversation to retrieve details for. This is required to fetch the specific conversation data.",  # noqa: E501
    ],
    retrieve_plaintext_conversation: Annotated[
        str | None,
        "Set to 'plaintext' to retrieve conversation messages in plain text format.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'retrieveConversation'."]:
    """Fetch details of a specific conversation from Intercom.

    Use this tool to retrieve detailed information about a single conversation on Intercom, including up to 500 recent parts. Suitable for accessing conversation metadata, especially when the AI agent is enabled in your workspace."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/conversations/{id}".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            id=conversation_id,
        ),
        method="GET",
        params=remove_none_values({"display_as": retrieve_plaintext_conversation}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def update_conversation(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    conversation_id: Annotated[
        int | None,
        "The ID of the conversation to update. It should be an integer representing the conversation you want to modify.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    retrieve_messages_as_plaintext: Annotated[
        str | None,
        "Specify 'plaintext' to retrieve conversation messages in plain text format.  Only used when mode is 'execute'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'updateConversation'."]:
    """Update an existing conversation.

    Use this tool to update details of an existing conversation without performing actions like replying or assigning.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path, query parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path, query parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["UPDATECONVERSATION"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path, query parameters. "  # noqa: E501
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not conversation_id:
        missing_params.append(("conversation_id", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(f"Required parameters validation failed: {param_details}"),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPDATECONVERSATION"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPDATECONVERSATION"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://{intercom_api_subdomain}.intercom.io/conversations/{id}".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            id=conversation_id,
        ),
        method="PUT",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["UPDATECONVERSATION"],
        params=remove_none_values({"display_as": retrieve_messages_as_plaintext}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def search_conversations(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'searchConversations'."]:
    """Search conversations by specific attributes.

    This tool allows users to search for conversations in Intercom by defining specific attributes and filters. Use operators like AND/OR to refine your search, controlling the number of results with pagination. Call this tool when you need specific conversation details filtered by attributes such as id, created date, or author info.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["SEARCHCONVERSATIONS"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["SEARCHCONVERSATIONS"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["SEARCHCONVERSATIONS"] + "\n```"
            ),
        ) from e

    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/conversations/search".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN")
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=json.dumps(request_data),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def reply_to_intercom_conversation(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    conversation_identifier: Annotated[
        str | None,
        "The unique identifier for the conversation or 'last' to reply to the most recent conversation.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'replyConversation'."]:
    """Reply to a conversation in Intercom with a message or note.

    Use this tool to send a reply to an ongoing conversation in Intercom. It can be used to send messages from an admin, on behalf of a contact, or as a note for other admins.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["REPLYTOINTERCOMCONVERSATION"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not conversation_identifier:
        missing_params.append(("conversation_identifier", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(f"Required parameters validation failed: {param_details}"),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["REPLYTOINTERCOMCONVERSATION"]
                + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["REPLYTOINTERCOMCONVERSATION"]
                + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://{intercom_api_subdomain}.intercom.io/conversations/{id}/reply".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            id=conversation_identifier,
        ),
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["REPLYTOINTERCOMCONVERSATION"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def manage_conversation(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    conversation_id: Annotated[
        str | None,
        "The unique identifier for the conversation in Intercom.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'manageConversation'."]:
    """Manage and update conversation statuses or assignments.

    Use this tool to close, snooze, open, or assign conversations to an admin or team. It helps in efficiently managing conversation workflows and statuses.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["MANAGECONVERSATION"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not conversation_id:
        missing_params.append(("conversation_id", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(f"Required parameters validation failed: {param_details}"),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["MANAGECONVERSATION"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["MANAGECONVERSATION"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://{intercom_api_subdomain}.intercom.io/conversations/{id}/parts".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            id=conversation_id,
        ),
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["MANAGECONVERSATION"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def auto_assign_intercom_conversation(
    context: ToolContext,
    conversation_id: Annotated[
        str, "The unique identifier for the conversation provided by Intercom."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'autoAssignConversation'."]:
    """Auto-assign a conversation in Intercom.

    Use this tool to automatically assign a conversation based on assignment rules in Intercom. Note that this functionality is deprecated in version 2.12 and later, and will be removed by December 31, 2026. This tool should not be used with Workflows."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/conversations/{id}/run_assignment_rules".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            id=conversation_id,
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def attach_contact_to_conversation(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    conversation_id: Annotated[
        str | None,
        "The unique identifier for the conversation in Intercom.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'attachContactToConversation'."]:
    """Attach a contact to a conversation in Intercom.

    Use this tool to add a contact as a participant to an Intercom conversation. If a contact is added via email and does not exist, a new contact with the role of 'lead' will be created. This is useful for managing participants in ongoing discussions.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["ATTACHCONTACTTOCONVERSATION"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not conversation_id:
        missing_params.append(("conversation_id", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(f"Required parameters validation failed: {param_details}"),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["ATTACHCONTACTTOCONVERSATION"]
                + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["ATTACHCONTACTTOCONVERSATION"]
                + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://{intercom_api_subdomain}.intercom.io/conversations/{id}/customers".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            id=conversation_id,
        ),
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["ATTACHCONTACTTOCONVERSATION"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def detach_contact_from_conversation(
    context: ToolContext,
    contact_identifier: Annotated[
        str,
        "The unique identifier for the contact provided by Intercom. Use this to specify which contact to detach from the conversation.",  # noqa: E501
    ],
    conversation_identifier: Annotated[
        str,
        "The unique identifier for the conversation in Intercom. This is required to detach the contact from the specified conversation.",  # noqa: E501
    ],
    admin_id: Annotated[
        dict[str, str] | None, "The ID of the admin performing the detachment action."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'detachContactFromConversation'."]:
    """Detach a contact from a conversation in Intercom.

    Use this tool to remove a participant who is a contact from a specific conversation within Intercom. The tool should be called when you need to unlink contacts from conversations on Intercom, using their conversation and contact IDs."""  # noqa: E501
    request_data: Any = admin_id
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/conversations/{conversation_id}/customers/{contact_id}".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            conversation_id=conversation_identifier,
            contact_id=contact_identifier,
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def redact_conversation_part_or_message(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'redactConversation'."]:
    """Redact specific parts or messages within a conversation.

    Use this tool to redact a specific part of a conversation or the original message source. Ensure the targeted part has a body if a conversation part is being redacted. For source messages, they must originate from a contact. If criteria are not met, an error will be returned.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["REDACTCONVERSATIONPARTORMESSAGE"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["REDACTCONVERSATIONPARTORMESSAGE"]
                + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["REDACTCONVERSATIONPARTORMESSAGE"]
                + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://{intercom_api_subdomain}.intercom.io/conversations/redact".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN")
        ),
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["REDACTCONVERSATIONPARTORMESSAGE"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def list_workspace_data_attributes(
    context: ToolContext,
    data_attribute_model: Annotated[
        str | None, "Specify the model type: 'contact', 'company', or 'conversation'."
    ] = None,
    include_archived_attributes: Annotated[
        bool | None,
        "Set to true to include archived attributes in the list. By default, archived attributes are excluded.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'lisDataAttributes'."]:
    """Fetch data attributes for contacts, companies, or conversations.

    Use this tool to retrieve a comprehensive list of all data attributes associated with a workspace, specifically for contacts, companies, or conversations."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/data_attributes".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN")
        ),
        method="GET",
        params=remove_none_values({
            "model": data_attribute_model,
            "include_archived": include_archived_attributes,
        }),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def create_data_attribute(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'createDataAttribute'."]:
    """Create a data attribute for a contact or company.

    This tool allows you to create a data attribute for a contact or company using the Intercom API. Use this when you need to add a new attribute to store additional information.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["CREATEDATAATTRIBUTE"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATEDATAATTRIBUTE"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATEDATAATTRIBUTE"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://{intercom_api_subdomain}.intercom.io/data_attributes".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN")
        ),
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["CREATEDATAATTRIBUTE"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def update_data_attribute(
    context: ToolContext,
    data_attribute_id: Annotated[
        int, "The unique identifier for the data attribute to be updated."
    ],
    allow_messenger_updates: Annotated[
        bool | None,
        "Specify if the data attribute can be updated by the Messenger. Use 'true' to allow updates and 'false' to prevent them.",  # noqa: E501
    ] = None,
    archive_attribute: Annotated[
        bool | None,
        "Indicate if the attribute should be archived. `True` to archive, `False` to keep unarchived.",  # noqa: E501
    ] = None,
    attribute_description: Annotated[
        str | None,
        "The readable description for the attribute as seen in the UI. Provides context or additional information about the attribute.",  # noqa: E501
    ] = None,
    list_attribute_options: Annotated[
        list[str] | None,
        "An array of strings representing options for list attributes. Each option should be provided as a hash with `value` as the key and the data type must be `string`.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'updateDataAttribute'."]:
    """Update a data attribute's value via the API.

    Use this tool to update a data attribute's value on Intercom. Note that changing the data type via the API is not supported; it must be done through the UI."""  # noqa: E501
    request_data: Any = {
        "archived": archive_attribute,
        "description": attribute_description,
        "options": list_attribute_options,
        "messenger_writable": allow_messenger_updates,
    }
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/data_attributes/{id}".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            id=data_attribute_id,
        ),
        method="PUT",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def send_intercom_event(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'createDataEvent'."]:
    """Submit events to Intercom for user activity tracking.

    This tool is used to send events to Intercom, associating them with a user, lead, or visitor. It captures activities and actions taken by users in your application. Useful for tracking user interactions and behaviors, including metadata. Requires an Access Token with write permissions.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["SENDINTERCOMEVENT"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["SENDINTERCOMEVENT"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["SENDINTERCOMEVENT"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://{intercom_api_subdomain}.intercom.io/events".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN")
        ),
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["SENDINTERCOMEVENT"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def create_event_summaries(
    context: ToolContext,
    event_last_occurrence: Annotated[
        int | None, "The timestamp representing the last occurrence of the event."
    ] = None,
    event_name_for_summaries: Annotated[
        str | None,
        "The name of the event, typically a past-tense verb-noun combination like 'updated-plan'.",  # noqa: E501
    ] = None,
    event_occurrence_count: Annotated[
        int | None, "The number of times the event occurred for the specified user."
    ] = None,
    first_event_timestamp: Annotated[
        int | None,
        "Timestamp for when the event first occurred. Use an integer representing Unix time.",  # noqa: E501
    ] = None,
    user_identifier: Annotated[
        str | None, "The unique identifier for the user to create event summaries for."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'dataEventSummaries'."]:
    """Create event summaries for tracking user events.

    This tool creates event summaries for a user, tracking the number of times an event has occurred along with the first and last occurrence."""  # noqa: E501
    request_data: Any = {
        "user_id": user_identifier,
        "event_summaries": {
            "event_name": event_name_for_summaries,
            "count": event_occurrence_count,
            "first": first_event_timestamp,
            "last": event_last_occurrence,
        },
    }
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/events/summaries".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN")
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def create_message_data_export(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'createDataExport'."]:
    """Create a data export job for Intercom messages.

    This tool creates a data export job for message content within specified date ranges in Intercom. Only one active export job is permitted per workspace. Dates include all data from the specified start to end dates.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["CREATEMESSAGEDATAEXPORT"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATEMESSAGEDATAEXPORT"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATEMESSAGEDATAEXPORT"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://{intercom_api_subdomain}.intercom.io/export/content/data".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN")
        ),
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["CREATEMESSAGEDATAEXPORT"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def check_export_job_status(
    context: ToolContext,
    job_identifier: Annotated[
        str,
        "The unique identifier for the export job you want to check. This ID is provided when the export job is created.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getDataExport'."]:
    """Check the status of your Intercom data export job.

    Use this tool to view the status of an export job in Intercom. It retrieves details about whether the job is still processing or completed, and notes the expiry of completed jobs, which is two days after completion."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/export/content/data/{job_identifier}".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            job_identifier=job_identifier,
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def cancel_data_export_job(
    context: ToolContext,
    job_identifier: Annotated[
        str,
        "The unique identifier for the data export job to be canceled. This is required to specify which job to stop.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'cancelDataExport'."]:
    """Cancels an active data export job on Intercom.

    Use this tool to cancel an ongoing data export job on Intercom by providing the job identifier."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/export/cancel/{job_identifier}".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            job_identifier=job_identifier,
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def download_intercom_data_export(
    context: ToolContext,
    job_identifier: Annotated[
        str,
        "The unique identifier for the completed data export job. Required to download the data.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'downloadDataExport'."]:
    """Download completed data exports from Intercom.

    This tool downloads your exported message data from Intercom when the export job is complete and a download URL is available. The data is returned in a gzipped CSV format."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/download/content/data/{job_identifier}".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            job_identifier=job_identifier,
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def create_admin_initiated_message(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'createMessage'."]:
    """Create a message initiated by an admin via Intercom.

    This tool allows you to create a message initiated by an admin, either as an in-app message or an email, using Intercom. Note that there might be a delay before a new contact can be messaged. The created message model is returned.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["CREATEADMININITIATEDMESSAGE"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["CREATEADMININITIATEDMESSAGE"]
                + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["CREATEADMININITIATEDMESSAGE"]
                + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://{intercom_api_subdomain}.intercom.io/messages".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN")
        ),
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["CREATEADMININITIATEDMESSAGE"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def fetch_news_items(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listNewsItems'."]:
    """Retrieve a list of news items from Intercom.

    Use this tool to fetch the latest news articles available through the Intercom service."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/news/news_items".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN")
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def create_news_item(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'createNewsItem'."]:
    """Create a news item using Intercom.

    This tool allows the creation of a news item via Intercom's API. Use it when you need to publish or distribute a new piece of news.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["CREATENEWSITEM"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATENEWSITEM"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATENEWSITEM"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://{intercom_api_subdomain}.intercom.io/news/news_items".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN")
        ),
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["CREATENEWSITEM"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def get_news_item_details(
    context: ToolContext,
    news_item_id: Annotated[int, "The unique identifier for the news item provided by Intercom."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'retrieveNewsItem'."]:
    """Fetches details of a specific news item.

    Use this tool to retrieve full information about a particular news item using its unique identifier."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/news/news_items/{id}".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            id=news_item_id,
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def update_news_item(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    news_item_id: Annotated[
        int | None,
        "The unique identifier for the news item provided by Intercom.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'updateNewsItem'."]:
    """Updates information for a specific news item.

    Call this tool to modify the details of an existing news item by its ID. Use it when you need to change or correct the content of a news article. The tool confirms whether the update was successful or not.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["UPDATENEWSITEM"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not news_item_id:
        missing_params.append(("news_item_id", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(f"Required parameters validation failed: {param_details}"),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPDATENEWSITEM"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPDATENEWSITEM"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://{intercom_api_subdomain}.intercom.io/news/news_items/{id}".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            id=news_item_id,
        ),
        method="PUT",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["UPDATENEWSITEM"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def delete_news_item(
    context: ToolContext,
    news_item_id: Annotated[int, "The unique identifier for the news item to be deleted."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteNewsItem'."]:
    """Delete a specific news item from the platform.

    Use this tool to delete a specific news item by its ID. This helps in managing content by removing outdated or incorrect news items."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/news/news_items/{id}".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            id=news_item_id,
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def fetch_live_newsfeed_items(
    context: ToolContext,
    newsfeed_id: Annotated[
        str,
        "The unique identifier for the newsfeed, provided by Intercom, to retrieve live news items.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listLiveNewsfeedItems'."]:
    """Retrieve all live news items from a specific newsfeed.

    This tool fetches a list of all current live news items from a specified newsfeed using the newsfeed's unique ID."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/news/newsfeeds/{id}/items".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            id=newsfeed_id,
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def fetch_all_newsfeeds(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listNewsfeeds'."]:
    """Fetch a list of all available newsfeeds.

    Use this tool to retrieve a complete list of newsfeeds from the service."""
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/news/newsfeeds".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN")
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def fetch_newsfeed_details(
    context: ToolContext,
    newsfeed_id: Annotated[
        str,
        "The unique identifier for the newsfeed item provided by Intercom. Use this to retrieve specific newsfeed details.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'retrieveNewsfeed'."]:
    """Fetch details of a specific newsfeed using its ID.

    Use this tool to retrieve comprehensive details about a particular newsfeed by providing its unique ID. This can be called when you need to access information about a single newsfeed item."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/news/newsfeeds/{id}".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            id=newsfeed_id,
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def fetch_note_details(
    context: ToolContext,
    note_id: Annotated[int, "The unique identifier for the note you want to retrieve details for."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'retrieveNote'."]:
    """Fetches details of a specific note.

    Use this tool to retrieve the details of a single note based on its ID. It should be called when detailed information about a specific note is needed."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/notes/{id}".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            id=note_id,
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def get_all_segments(
    context: ToolContext,
    include_contact_count: Annotated[
        bool | None, "Set to true to include the number of contacts in each segment."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listSegments'."]:
    """Retrieve a list of all segments.

    Use this tool to fetch and display all segments in Intercom, allowing you to view and manage customer groupings efficiently."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/segments".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN")
        ),
        method="GET",
        params=remove_none_values({"include_count": include_contact_count}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def get_segment_details(
    context: ToolContext,
    segment_id: Annotated[
        str, "The unique identifier of a specific segment to retrieve details for."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'retrieveSegment'."]:
    """Fetch details of a single segment from Intercom.

    This tool retrieves detailed information about a specific segment in Intercom. It should be called when you need to access or display segment details. Useful for understanding user groups within Intercom."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/segments/{id}".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            id=segment_id,
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def list_subscription_types(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listSubscriptionTypes'."]:
    """Retrieve all subscription types from Intercom.

    Use this tool to obtain a list of all available subscription types in Intercom, which can be useful for managing or displaying subscription options."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/subscription_types".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN")
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def deflect_phone_calls_to_messenger(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'createPhoneSwitch'."]:
    """Deflect phone calls to Intercom Messenger via SMS link.

    Use this tool to send an SMS with a link to the Intercom Messenger, redirecting phone calls to the Messenger. If custom attributes are provided, they will be added to the user or lead's custom data.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["DEFLECTPHONECALLSTOMESSENGER"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["DEFLECTPHONECALLSTOMESSENGER"]
                + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["DEFLECTPHONECALLSTOMESSENGER"]
                + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://{intercom_api_subdomain}.intercom.io/phone_call_redirects".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN")
        ),
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["DEFLECTPHONECALLSTOMESSENGER"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def fetch_workspace_tags(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listTags'."]:
    """Retrieve all tags from a workspace in Intercom.

    This tool fetches a list of all tags associated with a given workspace in Intercom. Use it to manage or organize content by accessing the available tags."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/tags".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN")
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def manage_tag_operations(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'createTag'."]:
    """Create, update, or manage tags for companies and users.

    This tool allows you to create or update tags, and manage tagging or untagging companies and users. It automatically creates new tags if they don't exist, while executing the tagging operations.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["MANAGETAGOPERATIONS"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["MANAGETAGOPERATIONS"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["MANAGETAGOPERATIONS"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://{intercom_api_subdomain}.intercom.io/tags".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN")
        ),
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["MANAGETAGOPERATIONS"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def fetch_tag_details(
    context: ToolContext,
    tag_id: Annotated[
        str,
        "The unique identifier for a specific tag to fetch its details from the workspace.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'findTag'."]:
    """Fetch details of a tag using its ID from the workspace.

    Use this tool to obtain information about specific tags in your workspace by providing the tag ID. It retrieves a tag object with relevant details."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/tags/{id}".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            id=tag_id,
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def remove_tag(
    context: ToolContext,
    tag_id: Annotated[str, "The unique identifier of the tag to be deleted from the workspace."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteTag'."]:
    """Delete a tag from the Intercom workspace using its ID.

    This tool deletes a tag from your Intercom workspace by using the tag's unique ID. Use it to manage and organize your workspace efficiently by removing unnecessary or outdated tags."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/tags/{id}".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            id=tag_id,
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def list_app_teams(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listTeams'."]:
    """Retrieve a list of teams for the application.

    This tool is used to fetch all team objects associated with the application. It should be called when you need detailed information about the teams configured in the app."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/teams".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN")
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def get_team_details(
    context: ToolContext,
    team_unique_identifier: Annotated[
        str, "The unique identifier of a specific team to retrieve details."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'retrieveTeam'."]:
    """Fetch details of a team and its admins.

    Use this tool to fetch comprehensive details about a specific team, including the list of admins associated with it. It's useful for scenarios where you need to understand the team composition within Intercom."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/teams/{id}".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            id=team_unique_identifier,
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def create_ticket_attribute(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    ticket_type_identifier: Annotated[
        str | None,
        "The unique identifier for the ticket type provided by Intercom, required to specify which ticket type the new attribute will be added to.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'createTicketTypeAttribute'."]:
    """Create a new attribute for a ticket type.

    Use this tool to add a custom attribute to a specified ticket type within the Intercom service. Ideal for augmenting ticket types with additional metadata.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["CREATETICKETATTRIBUTE"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not ticket_type_identifier:
        missing_params.append(("ticket_type_identifier", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(f"Required parameters validation failed: {param_details}"),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATETICKETATTRIBUTE"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATETICKETATTRIBUTE"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://{intercom_api_subdomain}.intercom.io/ticket_types/{ticket_type_id}/attributes".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            ticket_type_id=ticket_type_identifier,
        ),
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["CREATETICKETATTRIBUTE"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def update_ticket_type_attribute(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    ticket_type_identifier: Annotated[
        str | None,
        "The unique identifier for the ticket type provided by Intercom.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    ticket_attribute_id: Annotated[
        str | None,
        "The unique identifier for the ticket type attribute given by Intercom.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'updateTicketTypeAttribute'."]:
    """Updates an existing attribute for a ticket type.

    Use this tool to modify the attributes of a specific ticket type in Intercom by providing the ticket type and attribute IDs.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["UPDATETICKETTYPEATTRIBUTE"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not ticket_type_identifier:
        missing_params.append(("ticket_type_identifier", "path"))
    if not ticket_attribute_id:
        missing_params.append(("ticket_attribute_id", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(f"Required parameters validation failed: {param_details}"),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPDATETICKETTYPEATTRIBUTE"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPDATETICKETTYPEATTRIBUTE"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://{intercom_api_subdomain}.intercom.io/ticket_types/{ticket_type_id}/attributes/{id}".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            ticket_type_id=ticket_type_identifier,
            id=ticket_attribute_id,
        ),
        method="PUT",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["UPDATETICKETTYPEATTRIBUTE"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def get_ticket_types(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listTicketTypes'."]:
    """Retrieve a list of all ticket types for a workspace.

    This tool fetches a list of all available ticket types within a workspace, useful for understanding support categories."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/ticket_types".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN")
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def create_ticket_type(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'createTicketType'."]:
    """Create a new ticket type with default attributes.

    This tool allows creating a new ticket type in Intercom, including default title and description attributes. An emoji icon can be added using the Twemoji Cheatsheet.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["CREATETICKETTYPE"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATETICKETTYPE"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATETICKETTYPE"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://{intercom_api_subdomain}.intercom.io/ticket_types".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN")
        ),
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["CREATETICKETTYPE"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def fetch_ticket_type_details(
    context: ToolContext,
    ticket_type_id: Annotated[
        str,
        "The unique identifier for the ticket type assigned by Intercom. Used to fetch specific ticket type details.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getTicketType'."]:
    """Fetches details of a specific ticket type in Intercom.

    Use this tool to retrieve information about a particular ticket type by its ID from the Intercom service."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/ticket_types/{id}".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            id=ticket_type_id,
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def update_ticket_type(
    context: ToolContext,
    ticket_type_id: Annotated[
        str, "The unique identifier for the ticket type as given by Intercom."
    ],
    internal_use: Annotated[
        bool | None,
        "Set to true if tickets are intended for internal use only; false for customer sharing.",  # noqa: E501
    ] = False,
    is_ticket_type_archived: Annotated[
        bool | None,
        "Set to true to archive the ticket type, or false to keep it active.",
    ] = None,
    ticket_type_description: Annotated[
        str | None,
        "Describe the ticket type. This should provide an overview or details about the ticket type.",  # noqa: E501
    ] = None,
    ticket_type_icon: Annotated[
        str | None,
        "Specify an emoji for the ticket type icon using Twemoji Cheatsheet.",
    ] = "",
    ticket_type_name: Annotated[
        str | None, "The name of the ticket type you want to update."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'updateTicketType'."]:
    """Update a ticket type with a new icon or details.

    Use this tool to update a ticket type in the system. You can modify attributes such as icon and other details. Ensure the icon is an emoji from the Twemoji Cheatsheet."""  # noqa: E501
    request_data: Any = {
        "name": ticket_type_name,
        "description": ticket_type_description,
        "icon": ticket_type_icon,
        "archived": is_ticket_type_archived,
        "is_internal": internal_use,
    }
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/ticket_types/{id}".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            id=ticket_type_id,
        ),
        method="PUT",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def reply_to_ticket(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    ticket_id: Annotated[
        str | None,
        "The unique identifier of the ticket to reply to. This must be provided to specify which ticket the admin note is for.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'replyTicket'."]:
    """Reply to a ticket with an admin note.

    Use this tool to add a reply note to a specific ticket from an admin. Ideal for cases where you need to provide information or updates about a ticket directly from an admin's perspective.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["REPLYTOTICKET"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not ticket_id:
        missing_params.append(("ticket_id", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(f"Required parameters validation failed: {param_details}"),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["REPLYTOTICKET"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["REPLYTOTICKET"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://{intercom_api_subdomain}.intercom.io/tickets/{id}/reply".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            id=ticket_id,
        ),
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["REPLYTOTICKET"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def create_intercom_ticket(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'createTicket'."]:
    """Create a new support ticket in Intercom.

    Use this tool to generate a new support ticket via Intercom. Ideal for handling customer queries or issues by automatically logging them into the ticketing system.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["CREATEINTERCOMTICKET"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATEINTERCOMTICKET"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATEINTERCOMTICKET"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://{intercom_api_subdomain}.intercom.io/tickets".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN")
        ),
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["CREATEINTERCOMTICKET"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def update_support_ticket(
    context: ToolContext,
    ticket_id: Annotated[str, "The unique identifier for the ticket as provided by Intercom."],
    admin_id: Annotated[
        str | None, "The ID of the admin performing the action on the ticket."
    ] = None,
    assignee_id: Annotated[
        str | None,
        "The ID of the admin or team to which the ticket is assigned. Use '0' to unassign.",  # noqa: E501
    ] = None,
    ticket_details: Annotated[
        dict[str, str] | None,
        "A JSON object containing key-value pairs of the ticket attributes to be updated, such as subject, priority, or tags.",  # noqa: E501
    ] = None,
    ticket_state: Annotated[
        str | None,
        "The current state of the ticket. Must be one of: 'in_progress', 'waiting_on_customer', or 'resolved'.",  # noqa: E501
    ] = None,
    ticket_visible_to_users: Annotated[
        bool | None,
        "Set to true to make the ticket visible to users; false to keep it hidden.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'updateTicket'."]:
    """Modify an existing support ticket in Intercom.

    Use this tool to update the details of a support ticket in Intercom, such as status, priority, or assigned agent. This is helpful for managing customer support requests efficiently."""  # noqa: E501
    request_data: Any = {
        "ticket_attributes": ticket_details,
        "state": ticket_state,
        "is_shared": ticket_visible_to_users,
        "assignment": {"admin_id": admin_id, "assignee_id": assignee_id},
    }
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/tickets/{id}".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            id=ticket_id,
        ),
        method="PUT",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def fetch_ticket_details(
    context: ToolContext,
    ticket_identifier: Annotated[
        str, "The unique identifier for the ticket, as provided by Intercom."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getTicket'."]:
    """Fetch details of a specific ticket from Intercom.

    Use this tool to retrieve comprehensive information about a specific Intercom ticket by providing its ID."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/tickets/{id}".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN"),
            id=ticket_identifier,
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def update_visitor_info(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'updateVisitor'."]:
    """Update an existing visitor's information in Intercom.

    Use this tool to update a visitor's information by providing their `user_id` or `id`. It sends a PUT request to modify the visitor's details in Intercom's system.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["UPDATEVISITORINFO"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPDATEVISITORINFO"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPDATEVISITORINFO"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://{intercom_api_subdomain}.intercom.io/visitors".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN")
        ),
        method="PUT",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["UPDATEVISITORINFO"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def fetch_visitor_details(
    context: ToolContext,
    visitor_user_id: Annotated[str, "The user ID of the visitor you want to retrieve details for."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'retrieveVisitorWithUserId'."]:
    """Fetch details of a single visitor using their user ID.

    Use this tool to retrieve information about a visitor based on their user ID from Intercom."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://{intercom_api_subdomain}.intercom.io/visitors".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN")
        ),
        method="GET",
        params=remove_none_values({"user_id": visitor_user_id}),
        headers=remove_none_values({
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="intercom"),
    requires_secrets=["INTERCOM_API_SUBDOMAIN"],
)
async def convert_visitor_to_user(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'convertVisitor'."]:
    """Convert a Visitor into a User or merge with an existing User.

    Use this tool to convert a Visitor to a Contact of role type `lead` or `user`. If the User already exists, the Visitor will be merged into it and the User details will be returned. If the User does not exist, the Visitor will become a User, with their identifiers updated.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["CONVERTVISITORTOUSER"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CONVERTVISITORTOUSER"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CONVERTVISITORTOUSER"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://{intercom_api_subdomain}.intercom.io/visitors/convert".format(  # noqa: UP032
            intercom_api_subdomain=context.get_secret("INTERCOM_API_SUBDOMAIN")
        ),
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["CONVERTVISITORTOUSER"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Intercom-Version": "2.9",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}
