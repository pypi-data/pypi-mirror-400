"""Post-processing module to convert OpenDRIVE objects to signals.

This module converts traffic sign objects (as generated by netconvert) into
proper OpenDRIVE signals for compatibility with simulators like CARLA.
"""

from __future__ import annotations

import xml.etree.ElementTree as ET
from dataclasses import dataclass
from pathlib import Path

from loguru import logger

# CARLA / OpenDRIVE Standard Mapping (German StVO codes)
# These are commonly used traffic sign type IDs
TYPE_MAPPING: dict[str, str] = {
    "priority": "306",  # Priority road (Diamond sign)
    "yield": "205",  # Yield / Give Way
    "stop": "206",  # Stop
    "right before left": "102",  # Danger: Crossroad
    "speedLimit": "274",  # Speed Limit
}

# Default dimensions for different sign types (width, height) in meters
DIMENSIONS: dict[str, tuple[str, str]] = {
    "306": ("0.6", "0.6"),  # Priority road
    "205": ("0.9", "0.8"),  # Yield
    "206": ("0.75", "0.75"),  # Stop
    "102": ("0.7", "0.7"),  # Danger: Crossroad
    "274": ("0.6", "0.6"),  # Speed Limit
}


@dataclass
class ConversionResult:
    """Result of a signal conversion operation."""

    success: bool
    signals_converted: int
    poles_added: int
    error: str | None = None


def _add_pole(objects_elem: ET.Element, source_obj: ET.Element) -> None:
    """Add a pole object for a given sign object.

    Args:
        objects_elem: Parent objects element to add pole to.
        source_obj: Source sign object to create pole for.
    """
    pole = ET.SubElement(objects_elem, "object")
    pole.set("id", source_obj.get("id", "") + ".pole")
    pole.set("type", "pole")
    pole.set("name", "Sign Pole")
    pole.set("s", source_obj.get("s", "0.0"))
    pole.set("t", source_obj.get("t", "0.0"))
    pole.set("zOffset", "0.0")
    pole.set("height", "2.0")
    pole.set("radius", "0.05")
    pole.set("dynamic", "no")
    pole.set("hdg", "0.0")
    pole.set("pitch", "0.0")
    pole.set("roll", "0.0")


def _process_signals(
    objects_elem: ET.Element,
    signals_elem: ET.Element,
) -> tuple[int, int]:
    """Convert traffic sign objects to OpenDRIVE signals.

    Args:
        objects_elem: Objects element containing sign objects.
        signals_elem: Signals element to add converted signals to.

    Returns:
        Tuple of (signals_converted, poles_added).
    """
    to_remove: list[ET.Element] = []
    converted_count = 0
    poles_count = 0

    for obj in objects_elem.findall("object"):
        raw_type = obj.get("type")

        if raw_type in TYPE_MAPPING:
            signal_type_id = TYPE_MAPPING[raw_type]

            # Create Signal
            signal = ET.SubElement(signals_elem, "signal")
            signal.set("id", obj.get("id", ""))
            signal.set("type", signal_type_id)
            signal.set("name", raw_type or "")
            signal.set("s", obj.get("s", "0.0"))
            signal.set("t", obj.get("t", "0.0"))
            signal.set("dynamic", "no")
            signal.set("zOffset", "2.0")
            signal.set("country", "SE")  # Sweden

            w, h = DIMENSIONS.get(signal_type_id, ("0.5", "0.5"))
            signal.set("width", w)
            signal.set("height", h)

            signal.set("hOffset", "0.0")
            signal.set("pitch", "0.0")
            signal.set("roll", "0.0")

            # Set orientation based on t-coordinate
            try:
                t_str = obj.get("t")
                if t_str:
                    t_val = float(t_str)
                    signal.set("orientation", "+" if t_val < 0 else "-")
                else:
                    signal.set("orientation", "none")
            except (ValueError, TypeError):
                signal.set("orientation", "none")

            # Create Pole
            _add_pole(objects_elem, obj)
            poles_count += 1

            to_remove.append(obj)
            converted_count += 1

    for obj in to_remove:
        objects_elem.remove(obj)

    return converted_count, poles_count


def convert_objects_to_signals(xodr_file: Path) -> ConversionResult:
    """Convert traffic sign objects to OpenDRIVE signals in an XODR file.

    This function modifies the XODR file in place, converting objects
    with known traffic sign types to proper signal elements.

    Args:
        xodr_file: Path to the OpenDRIVE file to process.

    Returns:
        ConversionResult with success status and counts.
    """
    logger.info(f"Post-processing {xodr_file}...")

    if not xodr_file.exists():
        return ConversionResult(
            success=False,
            signals_converted=0,
            poles_added=0,
            error=f"File not found: {xodr_file}",
        )

    try:
        tree = ET.parse(xodr_file)
        root = tree.getroot()
    except ET.ParseError as e:
        return ConversionResult(
            success=False,
            signals_converted=0,
            poles_added=0,
            error=f"Failed to parse XML: {e}",
        )

    total_signals = 0
    total_poles = 0

    for road in root.findall("road"):
        objects_elem = road.find("objects")
        if objects_elem is None:
            continue

        signals_elem = road.find("signals")
        if signals_elem is None:
            signals_elem = ET.SubElement(road, "signals")

        signals, poles = _process_signals(objects_elem, signals_elem)
        total_signals += signals
        total_poles += poles

        # Remove empty objects element
        if len(objects_elem) == 0:
            road.remove(objects_elem)

    if total_signals > 0:
        try:
            tree.write(xodr_file, encoding="UTF-8", xml_declaration=True)
            logger.info(f"Converted {total_signals} signals, added {total_poles} poles")
        except Exception as e:
            return ConversionResult(
                success=False,
                signals_converted=total_signals,
                poles_added=total_poles,
                error=f"Failed to write file: {e}",
            )
    else:
        logger.info("No matching objects found to convert")

    return ConversionResult(
        success=True,
        signals_converted=total_signals,
        poles_added=total_poles,
    )
