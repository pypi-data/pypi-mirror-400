from _typeshed import Incomplete
from pyomo.common.autoslots import AutoSlots as AutoSlots
from pyomo.common.deprecation import RenamedClass as RenamedClass
from pyomo.common.deprecation import deprecation_warning as deprecation_warning
from pyomo.common.errors import PyomoException as PyomoException
from pyomo.common.log import is_debug_set as is_debug_set
from pyomo.common.modeling import NOTSET as NOTSET
from pyomo.common.modeling import unique_component_name as unique_component_name
from pyomo.common.numeric_types import native_logical_types as native_logical_types
from pyomo.common.numeric_types import native_types as native_types
from pyomo.common.timing import ConstructionTimer as ConstructionTimer
from pyomo.core import Any as Any
from pyomo.core import Binary as Binary
from pyomo.core import Block as Block
from pyomo.core import BooleanValue as BooleanValue
from pyomo.core import ConstraintList as ConstraintList
from pyomo.core import LogicalConstraintList as LogicalConstraintList
from pyomo.core import ModelComponentFactory as ModelComponentFactory
from pyomo.core import ScalarBooleanVar as ScalarBooleanVar
from pyomo.core import ScalarVar as ScalarVar
from pyomo.core import value as value
from pyomo.core.base.block import BlockData as BlockData
from pyomo.core.base.component import ActiveComponent as ActiveComponent
from pyomo.core.base.component import ActiveComponentData as ActiveComponentData
from pyomo.core.base.component import ComponentData as ComponentData
from pyomo.core.base.global_set import UnindexedComponent_index as UnindexedComponent_index
from pyomo.core.base.indexed_component import ActiveIndexedComponent as ActiveIndexedComponent
from pyomo.core.base.misc import apply_indexed_rule as apply_indexed_rule
from pyomo.core.expr.expr_common import ExpressionType as ExpressionType

logger: Incomplete

class GDP_Error(PyomoException): ...

class AutoLinkedBinaryVar(ScalarVar):
    INTEGER_TOLERANCE: float
    __autoslot_mappers__: Incomplete
    def __init__(self, boolean_var=None) -> None: ...
    def get_associated_boolean(self): ...
    def set_value(
        self, val, skip_validation: bool = False, _propagate_value: bool = True
    ) -> None: ...
    def fix(self, value=..., skip_validation: bool = False) -> None: ...
    def unfix(self) -> None: ...

class AutoLinkedBooleanVar(ScalarBooleanVar):
    def as_numeric(self): ...
    def as_binary(self): ...
    def set_value(
        self, val, skip_validation: bool = False, _propagate_value: bool = True
    ) -> None: ...
    def fix(self, value=..., skip_validation: bool = False) -> None: ...
    def unfix(self) -> None: ...
    @property
    def bounds(self): ...
    @bounds.setter
    def bounds(self, value) -> None: ...
    @property
    def lb(self): ...
    @lb.setter
    def lb(self, value) -> None: ...
    @property
    def ub(self): ...
    @ub.setter
    def ub(self, value) -> None: ...
    def __abs__(self): ...
    def __float__(self) -> float: ...
    def __int__(self) -> int: ...
    def __neg__(self): ...
    def __bool__(self) -> bool: ...
    def __pos__(self): ...
    def get_units(self): ...
    def has_lb(self): ...
    def has_ub(self): ...
    def is_binary(self): ...
    def is_continuous(self): ...
    def is_integer(self): ...
    def polynomial_degree(self): ...
    def __le__(self, arg): ...
    def __lt__(self, arg): ...
    def __ge__(self, arg): ...
    def __gt__(self, arg): ...
    def __eq__(self, arg): ...
    def __ne__(self, arg): ...
    def __add__(self, arg): ...
    def __div__(self, arg): ...
    def __mul__(self, arg): ...
    def __pow__(self, arg): ...
    def __sub__(self, arg): ...
    def __truediv__(self, arg): ...
    def __iadd__(self, arg): ...
    def __idiv__(self, arg): ...
    def __imul__(self, arg): ...
    def __ipow__(self, arg): ...
    def __isub__(self, arg): ...
    def __itruediv__(self, arg): ...
    def __radd__(self, arg): ...
    def __rdiv__(self, arg): ...
    def __rmul__(self, arg): ...
    def __rpow__(self, arg): ...
    def __rsub__(self, arg): ...
    def __rtruediv__(self, arg): ...
    def setlb(self, arg): ...
    def setub(self, arg): ...

class _Initializer:
    value: int
    deferred_value: int
    function: int
    dict_like: int
    @staticmethod
    def process(arg): ...

class DisjunctData(BlockData):
    __autoslot_mappers__: Incomplete
    @property
    def transformation_block(self): ...
    indicator_var: Incomplete
    binary_indicator_var: Incomplete
    def __init__(self, component) -> None: ...
    def activate(self) -> None: ...
    def deactivate(self) -> None: ...

class _DisjunctData(metaclass=RenamedClass):
    __renamed__new_class__ = DisjunctData
    __renamed__version__: str

class Disjunct(Block):
    def __new__(cls, *args, **kwds): ...
    def __init__(self, *args, **kwargs) -> None: ...

class ScalarDisjunct(DisjunctData, Disjunct):
    def __init__(self, *args, **kwds) -> None: ...

class SimpleDisjunct(metaclass=RenamedClass):
    __renamed__new_class__ = ScalarDisjunct
    __renamed__version__: str

class IndexedDisjunct(Disjunct):
    @property
    def active(self): ...

class DisjunctionData(ActiveComponentData):
    __autoslot_mappers__: Incomplete
    @property
    def algebraic_constraint(self): ...
    disjuncts: Incomplete
    xor: bool
    def __init__(self, component=None) -> None: ...
    def set_value(self, expr) -> None: ...

class _DisjunctionData(metaclass=RenamedClass):
    __renamed__new_class__ = DisjunctionData
    __renamed__version__: str

class Disjunction(ActiveIndexedComponent):
    def __new__(cls, *args, **kwds): ...
    def __init__(self, *args, **kwargs) -> None: ...
    def construct(self, data=None) -> None: ...

class ScalarDisjunction(DisjunctionData, Disjunction):
    def __init__(self, *args, **kwds) -> None: ...
    def set_value(self, expr): ...

class SimpleDisjunction(metaclass=RenamedClass):
    __renamed__new_class__ = ScalarDisjunction
    __renamed__version__: str

class IndexedDisjunction(Disjunction):
    @property
    def active(self): ...
