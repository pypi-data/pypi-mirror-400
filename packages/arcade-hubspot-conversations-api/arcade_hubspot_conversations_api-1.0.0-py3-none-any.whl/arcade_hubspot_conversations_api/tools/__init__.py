"""Arcade Starter Tools for Hubspot_Conversations

DO NOT EDIT THIS MODULE DIRECTLY.

THIS MODULE WAS AUTO-GENERATED BY TRANSPILING THE API STARTER TOOL JSON DEFINITIONS
IN THE ../wrapper_tools DIRECTORY INTO PYTHON CODE. ANY CHANGES TO THIS MODULE WILL
BE OVERWRITTEN BY THE TRANSPILER.
"""

import asyncio
import json
from enum import Enum
from typing import Annotated, Any

import httpx
import jsonschema
from arcade_tdk import ToolContext, tool
from arcade_tdk.auth import Hubspot
from arcade_tdk.errors import RetryableToolError

from .request_body_schemas import REQUEST_BODY_SCHEMAS

# Retry configuration
INITIAL_RETRY_DELAY = 0.5  # seconds

HTTP_CLIENT = httpx.AsyncClient(
    timeout=httpx.Timeout(60.0, connect=10.0),
    limits=httpx.Limits(max_keepalive_connections=20, max_connections=100),
    transport=httpx.AsyncHTTPTransport(retries=3),
    http2=True,
    follow_redirects=True,
)


class ToolMode(str, Enum):
    """Mode for tools with complex request bodies."""

    GET_REQUEST_SCHEMA = "get_request_schema"
    EXECUTE = "execute"


def remove_none_values(data: dict[str, Any]) -> dict[str, Any]:
    return {k: v for k, v in data.items() if v is not None}


async def make_request(
    url: str,
    method: str,
    params: dict[str, Any] | None = None,
    headers: dict[str, Any] | None = None,
    content: str | None = None,
    data: dict[str, Any] | None = None,
    auth: tuple[str, str] | None = None,
    max_retries: int = 3,
) -> httpx.Response:
    """Make an HTTP request with retry logic for 5xx server errors."""
    for attempt in range(max_retries):
        try:
            response = await HTTP_CLIENT.request(
                url=url,
                auth=auth,
                method=method,
                params=params,
                headers=headers,
                content=content,
            )
            response.raise_for_status()
        except httpx.HTTPStatusError as e:
            # Only retry on 5xx server errors
            if e.response.status_code >= 500 and attempt < max_retries - 1:
                # Exponential backoff: 0.5s, 1s, 2s
                await asyncio.sleep(INITIAL_RETRY_DELAY * (2**attempt))
                continue
            # Re-raise for 4xx errors or if max retries reached
            raise
        except httpx.RequestError:
            # Don't retry request errors (network issues are handled by transport)
            raise
        else:
            return response

    # This should never be reached, but satisfies type checker
    raise httpx.RequestError("Max retries exceeded")  # noqa: TRY003


async def make_request_with_schema_validation(
    url: str,
    method: str,
    request_data: dict[str, Any],
    schema: dict[str, Any] | str,
    auth: tuple[str, str] | None = None,
    params: dict[str, Any] | None = None,
    headers: dict[str, Any] | None = None,
    max_retries: int = 3,
) -> httpx.Response:
    """Make an HTTP request with schema validation on format errors."""
    # Parse schema if it's a string, skip validation if parsing fails
    parsed_schema = None
    if isinstance(schema, str):
        try:
            parsed_schema = json.loads(schema)
        except Exception:
            # If schema parsing fails, just skip validation
            parsed_schema = None
    else:
        parsed_schema = schema

    try:
        response = await make_request(
            url=url,
            auth=auth,
            method=method,
            params=params,
            headers=headers,
            content=json.dumps(request_data),
            max_retries=max_retries,
        )
    except httpx.HTTPStatusError as e:
        # Only provide schema validation for format-related errors
        if e.response.status_code in (400, 422):
            api_error_details = f"API returned {e.response.status_code}: {e.response.text}"

            # Only run validation if we have a valid parsed schema
            if parsed_schema is not None:
                # Run validation to provide additional context
                is_valid, validation_error = validate_json_against_schema(
                    request_data, parsed_schema
                )

                if not is_valid:
                    # Schema validation found issues - additional context
                    additional_context = (
                        f"{api_error_details}\n\n"
                        f"Schema validation found the following issues:\n"
                        f"{validation_error}"
                    )
                else:
                    # Schema validation passed - just show API error
                    additional_context = api_error_details
            else:
                # No valid schema - just show API error
                additional_context = api_error_details

            raise RetryableToolError(
                message=(f"API request failed with validation error: {e.response.status_code}"),
                developer_message=api_error_details,
                additional_prompt_content=additional_context,
            ) from e
        else:
            # For non-validation errors, re-raise as-is
            raise
    else:
        return response


def validate_json_against_schema(
    json_data: dict[str, Any], schema: dict[str, Any]
) -> tuple[bool, str | None]:
    """Validate JSON data against an OpenAPI/JSON Schema.

    This provides full JSON Schema Draft 7 validation including:
    - Required fields, types, enums
    - Pattern validation (regex)
    - Format validation (email, uuid, date-time, etc.)
    - Min/max length and values
    - oneOf, anyOf, allOf
    - And all other JSON Schema features

    Args:
        json_data: The JSON data to validate
        schema: The JSON Schema to validate against

    Returns:
        Tuple of (is_valid, error_messages). If valid, error_messages is None.
        If invalid, error_messages contains all validation errors.
    """
    try:
        validator = jsonschema.Draft7Validator(
            schema, format_checker=jsonschema.Draft7Validator.FORMAT_CHECKER
        )
        # Collect ALL validation errors
        errors = list(validator.iter_errors(json_data))
        if errors:
            # Format all errors with their paths
            error_messages = []
            for error in errors:
                error_path = ".".join(str(p) for p in error.path) if error.path else "root"
                error_messages.append(f"{error.message} at {error_path}")
            # Join all errors with newlines
            return False, "\n".join(error_messages)
        else:
            return True, None
    except jsonschema.SchemaError as e:
        return False, f"Invalid schema: {e.message}"
    except Exception as e:
        return False, f"Validation error: {e!s}"


@tool(requires_auth=Hubspot(scopes=["conversations.read"]))
async def list_conversation_inboxes(
    context: ToolContext,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get-/conversations/v3/conversations/inboxes'."
]:
    """Retrieve a list of conversation inboxes.

    This tool fetches a list of conversation inboxes, allowing for optional filters and sorting to customize the results."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.hubapi.com/conversations/v3/conversations/inboxes",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=Hubspot(scopes=["conversations.read"]))
async def retrieve_thread_by_id(
    context: ToolContext,
    conversation_thread_id: Annotated[
        str,
        "The unique identifier for the conversation thread you wish to retrieve. Provide the specific thread ID to access its details.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'get-/conversations/v3/conversations/threads/{threadId}'.",
]:
    """Retrieve detailed information about a conversation thread by ID.

    Use this to access specific conversation threads and their details for a given thread ID."""
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.hubapi.com/conversations/v3/conversations/threads/{threadId}".format(  # noqa: UP032
            threadId=conversation_thread_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=Hubspot(scopes=["conversations.write"]))
async def archive_conversation_thread(
    context: ToolContext,
    thread_identifier: Annotated[
        str,
        "The unique identifier of the conversation thread to archive. This is a required field and should match the specific thread you wish to archive.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'delete-/conversations/v3/conversations/threads/{threadId}'.",
]:
    """Archives a conversation thread, marking it for deletion.

    Use this tool to archive a conversation thread, which will then be permanently deleted after 30 days. Ideal for managing conversational data efficiently by removing unnecessary threads."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.hubapi.com/conversations/v3/conversations/threads/{threadId}".format(  # noqa: UP032
            threadId=thread_identifier
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=Hubspot(scopes=["conversations.write"]))
async def update_conversation_thread(
    context: ToolContext,
    thread_identifier: Annotated[
        str, "The unique identifier for the conversation thread to update or restore."
    ],
    is_thread_archived: Annotated[
        bool | None,
        "Set to true to archive or false to restore the thread. Determines if the thread is currently archived.",  # noqa: E501
    ] = None,
    thread_status: Annotated[str | None, "Set the thread's status to `OPEN` or `CLOSED`."] = None,
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'patch-/conversations/v3/conversations/threads/{threadId}'.",
]:
    """Update the status or restore a conversation thread.

    This tool updates a single thread's status or restores it within Hubspot Conversations. Use it to change the status or restore a thread based on the thread ID provided."""  # noqa: E501
    request_data: Any = {"archived": is_thread_archived, "status": thread_status}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.hubapi.com/conversations/v3/conversations/threads/{threadId}".format(  # noqa: UP032
            threadId=thread_identifier
        ),
        method="PATCH",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=Hubspot(scopes=["conversations.read"]))
async def retrieve_full_message_content(
    context: ToolContext,
    conversation_thread_id: Annotated[
        str, "The unique identifier for the conversation thread containing the message."
    ],
    message_id: Annotated[
        str,
        "The unique identifier for the message. Used to retrieve the message's full original content.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'get-/conversations/v3/conversations/threads/{threadId}/messages/{messageId}/original-content'.",  # noqa: E501
]:
    """Retrieve the original text and rich text of a HubSpot message.

    Use this tool to access the full original content of a message within a conversation on HubSpot. Ideal for retrieving untruncated message details when the truncation status indicates it might be truncated."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.hubapi.com/conversations/v3/conversations/threads/{threadId}/messages/{messageId}/original-content".format(  # noqa: UP032
            threadId=conversation_thread_id, messageId=message_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=Hubspot(scopes=["conversations.read"]))
async def list_conversation_channels(
    context: ToolContext,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get-/conversations/v3/conversations/channels'."
]:
    """Retrieve a list of conversation channels from Hubspot.

    Use this tool to get a list of conversation channels from Hubspot, applying optional filters and sorting if needed."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.hubapi.com/conversations/v3/conversations/channels",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=Hubspot(scopes=["conversations.read"]))
async def retrieve_actor_details(
    context: ToolContext,
    actor_id: Annotated[
        str, "The unique identifier for the actor whose details are to be retrieved."
    ],
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'get-/conversations/v3/conversations/actors/{actorId}'.",
]:
    """Retrieve details of a specific actor by actor ID.

    Use this tool to get information about a specific actor within Hubspot Conversations by providing their actor ID. It should be called when actor-specific details are needed."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.hubapi.com/conversations/v3/conversations/actors/{actorId}".format(  # noqa: UP032
            actorId=actor_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=Hubspot(scopes=["conversations.read"]))
async def retrieve_conversation_threads(
    context: ToolContext,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get-/conversations/v3/conversations/threads'."
]:
    """Retrieve conversation threads from Hubspot Conversations.

    Use this tool to fetch a list of conversation threads from Hubspot Conversations. You can apply optional filters and sorting to tailor the results."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.hubapi.com/conversations/v3/conversations/threads",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=Hubspot(scopes=["conversations.read"]))
async def get_message_history_for_thread(
    context: ToolContext,
    thread_id: Annotated[
        str,
        "The unique identifier for the conversation thread whose message history is to be retrieved.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'get-/conversations/v3/conversations/threads/{threadId}/messages'.",  # noqa: E501
]:
    """Retrieve the message history for a specific thread.

    This tool retrieves the message history for a given conversation thread by its ID. It should be used when you need to access past messages of a thread in Hubspot Conversations."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.hubapi.com/conversations/v3/conversations/threads/{threadId}/messages".format(  # noqa: UP032
            threadId=thread_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=Hubspot(scopes=["conversations.write"]))
async def send_conversation_message(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    thread_id: Annotated[
        str | None,
        "The unique identifier for the conversation thread where the message will be sent. It should be a string that corresponds to the existing thread ID in Hubspot.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'post-/conversations/v3/conversations/threads/{threadId}/messages'.",  # noqa: E501
]:
    """Send a new message in a conversation thread.

    Use this tool to send a new message on an existing conversation thread. Ideal for continuing discussions or replying within a thread.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["SENDCONVERSATIONMESSAGE"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not thread_id:
        missing_params.append(("thread_id", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(f"Required parameters validation failed: {param_details}"),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["SENDCONVERSATIONMESSAGE"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["SENDCONVERSATIONMESSAGE"] + "\n```"
            ),
        ) from e

    response = await make_request(
        url="https://api.hubapi.com/conversations/v3/conversations/threads/{threadId}/messages".format(  # noqa: UP032
            threadId=thread_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=json.dumps(request_data),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=Hubspot(scopes=["conversations.read"]))
async def resolve_conversation_actors(
    context: ToolContext,
    actor_ids: Annotated[
        list[str],
        "A list of Actor IDs to resolve into detailed participant information. Each entry should be a string representing an Actor ID.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'post-/conversations/v3/conversations/actors/batch/read'.",
]:
    """Resolve ActorIds to conversation participants.

    Use this tool to retrieve detailed information about participants in a conversation given their ActorIds. Typically called when there's a need to understand who the participants in a conversation are by resolving their IDs."""  # noqa: E501
    request_data: Any = {"inputs": actor_ids}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.hubapi.com/conversations/v3/conversations/actors/batch/read",
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=Hubspot(scopes=["conversations.read"]))
async def get_channel_account_details(
    context: ToolContext,
    channel_account_id: Annotated[
        str,
        "The unique ID of the HubSpot channel account to retrieve details for. This ID is required to fetch the channel account's information.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'get-/conversations/v3/conversations/channel-accounts/{channelAccountId}'.",  # noqa: E501
]:
    """Retrieve details of a HubSpot channel account by ID.

    Fetches detailed information about a specific HubSpot channel account using the channel account ID. Use this tool to obtain information about a channel account, such as its status and configuration."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.hubapi.com/conversations/v3/conversations/channel-accounts/{channelAccountId}".format(  # noqa: UP032
            channelAccountId=channel_account_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=Hubspot(scopes=["conversations.read"]))
async def retrieve_channel_accounts(
    context: ToolContext,
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'get-/conversations/v3/conversations/channel-accounts'.",
]:
    """Retrieve a list of channel accounts from Hubspot.

    This tool calls the Hubspot Conversations API to retrieve a list of channel accounts. It supports optional filters and sorting to refine the results."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.hubapi.com/conversations/v3/conversations/channel-accounts",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=Hubspot(scopes=["conversations.read"]))
async def retrieve_channel_details(
    context: ToolContext,
    channel_id: Annotated[
        str, "The unique ID of the channel to retrieve details for in Hubspot Conversations."
    ],
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'get-/conversations/v3/conversations/channels/{channelId}'.",
]:
    """Retrieve details of a channel using its ID.

    Use this tool to get comprehensive details about a specific channel in Hubspot Conversations by providing the channel ID."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.hubapi.com/conversations/v3/conversations/channels/{channelId}".format(  # noqa: UP032
            channelId=channel_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=Hubspot(scopes=["conversations.read"]))
async def get_inbox_details(
    context: ToolContext,
    inbox_id: Annotated[
        str,
        "The unique identifier for the conversation inbox you wish to retrieve details for. It should be a string representing the inbox ID.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'get-/conversations/v3/conversations/inboxes/{inboxId}'.",
]:
    """Retrieve details of a conversation inbox by ID.

    Use this tool to obtain detailed information about a specific conversation inbox by providing the inbox ID."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.hubapi.com/conversations/v3/conversations/inboxes/{inboxId}".format(  # noqa: UP032
            inboxId=inbox_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=Hubspot(scopes=["conversations.read"]))
async def retrieve_thread_message(
    context: ToolContext,
    message_id: Annotated[
        str,
        "The unique identifier for the specific message within a thread. Used to retrieve message details.",  # noqa: E501
    ],
    thread_id: Annotated[
        str, "The unique identifier of the conversation thread from which to retrieve the message."
    ],
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'get-/conversations/v3/conversations/threads/{threadId}/messages/{messageId}'.",  # noqa: E501
]:
    """Retrieve a single message from a conversation thread.

    Call this tool to get the details of a specific message within a conversation thread using the message ID. Useful for accessing conversation content for review or processing."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.hubapi.com/conversations/v3/conversations/threads/{threadId}/messages/{messageId}".format(  # noqa: UP032
            threadId=thread_id, messageId=message_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=Hubspot(scopes=["conversations.custom_channels.read"]))
async def get_custom_channel_message_details(
    context: ToolContext,
    channel_id: Annotated[
        str,
        "The unique identifier for the custom channel from which the message was sent. Required to fetch specific message details.",  # noqa: E501
    ],
    message_id: Annotated[
        str,
        "The unique identifier of the message to retrieve details for. This ID is used to specify the exact message in the custom channel.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'get-/conversations/v3/custom-channels/{channelId}/messages/{messageId}'.",  # noqa: E501
]:
    """Retrieve details for a specific message in a custom channel.

    Use this tool to get the details of a specific message sent through a custom channel in Hubspot Conversations. Ideal for obtaining message content, sender information, and timestamps."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.hubapi.com/conversations/v3/custom-channels/{channelId}/messages/{messageId}".format(  # noqa: UP032
            channelId=channel_id, messageId=message_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=Hubspot(scopes=["conversations.custom_channels.write"]))
async def update_message_status(
    context: ToolContext,
    channel_identifier: Annotated[
        str,
        "The unique identifier for the custom channel where the message is located. It is required to specify which channel the message belongs to.",  # noqa: E501
    ],
    message_id: Annotated[str, "Unique identifier of the message to be updated."],
    message_status: Annotated[
        str, "Specifies the status of the message. Valid values are SENT, FAILED, and READ."
    ],
    error_message_for_failed_status: Annotated[
        str | None,
        "Provide an error message when the status is FAILED to clarify the reason for failure. Only use this when 'statusType' is 'FAILED'.",  # noqa: E501
    ] = None,
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'patch-/conversations/v3/custom-channels/{channelId}/messages/{messageId}'.",  # noqa: E501
]:
    """Update the status of a conversation message.

    Use this tool to update the status of a message within a custom channel on Hubspot Conversations. It indicates whether a message was successfully sent, failed, or read. Additionally, for failed messages, you can include an error message for clarification."""  # noqa: E501
    request_data: Any = {
        "statusType": message_status,
        "errorMessage": error_message_for_failed_status,
    }
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.hubapi.com/conversations/v3/custom-channels/{channelId}/messages/{messageId}".format(  # noqa: UP032
            channelId=channel_identifier, messageId=message_id
        ),
        method="PATCH",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=Hubspot(
        scopes=["conversations.custom_channels.write", "conversations.custom_channels.read"],
    )
)
async def update_channel_account_staging(
    context: ToolContext,
    account_name: Annotated[
        str, "The name of the account to be updated for the channel account staging token."
    ],
    account_token: Annotated[
        str,
        "The unique token identifying the specific channel account staging. Required for updating account details.",  # noqa: E501
    ],
    channel_id: Annotated[
        str,
        "The unique identifier for the channel to update. This is necessary to specify which channel's staging token details are being modified.",  # noqa: E501
    ],
    delivery_identifier_type: Annotated[
        str,
        "Type of delivery identifier: HS_EMAIL_ADDRESS, HS_PHONE_NUMBER, or CHANNEL_SPECIFIC_OPAQUE_ID.",  # noqa: E501
    ],
    delivery_identifier_value: Annotated[
        str,
        "The PublicDeliveryIdentifier in string format, such as an E.164 phone number, an email address, or a channel-specific identifier.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'patch-/conversations/v3/custom-channels/{channelId}/channel-account-staging-tokens/{accountToken}'.",  # noqa: E501
]:
    """Update channel account staging token details for public apps.

    This tool updates the account name and delivery identifier of a channel account staging token in Hubspot Conversations. Use it when you need to modify these details for a specific channel account created from a staging token."""  # noqa: E501
    request_data: Any = {
        "accountName": account_name,
        "deliveryIdentifier": {
            "type": delivery_identifier_type,
            "value": delivery_identifier_value,
        },
    }
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.hubapi.com/conversations/v3/custom-channels/{channelId}/channel-account-staging-tokens/{accountToken}".format(  # noqa: UP032
            channelId=channel_id, accountToken=account_token
        ),
        method="PATCH",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=Hubspot(
        scopes=["conversations.custom_channels.write", "conversations.custom_channels.read"],
    )
)
async def get_custom_channel_accounts(
    context: ToolContext,
    custom_channel_id: Annotated[
        str,
        "The unique identifier of the custom channel to retrieve accounts for. Must be a valid string.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'get-/conversations/v3/custom-channels/{channelId}/channel-accounts'.",  # noqa: E501
]:
    """Retrieve accounts for a specified custom channel.

    This tool is used to fetch a list of accounts associated with a specific custom channel in Hubspot Conversations, identified by the channel ID."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.hubapi.com/conversations/v3/custom-channels/{channelId}/channel-accounts".format(  # noqa: UP032
            channelId=custom_channel_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=Hubspot(
        scopes=["conversations.custom_channels.write", "conversations.custom_channels.read"],
    )
)
async def create_channel_account(
    context: ToolContext,
    account_name: Annotated[
        str,
        "The name of the account to be created for the channel. It identifies the account within the specified communication channel.",  # noqa: E501
    ],
    channel_id: Annotated[
        str,
        "The unique identifier for the communication channel where the account will be created. This should be a string value.",  # noqa: E501
    ],
    inbox_id: Annotated[
        str,
        "The unique identifier for the inbox where the channel account will be created. This should be a string that corresponds to an existing inbox in Hubspot.",  # noqa: E501
    ],
    is_authorized: Annotated[
        bool,
        "Boolean to indicate if the account should be authorized. Set to true for authorized accounts, false otherwise.",  # noqa: E501
    ],
    delivery_identifier_type: Annotated[
        str | None,
        "Type of identifier: HS_EMAIL_ADDRESS, HS_PHONE_NUMBER, or CHANNEL_SPECIFIC_OPAQUE_ID.",
    ] = None,
    delivery_identifier_value: Annotated[
        str | None,
        "A string representation of the delivery identifier. Can be an E.164 phone number, an email address, or a channel-specific identifier.",  # noqa: E501
    ] = None,
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'post-/conversations/v3/custom-channels/{channelId}/channel-accounts'.",  # noqa: E501
]:
    """Create a new account for a specified communication channel.

    This tool is used to create a new account within a specific communication channel using Hubspot. It enables multiple accounts to communicate over a single channel with different delivery identifiers."""  # noqa: E501
    request_data: Any = {
        "authorized": is_authorized,
        "name": account_name,
        "deliveryIdentifier": {
            "type": delivery_identifier_type,
            "value": delivery_identifier_value,
        },
        "inboxId": inbox_id,
    }
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.hubapi.com/conversations/v3/custom-channels/{channelId}/channel-accounts".format(  # noqa: UP032
            channelId=channel_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=Hubspot(
        scopes=["conversations.custom_channels.write", "conversations.custom_channels.read"],
    )
)
async def retrieve_channel_account_details(
    context: ToolContext,
    channel_account_id: Annotated[
        str,
        "Unique identifier for the specific channel account to retrieve details about. Provided as a string.",  # noqa: E501
    ],
    channel_identifier: Annotated[
        str,
        "The unique identifier for the channel. Used to specify which channel's account details to retrieve.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'get-/conversations/v3/custom-channels/{channelId}/channel-accounts/{channelAccountId}'.",  # noqa: E501
]:
    """Retrieve details for a specific channel account.

    Use this tool to get detailed metadata about a channel account, including its channel, inbox ID, and delivery identifiers. Ideal for understanding the configuration and associations of a channel account in Hubspot."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.hubapi.com/conversations/v3/custom-channels/{channelId}/channel-accounts/{channelAccountId}".format(  # noqa: UP032
            channelId=channel_identifier, channelAccountId=channel_account_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(
    requires_auth=Hubspot(
        scopes=["conversations.custom_channels.write", "conversations.custom_channels.read"],
    )
)
async def update_channel_account_info(
    context: ToolContext,
    channel_account_id: Annotated[
        str,
        "The unique identifier for the channel account to be updated. It is required for specifying which channel account to modify.",  # noqa: E501
    ],
    channel_id: Annotated[
        str,
        "The unique identifier for the channel in Hubspot Conversations. Required to specify which channel account to update.",  # noqa: E501
    ],
    channel_account_name: Annotated[
        str | None,
        "The new name for the channel account. This updates the display name associated with the account.",  # noqa: E501
    ] = None,
    set_authorization_status: Annotated[
        bool | None,
        "Boolean value to update the channel account's authorization. Set to False to disable the account.",  # noqa: E501
    ] = None,
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'patch-/conversations/v3/custom-channels/{channelId}/channel-accounts/{channelAccountId}'.",  # noqa: E501
]:
    """Update channel account name and authorization status.

    Use this tool to modify the name and authorization status of a channel account in Hubspot Conversations. This is useful for managing channel accounts, including disabling them by setting the isAuthorized flag to False."""  # noqa: E501
    request_data: Any = {"authorized": set_authorization_status, "name": channel_account_name}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.hubapi.com/conversations/v3/custom-channels/{channelId}/channel-accounts/{channelAccountId}".format(  # noqa: UP032
            channelId=channel_id, channelAccountId=channel_account_id
        ),
        method="PATCH",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=Hubspot(scopes=["conversations.custom_channels.write"]))
async def publish_custom_channel_message(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    custom_channel_id: Annotated[
        str | None,
        "The unique ID of the custom channel where the message will be published. Must be a string.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'post-/conversations/v3/custom-channels/{channelId}/messages'.",
]:
    """Publish a message to a custom channel on HubSpot.

    This tool sends a message over a specified custom channel in HubSpot Conversations. Use this tool to communicate via custom-integrated messaging channels.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["PUBLISHCUSTOMCHANNELMESSAGE"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not custom_channel_id:
        missing_params.append(("custom_channel_id", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(f"Required parameters validation failed: {param_details}"),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["PUBLISHCUSTOMCHANNELMESSAGE"]
                + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["PUBLISHCUSTOMCHANNELMESSAGE"]
                + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.hubapi.com/conversations/v3/custom-channels/{channelId}/messages".format(  # noqa: UP032
            channelId=custom_channel_id
        ),
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["PUBLISHCUSTOMCHANNELMESSAGE"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}
