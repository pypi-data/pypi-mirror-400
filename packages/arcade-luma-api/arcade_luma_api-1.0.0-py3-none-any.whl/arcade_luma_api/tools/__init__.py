"""Arcade Starter Tools for Luma

DO NOT EDIT THIS MODULE DIRECTLY.

THIS MODULE WAS AUTO-GENERATED BY TRANSPILING THE API STARTER TOOL JSON DEFINITIONS
IN THE ../wrapper_tools DIRECTORY INTO PYTHON CODE. ANY CHANGES TO THIS MODULE WILL
BE OVERWRITTEN BY THE TRANSPILER.
"""

import asyncio
import json
from enum import Enum
from typing import Annotated, Any

import httpx
import jsonschema
from arcade_tdk import ToolContext, tool
from arcade_tdk.errors import RetryableToolError

from .request_body_schemas import REQUEST_BODY_SCHEMAS

# Retry configuration
INITIAL_RETRY_DELAY = 0.5  # seconds

HTTP_CLIENT = httpx.AsyncClient(
    timeout=httpx.Timeout(60.0, connect=10.0),
    limits=httpx.Limits(max_keepalive_connections=20, max_connections=100),
    transport=httpx.AsyncHTTPTransport(retries=3),
    http2=True,
    follow_redirects=True,
)


class ToolMode(str, Enum):
    """Mode for tools with complex request bodies."""

    GET_REQUEST_SCHEMA = "get_request_schema"
    EXECUTE = "execute"


def remove_none_values(data: dict[str, Any]) -> dict[str, Any]:
    return {k: v for k, v in data.items() if v is not None}


async def make_request(
    url: str,
    method: str,
    params: dict[str, Any] | None = None,
    headers: dict[str, Any] | None = None,
    content: str | None = None,
    data: dict[str, Any] | None = None,
    auth: tuple[str, str] | None = None,
    max_retries: int = 3,
) -> httpx.Response:
    """Make an HTTP request with retry logic for 5xx server errors."""
    for attempt in range(max_retries):
        try:
            response = await HTTP_CLIENT.request(
                url=url,
                auth=auth,
                method=method,
                params=params,
                headers=headers,
                content=content,
            )
            response.raise_for_status()
        except httpx.HTTPStatusError as e:
            # Only retry on 5xx server errors
            if e.response.status_code >= 500 and attempt < max_retries - 1:
                # Exponential backoff: 0.5s, 1s, 2s
                await asyncio.sleep(INITIAL_RETRY_DELAY * (2**attempt))
                continue
            # Re-raise for 4xx errors or if max retries reached
            raise
        except httpx.RequestError:
            # Don't retry request errors (network issues are handled by transport)
            raise
        else:
            return response

    # This should never be reached, but satisfies type checker
    raise httpx.RequestError("Max retries exceeded")  # noqa: TRY003


async def make_request_with_schema_validation(
    url: str,
    method: str,
    request_data: dict[str, Any],
    schema: dict[str, Any] | str,
    auth: tuple[str, str] | None = None,
    params: dict[str, Any] | None = None,
    headers: dict[str, Any] | None = None,
    max_retries: int = 3,
) -> httpx.Response:
    """Make an HTTP request with schema validation on format errors."""
    # Parse schema if it's a string, skip validation if parsing fails
    parsed_schema = None
    if isinstance(schema, str):
        try:
            parsed_schema = json.loads(schema)
        except Exception:
            # If schema parsing fails, just skip validation
            parsed_schema = None
    else:
        parsed_schema = schema

    try:
        response = await make_request(
            url=url,
            auth=auth,
            method=method,
            params=params,
            headers=headers,
            content=json.dumps(request_data),
            max_retries=max_retries,
        )
    except httpx.HTTPStatusError as e:
        # Only provide schema validation for format-related errors
        if e.response.status_code in (400, 422):
            api_error_details = f"API returned {e.response.status_code}: {e.response.text}"

            # Only run validation if we have a valid parsed schema
            if parsed_schema is not None:
                # Run validation to provide additional context
                is_valid, validation_error = validate_json_against_schema(
                    request_data, parsed_schema
                )

                if not is_valid:
                    # Schema validation found issues - additional context
                    additional_context = (
                        f"{api_error_details}\n\n"
                        f"Schema validation found the following issues:\n"
                        f"{validation_error}"
                    )
                else:
                    # Schema validation passed - just show API error
                    additional_context = api_error_details
            else:
                # No valid schema - just show API error
                additional_context = api_error_details

            raise RetryableToolError(
                message=(f"API request failed with validation error: {e.response.status_code}"),
                developer_message=api_error_details,
                additional_prompt_content=additional_context,
            ) from e
        else:
            # For non-validation errors, re-raise as-is
            raise
    else:
        return response


def validate_json_against_schema(
    json_data: dict[str, Any], schema: dict[str, Any]
) -> tuple[bool, str | None]:
    """Validate JSON data against an OpenAPI/JSON Schema.

    This provides full JSON Schema Draft 7 validation including:
    - Required fields, types, enums
    - Pattern validation (regex)
    - Format validation (email, uuid, date-time, etc.)
    - Min/max length and values
    - oneOf, anyOf, allOf
    - And all other JSON Schema features

    Args:
        json_data: The JSON data to validate
        schema: The JSON Schema to validate against

    Returns:
        Tuple of (is_valid, error_messages). If valid, error_messages is None.
        If invalid, error_messages contains all validation errors.
    """
    try:
        validator = jsonschema.Draft7Validator(
            schema, format_checker=jsonschema.Draft7Validator.FORMAT_CHECKER
        )
        # Collect ALL validation errors
        errors = list(validator.iter_errors(json_data))
        if errors:
            # Format all errors with their paths
            error_messages = []
            for error in errors:
                error_path = ".".join(str(p) for p in error.path) if error.path else "root"
                error_messages.append(f"{error.message} at {error_path}")
            # Join all errors with newlines
            return False, "\n".join(error_messages)
        else:
            return True, None
    except jsonschema.SchemaError as e:
        return False, f"Invalid schema: {e.message}"
    except Exception as e:
        return False, f"Validation error: {e!s}"


@tool(requires_secrets=["LUMA_API_KEY"])
async def get_event_admin_info(
    context: ToolContext,
    event_api_id: Annotated[
        str | None, "Event API ID, starting with 'evt-', used to identify the event."
    ] = None,
    event_id: Annotated[
        str | None, "The unique identifier for the event, usually starts with 'evt-'."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve admin information for an accessible event.

    This tool is used to get administrative details about an event for which the user has management access. It should be called when detailed event information is required by an admin."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://public-api.luma.com/v1/event/get",
        method="GET",
        params=remove_none_values({"id": event_id, "api_id": event_api_id}),
        headers=remove_none_values({"x-luma-api-key": context.get_secret("LUMA_API_KEY")}),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["LUMA_API_KEY"])
async def list_luma_calendar_events(
    context: ToolContext,
    event_sort_direction: Annotated[
        str | None,
        "Defines the order of events. Use 'asc' or 'desc' for ascending or descending. Options 'asc nulls last' and 'desc nulls last' place nulls at the end.",  # noqa: E501
    ] = None,
    filter_events_before: Annotated[
        str | None,
        "Filter events to show only those happening before this ISO 8601 Datetime. Example: 2022-10-19T03:27:13.673Z",  # noqa: E501
    ] = None,
    number_of_items_to_return: Annotated[
        float | None,
        "The number of events to return. The server enforces a maximum limit.",
    ] = None,
    pagination_cursor: Annotated[
        str | None,
        "Use the `next_cursor` value from a previous request to continue listing events.",
    ] = None,
    sort_by_column: Annotated[
        str | None,
        "Specify the column to sort events by. For now, 'start_at' is the available option.",
    ] = None,
    start_date_after: Annotated[
        str | None,
        "Specify the starting datetime to filter events after this timestamp in ISO 8601 format (e.g., 2022-10-19T03:27:13.673Z).",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve all events managed by your Luma Calendar.

    Use this tool to list all events managed by your Luma Calendar. It does not include events that are listed but not managed by the Calendar."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://public-api.luma.com/v1/calendar/list-events",
        method="GET",
        params=remove_none_values({
            "before": filter_events_before,
            "after": start_date_after,
            "pagination_cursor": pagination_cursor,
            "pagination_limit": number_of_items_to_return,
            "sort_column": sort_by_column,
            "sort_direction": event_sort_direction,
        }),
        headers=remove_none_values({"x-luma-api-key": context.get_secret("LUMA_API_KEY")}),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["LUMA_API_KEY"])
async def get_event_guest(
    context: ToolContext,
    event_api_id: Annotated[
        str | None, "Provide the unique API ID for the event to retrieve guest details."
    ] = None,
    event_identifier: Annotated[
        str | None,
        "The ID of the event, typically starting with 'evt-'. Used to identify the specific event.",
    ] = None,
    guest_api_id: Annotated[
        str | None,
        "The unique API ID of the guest, distinct from the user ID. This is used for identifying the guest within the system.",  # noqa: E501
    ] = None,
    guest_email: Annotated[str | None, "The email address of the event guest to look up."] = None,
    guest_identifier: Annotated[
        str | None,
        "Identifier for looking up the guest, such as guest ID (gst-), ticket key, guest key (g-), or the user's email.",  # noqa: E501
    ] = None,
    proxy_key: Annotated[
        str | None,
        "Value of the `pk` parameter from the check-in QR code used to identify the guest.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve event guest details using their ID.

    Use this tool to get details of an event guest by specifying their ID. It facilitates looking up guests through various parameters."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://public-api.luma.com/v1/event/get-guest",
        method="GET",
        params=remove_none_values({
            "event_id": event_identifier,
            "id": guest_identifier,
            "event_api_id": event_api_id,
            "api_id": guest_api_id,
            "email": guest_email,
            "proxy_key": proxy_key,
        }),
        headers=remove_none_values({"x-luma-api-key": context.get_secret("LUMA_API_KEY")}),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["LUMA_API_KEY"])
async def get_event_guests(
    context: ToolContext,
    event_api_id: Annotated[
        str | None, "The unique ID of the event, typically starting with 'evt-'."
    ] = None,
    event_id: Annotated[
        str | None, "The unique identifier for the event, usually starts with 'evt-'."
    ] = None,
    guest_approval_status: Annotated[
        str | None,
        "Filter guests by their approval status. Options: 'approved', 'session', 'pending_approval', 'invited', 'declined', 'waitlist'.",  # noqa: E501
    ] = None,
    guest_sort_column: Annotated[
        str | None,
        "The column to sort the guest list by. Options are 'name', 'email', 'created_at', 'registered_at', or 'checked_in_at'.",  # noqa: E501
    ] = None,
    items_to_return: Annotated[
        float | None,
        "Specify the number of guest entries to return. The server enforces a maximum limit.",
    ] = None,
    next_cursor_value: Annotated[
        str | None,
        "Value of `next_cursor` from a previous request to paginate through results.",
    ] = None,
    sort_order: Annotated[
        str | None,
        "Specify the order for sorting the list of guests. Acceptable values are 'asc', 'desc', 'asc nulls last', or 'desc nulls last'.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve registered or invited guests for an event.

    Use this tool to obtain a list of guests who have registered or been invited to a specific event."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://public-api.luma.com/v1/event/get-guests",
        method="GET",
        params=remove_none_values({
            "event_id": event_id,
            "approval_status": guest_approval_status,
            "pagination_cursor": next_cursor_value,
            "pagination_limit": items_to_return,
            "sort_column": guest_sort_column,
            "sort_direction": sort_order,
            "event_api_id": event_api_id,
        }),
        headers=remove_none_values({"x-luma-api-key": context.get_secret("LUMA_API_KEY")}),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["LUMA_API_KEY"])
async def get_user_info(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve the user's personal information and profile details.

    This tool is used to fetch the current user's personal details, including profile information. It can be called when an application needs to access the user's data for personalization or account management purposes."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://public-api.luma.com/v1/user/get-self",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({"x-luma-api-key": context.get_secret("LUMA_API_KEY")}),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["LUMA_API_KEY"])
async def list_person_tags(
    context: ToolContext,
    items_to_return: Annotated[
        float | None,
        "Specify the number of tags to return. The server will impose a maximum limit.",
    ] = None,
    pagination_cursor: Annotated[
        str | None,
        "Use the `next_cursor` value from a previous response to paginate results.",
    ] = None,
    sort_by_column: Annotated[
        str | None,
        "Specifies the column to sort the tags by. Options are 'name', 'color', or 'created_at'.",
    ] = None,
    sorting_direction: Annotated[
        str | None,
        "Specifies the order direction of the person tags. Choose from 'asc', 'desc', 'asc nulls last', or 'desc nulls last'.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve a list of tags associated with persons.

    This tool is used to call the Luma API to get a list of tags that are associated with persons. It should be called when there's a need to retrieve person tags from the Luma service."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://public-api.luma.com/v1/calendar/list-person-tags",
        method="GET",
        params=remove_none_values({
            "pagination_cursor": pagination_cursor,
            "pagination_limit": items_to_return,
            "sort_column": sort_by_column,
            "sort_direction": sorting_direction,
        }),
        headers=remove_none_values({"x-luma-api-key": context.get_secret("LUMA_API_KEY")}),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["LUMA_API_KEY"])
async def luma_entity_lookup(
    context: ToolContext,
    entity_slug: Annotated[
        str, "The unique string identifier for the entity to be looked up in Luma."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Lookup an entity on Luma by its slug.

    Use this tool to fetch detailed information about an entity from Luma using a specific slug identifier."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://public-api.luma.com/v1/entity/lookup",
        method="GET",
        params=remove_none_values({"slug": entity_slug}),
        headers=remove_none_values({"x-luma-api-key": context.get_secret("LUMA_API_KEY")}),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["LUMA_API_KEY"])
async def check_event_existence(
    context: ToolContext,
    calendar_platform_type: Annotated[
        str | None,
        "Specifies the source platform of the event, either 'external' or 'luma'.",
    ] = None,
    event_details_url: Annotated[
        str | None, "The URL of the event page to check if it exists in the calendar."
    ] = None,
    event_identifier: Annotated[
        str | None,
        "A unique string identifier for the event to check its existence on the calendar.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Determine if an event exists on the calendar.

    Use this tool to find out if an event is already listed on the calendar before deciding to add it."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://public-api.luma.com/v1/calendar/lookup-event",
        method="GET",
        params=remove_none_values({
            "platform": calendar_platform_type,
            "url": event_details_url,
            "event_api_id": event_identifier,
        }),
        headers=remove_none_values({"x-luma-api-key": context.get_secret("LUMA_API_KEY")}),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["LUMA_API_KEY"])
async def list_people(
    context: ToolContext,
    calendar_membership_status: Annotated[
        str | None,
        "Specify the membership status for filtering calendar members. This is only relevant for calendar memberships.",  # noqa: E501
    ] = None,
    calendar_membership_tier_api_id: Annotated[
        str | None,
        "A unique identifier for the calendar membership tier to filter people.",
    ] = None,
    calendar_tier_id: Annotated[
        str | None,
        "Unique identifier for the calendar membership tier to filter people.",
    ] = None,
    filter_by_tags: Annotated[
        str | None,
        "Comma-separated list of tag names or IDs to filter people with specified tags.",
    ] = None,
    items_to_return: Annotated[
        float | None,
        "Specify the number of items to return in the response. The server may enforce a maximum limit.",  # noqa: E501
    ] = None,
    pagination_next_cursor: Annotated[
        str | None,
        "Provide the `next_cursor` value from a previous request to continue pagination.",
    ] = None,
    search_query: Annotated[str | None, "Search for people using names or emails."] = None,
    sort_by_column: Annotated[
        str | None,
        "Sort the list of people by a specified column: created_at, event_checked_in_count, event_approved_count, name, or revenue_usd_cents.",  # noqa: E501
    ] = None,
    sort_order: Annotated[
        str | None,
        "Specifies the order for sorting results: 'asc', 'desc', 'asc nulls last', or 'desc nulls last'.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve a list of people from the calendar.

    Use this tool to obtain a list of people associated with the calendar."""
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://public-api.luma.com/v1/calendar/list-people",
        method="GET",
        params=remove_none_values({
            "query": search_query,
            "tags": filter_by_tags,
            "calendar_membership_tier_id": calendar_tier_id,
            "member_status": calendar_membership_status,
            "pagination_cursor": pagination_next_cursor,
            "pagination_limit": items_to_return,
            "sort_column": sort_by_column,
            "sort_direction": sort_order,
            "calendar_membership_tier_api_id": calendar_membership_tier_api_id,
        }),
        headers=remove_none_values({"x-luma-api-key": context.get_secret("LUMA_API_KEY")}),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["LUMA_API_KEY"])
async def list_event_coupons(
    context: ToolContext,
    event_api_id: Annotated[
        str | None,
        "The unique identifier for the event, typically starting with 'evt-'. Required to list coupons for the specified event.",  # noqa: E501
    ] = None,
    event_identifier: Annotated[
        str | None,
        "Event ID, typically starting with 'evt-'. It identifies the specific event for which to list coupons.",  # noqa: E501
    ] = None,
    item_return_limit: Annotated[
        float | None,
        "Specifies the number of items to return in the response, up to the server's maximum allowed.",  # noqa: E501
    ] = None,
    pagination_cursor: Annotated[
        str | None,
        "Value of `next_cursor` from a previous request to continue pagination.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve all coupons created for an event.

    Use this tool to obtain a list of all coupons that have been generated for a specific event. This tool is useful for managing and analyzing promotional strategies linked to events."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://public-api.luma.com/v1/event/coupons",
        method="GET",
        params=remove_none_values({
            "event_id": event_identifier,
            "pagination_cursor": pagination_cursor,
            "pagination_limit": item_return_limit,
            "event_api_id": event_api_id,
        }),
        headers=remove_none_values({"x-luma-api-key": context.get_secret("LUMA_API_KEY")}),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["LUMA_API_KEY"])
async def list_calendar_coupons(
    context: ToolContext,
    items_to_return: Annotated[
        float | None,
        "The number of coupon items to retrieve. The server enforces a maximum limit.",
    ] = None,
    pagination_cursor: Annotated[
        str | None,
        "Provide the `next_cursor` value obtained from a prior request to paginate through results.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve all coupons for a calendar.

    Use this tool to obtain a comprehensive list of all coupons that have been created for a specific calendar."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://public-api.luma.com/v1/calendar/coupons",
        method="GET",
        params=remove_none_values({
            "pagination_cursor": pagination_cursor,
            "pagination_limit": items_to_return,
        }),
        headers=remove_none_values({"x-luma-api-key": context.get_secret("LUMA_API_KEY")}),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["LUMA_API_KEY"])
async def list_event_ticket_types(
    context: ToolContext,
    event_id: Annotated[
        str | None,
        "The unique identifier for an event, typically starting with 'evt-'.",
    ] = None,
    event_identifier: Annotated[
        str | None, "The unique identifier for the event, usually starting with evt-."
    ] = None,
    include_hidden_ticket_types: Annotated[
        str | None, "Set to true to include hidden ticket types in the response list."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve a list of all ticket types for an event.

    Use this tool to get a detailed list of available ticket types for a specific event. It is useful for understanding ticket options and pricing for attendees."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://public-api.luma.com/v1/event/ticket-types/list",
        method="GET",
        params=remove_none_values({
            "event_id": event_id,
            "include_hidden": include_hidden_ticket_types,
            "event_api_id": event_identifier,
        }),
        headers=remove_none_values({"x-luma-api-key": context.get_secret("LUMA_API_KEY")}),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["LUMA_API_KEY"])
async def get_ticket_type_by_id(
    context: ToolContext,
    event_ticket_type_api_id: Annotated[
        str | None,
        "The unique API ID for the event ticket type. It must be provided to retrieve ticket information.",  # noqa: E501
    ] = None,
    ticket_type_id: Annotated[
        str | None,
        "The ID of the ticket type to retrieve, typically starts with 'ett-'.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve event ticket type details by ID.

    Use this tool to get detailed information about a specific ticket type by providing its ID. Ideal for fetching ticket-related details for events."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://public-api.luma.com/v1/event/ticket-types/get",
        method="GET",
        params=remove_none_values({
            "id": ticket_type_id,
            "event_ticket_type_api_id": event_ticket_type_api_id,
        }),
        headers=remove_none_values({"x-luma-api-key": context.get_secret("LUMA_API_KEY")}),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["LUMA_API_KEY"])
async def list_membership_tiers(
    context: ToolContext,
    items_to_return_count: Annotated[
        float | None,
        "Specify the number of membership tiers to return. The server may enforce a maximum limit.",
    ] = None,
    previous_request_next_cursor: Annotated[
        str | None,
        "The `next_cursor` value from a prior request for fetching subsequent data.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve available membership tiers for the calendar."""
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://public-api.luma.com/v1/memberships/tiers/list",
        method="GET",
        params=remove_none_values({
            "pagination_cursor": previous_request_next_cursor,
            "pagination_limit": items_to_return_count,
        }),
        headers=remove_none_values({"x-luma-api-key": context.get_secret("LUMA_API_KEY")}),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["LUMA_API_KEY"])
async def create_event(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Creates and schedules a new event.

    This tool allows users to create and schedule a new event using the Luma service. Call this tool when you need to set up a new event with specific details.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["CREATEEVENT"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATEEVENT"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATEEVENT"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://public-api.luma.com/v1/event/create",
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["CREATEEVENT"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "x-luma-api-key": context.get_secret("LUMA_API_KEY"),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["LUMA_API_KEY"])
async def update_event(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Update event details using Luma's API.

    This tool updates event information using Luma's event update endpoint. It should be called when modifications to event details are required.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["UPDATEEVENT"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPDATEEVENT"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPDATEEVENT"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://public-api.luma.com/v1/event/update",
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["UPDATEEVENT"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "x-luma-api-key": context.get_secret("LUMA_API_KEY"),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["LUMA_API_KEY"])
async def update_guest_status(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Updates the status of an event guest.

    Use this tool to change the status of a guest in an event, such as marking them as confirmed, declined, or pending.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["UPDATEGUESTSTATUS"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPDATEGUESTSTATUS"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPDATEGUESTSTATUS"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://public-api.luma.com/v1/event/update-guest-status",
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["UPDATEGUESTSTATUS"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "x-luma-api-key": context.get_secret("LUMA_API_KEY"),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["LUMA_API_KEY"])
async def send_guest_event_invite(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Send event invitations to guests via email and SMS.

    This tool sends an invitation to guests for an event by email and SMS, leveraging the Luma service. It is useful when you need to notify guests about an event quickly and ensure they receive the invitation through multiple channels.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["SENDGUESTEVENTINVITE"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["SENDGUESTEVENTINVITE"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["SENDGUESTEVENTINVITE"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://public-api.luma.com/v1/event/send-invites",
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["SENDGUESTEVENTINVITE"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "x-luma-api-key": context.get_secret("LUMA_API_KEY"),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["LUMA_API_KEY"])
async def add_event_guests(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Add guests to an event with default or custom tickets.

    Add guests to an event with the status \"Going.\" By default, each guest receives one ticket of the default type. Specify custom ticket assignments if needed.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["ADDEVENTGUESTS"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["ADDEVENTGUESTS"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["ADDEVENTGUESTS"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://public-api.luma.com/v1/event/add-guests",
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["ADDEVENTGUESTS"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "x-luma-api-key": context.get_secret("LUMA_API_KEY"),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["LUMA_API_KEY"])
async def add_event_host(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Add a host to an event in Luma.

    Use this tool to add a host to an event in Luma. If the host already has a Luma profile, it will automatically be recognized and added.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["ADDEVENTHOST"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["ADDEVENTHOST"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["ADDEVENTHOST"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://public-api.luma.com/v1/event/add-host",
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["ADDEVENTHOST"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "x-luma-api-key": context.get_secret("LUMA_API_KEY"),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["LUMA_API_KEY"])
async def create_event_coupon(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Create a non-editable coupon for event registration.

    Use this tool to create a coupon for guests registering for an event. Once created, the terms of the coupon cannot be edited.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["CREATEEVENTCOUPON"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATEEVENTCOUPON"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATEEVENTCOUPON"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://public-api.luma.com/v1/event/create-coupon",
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["CREATEEVENTCOUPON"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "x-luma-api-key": context.get_secret("LUMA_API_KEY"),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["LUMA_API_KEY"])
async def modify_coupon(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Update a coupon's details in the system.

    Use this tool to update the details of an existing coupon. It should be called when changes to coupon parameters are needed, such as expiration date or discount value.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["MODIFYCOUPON"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["MODIFYCOUPON"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["MODIFYCOUPON"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://public-api.luma.com/v1/event/update-coupon",
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["MODIFYCOUPON"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "x-luma-api-key": context.get_secret("LUMA_API_KEY"),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["LUMA_API_KEY"])
async def generate_event_coupon(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Create a coupon for calendar-managed events.

    This tool generates a coupon applicable to any event managed by the calendar. Ensure the coupon code is unique to avoid conflicts between specific events and the calendar.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["GENERATEEVENTCOUPON"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["GENERATEEVENTCOUPON"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["GENERATEEVENTCOUPON"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://public-api.luma.com/v1/calendar/coupons/create",
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["GENERATEEVENTCOUPON"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "x-luma-api-key": context.get_secret("LUMA_API_KEY"),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["LUMA_API_KEY"])
async def update_coupon(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Updates a coupon in the calendar.

    Use this tool to modify the details of an existing coupon in the Luma calendar system.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["UPDATECOUPON"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPDATECOUPON"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPDATECOUPON"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://public-api.luma.com/v1/calendar/coupons/update",
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["UPDATECOUPON"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "x-luma-api-key": context.get_secret("LUMA_API_KEY"),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["LUMA_API_KEY"])
async def import_people_to_calendar(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Import people to your calendar from contact lists.

    This tool is used to import individuals from contact lists into your calendar, making it simple to invite them to events and send newsletters. Use this when you need to manage and communicate with attendees efficiently.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["IMPORTPEOPLETOCALENDAR"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["IMPORTPEOPLETOCALENDAR"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["IMPORTPEOPLETOCALENDAR"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://public-api.luma.com/v1/calendar/import-people",
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["IMPORTPEOPLETOCALENDAR"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "x-luma-api-key": context.get_secret("LUMA_API_KEY"),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["LUMA_API_KEY"])
async def create_person_tag(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Create a new person tag in the calendar system.

    This tool is used to create a new person tag within the calendar system, allowing for the organization and tagging of individuals.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["CREATEPERSONTAG"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATEPERSONTAG"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATEPERSONTAG"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://public-api.luma.com/v1/calendar/create-person-tag",
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["CREATEPERSONTAG"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "x-luma-api-key": context.get_secret("LUMA_API_KEY"),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["LUMA_API_KEY"])
async def update_person_tag(
    context: ToolContext,
    person_tag_api_id: Annotated[
        str,
        "The unique identifier for the tag to be updated. It is required to identify which tag needs modification.",  # noqa: E501
    ],
    tag_color: Annotated[
        str | None,
        "Specify the color to be assigned to the person's tag. Choose from: cranberry, barney, red, green, blue, purple, yellow, orange.",  # noqa: E501
    ] = None,
    tag_name: Annotated[
        str | None,
        "The new name for the tag to be updated. It should be descriptive and relevant to the person's role or status.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Updates a tag for a person in the calendar system.

    This tool is used to update a person's tag within the calendar system. It should be called when there is a need to change or assign a new label to a person in a calendar context."""  # noqa: E501
    request_data: Any = {
        "tag_api_id": person_tag_api_id,
        "name": tag_name,
        "color": tag_color,
    }
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://public-api.luma.com/v1/calendar/update-person-tag",
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "x-luma-api-key": context.get_secret("LUMA_API_KEY"),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["LUMA_API_KEY"])
async def delete_person_tag(
    context: ToolContext,
    tag_identifier: Annotated[
        str,
        "The unique identifier of the person tag to be deleted. It should match the tag's API ID.",
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Deletes a person tag from the calendar.

    Use this tool to delete a person tag from a calendar entry when modifications are needed. It confirms the successful removal of the tag."""  # noqa: E501
    request_data: Any = {"tag_api_id": tag_identifier}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://public-api.luma.com/v1/calendar/delete-person-tag",
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "x-luma-api-key": context.get_secret("LUMA_API_KEY"),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["LUMA_API_KEY"])
async def apply_tag_to_calendar_members(
    context: ToolContext,
    tag_identifier: Annotated[
        str,
        "The Tag API ID (e.g., 'tag-123') or tag name to be applied to calendar members.",
    ],
    email_addresses: Annotated[
        list[str] | None,
        "Array of email addresses to apply the tag to existing calendar members.",
    ] = None,
    user_api_ids_to_tag: Annotated[
        list[str] | None,
        "Array of user API IDs to apply the tag to. Each ID corresponds to a calendar member.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Apply a tag to existing calendar members.

    Use this tool to assign a specific tag to already existing members of a calendar. It does not create new members but merely updates the tagging for current members."""  # noqa: E501
    request_data: Any = {
        "tag": tag_identifier,
        "user_api_ids": user_api_ids_to_tag,
        "emails": email_addresses,
    }
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://public-api.luma.com/v1/calendar/person-tags/apply",
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "x-luma-api-key": context.get_secret("LUMA_API_KEY"),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["LUMA_API_KEY"])
async def remove_tag_from_calendar_members(
    context: ToolContext,
    tag_identifier: Annotated[
        str,
        "The ID or name of the tag to remove from calendar members, such as 'tag-123' or 'Birthday'.",  # noqa: E501
    ],
    email_addresses_to_remove_tag: Annotated[
        list[str] | None,
        "Array of email addresses to remove the tag from the calendar members.",
    ] = None,
    user_api_ids_to_remove_tag: Annotated[
        list[str] | None,
        "Array of user API IDs from which to remove the specified tag.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Remove a tag from existing calendar members.

    Use this tool to remove a specified tag from existing members of a calendar. Intended for managing and updating member tags efficiently."""  # noqa: E501
    request_data: Any = {
        "tag": tag_identifier,
        "user_api_ids": user_api_ids_to_remove_tag,
        "emails": email_addresses_to_remove_tag,
    }
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://public-api.luma.com/v1/calendar/person-tags/unapply",
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "x-luma-api-key": context.get_secret("LUMA_API_KEY"),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["LUMA_API_KEY"])
async def add_event_to_luma_calendar(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Add an existing event to the Luma calendar.

    Use this tool to add an existing event from Luma or another platform to the Luma calendar without managing it there. Useful for integrating events across platforms.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["ADDEVENTTOLUMACALENDAR"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["ADDEVENTTOLUMACALENDAR"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["ADDEVENTTOLUMACALENDAR"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://public-api.luma.com/v1/calendar/add-event",
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["ADDEVENTTOLUMACALENDAR"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "x-luma-api-key": context.get_secret("LUMA_API_KEY"),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["LUMA_API_KEY"])
async def generate_upload_url(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Generates a URL for image upload.

    Use this tool to generate a URL where images can be uploaded. This is useful when you need to upload images to the Luma service.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["GENERATEUPLOADURL"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["GENERATEUPLOADURL"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["GENERATEUPLOADURL"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://public-api.luma.com/v1/images/create-upload-url",
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["GENERATEUPLOADURL"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "x-luma-api-key": context.get_secret("LUMA_API_KEY"),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["LUMA_API_KEY"])
async def create_event_ticket_type(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Create a new ticket type for an event.

    Use this tool to create a new ticket type for an event. Call this when you need to specify different ticket categories for an event.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["CREATEEVENTTICKETTYPE"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATEEVENTTICKETTYPE"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATEEVENTTICKETTYPE"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://public-api.luma.com/v1/event/ticket-types/create",
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["CREATEEVENTTICKETTYPE"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "x-luma-api-key": context.get_secret("LUMA_API_KEY"),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["LUMA_API_KEY"])
async def update_ticket_type_configuration(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Update an existing ticket type configuration.

    Use this tool to modify the settings of a ticket type for an event. It should be called when changes to a ticket type's details or availability are required.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["UPDATETICKETTYPECONFIGURATION"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["UPDATETICKETTYPECONFIGURATION"]
                + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["UPDATETICKETTYPECONFIGURATION"]
                + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://public-api.luma.com/v1/event/ticket-types/update",
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["UPDATETICKETTYPECONFIGURATION"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "x-luma-api-key": context.get_secret("LUMA_API_KEY"),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["LUMA_API_KEY"])
async def soft_delete_ticket_type(
    context: ToolContext,
    event_ticket_type_id: Annotated[
        str,
        "The ID of the event ticket type to be soft deleted. Ensure no tickets are sold, and it's not the last visible type before deletion.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Soft delete a ticket type if certain conditions are met.

    Use this tool to soft delete a ticket type, provided no tickets have been sold and it's not the last visible type."""  # noqa: E501
    request_data: Any = {"event_ticket_type_api_id": event_ticket_type_id}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://public-api.luma.com/v1/event/ticket-types/delete",
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "x-luma-api-key": context.get_secret("LUMA_API_KEY"),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["LUMA_API_KEY"])
async def add_user_to_membership_tier(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Add a user to a specified free membership tier.

    This tool adds a user to a free membership tier. It should be called whenever there is a need to enroll a user in a free membership program. Note that paid membership tiers are not supported by this tool, as they require a web payment flow.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["ADDUSERTOMEMBERSHIPTIER"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["ADDUSERTOMEMBERSHIPTIER"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["ADDUSERTOMEMBERSHIPTIER"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://public-api.luma.com/v1/memberships/members/add",
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["ADDUSERTOMEMBERSHIPTIER"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "x-luma-api-key": context.get_secret("LUMA_API_KEY"),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["LUMA_API_KEY"])
async def update_membership_status(
    context: ToolContext,
    membership_status: Annotated[
        str,
        "Set the membership status to either 'approved' to capture payment or 'declined' to cancel the subscription.",  # noqa: E501
    ],
    user_identifier: Annotated[
        str,
        "User ID (e.g., 'usr-xxx') or email address to identify the member whose status is to be updated.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Update a member's membership status and handle payments.

    Use this tool to approve or decline a member's membership status. Approving a paid tier member will capture their payment, while declining will cancel any active subscription."""  # noqa: E501
    request_data: Any = {"user_id": user_identifier, "status": membership_status}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://public-api.luma.com/v1/memberships/members/update-status",
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "x-luma-api-key": context.get_secret("LUMA_API_KEY"),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}
