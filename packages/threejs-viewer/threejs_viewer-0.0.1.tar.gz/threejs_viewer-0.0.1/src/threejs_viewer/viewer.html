<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Viewer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
        canvas { display: block; }
        #status {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            font-family: monospace;
            font-size: 12px;
            border-radius: 4px;
        }
        #status.connected { background: rgba(0, 128, 0, 0.7); }
        #status.disconnected { background: rgba(128, 0, 0, 0.7); }

        /* Animation Controls */
        #animation-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(30, 30, 30, 0.95);
            color: white;
            padding: 12px 20px;
            display: none;
            flex-direction: column;
            gap: 8px;
        }
        #animation-controls.visible { display: flex; }

        .timeline-row {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .transport-buttons {
            display: flex;
            gap: 4px;
        }
        .transport-buttons button {
            background: #444;
            border: none;
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .transport-buttons button:hover { background: #555; }
        .transport-buttons button:active { background: #333; }
        .transport-buttons button.active { background: #0066cc; }

        #timeline-container {
            flex: 1;
            position: relative;
            height: 24px;
            background: #333;
            border-radius: 4px;
            cursor: pointer;
        }
        #timeline-progress {
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            background: #0066cc;
            border-radius: 4px 0 0 4px;
            pointer-events: none;
        }
        #timeline-markers {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        .timeline-marker {
            position: absolute;
            top: 0;
            width: 2px;
            height: 100%;
            background: #ff6600;
        }
        .timeline-marker::after {
            content: attr(data-label);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #ff6600;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.2s;
        }
        #timeline-container:hover .timeline-marker::after { opacity: 1; }

        .time-display {
            font-family: monospace;
            font-size: 13px;
            min-width: 120px;
            text-align: center;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .speed-control button {
            background: #444;
            border: none;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        .speed-control button:hover { background: #555; }
        .speed-control button.active { background: #0066cc; }

        .loop-toggle {
            background: #444;
            border: none;
            color: white;
            padding: 4px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        .loop-toggle:hover { background: #555; }
        .loop-toggle.active { background: #0066cc; }

        .frame-display {
            font-family: monospace;
            font-size: 11px;
            color: #aaa;
            min-width: 100px;
        }

        .keyboard-hint {
            font-size: 10px;
            color: #666;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="status" class="disconnected">Disconnected</div>

    <div id="animation-controls">
        <div class="timeline-row">
            <div class="transport-buttons">
                <button id="btn-start" title="Jump to start (Home)">⏮</button>
                <button id="btn-prev-frame" title="Previous frame (←)">◀</button>
                <button id="btn-play" title="Play/Pause (Space)">▶</button>
                <button id="btn-next-frame" title="Next frame (→)">▶</button>
                <button id="btn-end" title="Jump to end (End)">⏭</button>
            </div>
            <div id="timeline-container">
                <div id="timeline-progress"></div>
                <div id="timeline-markers"></div>
            </div>
            <div class="time-display">
                <span id="current-time">0.00</span>s / <span id="total-time">0.00</span>s
            </div>
            <div class="speed-control">
                <button data-speed="0.25">0.25x</button>
                <button data-speed="0.5">0.5x</button>
                <button data-speed="1" class="active">1x</button>
                <button data-speed="2">2x</button>
                <button data-speed="4">4x</button>
            </div>
            <button id="btn-loop" class="loop-toggle active" title="Toggle loop (L)">⟳ Loop</button>
            <div class="frame-display">Frame <span id="current-frame">0</span>/<span id="total-frames">0</span></div>
        </div>
        <div class="keyboard-hint">Space: Play/Pause | ←→: Step frames | Shift+←→: Step 10 | Home/End: Jump | L: Loop | 1-5: Speed</div>
    </div>

    <!-- Three.js from CDN -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.170.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.170.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
        import { ColladaLoader } from 'three/addons/loaders/ColladaLoader.js';
        import { STLLoader } from 'three/addons/loaders/STLLoader.js';
        import { PLYLoader } from 'three/addons/loaders/PLYLoader.js';
        import { TDSLoader } from 'three/addons/loaders/TDSLoader.js';
        import { Line2 } from 'three/addons/lines/Line2.js';
        import { LineMaterial } from 'three/addons/lines/LineMaterial.js';
        import { LineGeometry } from 'three/addons/lines/LineGeometry.js';

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);

        // Z-up coordinate system (robotics convention)
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.up.set(0, 0, 1);  // Z is up
        camera.position.set(5, -5, 3);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 0.8;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // Lighting - reduced intensity
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);

        // Key light (main)
        const keyLight = new THREE.DirectionalLight(0xffffff, 0.3);
        keyLight.position.set(5, -5, 10);
        scene.add(keyLight);

        // Fill light
        const fillLight = new THREE.DirectionalLight(0xffffff, 0.15);
        fillLight.position.set(-5, 5, 5);
        scene.add(fillLight);

        // Grid helper on XY plane (Z-up)
        const gridHelper = new THREE.GridHelper(10, 10);
        gridHelper.rotation.x = Math.PI / 2;  // Rotate to XY plane
        scene.add(gridHelper);

        // Object registry
        const objects = new Map();

        // ========== Animation State ==========
        let animation = null;
        let animationPlaying = false;
        let animationTime = 0;
        let animationSpeed = 1;
        let animationLoop = true;
        let lastAnimationUpdate = 0;
        let baselineVisibility = new Map();  // Stores visibility state before animation

        const animControlsEl = document.getElementById('animation-controls');
        const timelineProgressEl = document.getElementById('timeline-progress');
        const timelineMarkersEl = document.getElementById('timeline-markers');
        const currentTimeEl = document.getElementById('current-time');
        const totalTimeEl = document.getElementById('total-time');
        const currentFrameEl = document.getElementById('current-frame');
        const totalFramesEl = document.getElementById('total-frames');
        const btnPlay = document.getElementById('btn-play');
        const btnLoop = document.getElementById('btn-loop');

        function loadAnimation(animData) {
            animation = animData;
            animationTime = 0;
            animationPlaying = false;
            lastAnimationUpdate = performance.now();

            // Store baseline visibility for all objects before animation starts
            baselineVisibility.clear();
            for (const [id, obj] of objects) {
                baselineVisibility.set(id, obj.visible);
            }

            // Update UI
            animControlsEl.classList.add('visible');
            totalTimeEl.textContent = animation.duration.toFixed(2);
            totalFramesEl.textContent = animation.frames.length;
            animationLoop = animation.loop;
            btnLoop.classList.toggle('active', animationLoop);
            updateAnimationUI();

            // Add markers
            timelineMarkersEl.innerHTML = '';
            if (animation.markers) {
                for (const marker of animation.markers) {
                    const el = document.createElement('div');
                    el.className = 'timeline-marker';
                    el.style.left = `${(marker.time / animation.duration) * 100}%`;
                    el.setAttribute('data-label', marker.label);
                    timelineMarkersEl.appendChild(el);
                }
            }

            // Apply first frame
            applyFrame(0);
            console.log(`Animation loaded: ${animation.frames.length} frames, ${animation.duration.toFixed(2)}s`);
        }

        function stopAnimation() {
            // Restore baseline visibility when stopping
            for (const [id, baselineVisible] of baselineVisibility) {
                const obj = objects.get(id);
                if (obj) {
                    obj.visible = baselineVisible;
                }
            }
            baselineVisibility.clear();
            animation = null;
            animationPlaying = false;
            animControlsEl.classList.remove('visible');
        }

        function applyFrame(frameIndex) {
            if (!animation || frameIndex < 0 || frameIndex >= animation.frames.length) return;

            const frame = animation.frames[frameIndex];

            // Apply transforms
            if (frame.transforms) {
                for (const [id, matrix] of Object.entries(frame.transforms)) {
                    const obj = objects.get(id);
                    if (obj) {
                        const m = new THREE.Matrix4();
                        m.fromArray(matrix);
                        obj.matrix.copy(m);
                        obj.matrix.decompose(obj.position, obj.quaternion, obj.scale);
                    }
                }
            }

            // Apply colors
            if (frame.colors) {
                for (const [id, color] of Object.entries(frame.colors)) {
                    const obj = objects.get(id);
                    if (obj) {
                        obj.traverse((child) => {
                            if (child.material) {
                                child.material.color.setHex(color);
                            }
                        });
                    }
                }
            }

            // Apply visibility: first restore baseline, then apply frame-specific changes
            // This ensures hidden objects reappear when scrubbing to frames that don't mention them
            for (const [id, baselineVisible] of baselineVisibility) {
                const obj = objects.get(id);
                if (obj) {
                    obj.visible = baselineVisible;
                }
            }
            if (frame.visibility) {
                for (const [id, visible] of Object.entries(frame.visibility)) {
                    const obj = objects.get(id);
                    if (obj) {
                        obj.visible = visible;
                    }
                }
            }

            // Apply opacity
            if (frame.opacity) {
                for (const [id, opacity] of Object.entries(frame.opacity)) {
                    const obj = objects.get(id);
                    if (obj) {
                        obj.traverse((child) => {
                            if (child.material) {
                                child.material.transparent = opacity < 1;
                                child.material.opacity = opacity;
                            }
                        });
                    }
                }
            }
        }

        function getFrameAtTime(time) {
            if (!animation || animation.frames.length === 0) return 0;
            // Find frame index for given time
            for (let i = animation.frames.length - 1; i >= 0; i--) {
                if (animation.frames[i].time <= time) {
                    return i;
                }
            }
            return 0;
        }

        function updateAnimationUI() {
            if (!animation) return;

            const frameIndex = getFrameAtTime(animationTime);
            const progress = animation.duration > 0 ? (animationTime / animation.duration) * 100 : 0;

            timelineProgressEl.style.width = `${progress}%`;
            currentTimeEl.textContent = animationTime.toFixed(2);
            currentFrameEl.textContent = frameIndex + 1;
            btnPlay.textContent = animationPlaying ? '⏸' : '▶';
        }

        function stepFrames(delta) {
            if (!animation) return;
            const currentFrame = getFrameAtTime(animationTime);
            const newFrame = Math.max(0, Math.min(animation.frames.length - 1, currentFrame + delta));
            animationTime = animation.frames[newFrame].time;
            applyFrame(newFrame);
            updateAnimationUI();
        }

        function seekToTime(time) {
            if (!animation) return;
            animationTime = Math.max(0, Math.min(animation.duration, time));
            const frameIndex = getFrameAtTime(animationTime);
            applyFrame(frameIndex);
            updateAnimationUI();
        }

        function togglePlay() {
            animationPlaying = !animationPlaying;
            if (animationPlaying) {
                lastAnimationUpdate = performance.now();
            }
            updateAnimationUI();
        }

        function setSpeed(speed) {
            animationSpeed = speed;
            document.querySelectorAll('.speed-control button').forEach(btn => {
                btn.classList.toggle('active', parseFloat(btn.dataset.speed) === speed);
            });
        }

        // Animation controls event listeners
        document.getElementById('btn-start').addEventListener('click', () => seekToTime(0));
        document.getElementById('btn-end').addEventListener('click', () => seekToTime(animation?.duration || 0));
        document.getElementById('btn-prev-frame').addEventListener('click', () => stepFrames(-1));
        document.getElementById('btn-next-frame').addEventListener('click', () => stepFrames(1));
        btnPlay.addEventListener('click', togglePlay);
        btnLoop.addEventListener('click', () => {
            animationLoop = !animationLoop;
            btnLoop.classList.toggle('active', animationLoop);
        });

        document.querySelectorAll('.speed-control button').forEach(btn => {
            btn.addEventListener('click', () => setSpeed(parseFloat(btn.dataset.speed)));
        });

        document.getElementById('timeline-container').addEventListener('click', (e) => {
            if (!animation) return;
            const rect = e.target.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const ratio = x / rect.width;
            seekToTime(ratio * animation.duration);
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (!animation) return;

            switch (e.code) {
                case 'Space':
                    e.preventDefault();
                    togglePlay();
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    stepFrames(e.shiftKey ? -10 : -1);
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    stepFrames(e.shiftKey ? 10 : 1);
                    break;
                case 'Home':
                    e.preventDefault();
                    seekToTime(0);
                    break;
                case 'End':
                    e.preventDefault();
                    seekToTime(animation.duration);
                    break;
                case 'KeyL':
                    animationLoop = !animationLoop;
                    btnLoop.classList.toggle('active', animationLoop);
                    break;
                case 'Digit1':
                    setSpeed(0.25);
                    break;
                case 'Digit2':
                    setSpeed(0.5);
                    break;
                case 'Digit3':
                    setSpeed(1);
                    break;
                case 'Digit4':
                    setSpeed(2);
                    break;
                case 'Digit5':
                    setSpeed(4);
                    break;
            }
        });

        // Loaders
        const loaders = {
            obj: new OBJLoader(),
            gltf: new GLTFLoader(),
            glb: new GLTFLoader(),
            fbx: new FBXLoader(),
            dae: new ColladaLoader(),
            stl: new STLLoader(),
            ply: new PLYLoader(),
            '3ds': new TDSLoader()
        };

        // Primitive creators
        const primitives = {
            box: (params) => new THREE.BoxGeometry(
                params.width || 1, params.height || 1, params.depth || 1
            ),
            sphere: (params) => new THREE.SphereGeometry(
                params.radius || 0.5, params.widthSegments || 32, params.heightSegments || 16
            ),
            cylinder: (params) => new THREE.CylinderGeometry(
                params.radiusTop || 0.5, params.radiusBottom || 0.5,
                params.height || 1, params.radialSegments || 32
            ),
            plane: (params) => new THREE.PlaneGeometry(
                params.width || 1, params.height || 1
            ),
            cone: (params) => new THREE.ConeGeometry(
                params.radius || 0.5, params.height || 1, params.radialSegments || 32
            ),
            torus: (params) => new THREE.TorusGeometry(
                params.radius || 0.5, params.tube || 0.2,
                params.radialSegments || 16, params.tubularSegments || 48
            ),
            capsule: (params) => new THREE.CapsuleGeometry(
                params.radius || 0.25, params.length || 0.5,
                params.capSegments || 8, params.radialSegments || 16
            )
        };

        // Apply transform to object
        function applyTransform(obj, transform) {
            if (!transform) return;

            if (transform.matrix) {
                const m = new THREE.Matrix4();
                m.fromArray(transform.matrix);
                obj.matrix.copy(m);
                obj.matrix.decompose(obj.position, obj.quaternion, obj.scale);
            } else {
                if (transform.position) {
                    obj.position.fromArray(transform.position);
                }
                if (transform.rotation) {
                    obj.rotation.fromArray(transform.rotation);
                }
                if (transform.quaternion) {
                    obj.quaternion.fromArray(transform.quaternion);
                }
                if (transform.scale) {
                    obj.scale.fromArray(transform.scale);
                }
            }
        }

        // Create material from params
        function createMaterial(params) {
            const color = params.color || 0x4a90d9;
            const materialType = params.materialType || 'standard';

            switch (materialType) {
                case 'basic':
                    return new THREE.MeshBasicMaterial({ color });
                case 'phong':
                    return new THREE.MeshPhongMaterial({ color });
                case 'lambert':
                    return new THREE.MeshLambertMaterial({ color });
                default:
                    return new THREE.MeshStandardMaterial({ color, roughness: 0.7, metalness: 0.3 });
            }
        }

        // Add object to scene
        async function addObject(id, objData) {
            let obj;

            if (objData.primitive) {
                const geometry = primitives[objData.primitive](objData.params || {});
                const material = createMaterial(objData.params || {});
                obj = new THREE.Mesh(geometry, material);
            } else if (objData.model) {
                const format = objData.format || 'gltf';
                const loader = loaders[format];

                if (!loader) {
                    console.error(`Unknown format: ${format}`);
                    return;
                }

                try {
                    if (objData.model.startsWith('data:') || objData.model.startsWith('blob:')) {
                        // Base64 or blob URL
                        obj = await loadModel(loader, objData.model, format);
                    } else {
                        // URL
                        obj = await loadModel(loader, objData.model, format);
                    }
                } catch (e) {
                    console.error(`Failed to load model: ${e}`);
                    return;
                }
            }

            if (obj) {
                obj.name = id;
                obj.userData.id = id;
                applyTransform(obj, objData.transform);

                if (objData.visible === false) {
                    obj.visible = false;
                }

                scene.add(obj);
                objects.set(id, obj);
            }
        }

        // Load model helper
        function loadModel(loader, url, format) {
            return new Promise((resolve, reject) => {
                loader.load(
                    url,
                    (result) => {
                        let obj;
                        if (format === 'gltf' || format === 'glb') {
                            obj = result.scene;
                        } else if (format === 'dae') {
                            // Create a clean group with only meshes (no lights/cameras from DAE)
                            obj = new THREE.Group();
                            result.scene.traverse((child) => {
                                if (child.isMesh) {
                                    obj.add(child.clone());
                                }
                            });
                        } else if (format === 'stl' || format === 'ply') {
                            const material = new THREE.MeshStandardMaterial({ color: 0x4a90d9 });
                            obj = new THREE.Mesh(result, material);
                        } else {
                            obj = result;
                        }
                        resolve(obj);
                    },
                    undefined,
                    reject
                );
            });
        }

        // Update object transform
        function updateTransform(id, transform) {
            const obj = objects.get(id);
            if (obj) {
                applyTransform(obj, transform);
            }
        }

        // Delete object
        function deleteObject(id) {
            const obj = objects.get(id);
            if (obj) {
                scene.remove(obj);
                objects.delete(id);
                // Clean up blob URL if present
                if (obj.userData.blobUrl) {
                    URL.revokeObjectURL(obj.userData.blobUrl);
                }
                // Dispose geometry and materials
                obj.traverse((child) => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(m => m.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                });
            }
        }

        // Set visibility
        function setVisibility(id, visible) {
            const obj = objects.get(id);
            if (obj) {
                obj.visible = visible;
            }
        }

        // Clear scene
        function clearScene() {
            for (const id of objects.keys()) {
                deleteObject(id);
            }
        }

        // Batch update transforms (for 60fps updates)
        function batchUpdate(transforms) {
            for (const [id, transform] of Object.entries(transforms)) {
                updateTransform(id, transform);
            }
        }

        // Sync full scene
        async function syncScene(sceneData) {
            clearScene();
            for (const [id, objData] of Object.entries(sceneData)) {
                await addObject(id, objData);
            }
        }

        // WebSocket connection - connects directly to Python client
        const statusEl = document.getElementById('status');
        let ws = null;
        let reconnectTimeout = null;
        const WS_PORT = 5666;  // Must match Python client port

        function connect() {
            ws = new WebSocket(`ws://localhost:${WS_PORT}`);

            ws.onopen = () => {
                statusEl.textContent = 'Connected';
                statusEl.className = 'connected';
            };

            ws.onclose = () => {
                statusEl.textContent = 'Waiting for Python...';
                statusEl.className = 'disconnected';
                reconnectTimeout = setTimeout(connect, 50);
            };

            ws.onerror = (e) => {
                console.error('WebSocket error:', e);
            };

            ws.onmessage = async (event) => {
                // Handle binary messages (for large polylines)
                if (event.data instanceof Blob) {
                    const buffer = await event.data.arrayBuffer();
                    const view = new DataView(buffer);

                    // First 4 bytes: header length (includes padding)
                    const headerLen = view.getUint32(0, true);
                    // Next headerLen bytes: JSON header (may have null padding at end)
                    const headerBytes = new Uint8Array(buffer, 4, headerLen);
                    const headerStr = new TextDecoder().decode(headerBytes).replace(/\0+$/, '');  // strip null padding
                    const header = JSON.parse(headerStr);

                    if (header.type === 'add_polyline_binary') {
                        try {
                            const dataOffset = 4 + headerLen;
                            const rawData = new Uint8Array(buffer, dataOffset);
                            const numPoints = header.numPoints || (rawData.length / 12);
                            const positionBytes = numPoints * 12;

                            // Extract position data
                            const posBuffer = new ArrayBuffer(positionBytes);
                            new Uint8Array(posBuffer).set(rawData.slice(0, positionBytes));
                            const pointData = new Float32Array(posBuffer);

                            console.log(`Creating polyline ${header.id} with ${numPoints} points`);

                            // Use Line2 for thick lines with vertex colors
                            const geometry = new LineGeometry();
                            geometry.setPositions(pointData);

                            let material;
                            if (header.hasVertexColors) {
                                // Extract color data (uint8 RGB)
                                const colorBytes = rawData.slice(positionBytes);
                                const colorData = new Float32Array(numPoints * 3);
                                for (let i = 0; i < numPoints; i++) {
                                    colorData[i * 3] = colorBytes[i * 3] / 255;
                                    colorData[i * 3 + 1] = colorBytes[i * 3 + 1] / 255;
                                    colorData[i * 3 + 2] = colorBytes[i * 3 + 2] / 255;
                                }
                                geometry.setColors(colorData);

                                material = new LineMaterial({
                                    color: 0xffffff,
                                    vertexColors: true,
                                    linewidth: header.lineWidth || 2,
                                    resolution: new THREE.Vector2(window.innerWidth, window.innerHeight),
                                });
                            } else {
                                material = new LineMaterial({
                                    color: header.color || 0xffffff,
                                    linewidth: header.lineWidth || 2,
                                    resolution: new THREE.Vector2(window.innerWidth, window.innerHeight),
                                });
                            }

                            const line = new Line2(geometry, material);
                            line.computeLineDistances();
                            line.name = header.id;
                            line.userData.id = header.id;
                            line.userData.isPolyline = true;
                            scene.add(line);
                            objects.set(header.id, line);
                        } catch (e) {
                            console.error(`Error creating polyline:`, e);
                        }
                    } else if (header.type === 'add_model_binary') {
                        try {
                            const dataOffset = 4 + headerLen;
                            const meshBytes = new Uint8Array(buffer, dataOffset);

                            // Create blob URL from mesh bytes
                            const blob = new Blob([meshBytes]);
                            const blobUrl = URL.createObjectURL(blob);

                            console.log(`Loading model ${header.id} (${header.format}) via blob URL`);

                            // Use existing addObject with blob URL
                            await addObject(header.id, {
                                model: blobUrl,
                                format: header.format || 'stl'
                            });

                            // Store blob URL for cleanup
                            const obj = objects.get(header.id);
                            if (obj) {
                                obj.userData.blobUrl = blobUrl;
                            }
                        } catch (e) {
                            console.error(`Error loading model:`, e);
                        }
                    }
                    return;
                }

                const data = JSON.parse(event.data);

                switch (data.type) {
                    case 'scene_sync':
                        await syncScene(data.objects);
                        break;
                    case 'add_object':
                        await addObject(data.id, data.object);
                        break;
                    case 'update_transform':
                        updateTransform(data.id, data.transform);
                        break;
                    case 'delete_object':
                        deleteObject(data.id);
                        break;
                    case 'set_visibility':
                        setVisibility(data.id, data.visible);
                        break;
                    case 'clear_scene':
                        clearScene();
                        break;
                    case 'batch_update':
                        batchUpdate(data.transforms);
                        break;
                    case 'set_color':
                        const colorObj = objects.get(data.id);
                        if (colorObj) {
                            colorObj.traverse((child) => {
                                if (child.material) {
                                    child.material.color.setHex(data.color);
                                }
                            });
                        }
                        break;
                    case 'batch_set_color':
                        for (const [id, color] of Object.entries(data.colors)) {
                            const obj = objects.get(id);
                            if (obj) {
                                obj.traverse((child) => {
                                    if (child.material) {
                                        child.material.color.setHex(color);
                                    }
                                });
                            }
                        }
                        break;
                    case 'list_objects':
                        ws.send(JSON.stringify({
                            type: 'list_objects_response',
                            requestId: data.requestId,
                            objects: Array.from(objects.keys())
                        }));
                        break;
                    case 'load_animation':
                        loadAnimation(data.animation);
                        break;
                    case 'stop_animation':
                        stopAnimation();
                        break;
                }
            };
        }

        connect();

        // Window resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            // Update LineMaterial resolution for all polylines
            objects.forEach((obj) => {
                if (obj.material && obj.material.resolution) {
                    obj.material.resolution.set(window.innerWidth, window.innerHeight);
                }
            });
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Update animation playback
            if (animation && animationPlaying) {
                const now = performance.now();
                const deltaTime = (now - lastAnimationUpdate) / 1000;
                lastAnimationUpdate = now;

                animationTime += deltaTime * animationSpeed;

                if (animationTime >= animation.duration) {
                    if (animationLoop) {
                        animationTime = animationTime % animation.duration;
                    } else {
                        animationTime = animation.duration;
                        animationPlaying = false;
                    }
                }

                const frameIndex = getFrameAtTime(animationTime);
                applyFrame(frameIndex);
                updateAnimationUI();
            }

            controls.update();
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
