import enum
import types
from collections.abc import Generator

from _typeshed import Incomplete
from pyomo.common.collections import Mapping as Mapping
from pyomo.common.collections import Sequence as Sequence
from pyomo.common.deprecation import deprecated as deprecated
from pyomo.common.deprecation import deprecation_warning as deprecation_warning
from pyomo.common.deprecation import relocated_module_attribute as relocated_module_attribute
from pyomo.common.fileutils import import_file as import_file
from pyomo.common.flags import NOTSET as NOTSET
from pyomo.common.flags import building_documentation as building_documentation
from pyomo.common.formatting import wrap_reStructuredText as wrap_reStructuredText

logger: Incomplete
USER_OPTION: int
ADVANCED_OPTION: int
DEVELOPER_OPTION: int

def Bool(val): ...
def Integer(val): ...
def PositiveInt(val): ...
def NegativeInt(val): ...
def NonPositiveInt(val): ...
def NonNegativeInt(val): ...
def PositiveFloat(val): ...
def NegativeFloat(val): ...
def NonPositiveFloat(val): ...
def NonNegativeFloat(val): ...

class In:
    def __new__(cls, domain=None, cast=None): ...
    def __init__(self, domain, cast=None) -> None: ...
    def __call__(self, value): ...
    def domain_name(self): ...

class InEnum:
    def __init__(self, domain) -> None: ...
    def __call__(self, value): ...
    def domain_name(self): ...

class IsInstance:
    baseClasses: Incomplete
    document_full_base_names: Incomplete
    def __init__(self, *bases, document_full_base_names: bool = False) -> None: ...
    def __call__(self, obj): ...
    def domain_name(self): ...

class ListOf:
    itemtype: Incomplete
    domain: Incomplete
    string_lexer: Incomplete
    def __init__(self, itemtype, domain=None, string_lexer=...) -> None: ...
    def __call__(self, value): ...
    def domain_name(self): ...

class Module:
    basePath: Incomplete
    expandPath: Incomplete
    def __init__(self, basePath=None, expandPath=None) -> None: ...
    def __call__(self, module_id): ...

class Path:
    BasePath: Incomplete
    SuppressPathExpansion: bool
    basePath: Incomplete
    expandPath: Incomplete
    def __init__(self, basePath=None, expandPath=None) -> None: ...
    def __call__(self, path): ...
    def domain_name(self): ...

class PathList(Path):
    def __call__(self, data): ...

class DynamicImplicitDomain:
    callback: Incomplete
    def __init__(self, callback) -> None: ...
    def __call__(self, key, value): ...

class ConfigEnum(enum.Enum):
    def __new__(cls, value, *args): ...
    @classmethod
    def from_enum_or_string(cls, arg): ...

__doc__: str

class _UnpickleableDomain:
    def __init__(self, obj) -> None: ...
    def __call__(self, arg): ...

class ConfigFormatter:
    def generate(self, config, indent_spacing: int = 2, width: int = 78, visibility=None): ...

class String_ConfigFormatter(ConfigFormatter):
    def __init__(self, block_start, block_end, item_start, item_body, item_end) -> None: ...

class LaTeX_ConfigFormatter(String_ConfigFormatter):
    def __init__(self) -> None: ...

class numpydoc_ConfigFormatter(ConfigFormatter): ...

def add_docstring_list(docstring, configdict, indent_by: int = 4): ...

class document_kwargs_from_configdict:
    config: Incomplete
    section: Incomplete
    indent_spacing: Incomplete
    width: Incomplete
    visibility: Incomplete
    doc: Incomplete
    def __init__(
        self,
        config,
        section: str = 'Keyword Arguments',
        indent_spacing: int = 4,
        width: int = 78,
        visibility=None,
        doc=None,
    ) -> None: ...
    def __call__(self, fcn): ...

class UninitializedMixin: ...

class ConfigBase:
    class NoArgument: ...
    __class__: Incomplete
    def __init__(
        self, default=None, domain=None, description=None, doc=None, visibility: int = 0
    ) -> None: ...
    def __call__(
        self,
        value=...,
        default=...,
        domain=...,
        description=...,
        doc=...,
        visibility=...,
        implicit=...,
        implicit_domain=...,
        preserve_implicit: bool = False,
    ): ...
    def name(self, fully_qualified: bool = False): ...
    def domain_name(self): ...
    def set_default_value(self, default) -> None: ...
    def set_domain(self, domain) -> None: ...
    def reset(self) -> None: ...
    def declare_as_argument(self, *args, **kwds): ...
    def initialize_argparse(self, parser): ...
    def import_argparse(self, parsed_args): ...
    def display(
        self, content_filter=None, indent_spacing: int = 2, ostream=None, visibility=None
    ) -> None: ...
    def generate_yaml_template(
        self, indent_spacing: int = 2, width: int = 78, visibility: int = 0
    ): ...
    def generate_documentation(
        self,
        block_start=None,
        block_end=None,
        item_start=None,
        item_body=None,
        item_end=None,
        indent_spacing: int = 2,
        width: int = 78,
        visibility=None,
        format: str = 'latex',
    ): ...
    def user_values(self) -> Generator[Incomplete]: ...
    def unused_user_values(self) -> Generator[Incomplete]: ...

class ConfigValue(ConfigBase):
    def value(self, accessValue: bool = True): ...
    def set_value(self, value) -> None: ...

class ImmutableConfigValue(ConfigValue):
    def __new__(self, *args, **kwds): ...

class MarkImmutable:
    def __init__(self, *args) -> None: ...
    def lock(self) -> None: ...
    def release_lock(self) -> None: ...
    def __enter__(self): ...
    def __exit__(
        self, t: type[BaseException] | None, v: BaseException | None, tb: types.TracebackType | None
    ) -> None: ...

class ConfigList(ConfigBase, Sequence):
    def __init__(
        self, default=None, domain=None, description=None, doc=None, visibility: int = 0
    ) -> None: ...
    def __getitem__(self, key): ...
    def get(self, key, default=...): ...
    def __setitem__(self, key, val) -> None: ...
    def __len__(self) -> int: ...
    def __iter__(self): ...
    def value(self, accessValue: bool = True): ...
    def set_value(self, value) -> None: ...
    def append(self, value=...) -> None: ...
    def add(self, value=...): ...

class ConfigDict(ConfigBase, Mapping):
    content_filters: Incomplete
    def __init__(
        self,
        description=None,
        doc=None,
        implicit: bool = False,
        implicit_domain=None,
        visibility: int = 0,
    ) -> None: ...
    def domain_name(self): ...
    def __dir__(self): ...
    def __getitem__(self, key): ...
    def get(self, key, default=...): ...
    def setdefault(self, key, default=...): ...
    def __setitem__(self, key, val) -> None: ...
    def __delitem__(self, key) -> None: ...
    def __contains__(self, key) -> bool: ...
    def __len__(self) -> int: ...
    def __iter__(self): ...
    def __getattr__(self, attr): ...
    def __setattr__(self, name, value) -> None: ...
    def __delattr__(self, name) -> None: ...
    def keys(self): ...
    def values(self): ...
    def items(self) -> Generator[Incomplete]: ...
    def iterkeys(self): ...
    def itervalues(self): ...
    def iteritems(self): ...
    def declare(self, name, config): ...
    def declare_from(self, other, skip=None) -> None: ...
    def add(self, name, config): ...
    def value(self, accessValue: bool = True): ...
    def set_value(self, value, skip_implicit: bool = False): ...
    def reset(self) -> None: ...

ConfigBlock = ConfigDict
