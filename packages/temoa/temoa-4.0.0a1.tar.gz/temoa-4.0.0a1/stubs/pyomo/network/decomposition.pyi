from _typeshed import Incomplete
from pyomo.common.collections import Bunch as Bunch
from pyomo.common.collections import ComponentMap as ComponentMap
from pyomo.common.collections import ComponentSet as ComponentSet
from pyomo.common.dependencies import networkx_available as networkx_available
from pyomo.common.dependencies import numpy as numpy
from pyomo.common.dependencies import numpy_available as numpy_available
from pyomo.core import Binary as Binary
from pyomo.core import ConcreteModel as ConcreteModel
from pyomo.core import Constraint as Constraint
from pyomo.core import Expression as Expression
from pyomo.core import Objective as Objective
from pyomo.core import Var as Var
from pyomo.core import minimize as minimize
from pyomo.core import value as value
from pyomo.core.expr import identify_variables as identify_variables
from pyomo.network import Arc as Arc
from pyomo.network import Port as Port
from pyomo.network.foqus_graph import FOQUSGraph as FOQUSGraph
from pyomo.repn import generate_standard_repn as generate_standard_repn

imports_available: Incomplete
logger: Incomplete

class SequentialDecomposition(FOQUSGraph):
    cache: Incomplete
    def __init__(self, **kwds) -> None: ...
    def set_guesses_for(self, port, guesses) -> None: ...
    def set_tear_set(self, tset) -> None: ...
    def tear_set_arcs(self, G, method: str = 'mip', **kwds): ...
    def indexes_to_arcs(self, G, lst): ...
    def run(self, model, function): ...
    def run_order(self, G, order, function, ignore=None, use_guesses: bool = False) -> None: ...
    def pass_values(self, arc, fixed_inputs) -> None: ...
    def pass_single_value(self, port, name, member, val, fixed) -> None: ...
    def load_guesses(self, guesses, port, fixed) -> None: ...
    def load_values(self, port, default, fixed, use_guesses) -> None: ...
    def check_value_fix(
        self, port, var, default, fixed, use_guesses, extensive: bool = False
    ) -> None: ...
    def combine_and_fix(self, port, name, obj, evars, fixed) -> None: ...
    def source_dest_peer(self, arc, name, index=None): ...
    def create_graph(self, model): ...
    def select_tear_mip_model(self, G): ...
    def select_tear_mip(self, G, solver, solver_io=None, solver_options={}): ...
    def compute_err(self, svals, dvals, tol_type): ...
    def tear_diff_direct(self, G, tears): ...
    def pass_edges(self, G, edges) -> None: ...
    def pass_tear_direct(self, G, tears) -> None: ...
    def pass_tear_wegstein(self, G, tears, x) -> None: ...
    def generate_gofx(self, G, tears): ...
    def generate_first_x(self, G, tears): ...
    def cacher(self, key, fcn, *args): ...
    def tear_set(self, G): ...
    def arc_to_edge(self, G): ...
    def fixed_inputs(self): ...
    def idx_to_node(self, G): ...
    def node_to_idx(self, G): ...
    def idx_to_edge(self, G): ...
    def edge_to_idx(self, G): ...
