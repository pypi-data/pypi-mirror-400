"""Rust code generator for SyncLangs types."""

from __future__ import annotations

import re

from synclangs.codegen.base import CodeGenerator
from synclangs.parser.ast import (
    ConstDef,
    ConstValue,
    EnumDef,
    FunctionDef,
    InterfaceDef,
    ListTypeExpr,
    MapTypeExpr,
    Module,
    NullableTypeExpr,
    PrimitiveType,
    PrimitiveTypeExpr,
    TypeDef,
    TypeExpr,
    TypeRef,
    VoidType,
)


class RustGenerator(CodeGenerator):
    """Generate Rust structs from SyncLangs AST."""

    def __init__(
        self,
        file_extension: str = ".rs",
        crate_name: str = "types",
    ) -> None:
        self._file_extension = file_extension
        self._crate_name = crate_name

    def generate(self, module: Module) -> str:
        """Generate Rust source code for a module."""
        lines: list[str] = [
            "// Auto-generated by SyncLangs - DO NOT EDIT",
            "",
        ]

        # Collect imports needed
        rust_uses = self._collect_uses(module)
        for use_stmt in sorted(rust_uses):
            lines.append(f"use {use_stmt};")
        if rust_uses:
            lines.append("")

        # Generate constants first
        for const_def in module.constants:
            lines.extend(self._generate_constant(const_def))
        if module.constants:
            lines.append("")

        # Generate enums
        for enum_def in module.enums:
            lines.extend(self._generate_enum(enum_def))
            lines.append("")

        # Generate structs (types with optional composition for inheritance)
        for type_def in module.types:
            lines.extend(self._generate_type(type_def))
            lines.append("")

        # Generate trait definitions
        for interface_def in module.interfaces:
            lines.extend(self._generate_trait(interface_def))
            lines.append("")

        # Generate function type aliases
        for fn_def in module.functions:
            lines.extend(self._generate_function_type(fn_def))
            lines.append("")

        return "\n".join(lines).rstrip() + "\n"

    def _generate_type(self, type_def: TypeDef) -> list[str]:
        """Generate a Rust struct for a type definition."""
        lines: list[str] = []
        if type_def.doc_comment:
            lines.extend(self._format_rust_doc(type_def.doc_comment, ""))
        lines.append("#[derive(Debug, Clone, Serialize, Deserialize)]")
        lines.append(f"pub struct {type_def.name} {{")

        # Embed base type using #[serde(flatten)] for inheritance
        if type_def.extends:
            lines.append("    #[serde(flatten)]")
            base_field = self._to_snake_case(type_def.extends)
            lines.append(f"    pub {base_field}: {type_def.extends},")

        for field in type_def.fields:
            if field.doc_comment:
                lines.extend(self._format_rust_doc(field.doc_comment, "    "))
            rust_field_name = self._to_snake_case(field.name)
            rust_type, is_optional = self._field_type(field.type_expr)

            # Add serde rename if field name differs from original
            if rust_field_name != field.name:
                lines.append(f'    #[serde(rename = "{field.name}")]')

            # Add skip_serializing_if for optional fields
            if is_optional:
                lines.append('    #[serde(skip_serializing_if = "Option::is_none")]')

            lines.append(f"    pub {rust_field_name}: {rust_type},")
        lines.append("}")
        return lines

    def _generate_trait(self, interface_def: InterfaceDef) -> list[str]:
        """Generate a Rust trait definition."""
        lines: list[str] = []
        if interface_def.doc_comment:
            lines.extend(self._format_rust_doc(interface_def.doc_comment, ""))
        lines.append(f"pub trait {interface_def.name} {{")

        # Generate method signatures
        for fn_def in interface_def.functions:
            if fn_def.doc_comment:
                lines.extend(self._format_rust_doc(fn_def.doc_comment, "    "))
            signature = self._function_signature(fn_def, is_trait_method=True)
            lines.append(f"    {signature}")

        lines.append("}")
        return lines

    def _generate_function_type(self, fn_def: FunctionDef) -> list[str]:
        """Generate a Rust function type alias."""
        lines: list[str] = []
        if fn_def.doc_comment:
            lines.extend(self._format_rust_doc(fn_def.doc_comment, ""))

        # Build parameter list
        params = ", ".join(
            self._type_to_rust(p.type_expr) for p in fn_def.params
        )

        # Build return type
        return_type = self._return_type_to_rust(fn_def.return_type)

        type_name = f"{fn_def.name[0].upper()}{fn_def.name[1:]}Fn"
        if return_type:
            lines.append(f"pub type {type_name} = fn({params}) -> {return_type};")
        else:
            lines.append(f"pub type {type_name} = fn({params});")
        return lines

    def _function_signature(self, fn_def: FunctionDef, is_trait_method: bool = False) -> str:
        """Generate a Rust function signature."""
        # Build parameter list with self for trait methods
        if is_trait_method:
            params = ["&self"] + [
                f"{self._to_snake_case(p.name)}: {self._type_to_rust(p.type_expr)}"
                for p in fn_def.params
            ]
        else:
            params = [
                f"{self._to_snake_case(p.name)}: {self._type_to_rust(p.type_expr)}"
                for p in fn_def.params
            ]
        params_str = ", ".join(params)

        # Build return type
        return_type = self._return_type_to_rust(fn_def.return_type)

        fn_name = self._to_snake_case(fn_def.name)

        if fn_def.is_async:
            # For async traits, we'd use async_trait macro in real code
            if return_type:
                return f"async fn {fn_name}({params_str}) -> {return_type};"
            return f"async fn {fn_name}({params_str});"
        else:
            if return_type:
                return f"fn {fn_name}({params_str}) -> {return_type};"
            return f"fn {fn_name}({params_str});"

    def _return_type_to_rust(self, return_type: TypeExpr | VoidType) -> str:
        """Convert a return type to Rust."""
        if isinstance(return_type, VoidType):
            return ""  # Rust uses () for void, but we can omit the return type
        return self._type_to_rust(return_type)

    def _collect_uses(self, module: Module) -> set[str]:
        """Collect Rust use statements needed for the module."""
        uses: set[str] = set()

        # Always need serde for derive macros
        if module.types or module.enums:
            uses.add("serde::{Deserialize, Serialize}")

        # Check if we need HashMap
        for type_def in module.types:
            for field in type_def.fields:
                if self._needs_hashmap(field.type_expr):
                    uses.add("std::collections::HashMap")
                    break

        return uses

    def _needs_hashmap(self, type_expr: TypeExpr) -> bool:
        """Check if a type expression requires HashMap import."""
        if isinstance(type_expr, MapTypeExpr):
            return True
        if isinstance(type_expr, ListTypeExpr):
            return self._needs_hashmap(type_expr.element_type)
        if isinstance(type_expr, NullableTypeExpr):
            return self._needs_hashmap(type_expr.inner_type)
        return False

    def _generate_constant(self, const_def: ConstDef) -> list[str]:
        """Generate a Rust constant definition."""
        lines: list[str] = []
        if const_def.doc_comment:
            lines.extend(self._format_rust_doc(const_def.doc_comment, ""))
        rust_type = self._type_to_rust(const_def.type_expr)
        value = self._const_value_to_rust(const_def.value)
        # Use static for String types, const for primitives
        if rust_type == "String":
            lines.append(f"pub const {const_def.name}: &str = {value};")
        else:
            lines.append(f"pub const {const_def.name}: {rust_type} = {value};")
        return lines

    def _generate_enum(self, enum_def: EnumDef) -> list[str]:
        """Generate a Rust enum with serde derives."""
        lines: list[str] = []
        if enum_def.doc_comment:
            lines.extend(self._format_rust_doc(enum_def.doc_comment, ""))
        lines.append("#[derive(Debug, Clone, Serialize, Deserialize)]")
        lines.append(f"pub enum {enum_def.name} {{")
        for variant in enum_def.variants:
            if variant.doc_comment:
                lines.extend(self._format_rust_doc(variant.doc_comment, "    "))
            lines.append(f"    {variant.name},")
        lines.append("}")
        return lines

    def _const_value_to_rust(self, value: ConstValue) -> str:
        """Convert a constant value to Rust literal."""
        if isinstance(value.value, str):
            return f'"{value.value}"'
        if isinstance(value.value, bool):
            return "true" if value.value else "false"
        return str(value.value)

    def _field_type(self, type_expr: TypeExpr) -> tuple[str, bool]:
        """Return the Rust type and optional flag for a field."""
        if isinstance(type_expr, NullableTypeExpr):
            inner_type = self._type_to_rust(type_expr.inner_type)
            return f"Option<{inner_type}>", True
        return self._type_to_rust(type_expr), False

    def _type_to_rust(self, type_expr: TypeExpr) -> str:
        """Convert a type expression to a Rust type."""
        if isinstance(type_expr, PrimitiveTypeExpr):
            return self._primitive_to_rust(type_expr.primitive)
        if isinstance(type_expr, ListTypeExpr):
            inner = self._type_to_rust(type_expr.element_type)
            return f"Vec<{inner}>"
        if isinstance(type_expr, MapTypeExpr):
            key = self._type_to_rust(type_expr.key_type)
            value = self._type_to_rust(type_expr.value_type)
            return f"HashMap<{key}, {value}>"
        if isinstance(type_expr, NullableTypeExpr):
            inner = self._type_to_rust(type_expr.inner_type)
            return f"Option<{inner}>"
        if isinstance(type_expr, TypeRef):
            return type_expr.name
        raise TypeError(f"Unsupported type expression: {type_expr}")

    def _primitive_to_rust(self, primitive: PrimitiveType) -> str:
        """Map primitive SyncLangs types to Rust types."""
        mapping = {
            PrimitiveType.STRING: "String",
            PrimitiveType.INT: "i64",
            PrimitiveType.FLOAT: "f64",
            PrimitiveType.BOOL: "bool",
            PrimitiveType.ANY: "serde_json::Value",
        }
        return mapping[primitive]

    def _to_snake_case(self, name: str) -> str:
        """Convert a camelCase name to snake_case."""
        # Insert underscore before uppercase letters and lowercase them
        result = re.sub(r'([A-Z])', r'_\1', name).lower()
        # Remove leading underscore if present
        if result.startswith('_'):
            result = result[1:]
        return result

    def _format_rust_doc(self, text: str, indent: str) -> list[str]:
        """Format a Rust doc comment with the provided indentation."""
        lines = text.splitlines()
        return [f"{indent}/// {line}" for line in lines]
