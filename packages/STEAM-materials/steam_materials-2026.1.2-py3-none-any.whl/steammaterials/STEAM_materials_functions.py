
# Auto-generated by generate_wrappers.py
# DO NOT EDIT BY HAND (regenerate from C sources)
import os
import numpy as _np
from typing import Optional
import importlib

# Import specification provided at generation time
_wrapper_import_spec = "steammaterials.STEAM_materials.STEAM_materials"
_wrapper_classname = "STEAM_materials"

# Try a few strategies to import the STEAM_materials class robustly.
try:
    # Direct import if module + classname provided (most common)
    from steammaterials.STEAM_materials import STEAM_materials as _STEAM_cls
except Exception:
    try:
        # If the user gave full dotted 'module.Class' as wrapper_import_spec, attempt to import
        parts = _wrapper_import_spec.rsplit('.', 1)
        if len(parts) == 2:
            _mod = importlib.import_module(parts[0])
            _STEAM_cls = getattr(_mod, parts[1])
        else:
            raise
    except Exception:
        try:
            # Last resort: import module and getattr class
            _mod = importlib.import_module(_wrapper_import_spec)
            _STEAM_cls = getattr(_mod, _wrapper_classname)
        except Exception as e:
            # Note: braces below are doubled so they end up in the generated file's f-string
            raise ImportError(f"Could not import STEAM_materials class using spec '{_wrapper_import_spec}' and class '{_wrapper_classname}': {e}")

# internal cache to reuse STEAM_materials instances per function
__cache = {}          # <-- escaped braces

def _get_sm(func_name: str, n_arg: int, n_points: int, material_objects_path: Optional[os.PathLike]):
    key = (func_name, n_arg, material_objects_path)
    entry = __cache.get(key)
    if entry is None or entry['_n_points'] != n_points:
        inst = _STEAM_cls(func_name, n_arg, n_points, material_objects_path)
        __cache[key] = {'_inst': inst, '_n_points': n_points}  # <-- double braces
        return inst
    return entry['_inst']


def BHAir_v1(x, arg1, arg2, arg3, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'BHAir_v1' (n_arg=4).
    Accepts one argument per parameter: x, arg1, arg2, arg3
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [x, arg1, arg2, arg3]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("BHAir_v1", 4, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def BHIron2_v1(x, arg1, arg2, arg3, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'BHIron2_v1' (n_arg=4).
    Accepts one argument per parameter: x, arg1, arg2, arg3
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [x, arg1, arg2, arg3]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("BHIron2_v1", 4, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_CS_eJoule_v1(component, jx, jy, jz, rho_matrix, jc_scaled, n, ec, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_CS_eJoule_v1' (n_arg=8).
    Accepts one argument per parameter: component, jx, jy, jz, rho_matrix, jc_scaled, n, ec
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [component, jx, jy, jz, rho_matrix, jc_scaled, n, ec]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_CS_eJoule_v1", 8, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_CpHeMass_v1(T, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_CpHeMass_v1' (n_arg=1).
    Accepts one argument per parameter: T
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_CpHeMass_v1", 1, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_CvAg_v1(T, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_CvAg_v1' (n_arg=1).
    Accepts one argument per parameter: T
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_CvAg_v1", 1, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_CvAl5083_v1(T, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_CvAl5083_v1' (n_arg=1).
    Accepts one argument per parameter: T
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_CvAl5083_v1", 1, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_CvAlAlloy_v1(T, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_CvAlAlloy_v1' (n_arg=1).
    Accepts one argument per parameter: T
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_CvAlAlloy_v1", 1, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_CvAl_v1(T, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_CvAl_v1' (n_arg=1).
    Accepts one argument per parameter: T
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_CvAl_v1", 1, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_CvBSCCO2212_v1(T, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_CvBSCCO2212_v1' (n_arg=1).
    Accepts one argument per parameter: T
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_CvBSCCO2212_v1", 1, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_CvBeCu_v1(T, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_CvBeCu_v1' (n_arg=1).
    Accepts one argument per parameter: T
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_CvBeCu_v1", 1, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_CvBrass_v1(T, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_CvBrass_v1' (n_arg=1).
    Accepts one argument per parameter: T
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_CvBrass_v1", 1, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_CvCu_CUDI_v1(T, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_CvCu_CUDI_v1' (n_arg=1).
    Accepts one argument per parameter: T
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_CvCu_CUDI_v1", 1, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_CvCu_NIST_v1(T, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_CvCu_NIST_v1' (n_arg=1).
    Accepts one argument per parameter: T
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_CvCu_NIST_v1", 1, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_CvCu_v1(T, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_CvCu_v1' (n_arg=1).
    Accepts one argument per parameter: T
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_CvCu_v1", 1, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_CvG10_v1(T, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_CvG10_v1' (n_arg=1).
    Accepts one argument per parameter: T
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_CvG10_v1", 1, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_CvHast_v1(T, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_CvHast_v1' (n_arg=1).
    Accepts one argument per parameter: T
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_CvHast_v1", 1, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_CvHeMass_v1(T, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_CvHeMass_v1' (n_arg=1).
    Accepts one argument per parameter: T
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_CvHeMass_v1", 1, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_CvHe_CUDI_v1(T, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_CvHe_CUDI_v1' (n_arg=1).
    Accepts one argument per parameter: T
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_CvHe_CUDI_v1", 1, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_CvHe_NIST_v1(T, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_CvHe_NIST_v1' (n_arg=1).
    Accepts one argument per parameter: T
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_CvHe_NIST_v1", 1, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_CvHe_v1(T, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_CvHe_v1' (n_arg=1).
    Accepts one argument per parameter: T
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_CvHe_v1", 1, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_CvIn_v0(T, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_CvIn_v0' (n_arg=1).
    Accepts one argument per parameter: T
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_CvIn_v0", 1, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_CvKapton_v1(T, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_CvKapton_v1' (n_arg=1).
    Accepts one argument per parameter: T
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_CvKapton_v1", 1, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_CvNb3Sn_Arp_Knapp_v1(T, Tc, Tc0, Tcs, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_CvNb3Sn_Arp_Knapp_v1' (n_arg=4).
    Accepts one argument per parameter: T, Tc, Tc0, Tcs
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T, Tc, Tc0, Tcs]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_CvNb3Sn_Arp_Knapp_v1", 4, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_CvNb3Sn_Arp_Knapp_v2(T, Tc, Tc0, Tcs, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_CvNb3Sn_Arp_Knapp_v2' (n_arg=4).
    Accepts one argument per parameter: T, Tc, Tc0, Tcs
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T, Tc, Tc0, Tcs]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_CvNb3Sn_Arp_Knapp_v2", 4, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_CvNb3Sn_v1(T, B, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_CvNb3Sn_v1' (n_arg=2).
    Accepts one argument per parameter: T, B
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T, B]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_CvNb3Sn_v1", 2, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_CvNb3Sn_v2(T, B, Tc0, Bc20, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_CvNb3Sn_v2' (n_arg=4).
    Accepts one argument per parameter: T, B, Tc0, Bc20
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T, B, Tc0, Bc20]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_CvNb3Sn_v2", 4, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_CvNbTi_CUDI_v1(T, B, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_CvNbTi_CUDI_v1' (n_arg=2).
    Accepts one argument per parameter: T, B
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T, B]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_CvNbTi_CUDI_v1", 2, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_CvNbTi_v1(T, B, I, C1, C2, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_CvNbTi_v1' (n_arg=5).
    Accepts one argument per parameter: T, B, I, C1, C2
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T, B, I, C1, C2]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_CvNbTi_v1", 5, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_CvSS316_NIST_v1(T, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_CvSS316_NIST_v1' (n_arg=1).
    Accepts one argument per parameter: T
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_CvSS316_NIST_v1", 1, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_CvSteel_v1(T, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_CvSteel_v1' (n_arg=1).
    Accepts one argument per parameter: T
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_CvSteel_v1", 1, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_CvTi_v1(T, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_CvTi_v1' (n_arg=1).
    Accepts one argument per parameter: T
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_CvTi_v1", 1, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_HTS_JcFit_Fujikura_v1(Top_IN, Bnorm_IN, thetaFieldTape_IN, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_HTS_JcFit_Fujikura_v1' (n_arg=3).
    Accepts one argument per parameter: Top_IN, Bnorm_IN, thetaFieldTape_IN
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [Top_IN, Bnorm_IN, thetaFieldTape_IN]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_HTS_JcFit_Fujikura_v1", 3, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_HTS_JcFit_SUPERPOWER_v1(Top_IN, Bnorm_IN, thetaFieldTape_IN, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_HTS_JcFit_SUPERPOWER_v1' (n_arg=3).
    Accepts one argument per parameter: Top_IN, Bnorm_IN, thetaFieldTape_IN
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [Top_IN, Bnorm_IN, thetaFieldTape_IN]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_HTS_JcFit_SUPERPOWER_v1", 3, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_HTS_JcFit_Succi_v2(Top_IN, Bnorm_IN, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_HTS_JcFit_Succi_v2' (n_arg=2).
    Accepts one argument per parameter: Top_IN, Bnorm_IN
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [Top_IN, Bnorm_IN]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_HTS_JcFit_Succi_v2", 2, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_HTS_JcFit_THEVA_v1(Top_IN, Bnorm_IN, thetaFieldTape_IN, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_HTS_JcFit_THEVA_v1' (n_arg=3).
    Accepts one argument per parameter: Top_IN, Bnorm_IN, thetaFieldTape_IN
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [Top_IN, Bnorm_IN, thetaFieldTape_IN]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_HTS_JcFit_THEVA_v1", 3, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_HTS_JcFit_sunam_v1(Top_IN, Bnorm_IN, thetaFieldTape_IN, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_HTS_JcFit_sunam_v1' (n_arg=3).
    Accepts one argument per parameter: Top_IN, Bnorm_IN, thetaFieldTape_IN
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [Top_IN, Bnorm_IN, thetaFieldTape_IN]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_HTS_JcFit_sunam_v1", 3, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_IcNb3Sn_HiLumi_v1(T, B, Area, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_IcNb3Sn_HiLumi_v1' (n_arg=3).
    Accepts one argument per parameter: T, B, Area
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T, B, Area]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_IcNb3Sn_HiLumi_v1", 3, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_IcNb3Sn_WithStress_v1(T, B, Area, S, a, Smax, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_IcNb3Sn_WithStress_v1' (n_arg=6).
    Accepts one argument per parameter: T, B, Area, S, a, Smax
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T, B, Area, S, a, Smax]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_IcNb3Sn_WithStress_v1", 6, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_IcNb3Sn_v1(T, B, Area, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_IcNb3Sn_v1' (n_arg=3).
    Accepts one argument per parameter: T, B, Area
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T, B, Area]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_IcNb3Sn_v1", 3, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_IcNbTi_v1(T, B, Area, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_IcNbTi_v1' (n_arg=3).
    Accepts one argument per parameter: T, B, Area
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T, B, Area]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_IcNbTi_v1", 3, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_JcNbTiLowCurrent_v1(T, B, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_JcNbTiLowCurrent_v1' (n_arg=2).
    Accepts one argument per parameter: T, B
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T, B]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_JcNbTiLowCurrent_v1", 2, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_Jc_Nb3Sn_Bordini_v1(T, B, C0, Tc0_Nb3Sn, Bc20_Nb3Sn, alpha, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_Jc_Nb3Sn_Bordini_v1' (n_arg=6).
    Accepts one argument per parameter: T, B, C0, Tc0_Nb3Sn, Bc20_Nb3Sn, alpha
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T, B, C0, Tc0_Nb3Sn, Bc20_Nb3Sn, alpha]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_Jc_Nb3Sn_Bordini_v1", 6, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_Jc_Nb3Sn_Bottura_v1(T, B, Tc0, Bc20, CJ, p, q, wireDiameter, Cu_noCu, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_Jc_Nb3Sn_Bottura_v1' (n_arg=9).
    Accepts one argument per parameter: T, B, Tc0, Bc20, CJ, p, q, wireDiameter, Cu_noCu
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T, B, Tc0, Bc20, CJ, p, q, wireDiameter, Cu_noCu]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_Jc_Nb3Sn_Bottura_v1", 9, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_Jc_Nb3Sn_HFM_v1(T, B, C0, Tc0_Nb3Sn, Bc20_Nb3Sn, alpha, nu, p, q, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_Jc_Nb3Sn_HFM_v1' (n_arg=9).
    Accepts one argument per parameter: T, B, C0, Tc0_Nb3Sn, Bc20_Nb3Sn, alpha, nu, p, q
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T, B, C0, Tc0_Nb3Sn, Bc20_Nb3Sn, alpha, nu, p, q]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_Jc_Nb3Sn_HFM_v1", 9, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_Jc_Nb3Sn_Summers_v1(T, B, Jc_Nb3Sn0, Tc0_Nb3Sn, Bc20_Nb3Sn, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_Jc_Nb3Sn_Summers_v1' (n_arg=5).
    Accepts one argument per parameter: T, B, Jc_Nb3Sn0, Tc0_Nb3Sn, Bc20_Nb3Sn
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T, B, Jc_Nb3Sn0, Tc0_Nb3Sn, Bc20_Nb3Sn]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_Jc_Nb3Sn_Summers_v1", 5, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_Jc_NbTi_Bottura_v1(T, B, Tc0, Bc20, Jc_ref, C0, alpha, beta, gamma, wireDiameter, Cu_noCu, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_Jc_NbTi_Bottura_v1' (n_arg=11).
    Accepts one argument per parameter: T, B, Tc0, Bc20, Jc_ref, C0, alpha, beta, gamma, wireDiameter, Cu_noCu
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T, B, Tc0, Bc20, Jc_ref, C0, alpha, beta, gamma, wireDiameter, Cu_noCu]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_Jc_NbTi_Bottura_v1", 11, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_Jc_NbTi_Cudi_fit1_v1(T, B, Tc0, Bc20, C1, C2, wireDiameter, Cu_noCu, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_Jc_NbTi_Cudi_fit1_v1' (n_arg=8).
    Accepts one argument per parameter: T, B, Tc0, Bc20, C1, C2, wireDiameter, Cu_noCu
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T, B, Tc0, Bc20, C1, C2, wireDiameter, Cu_noCu]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_Jc_NbTi_Cudi_fit1_v1", 8, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_Jc_NbTi_Cudi_v1(T, B, Tc0, Bc20, c1, c2, c3, c4, c5, c6, wireDiameter, Cu_noCu, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_Jc_NbTi_Cudi_v1' (n_arg=12).
    Accepts one argument per parameter: T, B, Tc0, Bc20, c1, c2, c3, c4, c5, c6, wireDiameter, Cu_noCu
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T, B, Tc0, Bc20, c1, c2, c3, c4, c5, c6, wireDiameter, Cu_noCu]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_Jc_NbTi_Cudi_v1", 12, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_Jc_T_B_BSCCO2212_Power_Gosh_v1(T, B, f_scaling, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_Jc_T_B_BSCCO2212_Power_Gosh_v1' (n_arg=3).
    Accepts one argument per parameter: T, B, f_scaling
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T, B, f_scaling]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_Jc_T_B_BSCCO2212_Power_Gosh_v1", 3, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_Jc_T_B_BSCCO2212_Power_Jiang_Wesche_v1(T, B, f_scaling, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_Jc_T_B_BSCCO2212_Power_Jiang_Wesche_v1' (n_arg=3).
    Accepts one argument per parameter: T, B, f_scaling
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T, B, f_scaling]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_Jc_T_B_BSCCO2212_Power_Jiang_Wesche_v1", 3, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_Jc_T_B_BSCCO2212_new_v1(T, B, f_scaling, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_Jc_T_B_BSCCO2212_new_v1' (n_arg=3).
    Accepts one argument per parameter: T, B, f_scaling
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T, B, f_scaling]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_Jc_T_B_BSCCO2212_new_v1", 3, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_Jc_T_B_BSCCO2212_v1(T, B, f_scaling, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_Jc_T_B_BSCCO2212_v1' (n_arg=3).
    Accepts one argument per parameter: T, B, f_scaling
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T, B, f_scaling]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_Jc_T_B_BSCCO2212_v1", 3, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_NZPV_v1(J, T_bath, Tcs, Tc, cv, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_NZPV_v1' (n_arg=5).
    Accepts one argument per parameter: J, T_bath, Tcs, Tc, cv
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [J, T_bath, Tcs, Tc, cv]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_NZPV_v1", 5, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_P2vsT2_cryocooler_SHI_SRDE_418D4_v2(T, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_P2vsT2_cryocooler_SHI_SRDE_418D4_v2' (n_arg=1).
    Accepts one argument per parameter: T
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_P2vsT2_cryocooler_SHI_SRDE_418D4_v2", 1, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_PvsT_cryocooler_SHI_SRDE_418D4_v1(T, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_PvsT_cryocooler_SHI_SRDE_418D4_v1' (n_arg=1).
    Accepts one argument per parameter: T
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_PvsT_cryocooler_SHI_SRDE_418D4_v1", 1, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_QHCircuitRLC_v1(t, rho_SS, t_on, U_0, C, R_warm, w_SS, h_SS, l_SS, L, mode, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_QHCircuitRLC_v1' (n_arg=11).
    Accepts one argument per parameter: t, rho_SS, t_on, U_0, C, R_warm, w_SS, h_SS, l_SS, L, mode
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [t, rho_SS, t_on, U_0, C, R_warm, w_SS, h_SS, l_SS, L, mode]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_QHCircuitRLC_v1", 11, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_QHCircuit_v1(t, t_on, T, U_0, C, R_warm, w_QH, h_QH, l_QH, mode, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_QHCircuit_v1' (n_arg=10).
    Accepts one argument per parameter: t, t_on, T, U_0, C, R_warm, w_QH, h_QH, l_QH, mode
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [t, t_on, T, U_0, C, R_warm, w_QH, h_QH, l_QH, mode]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_QHCircuit_v1", 10, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_QHCircuit_v2(t, rho_SS, t_on, U_0, C, R_warm, w_SS, h_SS, l_SS, mode, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_QHCircuit_v2' (n_arg=10).
    Accepts one argument per parameter: t, rho_SS, t_on, U_0, C, R_warm, w_SS, h_SS, l_SS, mode
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [t, rho_SS, t_on, U_0, C, R_warm, w_SS, h_SS, l_SS, mode]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_QHCircuit_v2", 10, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_QHCircuit_v3(t, rho_SS, t_on, U_0, C, R_warm, w_SS, h_SS, l_SS, L, mode, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_QHCircuit_v3' (n_arg=11).
    Accepts one argument per parameter: t, rho_SS, t_on, U_0, C, R_warm, w_SS, h_SS, l_SS, L, mode
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [t, rho_SS, t_on, U_0, C, R_warm, w_SS, h_SS, l_SS, L, mode]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_QHCircuit_v3", 11, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_ROHF_fluxDensity_jrev_v1(Lint0, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_ROHF_fluxDensity_jrev_v1' (n_arg=1).
    Accepts one argument per parameter: Lint0
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [Lint0]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_ROHF_fluxDensity_jrev_v1", 1, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_ROHF_fluxDensity_v1(Lint0, j_new, delta_t, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_ROHF_fluxDensity_v1' (n_arg=3).
    Accepts one argument per parameter: Lint0, j_new, delta_t
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [Lint0, j_new, delta_t]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_ROHF_fluxDensity_v1", 3, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_ROHF_jrev_v1(j_new, j_prev_rev, j_prev_eddy, kappa, tau_e, delta_t, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_ROHF_jrev_v1' (n_arg=6).
    Accepts one argument per parameter: j_new, j_prev_rev, j_prev_eddy, kappa, tau_e, delta_t
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [j_new, j_prev_rev, j_prev_eddy, kappa, tau_e, delta_t]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_ROHF_jrev_v1", 6, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_ROHF_jreveddy_v1(j_new, j_prev_eddy, kappa, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_ROHF_jreveddy_v1' (n_arg=3).
    Accepts one argument per parameter: j_new, j_prev_eddy, kappa
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [j_new, j_prev_eddy, kappa]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_ROHF_jreveddy_v1", 3, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_ROHM_bHyst_v1(vec_index, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_ROHM_bHyst_v1' (n_arg=1).
    Accepts one argument per parameter: vec_index
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [vec_index]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_ROHM_bHyst_v1", 1, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_ROHM_g_v1(vec_index, kappa_k, h_new_1, h_new_2, h_new_3, h_prev_rev_1, h_prev_rev_2, h_prev_rev_3, h_prev_eddy_coupl_1, h_prev_eddy_coupl_2, h_prev_eddy_coupl_3, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_ROHM_g_v1' (n_arg=11).
    Accepts one argument per parameter: vec_index, kappa_k, h_new_1, h_new_2, h_new_3, h_prev_rev_1, h_prev_rev_2, h_prev_rev_3, h_prev_eddy_coupl_1, h_prev_eddy_coupl_2, h_prev_eddy_coupl_3
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [vec_index, kappa_k, h_new_1, h_new_2, h_new_3, h_prev_rev_1, h_prev_rev_2, h_prev_rev_3, h_prev_eddy_coupl_1, h_prev_eddy_coupl_2, h_prev_eddy_coupl_3]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_ROHM_g_v1", 11, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_ROHM_hCoupling_v1(vec_index, f_chi, tau_c_k, chi_k, dbk_dt_1, dbk_dt_2, dbk_dt_3, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_ROHM_hCoupling_v1' (n_arg=7).
    Accepts one argument per parameter: vec_index, f_chi, tau_c_k, chi_k, dbk_dt_1, dbk_dt_2, dbk_dt_3
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [vec_index, f_chi, tau_c_k, chi_k, dbk_dt_1, dbk_dt_2, dbk_dt_3]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_ROHM_hCoupling_v1", 7, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_ROHM_hRev_v1(vec_index, w_k, kappa_k, chi_k, tau_c_k, tau_e_k, delta_t, h_new_1, h_new_2, h_new_3, h_prev_rev_1, h_prev_rev_2, h_prev_rev_3, h_prev_eddy_coupl_1, h_prev_eddy_coupl_2, h_prev_eddy_coupl_3, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_ROHM_hRev_v1' (n_arg=15).
    Accepts one argument per parameter: vec_index, w_k, kappa_k, chi_k, tau_c_k, tau_e_k, delta_t, h_new_1, h_new_2, h_new_3, h_prev_rev_1, h_prev_rev_2, h_prev_rev_3, h_prev_eddy_coupl_1, h_prev_eddy_coupl_2, h_prev_eddy_coupl_3
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [vec_index, w_k, kappa_k, chi_k, tau_c_k, tau_e_k, delta_t, h_new_1, h_new_2, h_new_3, h_prev_rev_1, h_prev_rev_2, h_prev_rev_3, h_prev_eddy_coupl_1, h_prev_eddy_coupl_2, h_prev_eddy_coupl_3]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_ROHM_hRev_v1", 15, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_TcNb3Sn_v1(B, Tc0_Nb3Sn, Bc20_Nb3Sn, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_TcNb3Sn_v1' (n_arg=3).
    Accepts one argument per parameter: B, Tc0_Nb3Sn, Bc20_Nb3Sn
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [B, Tc0_Nb3Sn, Bc20_Nb3Sn]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_TcNb3Sn_v1", 3, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_TcNbTi_v1(B, Tc0_NbTi, Bc20_NbTi, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_TcNbTi_v1' (n_arg=3).
    Accepts one argument per parameter: B, Tc0_NbTi, Bc20_NbTi
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [B, Tc0_NbTi, Bc20_NbTi]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_TcNbTi_v1", 3, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_TcsNbTi_v1(B, I, C1, C2, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_TcsNbTi_v1' (n_arg=4).
    Accepts one argument per parameter: B, I, C1, C2
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [B, I, C1, C2]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_TcsNbTi_v1", 4, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_Tcs_Nb3Sn_v1(J_sc, B, Jc0, Jc_Nb3Sn0, Tc0_Nb3Sn, Bc20_Nb3Sn, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_Tcs_Nb3Sn_v1' (n_arg=6).
    Accepts one argument per parameter: J_sc, B, Jc0, Jc_Nb3Sn0, Tc0_Nb3Sn, Bc20_Nb3Sn
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [J_sc, B, Jc0, Jc_Nb3Sn0, Tc0_Nb3Sn, Bc20_Nb3Sn]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_Tcs_Nb3Sn_v1", 6, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_densityHe_v1(T, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_densityHe_v1' (n_arg=1).
    Accepts one argument per parameter: T
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_densityHe_v1", 1, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_fisc_I_Ic_n_rhom_Am_BSCCO2212_v1(I, Ic, n, rho_m, A_matrix, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_fisc_I_Ic_n_rhom_Am_BSCCO2212_v1' (n_arg=5).
    Accepts one argument per parameter: I, Ic, n, rho_m, A_matrix
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [I, Ic, n, rho_m, A_matrix]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_fisc_I_Ic_n_rhom_Am_BSCCO2212_v1", 5, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_hHe_v1(T, THe, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_hHe_v1' (n_arg=2).
    Accepts one argument per parameter: T, THe
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T, THe]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_hHe_v1", 2, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_hN_v1(T_diff, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_hN_v1' (n_arg=1).
    Accepts one argument per parameter: T_diff
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T_diff]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_hN_v1", 1, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_kAg_RRR30_v1(T, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_kAg_RRR30_v1' (n_arg=1).
    Accepts one argument per parameter: T
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_kAg_RRR30_v1", 1, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_kAg_v1(T, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_kAg_v1' (n_arg=1).
    Accepts one argument per parameter: T
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_kAg_v1", 1, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_kAl1350_v1(T, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_kAl1350_v1' (n_arg=1).
    Accepts one argument per parameter: T
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_kAl1350_v1", 1, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_kAl5083_v1(T, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_kAl5083_v1' (n_arg=1).
    Accepts one argument per parameter: T
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_kAl5083_v1", 1, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_kAl6061_v1(T, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_kAl6061_v1' (n_arg=1).
    Accepts one argument per parameter: T
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_kAl6061_v1", 1, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_kAlAlloy_v1(T, RRR, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_kAlAlloy_v1' (n_arg=2).
    Accepts one argument per parameter: T, RRR
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T, RRR]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_kAlAlloy_v1", 2, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_kBeCu_WiedemannFranz_v1(T, rhoBeCu, f_scaling, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_kBeCu_WiedemannFranz_v1' (n_arg=3).
    Accepts one argument per parameter: T, rhoBeCu, f_scaling
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T, rhoBeCu, f_scaling]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_kBeCu_WiedemannFranz_v1", 3, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_kBrass_v1(T, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_kBrass_v1' (n_arg=1).
    Accepts one argument per parameter: T
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_kBrass_v1", 1, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_kCu_Wiedemann_v1(T, rho, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_kCu_Wiedemann_v1' (n_arg=2).
    Accepts one argument per parameter: T, rho
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T, rho]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_kCu_Wiedemann_v1", 2, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_kCu_v1(T, RRR, rho_B0, rho, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_kCu_v1' (n_arg=4).
    Accepts one argument per parameter: T, RRR, rho_B0, rho
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T, RRR, rho_B0, rho]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_kCu_v1", 4, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_kG10_v1(T, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_kG10_v1' (n_arg=1).
    Accepts one argument per parameter: T
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_kG10_v1", 1, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_kG10_v2(T, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_kG10_v2' (n_arg=1).
    Accepts one argument per parameter: T
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_kG10_v2", 1, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_kHast_v1(T, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_kHast_v1' (n_arg=1).
    Accepts one argument per parameter: T
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_kHast_v1", 1, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_kIn_v0(T, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_kIn_v0' (n_arg=1).
    Accepts one argument per parameter: T
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_kIn_v0", 1, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_kKapton_v1(T, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_kKapton_v1' (n_arg=1).
    Accepts one argument per parameter: T
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_kKapton_v1", 1, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_kKapton_v2(T, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_kKapton_v2' (n_arg=1).
    Accepts one argument per parameter: T
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_kKapton_v2", 1, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_kSteel_v1(T, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_kSteel_v1' (n_arg=1).
    Accepts one argument per parameter: T
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_kSteel_v1", 1, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_kSteel_v2(T, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_kSteel_v2' (n_arg=1).
    Accepts one argument per parameter: T
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_kSteel_v2", 1, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_kStycast_v1(T, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_kStycast_v1' (n_arg=1).
    Accepts one argument per parameter: T
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_kStycast_v1", 1, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_n_T_B_BSCCO2212_Jiang_Wesche_v1(T, B, n0, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_n_T_B_BSCCO2212_Jiang_Wesche_v1' (n_arg=3).
    Accepts one argument per parameter: T, B, n0
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T, B, n0]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_n_T_B_BSCCO2212_Jiang_Wesche_v1", 3, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_quenchState_v1(arg0, arg1, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_quenchState_v1' (n_arg=2).
    Accepts one argument per parameter: arg0, arg1
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [arg0, arg1]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_quenchState_v1", 2, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_rhoAgMg_v1(T, B, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_rhoAgMg_v1' (n_arg=2).
    Accepts one argument per parameter: T, B
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T, B]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_rhoAgMg_v1", 2, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_rhoAg_v1(T, B, RRR, Tref_RRR, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_rhoAg_v1' (n_arg=4).
    Accepts one argument per parameter: T, B, RRR, Tref_RRR
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T, B, RRR, Tref_RRR]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_rhoAg_v1", 4, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_rhoAl1350_v1(T, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_rhoAl1350_v1' (n_arg=1).
    Accepts one argument per parameter: T
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_rhoAl1350_v1", 1, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_rhoAl5083_v1(T, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_rhoAl5083_v1' (n_arg=1).
    Accepts one argument per parameter: T
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_rhoAl5083_v1", 1, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_rhoAl6061_v1(T, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_rhoAl6061_v1' (n_arg=1).
    Accepts one argument per parameter: T
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_rhoAl6061_v1", 1, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_rhoAlAlloy_v1(T, RRR, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_rhoAlAlloy_v1' (n_arg=2).
    Accepts one argument per parameter: T, RRR
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T, RRR]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_rhoAlAlloy_v1", 2, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_rhoAl_v2(T, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_rhoAl_v2' (n_arg=1).
    Accepts one argument per parameter: T
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_rhoAl_v2", 1, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_rhoBeCu_v1(T, f_scaling, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_rhoBeCu_v1' (n_arg=2).
    Accepts one argument per parameter: T, f_scaling
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T, f_scaling]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_rhoBeCu_v1", 2, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_rhoCu_CUDI_v1(T, B, RRR, MR, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_rhoCu_CUDI_v1' (n_arg=4).
    Accepts one argument per parameter: T, B, RRR, MR
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T, B, RRR, MR]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_rhoCu_CUDI_v1", 4, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_rhoCu_NIST_v2(T, B, RRR, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_rhoCu_NIST_v2' (n_arg=3).
    Accepts one argument per parameter: T, B, RRR
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T, B, RRR]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_rhoCu_NIST_v2", 3, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_rhoHast_v1(T, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_rhoHast_v1' (n_arg=1).
    Accepts one argument per parameter: T
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_rhoHast_v1", 1, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_rhoHast_v2(T, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_rhoHast_v2' (n_arg=1).
    Accepts one argument per parameter: T
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_rhoHast_v2", 1, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_rhoIn_v0(T, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_rhoIn_v0' (n_arg=1).
    Accepts one argument per parameter: T
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_rhoIn_v0", 1, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def CFUN_rhoSS_v1(T, material_objects_path: Optional[os.PathLike] = None):
    """Auto-generated wrapper for C material function 'CFUN_rhoSS_v1' (n_arg=1).
    Accepts one argument per parameter: T
    Each argument can be a scalar or a 1-D array-like of length n_points.
    Returns numpy array of length n_points (the outReal from the C function).
    """
    # Collect arguments into list (preserve order)
    _args = [T]
    # Convert inputs to arrays (scalars become 1-D arrays later)
    _arrays = []
    _length = None
    for _a in _args:
        arr = _np.asarray(_a, dtype=_np.float64)
        if arr.ndim == 0:
            # scalar, keep as 0-d array (broadcast later)
            _arrays.append(arr)
            continue
        if arr.ndim == 1:
            _arrays.append(arr)
            if _length is None:
                _length = arr.shape[0]
            elif arr.shape[0] != _length:
                raise ValueError("All input arrays must have the same length")
        else:
            raise ValueError("Each parameter should be a scalar or 1-D array")
    # determine n_points
    if _length is None:
        n_points = 1
    else:
        n_points = _length
    # build columns, broadcasting scalars
    _cols = []
    for a in _arrays:
        if a.ndim == 0:
            _cols.append(_np.full((n_points,), float(a), dtype=_np.float64))
        else:
            _cols.append(a)
    numpy2d = _np.vstack(_cols)
    sm = _get_sm("CFUN_rhoSS_v1", 1, n_points, material_objects_path)
    return sm.evaluate(numpy2d)


def available_material_functions():
    return ["BHAir_v1", "BHIron2_v1", "CFUN_CS_eJoule_v1", "CFUN_CpHeMass_v1", "CFUN_CvAg_v1", "CFUN_CvAl5083_v1", "CFUN_CvAlAlloy_v1", "CFUN_CvAl_v1", "CFUN_CvBSCCO2212_v1", "CFUN_CvBeCu_v1", "CFUN_CvBrass_v1", "CFUN_CvCu_CUDI_v1", "CFUN_CvCu_NIST_v1", "CFUN_CvCu_v1", "CFUN_CvG10_v1", "CFUN_CvHast_v1", "CFUN_CvHeMass_v1", "CFUN_CvHe_CUDI_v1", "CFUN_CvHe_NIST_v1", "CFUN_CvHe_v1", "CFUN_CvIn_v0", "CFUN_CvKapton_v1", "CFUN_CvNb3Sn_Arp_Knapp_v1", "CFUN_CvNb3Sn_Arp_Knapp_v2", "CFUN_CvNb3Sn_v1", "CFUN_CvNb3Sn_v2", "CFUN_CvNbTi_CUDI_v1", "CFUN_CvNbTi_v1", "CFUN_CvSS316_NIST_v1", "CFUN_CvSteel_v1", "CFUN_CvTi_v1", "CFUN_HTS_JcFit_Fujikura_v1", "CFUN_HTS_JcFit_SUPERPOWER_v1", "CFUN_HTS_JcFit_Succi_v2", "CFUN_HTS_JcFit_THEVA_v1", "CFUN_HTS_JcFit_sunam_v1", "CFUN_IcNb3Sn_HiLumi_v1", "CFUN_IcNb3Sn_WithStress_v1", "CFUN_IcNb3Sn_v1", "CFUN_IcNbTi_v1", "CFUN_JcNbTiLowCurrent_v1", "CFUN_Jc_Nb3Sn_Bordini_v1", "CFUN_Jc_Nb3Sn_Bottura_v1", "CFUN_Jc_Nb3Sn_HFM_v1", "CFUN_Jc_Nb3Sn_Summers_v1", "CFUN_Jc_NbTi_Bottura_v1", "CFUN_Jc_NbTi_Cudi_fit1_v1", "CFUN_Jc_NbTi_Cudi_v1", "CFUN_Jc_T_B_BSCCO2212_Power_Gosh_v1", "CFUN_Jc_T_B_BSCCO2212_Power_Jiang_Wesche_v1", "CFUN_Jc_T_B_BSCCO2212_new_v1", "CFUN_Jc_T_B_BSCCO2212_v1", "CFUN_NZPV_v1", "CFUN_P2vsT2_cryocooler_SHI_SRDE_418D4_v2", "CFUN_PvsT_cryocooler_SHI_SRDE_418D4_v1", "CFUN_QHCircuitRLC_v1", "CFUN_QHCircuit_v1", "CFUN_QHCircuit_v2", "CFUN_QHCircuit_v3", "CFUN_ROHF_fluxDensity_jrev_v1", "CFUN_ROHF_fluxDensity_v1", "CFUN_ROHF_jrev_v1", "CFUN_ROHF_jreveddy_v1", "CFUN_ROHM_bHyst_v1", "CFUN_ROHM_g_v1", "CFUN_ROHM_hCoupling_v1", "CFUN_ROHM_hRev_v1", "CFUN_TcNb3Sn_v1", "CFUN_TcNbTi_v1", "CFUN_TcsNbTi_v1", "CFUN_Tcs_Nb3Sn_v1", "CFUN_densityHe_v1", "CFUN_fisc_I_Ic_n_rhom_Am_BSCCO2212_v1", "CFUN_hHe_v1", "CFUN_hN_v1", "CFUN_kAg_RRR30_v1", "CFUN_kAg_v1", "CFUN_kAl1350_v1", "CFUN_kAl5083_v1", "CFUN_kAl6061_v1", "CFUN_kAlAlloy_v1", "CFUN_kBeCu_WiedemannFranz_v1", "CFUN_kBrass_v1", "CFUN_kCu_Wiedemann_v1", "CFUN_kCu_v1", "CFUN_kG10_v1", "CFUN_kG10_v2", "CFUN_kHast_v1", "CFUN_kIn_v0", "CFUN_kKapton_v1", "CFUN_kKapton_v2", "CFUN_kSteel_v1", "CFUN_kSteel_v2", "CFUN_kStycast_v1", "CFUN_n_T_B_BSCCO2212_Jiang_Wesche_v1", "CFUN_quenchState_v1", "CFUN_rhoAgMg_v1", "CFUN_rhoAg_v1", "CFUN_rhoAl1350_v1", "CFUN_rhoAl5083_v1", "CFUN_rhoAl6061_v1", "CFUN_rhoAlAlloy_v1", "CFUN_rhoAl_v2", "CFUN_rhoBeCu_v1", "CFUN_rhoCu_CUDI_v1", "CFUN_rhoCu_NIST_v2", "CFUN_rhoHast_v1", "CFUN_rhoHast_v2", "CFUN_rhoIn_v0", "CFUN_rhoSS_v1"]
