#!/usr/bin/env python3
"""
Unit tests for registry utilities.

Tests cryptographic utility functions.
All code in English as per project requirements.
"""

import pytest

from openssl_encrypt.modules.registry.utils import (
    constant_time_compare,
    derive_salt_for_round,
    format_bytes_hex,
    generate_random_bytes,
    pad_pkcs7,
    safe_memzero,
    split_buffer,
    unpad_pkcs7,
    xor_bytes,
)


class TestGenerateRandomBytes:
    """Tests for generate_random_bytes()."""

    def test_correct_length(self):
        """Test that generated bytes have correct length."""
        for length in [16, 32, 64, 128]:
            result = generate_random_bytes(length)
            assert len(result) == length

    def test_randomness(self):
        """Test that consecutive calls produce different results."""
        result1 = generate_random_bytes(32)
        result2 = generate_random_bytes(32)
        assert result1 != result2

    def test_zero_length(self):
        """Test generating zero bytes."""
        result = generate_random_bytes(0)
        assert len(result) == 0

    def test_negative_length(self):
        """Test that negative length raises error."""
        with pytest.raises(ValueError, match="non-negative"):
            generate_random_bytes(-1)


class TestConstantTimeCompare:
    """Tests for constant_time_compare()."""

    def test_equal_bytes(self):
        """Test comparison of equal byte strings."""
        a = b"hello world"
        b = b"hello world"
        assert constant_time_compare(a, b) is True

    def test_different_bytes(self):
        """Test comparison of different byte strings."""
        a = b"hello world"
        b = b"hello earth"
        assert constant_time_compare(a, b) is False

    def test_different_lengths(self):
        """Test comparison of different length strings."""
        a = b"hello"
        b = b"hello world"
        assert constant_time_compare(a, b) is False

    def test_empty_bytes(self):
        """Test comparison of empty byte strings."""
        assert constant_time_compare(b"", b"") is True

    def test_single_bit_difference(self):
        """Test that single bit difference is detected."""
        a = b"\x00"
        b = b"\x01"
        assert constant_time_compare(a, b) is False


class TestPKCS7Padding:
    """Tests for PKCS#7 padding functions."""

    def test_pad_full_block(self):
        """Test padding data that is already a full block."""
        data = b"0123456789ABCDEF"  # 16 bytes
        padded = pad_pkcs7(data, 16)
        # Should add a full block of padding (16 bytes of 0x10)
        assert len(padded) == 32
        assert padded[-16:] == bytes([16] * 16)

    def test_pad_partial_block(self):
        """Test padding data that is not a full block."""
        data = b"0123456789"  # 10 bytes
        padded = pad_pkcs7(data, 16)
        # Should add 6 bytes of padding (value 0x06)
        assert len(padded) == 16
        assert padded[-6:] == bytes([6] * 6)

    def test_pad_unpad_roundtrip(self):
        """Test that padding and unpadding is reversible."""
        original = b"Test data with arbitrary length!"
        padded = pad_pkcs7(original, 16)
        unpadded = unpad_pkcs7(padded)
        assert original == unpadded

    def test_unpad_valid_padding(self):
        """Test unpadding correctly padded data."""
        data = b"0123456789\x06\x06\x06\x06\x06\x06"
        unpadded = unpad_pkcs7(data)
        assert unpadded == b"0123456789"

    def test_unpad_empty_data(self):
        """Test unpadding empty data raises error."""
        with pytest.raises(ValueError, match="empty"):
            unpad_pkcs7(b"")

    def test_unpad_invalid_padding_length(self):
        """Test unpadding with invalid padding length."""
        data = b"0123456789\x99\x99"  # Invalid padding length
        with pytest.raises(ValueError, match="Invalid padding"):
            unpad_pkcs7(data)

    def test_unpad_invalid_padding_bytes(self):
        """Test unpadding with incorrect padding bytes."""
        data = b"0123456789\x06\x06\x06\x05\x06\x06"  # One wrong byte
        with pytest.raises(ValueError, match="Invalid padding"):
            unpad_pkcs7(data)

    def test_pad_invalid_block_size(self):
        """Test padding with invalid block size."""
        with pytest.raises(ValueError, match="between 1 and 255"):
            pad_pkcs7(b"data", 0)

        with pytest.raises(ValueError, match="between 1 and 255"):
            pad_pkcs7(b"data", 256)


class TestDeriveSaltForRound:
    """Tests for derive_salt_for_round()."""

    def test_different_rounds_different_salts(self):
        """Test that different rounds produce different salts."""
        base_salt = b"base_salt_value"
        salt0 = derive_salt_for_round(base_salt, 0)
        salt1 = derive_salt_for_round(base_salt, 1)
        salt2 = derive_salt_for_round(base_salt, 2)

        assert salt0 != salt1
        assert salt1 != salt2
        assert salt0 != salt2

    def test_deterministic(self):
        """Test that same inputs produce same outputs."""
        base_salt = b"base_salt_value"
        salt1 = derive_salt_for_round(base_salt, 5)
        salt2 = derive_salt_for_round(base_salt, 5)

        assert salt1 == salt2

    def test_salt_length(self):
        """Test that derived salt is always 16 bytes."""
        base_salt = b"test"
        for round_num in range(10):
            salt = derive_salt_for_round(base_salt, round_num)
            assert len(salt) == 16


class TestXorBytes:
    """Tests for xor_bytes()."""

    def test_basic_xor(self):
        """Test basic XOR operation."""
        a = b"\x00\xFF\xAA\x55"
        b = b"\xFF\x00\x55\xAA"
        result = xor_bytes(a, b)
        assert result == b"\xFF\xFF\xFF\xFF"

    def test_xor_self_is_zero(self):
        """Test that XORing with self produces zeros."""
        data = b"test data"
        result = xor_bytes(data, data)
        assert result == bytes(len(data))

    def test_xor_commutative(self):
        """Test that XOR is commutative."""
        a = b"hello"
        b = b"world"
        assert xor_bytes(a, b) == xor_bytes(b, a)

    def test_length_mismatch(self):
        """Test that length mismatch raises error."""
        a = b"short"
        b = b"much longer string"
        with pytest.raises(ValueError, match="Length mismatch"):
            xor_bytes(a, b)


class TestSplitBuffer:
    """Tests for split_buffer()."""

    def test_basic_split(self):
        """Test basic buffer splitting."""
        data = b"0123456789"
        part1, part2, part3 = split_buffer(data, 4, 3, 3)

        assert part1 == b"0123"
        assert part2 == b"456"
        assert part3 == b"789"

    def test_split_entire_buffer(self):
        """Test splitting entire buffer."""
        data = b"ABCDEFGH"
        part1, part2 = split_buffer(data, 4, 4)

        assert part1 == b"ABCD"
        assert part2 == b"EFGH"

    def test_split_with_remainder(self):
        """Test splitting with remaining data."""
        data = b"0123456789"
        part1, part2 = split_buffer(data, 3, 3)

        assert part1 == b"012"
        assert part2 == b"345"
        # Remaining data (6789) is not returned

    def test_size_exceeds_data(self):
        """Test that oversized split raises error."""
        data = b"short"
        with pytest.raises(ValueError, match="exceeds data length"):
            split_buffer(data, 10)

    def test_empty_split(self):
        """Test splitting with no sizes."""
        data = b"data"
        result = split_buffer(data)
        assert result == ()


class TestFormatBytesHex:
    """Tests for format_bytes_hex()."""

    def test_full_formatting(self):
        """Test formatting without truncation."""
        data = b"\x00\x01\x02\x03"
        result = format_bytes_hex(data, max_length=None)
        assert result == "00010203"

    def test_truncation(self):
        """Test formatting with truncation."""
        data = b"0123456789ABCDEF"
        result = format_bytes_hex(data, max_length=4)
        assert result == "30313233..."

    def test_no_truncation_when_short(self):
        """Test that short data is not truncated."""
        data = b"AB"
        result = format_bytes_hex(data, max_length=10)
        assert result == "4142"
        assert "..." not in result


class TestSafeMemzero:
    """Tests for safe_memzero()."""

    def test_zeroing_bytearray(self):
        """Test zeroing a bytearray."""
        data = bytearray(b"sensitive data")
        safe_memzero(data)
        assert data == bytearray(14)  # All zeros

    def test_non_bytearray_no_error(self):
        """Test that non-bytearray doesn't cause error."""
        data = b"immutable bytes"
        safe_memzero(data)  # Should not raise


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
