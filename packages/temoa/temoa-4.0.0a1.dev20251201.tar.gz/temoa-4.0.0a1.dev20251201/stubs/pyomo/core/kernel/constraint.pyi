from _typeshed import Incomplete
from pyomo.common.modeling import NOTSET as NOTSET
from pyomo.core.expr.expr_common import ExpressionType as ExpressionType
from pyomo.core.expr.numvalue import ZeroConstant as ZeroConstant
from pyomo.core.expr.numvalue import as_numeric as as_numeric
from pyomo.core.expr.numvalue import is_numeric_data as is_numeric_data
from pyomo.core.expr.numvalue import is_potentially_variable as is_potentially_variable
from pyomo.core.expr.numvalue import value as value
from pyomo.core.expr.relational_expr import EqualityExpression as EqualityExpression
from pyomo.core.expr.relational_expr import InequalityExpression as InequalityExpression
from pyomo.core.expr.relational_expr import RangedExpression as RangedExpression
from pyomo.core.kernel.base import ICategorizedObject as ICategorizedObject
from pyomo.core.kernel.container_utils import define_simple_containers as define_simple_containers

class IConstraint(ICategorizedObject):
    body: Incomplete
    lower: Incomplete
    upper: Incomplete
    lb: Incomplete
    ub: Incomplete
    rhs: Incomplete
    equality: Incomplete
    def __call__(self, exception=...): ...
    @property
    def lslack(self): ...
    @property
    def uslack(self): ...
    @property
    def slack(self): ...
    @property
    def expr(self): ...
    @property
    def bounds(self): ...
    def has_lb(self): ...
    def has_ub(self): ...
    def to_bounded_expression(self, evaluate_bounds: bool = False): ...

class _MutableBoundsConstraintMixin:
    @property
    def lower(self): ...
    @lower.setter
    def lower(self, lb) -> None: ...
    @property
    def upper(self): ...
    @upper.setter
    def upper(self, ub) -> None: ...
    @property
    def lb(self): ...
    @lb.setter
    def lb(self, lb) -> None: ...
    @property
    def ub(self): ...
    @ub.setter
    def ub(self, ub) -> None: ...
    @property
    def rhs(self): ...
    @rhs.setter
    def rhs(self, rhs) -> None: ...
    @property
    def bounds(self): ...
    @bounds.setter
    def bounds(self, bounds_tuple) -> None: ...
    @property
    def equality(self): ...
    @equality.setter
    def equality(self, equality) -> None: ...

class constraint(_MutableBoundsConstraintMixin, IConstraint):
    lb: Incomplete
    ub: Incomplete
    rhs: Incomplete
    def __init__(self, expr=None, body=None, lb=None, ub=None, rhs=None) -> None: ...
    @property
    def body(self): ...
    @body.setter
    def body(self, body) -> None: ...
    @property
    def expr(self): ...
    @expr.setter
    def expr(self, expr) -> None: ...

class linear_constraint(_MutableBoundsConstraintMixin, IConstraint):
    lb: Incomplete
    ub: Incomplete
    rhs: Incomplete
    def __init__(
        self, variables=None, coefficients=None, terms=None, lb=None, ub=None, rhs=None
    ) -> None: ...
    @property
    def terms(self): ...
    @terms.setter
    def terms(self, terms) -> None: ...
    def __call__(self, exception=...): ...
    @property
    def body(self): ...
    def canonical_form(self, compute_values: bool = True): ...
