"""Arcade Starter Tools for Hubspot_Events

DO NOT EDIT THIS MODULE DIRECTLY.

THIS MODULE WAS AUTO-GENERATED BY TRANSPILING THE API STARTER TOOL JSON DEFINITIONS
IN THE ../wrapper_tools DIRECTORY INTO PYTHON CODE. ANY CHANGES TO THIS MODULE WILL
BE OVERWRITTEN BY THE TRANSPILER.
"""

import asyncio
import json
from typing import Annotated, Any

import httpx

from arcade_tdk import tool, ToolContext
from arcade_tdk.auth import Hubspot


# Retry configuration
INITIAL_RETRY_DELAY = 0.5  # seconds

HTTP_CLIENT = httpx.AsyncClient(
    timeout=httpx.Timeout(60.0, connect=10.0),
    limits=httpx.Limits(max_keepalive_connections=20, max_connections=100),
    transport=httpx.AsyncHTTPTransport(retries=3),
    http2=True,
    follow_redirects=True,
)


def remove_none_values(data: dict[str, Any]) -> dict[str, Any]:
    return {k: v for k, v in data.items() if v is not None}


async def make_request(
    url: str,
    method: str,
    params: dict[str, Any] | None = None,
    headers: dict[str, Any] | None = None,
    content: str | None = None,
    data: dict[str, Any] | None = None,
    auth: tuple[str, str] | None = None,
    max_retries: int = 3,
) -> httpx.Response:
    """Make an HTTP request with retry logic for 5xx server errors."""
    for attempt in range(max_retries):
        try:
            response = await HTTP_CLIENT.request(
                url=url,
                auth=auth,
                method=method,
                params=params,
                headers=headers,
                content=content,
            )
            response.raise_for_status()
        except httpx.HTTPStatusError as e:
            # Only retry on 5xx server errors
            if e.response.status_code >= 500 and attempt < max_retries - 1:
                # Exponential backoff: 0.5s, 1s, 2s
                await asyncio.sleep(INITIAL_RETRY_DELAY * (2**attempt))
                continue
            # Re-raise for 4xx errors or if max retries reached
            raise
        except httpx.RequestError as e:
            # Don't retry request errors (network issues are handled by transport)
            raise
        else:
            return response

    # This should never be reached, but satisfies type checker
    raise httpx.RequestError("Max retries exceeded")  # noqa: TRY003


@tool(requires_auth=Hubspot(scopes=["oauth"]))
async def list_event_types(
    context: ToolContext,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get-/events/v3/events/event-types_getTypes'."
]:
    """Retrieve a list of visible event type names.

    This tool retrieves a list of event type names that are visible to the user, which can be used to query specific event instances."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.hubapi.com/events/v3/events/event-types",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=Hubspot(scopes=["behavioral_events.event_definitions.read_write"]))
async def retrieve_custom_event_definitions(
    context: ToolContext,
    event_name_search_string: Annotated[
        str | None,
        "String of characters to search for in event names. This is a simple 'contains' search without fuzzy matching.",  # noqa: E501
    ] = None,
    include_event_properties: Annotated[
        bool | None,
        "Include event properties in the response. Set to true to include all properties.",
    ] = None,
    paging_cursor_token: Annotated[
        str | None,
        "The token indicating the position after the last successfully read resource for continued paged results.",  # noqa: E501
    ] = None,
    results_per_page_limit: Annotated[
        int | None, "The maximum number of event definitions to retrieve per page."
    ] = None,
    sort_order: Annotated[
        str | None,
        "Specify the order to sort results. Use 'ASC' for ascending or 'DESC' for descending.",
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get-/events/v3/event-definitions'."
]:
    """Retrieve existing custom event definitions from Hubspot.

    Use this tool to obtain the current list of custom event definitions stored in Hubspot. It helps in understanding or displaying existing events configured within your system."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.hubapi.com/events/v3/event-definitions",
        method="GET",
        params=remove_none_values({
            "searchString": event_name_search_string,
            "after": paging_cursor_token,
            "limit": results_per_page_limit,
            "includeProperties": include_event_properties,
            "sortOrder": sort_order,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=Hubspot(scopes=["behavioral_events.event_definitions.read_write"]))
async def fetch_event_definition_by_name(
    context: ToolContext,
    event_name: Annotated[str, "The internal name of the custom event to fetch its definition."],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get-/events/v3/event-definitions/{eventName}'."
]:
    """Fetch details of a custom event definition by name.

    Use this tool to retrieve the definition and details of a specific custom event by providing its name."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.hubapi.com/events/v3/event-definitions/{eventName}".format(  # noqa: UP032
            eventName=event_name
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=Hubspot(scopes=["behavioral_events.event_definitions.read_write"]))
async def delete_custom_event_definition(
    context: ToolContext,
    event_name: Annotated[str, "The name of the custom event definition to delete."],
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'delete-/events/v3/event-definitions/{eventName}'.",
]:
    """Delete a custom event definition by name.

    Use this tool to delete a specified custom event definition in HubSpot by providing the event name. It is useful for managing and organizing event definitions that are no longer needed."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.hubapi.com/events/v3/event-definitions/{eventName}".format(  # noqa: UP032
            eventName=event_name
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=Hubspot(scopes=["behavioral_events.event_definitions.read_write"]))
async def update_custom_event_definition(
    context: ToolContext,
    internal_event_name: Annotated[
        str, "The internal name of the custom event to be updated in Hubspot."
    ],
    event_description: Annotated[
        str | None,
        "Provide a description for the custom event to be displayed as help text in HubSpot.",
    ] = None,
    event_label: Annotated[
        str | None, "The human-readable label for the event, used in the HubSpot UI."
    ] = None,
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'patch-/events/v3/event-definitions/{eventName}'.",
]:
    """Update a specific custom event definition by name.

    Use this tool to update the definition of a specific custom event in Hubspot by specifying the event name."""  # noqa: E501
    request_data: Any = {"description": event_description, "label": event_label}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.hubapi.com/events/v3/event-definitions/{eventName}".format(  # noqa: UP032
            eventName=internal_event_name
        ),
        method="PATCH",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=Hubspot(scopes=["behavioral_events.event_definitions.read_write"]))
async def delete_custom_event_property(
    context: ToolContext,
    custom_event_internal_name: Annotated[
        str, "The internal name of the custom event from which the property will be deleted."
    ],
    property_internal_name: Annotated[
        str, "The internal name of the property to delete from the custom event."
    ],
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'delete-/events/v3/event-definitions/{eventName}/property/{propertyName}'.",  # noqa: E501
]:
    """Delete a property from a custom event definition.

    Use this tool to remove an existing property from a specific custom event definition in Hubspot."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.hubapi.com/events/v3/event-definitions/{eventName}/property/{propertyName}".format(  # noqa: UP032
            eventName=custom_event_internal_name, propertyName=property_internal_name
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}
