import collections.abc
import typing
from typing import ClassVar, overload

import numpy
import numpy.typing

ArgaezTapia: MeritFcn
LineSearch: SearchStrategy
NormFmu: MeritFcn
TrustPDS: SearchStrategy
TrustRegion: SearchStrategy
VanShanno: MeritFcn

class BoundConstraint(ConstraintBase):
    def __init__(self, *args, **kwargs) -> None: ...
    @staticmethod
    def create(
        nc: typing.SupportsInt, A: SerialDenseVector, rhs: SerialDenseVector
    ) -> BoundConstraint: ...

class CompoundConstraint:
    def __init__(self, *args, **kwargs) -> None: ...

class Constraint:
    def __init__(self, *args, **kwargs) -> None: ...

class ConstraintBase:
    def __init__(self, *args, **kwargs) -> None: ...
    @staticmethod
    def delete(arg0: ConstraintBase) -> None: ...

class LinearConstraint(ConstraintBase):
    def __init__(self, *args, **kwargs) -> None: ...

class LinearEquation(LinearConstraint):
    def __init__(self, *args, **kwargs) -> None: ...
    @staticmethod
    def create(A: SerialDenseMatrix, rhs: SerialDenseVector) -> LinearEquation: ...

class LinearInequality(LinearConstraint):
    def __init__(self, *args, **kwargs) -> None: ...
    @staticmethod
    def create(
        A: SerialDenseMatrix, lower: SerialDenseVector, upper: SerialDenseVector
    ) -> LinearInequality: ...

class MeritFcn:
    __members__: ClassVar[dict] = ...  # read-only
    ArgaezTapia: ClassVar[MeritFcn] = ...
    NormFmu: ClassVar[MeritFcn] = ...
    VanShanno: ClassVar[MeritFcn] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: typing.SupportsInt) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class NLF1(NLPBase):
    def __init__(self, *args, **kwargs) -> None: ...
    @staticmethod
    def create(
        ndim: typing.SupportsInt,
        eval_f: collections.abc.Callable,
        eval_g: collections.abc.Callable,
        x0: SerialDenseVector,
    ) -> NLF1: ...
    @staticmethod
    def create_constrained(
        ndim: typing.SupportsInt,
        eval_cf: collections.abc.Callable,
        eval_cg: collections.abc.Callable,
        x0: SerialDenseVector,
    ) -> NLF1: ...
    def getF(self) -> float: ...
    def getXc(self) -> SerialDenseVector: ...
    def setConstraints(self, compound_constraint) -> None: ...

class NLP:
    def __init__(self, *args, **kwargs) -> None: ...
    @staticmethod
    def create(nlp: NLPBase) -> NLP: ...

class NLPBase:
    def __init__(self, *args, **kwargs) -> None: ...

class NonLinearConstraint(ConstraintBase):
    def __init__(self, *args, **kwargs) -> None: ...

class NonLinearEquation(NonLinearConstraint):
    def __init__(self, *args, **kwargs) -> None: ...
    @staticmethod
    def create(
        nlprob: NLP, rhs: SerialDenseVector, numconstraints: typing.SupportsInt = ...
    ) -> NonLinearEquation: ...

class NonLinearInequality(NonLinearConstraint):
    def __init__(self, *args, **kwargs) -> None: ...
    @staticmethod
    def create(
        nlprob: NLP,
        lower: SerialDenseVector,
        upper: SerialDenseVector,
        numconstraints: typing.SupportsInt = ...,
    ) -> NonLinearInequality: ...

class OptQNIPS:
    def __init__(self, p: NLF1) -> None: ...
    def cleanup(self) -> None: ...
    def optimize(self) -> None: ...
    def setDebug(self) -> None: ...
    def setOutputFile(self, filename: str, mode: typing.SupportsInt = ...) -> int: ...
    def setSearchStrategy(self, s: SearchStrategy) -> None: ...
    def setSearchSize(self, search_pattern_size: typing.SupportsInt) -> None: ...
    def setTRSize(self, size: typing.SupportsFloat) -> None: ...
    def setGradMult(self, gradient_multiplier: typing.SupportsFloat) -> None: ...
    def setMaxIter(self, max_iterations: typing.SupportsInt) -> None: ...
    def setMaxFeval(self, max_function_evaluations: typing.SupportsInt) -> None: ...
    def setFcnTol(self, convergence_tolerance: typing.SupportsFloat) -> None: ...
    def setGradTol(self, gradient_tolerance: typing.SupportsFloat) -> None: ...
    def setConTol(self, constraint_tolerance: typing.SupportsFloat) -> None: ...
    def setMeritFcn(self, merit_function: MeritFcn) -> None: ...
    def setCenteringParameter(self, sigma: typing.SupportsFloat) -> None: ...
    def setMu(self, mu: typing.SupportsFloat) -> None: ...
    def setStepLengthToBdry(self, tau: typing.SupportsFloat) -> None: ...

class OptQNewton:
    def __init__(self, p: NLF1) -> None: ...
    def cleanup(self) -> None: ...
    def optimize(self) -> None: ...
    def setDebug(self) -> None: ...
    def setOutputFile(self, filename: str, mode: typing.SupportsInt = ...) -> int: ...
    def setSearchStrategy(self, s: SearchStrategy) -> None: ...
    def setSearchSize(self, search_pattern_size: typing.SupportsInt) -> None: ...
    def setTRSize(self, size: typing.SupportsFloat) -> None: ...
    def setGradMult(self, gradient_multiplier: typing.SupportsFloat) -> None: ...
    def setMaxIter(self, max_iterations: typing.SupportsInt) -> None: ...
    def setMaxFeval(self, max_function_evaluations: typing.SupportsInt) -> None: ...
    def setFcnTol(self, convergence_tolerance: typing.SupportsFloat) -> None: ...
    def setGradTol(self, gradient_tolerance: typing.SupportsFloat) -> None: ...

class OptBCQNewton:
    def __init__(self, p: NLF1) -> None: ...
    def cleanup(self) -> None: ...
    def optimize(self) -> None: ...
    def setDebug(self) -> None: ...
    def setOutputFile(self, filename: str, mode: typing.SupportsInt = ...) -> int: ...
    def setSearchStrategy(self, s: SearchStrategy) -> None: ...
    def setSearchSize(self, search_pattern_size: typing.SupportsInt) -> None: ...
    def setTRSize(self, size: typing.SupportsFloat) -> None: ...
    def setGradMult(self, gradient_multiplier: typing.SupportsFloat) -> None: ...
    def setMaxIter(self, max_iterations: typing.SupportsInt) -> None: ...
    def setMaxFeval(self, max_function_evaluations: typing.SupportsInt) -> None: ...
    def setFcnTol(self, convergence_tolerance: typing.SupportsFloat) -> None: ...
    def setGradTol(self, gradient_tolerance: typing.SupportsFloat) -> None: ...

class SearchStrategy:
    __members__: ClassVar[dict] = ...  # read-only
    LineSearch: ClassVar[SearchStrategy] = ...
    TrustPDS: ClassVar[SearchStrategy] = ...
    TrustRegion: ClassVar[SearchStrategy] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: typing.SupportsInt) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class SerialDenseMatrix:
    def __init__(
        self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64]
    ) -> None: ...
    def __buffer__(self, *args, **kwargs): ...
    def __release_buffer__(self, *args, **kwargs): ...

class SerialDenseVector:
    @overload
    def __init__(self, arg0: typing.SupportsInt) -> None: ...
    @overload
    def __init__(
        self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64]
    ) -> None: ...
    def size(self) -> int: ...
    def to_numpy(self) -> numpy.typing.NDArray[numpy.float64]: ...
    def __buffer__(self, *args, **kwargs): ...
    def __getitem__(self, arg0: typing.SupportsInt) -> float: ...
    def __len__(self) -> int: ...
    def __release_buffer__(self, *args, **kwargs): ...
    def __setitem__(
        self, arg0: typing.SupportsInt, arg1: typing.SupportsFloat
    ) -> None: ...

class SerialSymDenseMatrix:
    def __init__(self, *args, **kwargs) -> None: ...

def create_compound_constraint(
    constraints: collections.abc.Sequence[ConstraintBase],
) -> CompoundConstraint: ...
