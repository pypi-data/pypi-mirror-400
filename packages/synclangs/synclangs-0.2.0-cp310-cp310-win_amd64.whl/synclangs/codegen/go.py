"""Go code generator for SyncLangs types."""

from __future__ import annotations


from synclangs.codegen.base import CodeGenerator
from synclangs.parser.ast import (
    ConstDef,
    ConstValue,
    EnumDef,
    FunctionDef,
    InterfaceDef,
    ListTypeExpr,
    MapTypeExpr,
    Module,
    NullableTypeExpr,
    PrimitiveType,
    PrimitiveTypeExpr,
    TypeDef,
    TypeExpr,
    TypeRef,
    VoidType,
)


class GoGenerator(CodeGenerator):
    """Generate Go structs from SyncLangs AST."""

    def __init__(
        self,
        file_extension: str = ".go",
        package_name: str = "types",
    ) -> None:
        self._file_extension = file_extension
        self._package_name = package_name

    def generate(self, module: Module) -> str:
        """Generate Go source code for a module."""
        lines: list[str] = [
            "// Auto-generated by SyncLangs - DO NOT EDIT",
            "",
            f"package {self._package_name}",
            "",
        ]

        # Collect imports needed
        go_imports = self._collect_imports(module)
        if go_imports:
            if len(go_imports) == 1:
                lines.append(f'import "{list(go_imports)[0]}"')
            else:
                lines.append("import (")
                for imp in sorted(go_imports):
                    lines.append(f'\t"{imp}"')
                lines.append(")")
            lines.append("")

        # Generate constants first
        if module.constants:
            lines.append("const (")
            for const_def in module.constants:
                lines.extend(self._generate_constant(const_def))
            lines.append(")")
            lines.append("")

        # Generate enums as type aliases with const blocks
        for enum_def in module.enums:
            lines.extend(self._generate_enum(enum_def))
            lines.append("")

        # Generate structs (types with optional embedding for inheritance)
        for type_def in module.types:
            lines.extend(self._generate_type(type_def))
            lines.append("")

        # Generate interface definitions
        for interface_def in module.interfaces:
            lines.extend(self._generate_interface(interface_def))
            lines.append("")

        # Generate function types
        for fn_def in module.functions:
            lines.extend(self._generate_function_type(fn_def))
            lines.append("")

        return "\n".join(lines).rstrip() + "\n"

    def _generate_type(self, type_def: TypeDef) -> list[str]:
        """Generate a Go struct for a type definition."""
        lines: list[str] = []
        if type_def.doc_comment:
            lines.extend(self._format_go_comment(type_def.doc_comment, ""))
        lines.append(f"type {type_def.name} struct {{")

        # Embed base type if extends is specified (Go composition)
        if type_def.extends:
            lines.append(f"\t{type_def.extends}")

        for field in type_def.fields:
            if field.doc_comment:
                lines.extend(self._format_go_comment(field.doc_comment, "\t"))
            go_field_name = self._to_pascal_case(field.name)
            go_type, is_optional = self._field_type(field.type_expr)
            json_tag = self._json_tag(field.name, is_optional)
            lines.append(f"\t{go_field_name} {go_type} `json:{json_tag}`")
        lines.append("}")
        return lines

    def _generate_interface(self, interface_def: InterfaceDef) -> list[str]:
        """Generate a Go interface definition."""
        lines: list[str] = []
        if interface_def.doc_comment:
            lines.extend(self._format_go_comment(interface_def.doc_comment, ""))
        lines.append(f"type {interface_def.name} interface {{")

        # Generate method signatures
        for fn_def in interface_def.functions:
            if fn_def.doc_comment:
                lines.extend(self._format_go_comment(fn_def.doc_comment, "\t"))
            signature = self._function_signature(fn_def)
            lines.append(f"\t{signature}")

        lines.append("}")
        return lines

    def _generate_function_type(self, fn_def: FunctionDef) -> list[str]:
        """Generate a Go function type alias."""
        lines: list[str] = []
        if fn_def.doc_comment:
            lines.extend(self._format_go_comment(fn_def.doc_comment, ""))

        # Build parameter list
        params = ", ".join(
            f"{p.name} {self._type_to_go(p.type_expr)}"
            for p in fn_def.params
        )

        # Build return type
        return_type = self._return_type_to_go(fn_def.return_type)

        type_name = f"{fn_def.name[0].upper()}{fn_def.name[1:]}Fn"
        if return_type:
            lines.append(f"type {type_name} func({params}) {return_type}")
        else:
            lines.append(f"type {type_name} func({params})")
        return lines

    def _function_signature(self, fn_def: FunctionDef) -> str:
        """Generate a Go method signature for an interface."""
        # Build parameter list
        params = ", ".join(
            f"{p.name} {self._type_to_go(p.type_expr)}"
            for p in fn_def.params
        )

        # Build return type
        return_type = self._return_type_to_go(fn_def.return_type)

        method_name = self._to_pascal_case(fn_def.name)
        if return_type:
            return f"{method_name}({params}) {return_type}"
        return f"{method_name}({params})"

    def _return_type_to_go(self, return_type: TypeExpr | VoidType) -> str:
        """Convert a return type to Go."""
        if isinstance(return_type, VoidType):
            return ""  # Go has no return type for void functions
        return self._type_to_go(return_type)

    def _collect_imports(self, module: Module) -> set[str]:
        """Collect Go imports needed for the module."""
        imports: set[str] = set()
        # We don't need any standard library imports for basic types
        # If we used time.Time for timestamps, we'd add "time" here
        return imports

    def _generate_constant(self, const_def: ConstDef) -> list[str]:
        """Generate a Go constant definition."""
        lines: list[str] = []
        if const_def.doc_comment:
            lines.extend(self._format_go_comment(const_def.doc_comment, "\t"))
        go_type = self._type_to_go(const_def.type_expr)
        value = self._const_value_to_go(const_def.value)
        lines.append(f"\t{const_def.name} {go_type} = {value}")
        return lines

    def _generate_enum(self, enum_def: EnumDef) -> list[str]:
        """Generate a Go enum as type alias with const block."""
        lines: list[str] = []
        if enum_def.doc_comment:
            lines.extend(self._format_go_comment(enum_def.doc_comment, ""))
        lines.append(f"type {enum_def.name} string")
        lines.append("")
        lines.append("const (")
        for variant in enum_def.variants:
            if variant.doc_comment:
                lines.extend(self._format_go_comment(variant.doc_comment, "\t"))
            const_name = f"{enum_def.name}{variant.name}"
            lines.append(f'\t{const_name} {enum_def.name} = "{variant.name}"')
        lines.append(")")
        return lines

    def _const_value_to_go(self, value: ConstValue) -> str:
        """Convert a constant value to Go literal."""
        if isinstance(value.value, str):
            return f'"{value.value}"'
        if isinstance(value.value, bool):
            return "true" if value.value else "false"
        return str(value.value)

    def _field_type(self, type_expr: TypeExpr) -> tuple[str, bool]:
        """Return the Go type and optional flag for a field."""
        if isinstance(type_expr, NullableTypeExpr):
            inner_type = self._type_to_go(type_expr.inner_type)
            return f"*{inner_type}", True
        return self._type_to_go(type_expr), False

    def _type_to_go(self, type_expr: TypeExpr) -> str:
        """Convert a type expression to a Go type."""
        if isinstance(type_expr, PrimitiveTypeExpr):
            return self._primitive_to_go(type_expr.primitive)
        if isinstance(type_expr, ListTypeExpr):
            inner = self._type_to_go(type_expr.element_type)
            return f"[]{inner}"
        if isinstance(type_expr, MapTypeExpr):
            key = self._type_to_go(type_expr.key_type)
            value = self._type_to_go(type_expr.value_type)
            return f"map[{key}]{value}"
        if isinstance(type_expr, NullableTypeExpr):
            inner = self._type_to_go(type_expr.inner_type)
            return f"*{inner}"
        if isinstance(type_expr, TypeRef):
            return type_expr.name
        raise TypeError(f"Unsupported type expression: {type_expr}")

    def _primitive_to_go(self, primitive: PrimitiveType) -> str:
        """Map primitive SyncLangs types to Go types."""
        mapping = {
            PrimitiveType.STRING: "string",
            PrimitiveType.INT: "int64",
            PrimitiveType.FLOAT: "float64",
            PrimitiveType.BOOL: "bool",
            PrimitiveType.ANY: "interface{}",
        }
        return mapping[primitive]

    def _json_tag(self, field_name: str, omitempty: bool = False) -> str:
        """Generate a JSON struct tag for a field."""
        json_name = self._to_camel_case(field_name)
        if omitempty:
            return f'"{json_name},omitempty"'
        return f'"{json_name}"'

    def _to_pascal_case(self, name: str) -> str:
        """Convert a name to PascalCase (Go public field naming)."""
        # Handle camelCase -> PascalCase
        if name and name[0].islower():
            return name[0].upper() + name[1:]
        return name

    def _to_camel_case(self, name: str) -> str:
        """Ensure field name is in camelCase for JSON tags."""
        # Handle PascalCase -> camelCase
        if name and name[0].isupper():
            return name[0].lower() + name[1:]
        return name

    def _format_go_comment(self, text: str, indent: str) -> list[str]:
        """Format a Go comment with the provided indentation."""
        lines = text.splitlines()
        return [f"{indent}// {line}" for line in lines]
