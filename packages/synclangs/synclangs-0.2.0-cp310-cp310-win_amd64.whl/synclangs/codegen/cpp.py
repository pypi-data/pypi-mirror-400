"""C++ code generator for SyncLangs types."""

from __future__ import annotations

import re

from synclangs.codegen.base import CodeGenerator
from synclangs.parser.ast import (
    ConstDef,
    ConstValue,
    EnumDef,
    FunctionDef,
    InterfaceDef,
    ListTypeExpr,
    MapTypeExpr,
    Module,
    NullableTypeExpr,
    PrimitiveType,
    PrimitiveTypeExpr,
    TypeDef,
    TypeExpr,
    TypeRef,
    VoidType,
)


class CppGenerator(CodeGenerator):
    """Generate C++ structs from SyncLangs AST."""

    def __init__(
        self,
        file_extension: str = ".hpp",
        namespace_name: str = "types",
    ) -> None:
        self._file_extension = file_extension
        self._namespace_name = namespace_name

    def generate(self, module: Module) -> str:
        """Generate C++ source code for a module."""
        # Generate header guard from namespace
        guard_name = f"SYNCLANGS_{self._namespace_name.upper()}_HPP"
        
        lines: list[str] = [
            "// Auto-generated by SyncLangs - DO NOT EDIT",
            "",
            f"#ifndef {guard_name}",
            f"#define {guard_name}",
            "",
        ]

        # Collect includes needed
        cpp_includes = self._collect_includes(module)
        for inc in sorted(cpp_includes):
            lines.append(f"#include <{inc}>")
        if cpp_includes:
            lines.append("")

        # Open namespace
        lines.append(f"namespace {self._namespace_name} {{")
        lines.append("")

        # Generate constants
        for const_def in module.constants:
            lines.extend(self._generate_constant(const_def))
        if module.constants:
            lines.append("")

        # Generate forward declarations for types
        if module.types:
            for type_def in module.types:
                lines.append(f"struct {type_def.name};")
            lines.append("")

        # Generate enums
        for enum_def in module.enums:
            lines.extend(self._generate_enum(enum_def))
            lines.append("")

        # Generate structs for types
        for type_def in module.types:
            lines.extend(self._generate_type(type_def))
            lines.append("")

        # Generate abstract classes for interfaces
        for interface_def in module.interfaces:
            lines.extend(self._generate_interface(interface_def))
            lines.append("")

        # Generate function type aliases
        for fn_def in module.functions:
            lines.extend(self._generate_function_type(fn_def))
            lines.append("")

        # Close namespace
        lines.append(f"}} // namespace {self._namespace_name}")
        lines.append("")
        lines.append(f"#endif // {guard_name}")

        return "\n".join(lines).rstrip() + "\n"

    def _generate_type(self, type_def: TypeDef) -> list[str]:
        """Generate a C++ struct for a type definition."""
        lines: list[str] = []
        if type_def.doc_comment:
            lines.extend(self._format_doxygen(type_def.doc_comment, ""))

        # Build inheritance
        inheritance = ""
        if type_def.extends:
            inheritance = f" : public {type_def.extends}"

        lines.append(f"struct {type_def.name}{inheritance} {{")

        for field in type_def.fields:
            if field.doc_comment:
                lines.extend(self._format_doxygen(field.doc_comment, "    "))
            cpp_type = self._type_to_cpp(field.type_expr)
            cpp_field_name = self._to_snake_case(field.name)
            lines.append(f"    {cpp_type} {cpp_field_name};")

        lines.append("};")
        return lines

    def _generate_interface(self, interface_def: InterfaceDef) -> list[str]:
        """Generate a C++ abstract class for an interface."""
        lines: list[str] = []
        if interface_def.doc_comment:
            lines.extend(self._format_doxygen(interface_def.doc_comment, ""))
        lines.append(f"class {interface_def.name} {{")
        lines.append("public:")
        
        # Virtual destructor
        lines.append(f"    virtual ~{interface_def.name}() = default;")
        lines.append("")

        # Generate pure virtual methods
        for fn_def in interface_def.functions:
            if fn_def.doc_comment:
                lines.extend(self._format_doxygen(fn_def.doc_comment, "    "))
            signature = self._function_signature(fn_def, is_pure_virtual=True)
            lines.append(f"    {signature}")

        lines.append("};")
        return lines

    def _generate_function_type(self, fn_def: FunctionDef) -> list[str]:
        """Generate a C++ function type alias using std::function."""
        lines: list[str] = []
        if fn_def.doc_comment:
            lines.extend(self._format_doxygen(fn_def.doc_comment, ""))

        # Build parameter types
        param_types = ", ".join(
            self._type_to_cpp(p.type_expr) for p in fn_def.params
        )

        return_type = self._return_type_to_cpp(fn_def.return_type)
        
        type_name = f"{fn_def.name[0].upper()}{fn_def.name[1:]}Fn"
        lines.append(f"using {type_name} = std::function<{return_type}({param_types})>;")
        return lines

    def _function_signature(self, fn_def: FunctionDef, is_pure_virtual: bool = False) -> str:
        """Generate a C++ method signature."""
        params = ", ".join(
            f"{self._type_to_cpp(p.type_expr)} {self._to_snake_case(p.name)}"
            for p in fn_def.params
        )

        return_type = self._return_type_to_cpp(fn_def.return_type)
        fn_name = self._to_snake_case(fn_def.name)

        if is_pure_virtual:
            return f"virtual {return_type} {fn_name}({params}) = 0;"
        return f"{return_type} {fn_name}({params});"

    def _return_type_to_cpp(self, return_type: TypeExpr | VoidType) -> str:
        """Convert a return type to C++."""
        if isinstance(return_type, VoidType):
            return "void"
        return self._type_to_cpp(return_type)

    def _collect_includes(self, module: Module) -> set[str]:
        """Collect C++ includes needed for the module."""
        includes: set[str] = set()
        includes.add("string")  # Almost always needed

        for type_def in module.types:
            for field in type_def.fields:
                self._collect_type_includes(field.type_expr, includes)

        for interface_def in module.interfaces:
            for fn_def in interface_def.functions:
                for param in fn_def.params:
                    self._collect_type_includes(param.type_expr, includes)
                if not isinstance(fn_def.return_type, VoidType):
                    self._collect_type_includes(fn_def.return_type, includes)

        for fn_def in module.functions:
            includes.add("functional")
            for param in fn_def.params:
                self._collect_type_includes(param.type_expr, includes)
            if not isinstance(fn_def.return_type, VoidType):
                self._collect_type_includes(fn_def.return_type, includes)

        return includes

    def _collect_type_includes(self, type_expr: TypeExpr, includes: set[str]) -> None:
        """Collect includes for a type expression."""
        if isinstance(type_expr, ListTypeExpr):
            includes.add("vector")
            self._collect_type_includes(type_expr.element_type, includes)
        elif isinstance(type_expr, MapTypeExpr):
            includes.add("unordered_map")
            self._collect_type_includes(type_expr.key_type, includes)
            self._collect_type_includes(type_expr.value_type, includes)
        elif isinstance(type_expr, NullableTypeExpr):
            includes.add("optional")
            self._collect_type_includes(type_expr.inner_type, includes)
        elif isinstance(type_expr, PrimitiveTypeExpr):
            if type_expr.primitive == PrimitiveType.ANY:
                includes.add("any")
            elif type_expr.primitive == PrimitiveType.INT:
                includes.add("cstdint")

    def _generate_constant(self, const_def: ConstDef) -> list[str]:
        """Generate a C++ constant definition."""
        lines: list[str] = []
        if const_def.doc_comment:
            lines.extend(self._format_doxygen(const_def.doc_comment, ""))
        cpp_type = self._type_to_cpp(const_def.type_expr)
        value = self._const_value_to_cpp(const_def.value)
        
        # Use constexpr for compile-time constants, const for strings
        if cpp_type == "std::string":
            lines.append(f'inline const {cpp_type} {const_def.name} = {value};')
        else:
            lines.append(f"constexpr {cpp_type} {const_def.name} = {value};")
        return lines

    def _generate_enum(self, enum_def: EnumDef) -> list[str]:
        """Generate a C++ enum class."""
        lines: list[str] = []
        if enum_def.doc_comment:
            lines.extend(self._format_doxygen(enum_def.doc_comment, ""))
        lines.append(f"enum class {enum_def.name} {{")
        
        for i, variant in enumerate(enum_def.variants):
            if variant.doc_comment:
                lines.extend(self._format_doxygen(variant.doc_comment, "    "))
            comma = "," if i < len(enum_def.variants) - 1 else ""
            lines.append(f"    {variant.name}{comma}")
        
        lines.append("};")
        return lines

    def _const_value_to_cpp(self, value: ConstValue) -> str:
        """Convert a constant value to C++ literal."""
        if isinstance(value.value, str):
            return f'"{value.value}"'
        if isinstance(value.value, bool):
            return "true" if value.value else "false"
        return str(value.value)

    def _type_to_cpp(self, type_expr: TypeExpr) -> str:
        """Convert a type expression to a C++ type."""
        if isinstance(type_expr, PrimitiveTypeExpr):
            return self._primitive_to_cpp(type_expr.primitive)
        if isinstance(type_expr, ListTypeExpr):
            inner = self._type_to_cpp(type_expr.element_type)
            return f"std::vector<{inner}>"
        if isinstance(type_expr, MapTypeExpr):
            key = self._type_to_cpp(type_expr.key_type)
            value = self._type_to_cpp(type_expr.value_type)
            return f"std::unordered_map<{key}, {value}>"
        if isinstance(type_expr, NullableTypeExpr):
            inner = self._type_to_cpp(type_expr.inner_type)
            return f"std::optional<{inner}>"
        if isinstance(type_expr, TypeRef):
            return type_expr.name
        raise TypeError(f"Unsupported type expression: {type_expr}")

    def _primitive_to_cpp(self, primitive: PrimitiveType) -> str:
        """Map primitive SyncLangs types to C++ types."""
        mapping = {
            PrimitiveType.STRING: "std::string",
            PrimitiveType.INT: "int64_t",
            PrimitiveType.FLOAT: "double",
            PrimitiveType.BOOL: "bool",
            PrimitiveType.ANY: "std::any",
        }
        return mapping[primitive]

    def _to_snake_case(self, name: str) -> str:
        """Convert a camelCase name to snake_case."""
        result = re.sub(r'([A-Z])', r'_\1', name).lower()
        if result.startswith('_'):
            result = result[1:]
        return result

    def _format_doxygen(self, text: str, indent: str) -> list[str]:
        """Format a Doxygen comment with the provided indentation."""
        lines = text.splitlines()
        if len(lines) == 1:
            return [f"{indent}/// {lines[0]}"]
        formatted = [f"{indent}/**"]
        formatted.extend(f"{indent} * {line}" for line in lines)
        formatted.append(f"{indent} */")
        return formatted
