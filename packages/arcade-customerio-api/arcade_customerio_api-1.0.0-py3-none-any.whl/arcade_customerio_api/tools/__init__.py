"""Arcade Starter Tools for Customerio

DO NOT EDIT THIS MODULE DIRECTLY.

THIS MODULE WAS AUTO-GENERATED BY TRANSPILING THE API STARTER TOOL JSON DEFINITIONS
IN THE ../wrapper_tools DIRECTORY INTO PYTHON CODE. ANY CHANGES TO THIS MODULE WILL
BE OVERWRITTEN BY THE TRANSPILER.
"""

import asyncio
import json
from enum import Enum
from typing import Annotated, Any

import httpx
import jsonschema
from arcade_tdk import ToolContext, tool
from arcade_tdk.errors import RetryableToolError

from .request_body_schemas import REQUEST_BODY_SCHEMAS

# Retry configuration
INITIAL_RETRY_DELAY = 0.5  # seconds

HTTP_CLIENT = httpx.AsyncClient(
    timeout=httpx.Timeout(60.0, connect=10.0),
    limits=httpx.Limits(max_keepalive_connections=20, max_connections=100),
    transport=httpx.AsyncHTTPTransport(retries=3),
    http2=True,
    follow_redirects=True,
)


class ToolMode(str, Enum):
    """Mode for tools with complex request bodies."""

    GET_REQUEST_SCHEMA = "get_request_schema"
    EXECUTE = "execute"


def remove_none_values(data: dict[str, Any]) -> dict[str, Any]:
    return {k: v for k, v in data.items() if v is not None}


async def make_request(
    url: str,
    method: str,
    params: dict[str, Any] | None = None,
    headers: dict[str, Any] | None = None,
    content: str | None = None,
    data: dict[str, Any] | None = None,
    auth: tuple[str, str] | None = None,
    max_retries: int = 3,
) -> httpx.Response:
    """Make an HTTP request with retry logic for 5xx server errors."""
    for attempt in range(max_retries):
        try:
            response = await HTTP_CLIENT.request(
                url=url,
                auth=auth,
                method=method,
                params=params,
                headers=headers,
                content=content,
            )
            response.raise_for_status()
        except httpx.HTTPStatusError as e:
            # Only retry on 5xx server errors
            if e.response.status_code >= 500 and attempt < max_retries - 1:
                # Exponential backoff: 0.5s, 1s, 2s
                await asyncio.sleep(INITIAL_RETRY_DELAY * (2**attempt))
                continue
            # Re-raise for 4xx errors or if max retries reached
            raise
        except httpx.RequestError:
            # Don't retry request errors (network issues are handled by transport)
            raise
        else:
            return response

    # This should never be reached, but satisfies type checker
    raise httpx.RequestError("Max retries exceeded")  # noqa: TRY003


async def make_request_with_schema_validation(
    url: str,
    method: str,
    request_data: dict[str, Any],
    schema: dict[str, Any] | str,
    auth: tuple[str, str] | None = None,
    params: dict[str, Any] | None = None,
    headers: dict[str, Any] | None = None,
    max_retries: int = 3,
) -> httpx.Response:
    """Make an HTTP request with schema validation on format errors."""
    # Parse schema if it's a string, skip validation if parsing fails
    parsed_schema = None
    if isinstance(schema, str):
        try:
            parsed_schema = json.loads(schema)
        except Exception:
            # If schema parsing fails, just skip validation
            parsed_schema = None
    else:
        parsed_schema = schema

    try:
        response = await make_request(
            url=url,
            auth=auth,
            method=method,
            params=params,
            headers=headers,
            content=json.dumps(request_data),
            max_retries=max_retries,
        )
    except httpx.HTTPStatusError as e:
        # Only provide schema validation for format-related errors
        if e.response.status_code in (400, 422):
            api_error_details = f"API returned {e.response.status_code}: {e.response.text}"

            # Only run validation if we have a valid parsed schema
            if parsed_schema is not None:
                # Run validation to provide additional context
                is_valid, validation_error = validate_json_against_schema(
                    request_data, parsed_schema
                )

                if not is_valid:
                    # Schema validation found issues - additional context
                    additional_context = (
                        f"{api_error_details}\n\n"
                        f"Schema validation found the following issues:\n"
                        f"{validation_error}"
                    )
                else:
                    # Schema validation passed - just show API error
                    additional_context = api_error_details
            else:
                # No valid schema - just show API error
                additional_context = api_error_details

            raise RetryableToolError(
                message=(f"API request failed with validation error: {e.response.status_code}"),
                developer_message=api_error_details,
                additional_prompt_content=additional_context,
            ) from e
        else:
            # For non-validation errors, re-raise as-is
            raise
    else:
        return response


def validate_json_against_schema(
    json_data: dict[str, Any], schema: dict[str, Any]
) -> tuple[bool, str | None]:
    """Validate JSON data against an OpenAPI/JSON Schema.

    This provides full JSON Schema Draft 7 validation including:
    - Required fields, types, enums
    - Pattern validation (regex)
    - Format validation (email, uuid, date-time, etc.)
    - Min/max length and values
    - oneOf, anyOf, allOf
    - And all other JSON Schema features

    Args:
        json_data: The JSON data to validate
        schema: The JSON Schema to validate against

    Returns:
        Tuple of (is_valid, error_messages). If valid, error_messages is None.
        If invalid, error_messages contains all validation errors.
    """
    try:
        validator = jsonschema.Draft7Validator(
            schema, format_checker=jsonschema.Draft7Validator.FORMAT_CHECKER
        )
        # Collect ALL validation errors
        errors = list(validator.iter_errors(json_data))
        if errors:
            # Format all errors with their paths
            error_messages = []
            for error in errors:
                error_path = ".".join(str(p) for p in error.path) if error.path else "root"
                error_messages.append(f"{error.message} at {error_path}")
            # Join all errors with newlines
            return False, "\n".join(error_messages)
        else:
            return True, None
    except jsonschema.SchemaError as e:
        return False, f"Invalid schema: {e.message}"
    except Exception as e:
        return False, f"Validation error: {e!s}"


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def trigger_broadcast_message(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    broadcast_id: Annotated[
        int | None,
        "The unique ID of the broadcast campaign you want to trigger in Customerio. This ID is required to specify which broadcast to activate.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'triggerBroadcast'."]:
    """Trigger a broadcast to a specific audience using Customerio.

    This tool triggers a broadcast campaign in Customerio, allowing for message personalization via provided data. It should be called when you need to send messages to an audience already in your workspace, specified by a segment, email list, customer ID list, user map, or data file. It's important to handle existing users only, as the tool won't add or identify new users. Set flags to skip over non-existent users if needed. Designed for large audience message dispatch rather than individual interactions.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["TRIGGERBROADCASTMESSAGE"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not broadcast_id:
        missing_params.append(("broadcast_id", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(f"Required parameters validation failed: {param_details}"),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["TRIGGERBROADCASTMESSAGE"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["TRIGGERBROADCASTMESSAGE"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.customer.io/v1/campaigns/{broadcast_id}/triggers".format(  # noqa: UP032
            broadcast_id=broadcast_id
        ),
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["TRIGGERBROADCASTMESSAGE"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_broadcast_errors(
    context: ToolContext,
    broadcast_id: Annotated[
        int,
        "The ID of the broadcast to retrieve error information for. Use this to specify which broadcast's errors you want to investigate.",  # noqa: E501
    ],
    campaign_trigger_id: Annotated[
        int,
        "The ID of the campaign trigger to return information for. Use this to focus on specific trigger details.",  # noqa: E501
    ],
    page_start_token: Annotated[
        str | None,
        "Token to specify which page of results to return. Use the `next` value from responses to navigate pages.",  # noqa: E501
    ] = None,
    results_per_page: Annotated[
        int | None, "The maximum number of results to retrieve per page."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'broadcastErrors'."]:
    """Retrieve details of broadcast validation errors.

    This tool helps identify and understand validation errors in broadcast campaigns, focusing on issues within the broadcast audience and associated elements. Use it to diagnose and resolve broadcast errors."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/campaigns/{broadcast_id}/triggers/{trigger_id}/errors".format(  # noqa: UP032
            broadcast_id=broadcast_id, trigger_id=campaign_trigger_id
        ),
        method="GET",
        params=remove_none_values({"start": page_start_token, "limit": results_per_page}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def send_transactional_email(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'sendEmail'."]:
    """Send a customizable transactional email.

    Use this tool to send a transactional email using Customerio. You can utilize a `transactional_message_id` to specify a template or customize the email by providing `body`, `subject`, and `from` values. If a metrics association is needed, include the `transactional_message_id`. It's designed for sending personalized messages while tracking delivery metrics effectively.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["SENDTRANSACTIONALEMAIL"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["SENDTRANSACTIONALEMAIL"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["SENDTRANSACTIONALEMAIL"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.customer.io/v1/send/email",
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["SENDTRANSACTIONALEMAIL"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def send_transactional_push_notification(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'sendPush'."]:
    """Send a customized transactional push notification.

    This tool sends a transactional push notification using a specified message template from Customerio. You can override template values at send time using the `transactional_message_id`, which can be the numerical ID or the Trigger Name. Use this tool to send personalized push messages to users.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["SENDTRANSACTIONALPUSHNOTIFICATION"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["SENDTRANSACTIONALPUSHNOTIFICATION"]
                + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["SENDTRANSACTIONALPUSHNOTIFICATION"]
                + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.customer.io/v1/send/push",
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["SENDTRANSACTIONALPUSHNOTIFICATION"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def send_transactional_sms(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'sendSMS'."]:
    """Send a transactional SMS message using a template.

    Send a transactional SMS by providing a `transactional_message_id`, which can be the numerical ID or *Trigger Name* of your message template. This allows you to automate SMS communications using predefined templates.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["SENDTRANSACTIONALSMS"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["SENDTRANSACTIONALSMS"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["SENDTRANSACTIONALSMS"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.customer.io/v1/send/sms",
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["SENDTRANSACTIONALSMS"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_campaign_list(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listCampaigns'."]:
    """Retrieve a list of marketing campaigns.

    Use this tool to get a list of your marketing campaigns and their associated metadata. Ideal for reviewing, auditing, or managing your email campaigns."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/campaigns",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_campaign_metadata(
    context: ToolContext,
    campaign_id: Annotated[
        int, "The ID of the campaign for which metadata is requested. Provide a valid integer."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getCampaigns'."]:
    """Retrieve metadata for a specific campaign.

    Use this tool to get detailed metadata about an individual campaign by specifying the campaign ID."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/campaigns/{campaign_id}".format(campaign_id=campaign_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_campaign_metrics(
    context: ToolContext,
    campaign_id: Annotated[int, "The unique ID of the campaign to retrieve metrics for."],
    metrics_api_version: Annotated[
        str, "Specify the version of the metrics API to use. Recommended value is '2'."
    ],
    end_time_unix: Annotated[
        int | None,
        "Unix timestamp marking the end of the metrics period. Use only with version 2. Limited to 10 years from the start parameter.",  # noqa: E501
    ] = None,
    metrics_item_type: Annotated[
        str | None,
        "Specify the type of item for metrics: email, webhook, twilio, slack, push, in_app. Leave empty for all types.",  # noqa: E501
    ] = None,
    metrics_start_timestamp: Annotated[
        int | None, "Unix timestamp marking the start of the metrics period for version 2."
    ] = None,
    number_of_steps: Annotated[
        int | None,
        "(Version 1 only) The number of periods to return, with defaults and maximum limits based on the period unit (e.g., hours, days).",  # noqa: E501
    ] = None,
    resolution: Annotated[
        str | None,
        "Determines increment for metricsâ€”hourly, daily, weekly, or monthly. Only for Version 2.",
    ] = None,
    timezone_for_metrics: Annotated[
        str | None,
        "For version 2 only. Specify the time zone for the metrics requested. Defaults to EST if not provided. Use the region format.",  # noqa: E501
    ] = None,
    version_1_time_unit: Annotated[
        str | None,
        "For Version 1 only, specify the time unit for the report. Options include hours, days, weeks, or months.",  # noqa: E501
    ] = "days",
) -> Annotated[dict[str, Any], "Response from the API endpoint 'campaignMetrics'."]:
    """Fetch metrics for an individual campaign.

    Use this tool to retrieve a list of metrics for a specific campaign. It supports flexible time-based metrics by utilizing parameters like resolution, time zone, start, and end times. The recommended version 2 provides greater flexibility with these options. This tool is ideal for analyzing campaign performance over time."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/campaigns/{campaign_id}/metrics".format(  # noqa: UP032
            campaign_id=campaign_id
        ),
        method="GET",
        params=remove_none_values({
            "version": metrics_api_version,
            "type": metrics_item_type,
            "res": resolution,
            "tz": timezone_for_metrics,
            "start": metrics_start_timestamp,
            "end": end_time_unix,
            "period": version_1_time_unit,
            "steps": number_of_steps,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_campaign_link_metrics(
    context: ToolContext,
    campaign_identifier: Annotated[
        int,
        "The unique identifier for the campaign you want metrics for. Use this ID to specify the target campaign.",  # noqa: E501
    ],
    count_unique_customers: Annotated[
        bool | None,
        "Set to true to only include unique customer results. Set to false to count all clicks.",
    ] = False,
    number_of_periods: Annotated[
        int | None,
        "The number of periods to return metrics for. Defaults to the maximum available, or 12 if the period is in months. Maximums are 24 hours, 45 days, 12 weeks, or 121 months.",  # noqa: E501
    ] = None,
    report_time_unit: Annotated[
        str | None,
        "The unit of time for the report. Options are: 'hours', 'days', 'weeks', 'months'.",
    ] = "days",
) -> Annotated[dict[str, Any], "Response from the API endpoint 'campaignLinkMetrics'."]:
    """Get link click metrics for a campaign over specified periods.

    This tool fetches metrics for link clicks within a specified campaign, providing both total and period-specific data (like days or weeks). It's useful for analyzing campaign performance over time."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/campaigns/{campaign_id}/metrics/links".format(  # noqa: UP032
            campaign_id=campaign_identifier
        ),
        method="GET",
        params=remove_none_values({
            "period": report_time_unit,
            "steps": number_of_periods,
            "unique": count_unique_customers,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def list_campaign_actions(
    context: ToolContext,
    campaign_id: Annotated[
        int, "The ID of the campaign to retrieve workflow information for. Must be an integer."
    ],
    page_token: Annotated[
        str | None,
        "Token for the results page to return. Use 'next' from the response as this value for subsequent pages.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listCampaignActions'."]:
    """Retrieve operations in a campaign workflow.

    This tool retrieves the actions or 'tiles' in a campaign workflow, returning up to 10 actions per call. If more pages of results are available, a 'next' string is included, which can be used to access subsequent pages. Ideal for analyzing or modifying campaign workflows."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/campaigns/{campaign_id}/actions".format(  # noqa: UP032
            campaign_id=campaign_id
        ),
        method="GET",
        params=remove_none_values({"start": page_token}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_campaign_messages(
    context: ToolContext,
    campaign_id: Annotated[int, "The ID of the campaign to fetch message deliveries from."],
    beginning_timestamp: Annotated[
        int | None, "The starting timestamp for the query to filter messages from a specific time."
    ] = None,
    end_timestamp: Annotated[
        int | None,
        "The ending timestamp for your query to specify the end of the time range for retrieving message deliveries.",  # noqa: E501
    ] = None,
    message_type: Annotated[
        str | None,
        "Specify the type of item for metrics (e.g., email, webhook, slack, etc.). Defaults to all types if empty.",  # noqa: E501
    ] = None,
    metrics_to_return: Annotated[
        str | None,
        "Specify the metrics you want to retrieve, such as 'sent', 'opened', or 'clicked'.",
    ] = None,
    pagination_token: Annotated[
        str | None,
        "Token indicating the starting point for the page of results to return. Use the `next` property from previous responses.",  # noqa: E501
    ] = None,
    results_per_page: Annotated[
        int | None,
        "Specify the maximum number of results to retrieve per page. It determines the number of message deliveries returned in a single API response.",  # noqa: E501
    ] = 50,
    return_drafts: Annotated[
        bool | None, "Set to true to return drafts rather than active/sent messages."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getCampaignMessages'."]:
    """Retrieve message deliveries from a campaign.

    Fetch information on individual message deliveries from a specific campaign over a specified time range. Use parameters like `start_ts` and `end_ts` to refine the data to a specific period."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/campaigns/{campaign_id}/messages".format(  # noqa: UP032
            campaign_id=campaign_id
        ),
        method="GET",
        params=remove_none_values({
            "start": pagination_token,
            "limit": results_per_page,
            "type": message_type,
            "metric": metrics_to_return,
            "drafts": return_drafts,
            "start_ts": beginning_timestamp,
            "end_ts": end_timestamp,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_campaign_action_info(
    context: ToolContext,
    action_id: Annotated[
        int,
        "The identifier for the campaign action you want to look up or act on. Provide the integer ID of the action.",  # noqa: E501
    ],
    campaign_identifier: Annotated[
        int, "The unique ID of the campaign for retrieving specific action information."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getCampaignAction'."]:
    """Retrieve details for a specific action in a campaign.

    Use this tool to get detailed information about a specific action within a marketing campaign. It should be called when you need to understand the specifics of campaign actions such as type, status, or execution details."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/campaigns/{campaign_id}/actions/{action_id}".format(  # noqa: UP032
            campaign_id=campaign_identifier, action_id=action_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def update_campaign_action(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    campaign_id: Annotated[
        int | None,
        "The numeric ID of the specific campaign to update or retrieve information about.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    action_id: Annotated[
        int | None,
        "The identifier for the specific action within a campaign to be updated.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'updateCampaignAction'."]:
    """Update campaign action details and content.

    This tool updates the contents of a specific campaign action, allowing modifications to messages and HTTP requests. Use it to edit existing campaign steps.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["UPDATECAMPAIGNACTION"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not campaign_id:
        missing_params.append(("campaign_id", "path"))
    if not action_id:
        missing_params.append(("action_id", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(f"Required parameters validation failed: {param_details}"),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPDATECAMPAIGNACTION"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPDATECAMPAIGNACTION"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.customer.io/v1/campaigns/{campaign_id}/actions/{action_id}".format(  # noqa: UP032
            campaign_id=campaign_id, action_id=action_id
        ),
        method="PUT",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["UPDATECAMPAIGNACTION"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def translate_campaign_message(
    context: ToolContext,
    campaign_action_id: Annotated[
        int, "The ID of the action to look up or act on within the campaign."
    ],
    campaign_id: Annotated[
        int, "The numeric ID of the campaign to get information about or trigger."
    ],
    target_language: Annotated[
        str,
        "A language tag for the language variant to translate to. Defaults to the default language if empty. Returns an error if the variant doesn't exist.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getCampaignActionTranslation'."]:
    """Fetches a translated message for a specific campaign action.

    Returns a translated version of a message in a campaign using the action ID and specified language. Use when a translated version of a campaign message is needed."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/campaigns/{campaign_id}/actions/{action_id}/language/{language}".format(  # noqa: UP032
            campaign_id=campaign_id, action_id=campaign_action_id, language=target_language
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def update_campaign_action_translation(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    campaign_id: Annotated[
        int | None,
        "The ID of the campaign to update or retrieve information about.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    action_id: Annotated[
        int | None,
        "The ID of the action to look up or act on for the campaign.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    language_tag: Annotated[
        str | None,
        "The language tag for the campaign action variant. Use an empty string for the default language. If the variant doesn't exist, an error is returned.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'updateCampaignActionTranslation'."]:
    """Update a language variant of a campaign action.

    Use this tool to update the contents of a language variant for a specific campaign action, including the message body and HTTP requests.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["UPDATECAMPAIGNACTIONTRANSLATION"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not campaign_id:
        missing_params.append(("campaign_id", "path"))
    if not action_id:
        missing_params.append(("action_id", "path"))
    if not language_tag:
        missing_params.append(("language_tag", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(f"Required parameters validation failed: {param_details}"),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["UPDATECAMPAIGNACTIONTRANSLATION"]
                + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["UPDATECAMPAIGNACTIONTRANSLATION"]
                + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.customer.io/v1/campaigns/{campaign_id}/actions/{action_id}/language/{language}".format(  # noqa: UP032
            campaign_id=campaign_id, action_id=action_id, language=language_tag
        ),
        method="PUT",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["UPDATECAMPAIGNACTIONTRANSLATION"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_campaign_action_metrics(
    context: ToolContext,
    action_identifier: Annotated[
        int, "The ID of the specific action to retrieve metrics for within a campaign."
    ],
    campaign_id: Annotated[int, "The integer ID of the campaign to retrieve metrics for."],
    metrics_api_version: Annotated[
        str, "Specify the version of the metrics API to use. Recommended to use version '2'."
    ],
    item_type_for_metrics: Annotated[
        str | None,
        "Specify the type of item to return metrics for, such as 'email', 'webhook', 'twilio', etc. Leaving it empty returns metrics for all types.",  # noqa: E501
    ] = None,
    metrics_end_timestamp: Annotated[
        int | None,
        "The Unix timestamp marking the end of the metrics period. Applicable only for Version 2 and limited to 10 years from the start timestamp.",  # noqa: E501
    ] = None,
    metrics_resolution: Annotated[
        str | None,
        "Specifies the increment for metrics in version 2. Options are hourly, daily, weekly, or monthly.",  # noqa: E501
    ] = None,
    metrics_start_timestamp: Annotated[
        int | None, "Unix timestamp for the start of metrics (Version 2 only)."
    ] = None,
    number_of_steps: Annotated[
        int | None,
        "For Version 1 only. Specifies the number of time periods to return. Defaults to the maximum, or `12` if in months. Maximums are 24 hours, 45 days, 12 weeks, or 120 months.",  # noqa: E501
    ] = None,
    timezone: Annotated[
        str | None,
        "The time zone in region format for the metrics. Default is EST if not specified.",
    ] = None,
    version_1_time_unit: Annotated[
        str | None,
        "Specifies the time unit for the report in Version 1 (e.g., hours, days, weeks, months).",
    ] = "days",
) -> Annotated[dict[str, Any], "Response from the API endpoint 'campaignActionMetrics'."]:
    """Retrieve metrics for a specific campaign action.

    Fetch detailed metrics for an individual action within a campaign. Utilizes version 2, allowing for flexible time ranges and resolution-based metrics. Essential for tracking the performance of campaign actions over time."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/campaigns/{campaign_id}/actions/{action_id}/metrics".format(  # noqa: UP032
            campaign_id=campaign_id, action_id=action_identifier
        ),
        method="GET",
        params=remove_none_values({
            "version": metrics_api_version,
            "type": item_type_for_metrics,
            "res": metrics_resolution,
            "tz": timezone,
            "start": metrics_start_timestamp,
            "end": metrics_end_timestamp,
            "period": version_1_time_unit,
            "steps": number_of_steps,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_campaign_action_link_metrics(
    context: ToolContext,
    action_identifier: Annotated[
        int,
        "The identifier of the action to lookup or perform an operation on in the campaign. It is expected to be an integer.",  # noqa: E501
    ],
    campaign_id: Annotated[
        int,
        "The unique ID of the campaign to retrieve metrics for. Ensure this is a valid integer.",
    ],
    metric_item_type: Annotated[
        str | None,
        "Specify the type of item to return metrics for. Acceptable values are 'email', 'webhook', 'twilio', 'slack', 'push', 'in_app'. Leave empty for metrics of all types.",  # noqa: E501
    ] = None,
    number_of_periods_to_return: Annotated[
        int | None,
        "Number of periods to return metrics for. Defaults to max available or 12 if in months. Max: 24 hours, 45 days, 12 weeks, 121 months.",  # noqa: E501
    ] = None,
    report_time_unit: Annotated[
        str | None, "The unit of time for the report. Options: hours, days, weeks, or months."
    ] = "days",
) -> Annotated[dict[str, Any], "Response from the API endpoint 'campaignActionLinks'."]:
    """Retrieve link click metrics for a specific campaign action.

    This tool retrieves link click metrics for an individual action within a specific campaign. It provides click data for up to 45 days unless specified otherwise and requires at least two steps for any period. Use this tool to analyze link engagement in marketing campaigns."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/campaigns/{campaign_id}/actions/{action_id}/metrics/links".format(  # noqa: UP032
            campaign_id=campaign_id, action_id=action_identifier
        ),
        method="GET",
        params=remove_none_values({
            "period": report_time_unit,
            "steps": number_of_periods_to_return,
            "type": metric_item_type,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_campaign_journey_metrics(
    context: ToolContext,
    campaign_id: Annotated[int, "The ID of the campaign to return journey metrics for."],
    end_timestamp: Annotated[
        int, "The Unix timestamp marking the end of the journey metrics report period."
    ],
    metrics_resolution: Annotated[
        str, "Determines the increment for metrics reporting: hourly, daily, weekly, or monthly."
    ],
    start_timestamp: Annotated[
        int, "The UNIX timestamp marking the start of the journey metrics report period."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'campaignJourneyMetrics'."]:
    """Retrieve journey metrics for a specific campaign.

    This tool retrieves a list of journey metrics for a specified campaign. It provides insights into how many people triggered the campaign and other related metrics within a specified time period and resolution. Useful for campaign performance analysis."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/campaigns/{campaign_id}/journey_metrics".format(  # noqa: UP032
            campaign_id=campaign_id
        ),
        method="GET",
        params=remove_none_values({
            "start": start_timestamp,
            "end": end_timestamp,
            "res": metrics_resolution,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def list_recent_activities(
    context: ToolContext,
    activity_type: Annotated[
        str | None,
        "Specifies the type of activity to search for. Use specific activity types or patterns like `_o:<object_type_id>` for objects and `_r:<object_type_id>` for relationships.",  # noqa: E501
    ] = None,
    customer_id_type: Annotated[
        str | None,
        "Specify the type of `customer_id` to reference a person. Options are `id`, `email`, or `cio_id`. Default is `id`.",  # noqa: E501
    ] = None,
    event_or_attribute_name: Annotated[
        str | None, "The name of the event or attribute to return in the activity logs."
    ] = None,
    include_deleted_people: Annotated[
        bool | None, "If true, return results for deleted people in the list of activities."
    ] = False,
    pagination_token: Annotated[
        str | None,
        "Token to specify the page of results to return. Use the `next` property from the previous response.",  # noqa: E501
    ] = None,
    person_identifier: Annotated[
        str | None,
        "The identifier for the person to look up, which can be their `id`, `email`, or `cio_id`. Prefix with `cio_` for `cio_id`.",  # noqa: E501
    ] = None,
    results_per_page_limit: Annotated[
        int | None, "Specify the maximum number of activity results to retrieve per page."
    ] = 10,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listActivities'."]:
    """Retrieve recent activity logs from the past 30 days.

    This tool calls the Customerio API to obtain a list of recent activities for people. It returns activity history within the past 30 days, similar to workspace's Activity Logs, and might include older activities."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/activities",
        method="GET",
        params=remove_none_values({
            "start": pagination_token,
            "type": activity_type,
            "name": event_or_attribute_name,
            "deleted": include_deleted_people,
            "customer_id": person_identifier,
            "id_type": customer_id_type,
            "limit": results_per_page_limit,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def list_broadcasts(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listBroadcasts'."]:
    """Retrieve a list of API-triggered broadcasts with metadata.

    Use this tool to get detailed information on all your API-triggered broadcasts, including their metadata. Ideal for keeping track of broadcast activities or managing campaigns."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/broadcasts",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_broadcast_metadata(
    context: ToolContext,
    broadcast_identifier: Annotated[
        int,
        "The unique identifier for a specific broadcast. Use this to retrieve the corresponding metadata.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getBroadcast'."]:
    """Retrieve metadata for a specific broadcast.

    Use this tool to get detailed metadata for an individual broadcast based on its unique identifier. Useful for tracking and analyzing individual broadcast details."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/broadcasts/{broadcast_id}".format(  # noqa: UP032
            broadcast_id=broadcast_identifier
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_broadcast_status(
    context: ToolContext,
    broadcast_identifier: Annotated[
        int,
        "The unique ID of the broadcast to retrieve information about. This should be an integer.",
    ],
    campaign_trigger_id: Annotated[
        int, "The ID of the specific campaign trigger whose status you want to retrieve."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'broadcastStatus'."]:
    """Retrieve the status of a broadcast using its trigger ID.

    Use this tool to get the current status of a broadcast after it has been triggered. Requires the `broadcast_id` and `trigger_id` to fetch the specific status."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/campaigns/{broadcast_id}/triggers/{trigger_id}".format(  # noqa: UP032
            broadcast_id=broadcast_identifier, trigger_id=campaign_trigger_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_broadcast_metrics(
    context: ToolContext,
    broadcast_identifier: Annotated[int, "The unique integer identifier for a specific broadcast."],
    metric_type: Annotated[
        str | None,
        "Specify the type of item to return metrics for. Options include 'email', 'webhook', 'twilio', 'slack', 'push', and 'in_app'. Leave empty to get metrics for all types.",  # noqa: E501
    ] = None,
    number_of_time_periods: Annotated[
        int | None,
        "The number of time periods to return metrics for. Follow the specific period limits: 24 for hours, 45 for days, 12 for weeks, or 121 for months. Defaults if not specified: to maximum available or 12 for monthly periods. Days start at 00:00 EST, weeks at 00:00 EST on Sunday, and months at 00:00 EST on the 1st.",  # noqa: E501
    ] = None,
    time_period_unit: Annotated[
        str | None,
        "Specifies the unit of time for the report, such as hours, days, weeks, or months.",
    ] = "days",
) -> Annotated[dict[str, Any], "Response from the API endpoint 'broadcastMetrics'."]:
    """Retrieve metrics for a specific broadcast over defined time steps.

    This tool retrieves a list of performance metrics for an individual broadcast, broken down into specified time intervals (steps) such as days or weeks. It is useful for analyzing broadcast performance trends. The metrics are returned from the oldest to the newest period."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/broadcasts/{broadcast_id}/metrics".format(  # noqa: UP032
            broadcast_id=broadcast_identifier
        ),
        method="GET",
        params=remove_none_values({
            "period": time_period_unit,
            "steps": number_of_time_periods,
            "type": metric_type,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_broadcast_link_metrics(
    context: ToolContext,
    broadcast_identifier: Annotated[
        int, "The numeric identifier of the broadcast for which link metrics are needed."
    ],
    period_steps: Annotated[
        int | None,
        "Specify the number of time periods to return. Defaults to the maximum or 12 if the period is 'months'. Max: 24 hours, 45 days, 12 weeks, or 121 months.",  # noqa: E501
    ] = None,
    report_period: Annotated[
        str | None,
        "Defines the unit of time for the report. Options are 'hours', 'days', 'weeks', or 'months'.",  # noqa: E501
    ] = "days",
    return_unique_customer_results: Annotated[
        bool | None,
        "Set to true to return only unique customer results, ensuring each customer is counted once regardless of clicks.",  # noqa: E501
    ] = False,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'broadcastLinks'."]:
    """Retrieve metrics for link clicks in a broadcast.

    This tool returns metrics for link clicks within a specified broadcast, providing both total counts and series data over defined periods such as days or weeks. Useful for analyzing broadcast performance."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/broadcasts/{broadcast_id}/metrics/links".format(  # noqa: UP032
            broadcast_id=broadcast_identifier
        ),
        method="GET",
        params=remove_none_values({
            "period": report_period,
            "steps": period_steps,
            "unique": return_unique_customer_results,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_broadcast_actions(
    context: ToolContext,
    broadcast_identifier: Annotated[
        int, "The unique identifier of the broadcast to retrieve its actions."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'broadcastActions'."]:
    """Retrieve actions from a specific broadcast.

    Use this tool to get detailed actions that occur as part of a specific broadcast by providing the broadcast ID."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/broadcasts/{broadcast_id}/actions".format(  # noqa: UP032
            broadcast_id=broadcast_identifier
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_broadcast_message_info(
    context: ToolContext,
    broadcast_identifier: Annotated[
        int, "The ID used to identify the specific broadcast to retrieve information about."
    ],
    beginning_timestamp: Annotated[
        int | None,
        "The start timestamp for the query, defining the beginning of the time range for message retrieval.",  # noqa: E501
    ] = None,
    broadcast_state: Annotated[
        str | None,
        "Specifies the state of a broadcast message. Options are: 'failed', 'sent', 'drafted', or 'attempted'.",  # noqa: E501
    ] = None,
    ending_timestamp: Annotated[
        int | None,
        "The endpoint of the time range for the query. It must be an integer representing a timestamp.",  # noqa: E501
    ] = None,
    item_type: Annotated[
        str | None,
        "Specify the type of item to return metrics for (e.g., email, webhook). Leave empty for all types.",  # noqa: E501
    ] = None,
    maximum_results_per_page: Annotated[
        int | None,
        "Specify the maximum number of message deliveries to retrieve per page. Adjust to control the pagination size for results.",  # noqa: E501
    ] = None,
    metric_type: Annotated[
        str | None,
        "Select the metric(s) to be returned. Options include: 'attempted', 'sent', 'delivered', 'opened', 'clicked', 'converted', 'bounced', 'spammed', 'unsubscribed', 'dropped', 'failed', 'undeliverable'.",  # noqa: E501
    ] = None,
    pagination_start_token: Annotated[
        str | None,
        "Token for the page of results to return. Use the 'next' property from responses for this value to get the next page.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'broadcastMessages'."]:
    """Retrieve details about broadcast message deliveries.

    This tool returns information about message deliveries from an API-triggered broadcast. Use it to get insights on individual deliveries within a specific time range by providing `start_ts` and `end_ts`. If not specified, data for one month post-trigger is returned. The information reflects when the deliveries were created, with a possible delay to actual send time."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/broadcasts/{broadcast_id}/messages".format(  # noqa: UP032
            broadcast_id=broadcast_identifier
        ),
        method="GET",
        params=remove_none_values({
            "start": pagination_start_token,
            "limit": maximum_results_per_page,
            "metric": metric_type,
            "state": broadcast_state,
            "type": item_type,
            "start_ts": beginning_timestamp,
            "end_ts": ending_timestamp,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_broadcast_action_info(
    context: ToolContext,
    action_id: Annotated[int, "The ID of the action to look up or act on within a broadcast."],
    broadcast_identifier: Annotated[
        int, "The numeric identifier of the broadcast to retrieve action details from."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getBroadcastAction'."]:
    """Retrieve details of a specific broadcast action.

    Call this tool to obtain detailed information about a specific action within a broadcast by providing the broadcast and action IDs."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/broadcasts/{broadcast_id}/actions/{action_id}".format(  # noqa: UP032
            broadcast_id=broadcast_identifier, action_id=action_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def update_broadcast_action(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    broadcast_id: Annotated[
        int | None,
        "The identifier of a broadcast to update its contents.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    lookup_action_id: Annotated[
        int | None,
        "The unique identifier for the action to update or modify in the broadcast.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'updateBroadcastAction'."]:
    """Update the contents of a broadcast action.

    Use this tool to update the body of messages or HTTP requests in a broadcast action. It should be called when you need to modify the content associated with a specific broadcast action in Customerio.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["UPDATEBROADCASTACTION"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not broadcast_id:
        missing_params.append(("broadcast_id", "path"))
    if not lookup_action_id:
        missing_params.append(("lookup_action_id", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(f"Required parameters validation failed: {param_details}"),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPDATEBROADCASTACTION"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPDATEBROADCASTACTION"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.customer.io/v1/broadcasts/{broadcast_id}/actions/{action_id}".format(  # noqa: UP032
            broadcast_id=broadcast_id, action_id=lookup_action_id
        ),
        method="PUT",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["UPDATEBROADCASTACTION"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_broadcast_translation_info(
    context: ToolContext,
    action_id: Annotated[
        int,
        "The identifier for the action you want to lookup or act on. Used to retrieve specific translation details.",  # noqa: E501
    ],
    broadcast_identifier: Annotated[
        int, "The unique identifier for a broadcast. Integer type is expected."
    ],
    language_tag: Annotated[
        str, "The language tag for the translation. Use an empty string for the default language."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getBroadcastActionLanguage'."]:
    """Retrieve translation info for a broadcast message.

    Use this tool to get details about a specific translation of a message within a broadcast by providing the `action_id`. Useful for checking how a message is translated into a specific language."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/broadcasts/{broadcast_id}/actions/{action_id}/language/{language}".format(  # noqa: UP032
            broadcast_id=broadcast_identifier, action_id=action_id, language=language_tag
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def update_broadcast_action_language(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    broadcast_identifier: Annotated[
        int | None,
        "The unique identifier for the broadcast you want to update.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    action_id: Annotated[
        int | None,
        "The ID of the broadcast action you wish to update or query.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    broadcast_action_language: Annotated[
        str | None,
        "Specify the language tag for the broadcast translation. Defaults to the default language if an empty string is provided.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'updateBroadcastActionLanguage'."]:
    """Update the translation for a broadcast action.

    Use this tool to update the translation of a specific broadcast action, including message bodies or HTTP request content. This can be useful when you need to update translations for different languages in your broadcast actions.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["UPDATEBROADCASTACTIONLANGUAGE"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not broadcast_identifier:
        missing_params.append(("broadcast_identifier", "path"))
    if not action_id:
        missing_params.append(("action_id", "path"))
    if not broadcast_action_language:
        missing_params.append(("broadcast_action_language", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(f"Required parameters validation failed: {param_details}"),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["UPDATEBROADCASTACTIONLANGUAGE"]
                + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["UPDATEBROADCASTACTIONLANGUAGE"]
                + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.customer.io/v1/broadcasts/{broadcast_id}/actions/{action_id}/language/{language}".format(  # noqa: UP032
            broadcast_id=broadcast_identifier,
            action_id=action_id,
            language=broadcast_action_language,
        ),
        method="PUT",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["UPDATEBROADCASTACTIONLANGUAGE"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_broadcast_action_metrics(
    context: ToolContext,
    broadcast_identifier: Annotated[
        int, "The ID of the broadcast you wish to retrieve metrics for."
    ],
    lookup_action_id: Annotated[
        int, "The ID of the action you want to look up or act on. Provide an integer value."
    ],
    metrics_item_type: Annotated[
        str | None,
        "Specifies the type of item (e.g., email, webhook) to return metrics for. If not provided, metrics for all types are returned.",  # noqa: E501
    ] = None,
    period_steps: Annotated[
        int | None,
        "Specify the number of time periods to return metrics for. Defaults to the maximum allowed (24 hours, 45 days, 12 weeks, or 121 months) or `12` if the period is in months.",  # noqa: E501
    ] = None,
    time_unit_for_report: Annotated[
        str | None, "The unit of time for the report, such as hours, days, weeks, or months."
    ] = "days",
) -> Annotated[dict[str, Any], "Response from the API endpoint 'broadcastActionMetrics'."]:
    """Retrieve metrics for a broadcast action over time steps.

    Get metrics for an individual broadcast action, both in total and divided by time steps like days or weeks, over a specified period."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/broadcasts/{broadcast_id}/actions/{action_id}/metrics".format(  # noqa: UP032
            broadcast_id=broadcast_identifier, action_id=lookup_action_id
        ),
        method="GET",
        params=remove_none_values({
            "period": time_unit_for_report,
            "steps": period_steps,
            "type": metrics_item_type,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_broadcast_action_link_metrics(
    context: ToolContext,
    broadcast_action_id: Annotated[int, "The ID of the action you want to look up or act on."],
    broadcast_identifier: Annotated[
        int,
        "The unique identifier for the broadcast to retrieve metrics for. It should be an integer value.",  # noqa: E501
    ],
    item_type: Annotated[
        str | None,
        "Specifies the type of item to return metrics for; options include email, webhook, twilio, slack, push, and in_app. Leave empty for all types.",  # noqa: E501
    ] = None,
    number_of_periods_to_return: Annotated[
        int | None,
        "The number of time periods to return metrics for. Defaults to the maximum, or 12 if in months. Max: 24 hours, 45 days, 12 weeks, 121 months.",  # noqa: E501
    ] = None,
    time_period_unit: Annotated[
        str | None,
        "The unit of time for the report. Acceptable values are 'hours', 'days', 'weeks', or 'months'.",  # noqa: E501
    ] = "days",
) -> Annotated[dict[str, Any], "Response from the API endpoint 'broadcastActionLinks'."]:
    """Retrieve link click metrics for a specific broadcast action.

    This tool retrieves link click metrics for an individual broadcast action. It provides data for a maximum of 45 days, unless specified otherwise. Use appropriate period and step parameters for custom data ranges."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/broadcasts/{broadcast_id}/actions/{action_id}/metrics/links".format(  # noqa: UP032
            broadcast_id=broadcast_identifier, action_id=broadcast_action_id
        ),
        method="GET",
        params=remove_none_values({
            "period": time_period_unit,
            "steps": number_of_periods_to_return,
            "type": item_type,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_broadcast_triggers(
    context: ToolContext,
    broadcast_identifier: Annotated[
        int, "The identifier of a broadcast to retrieve its triggers. Must be an integer."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listBroadcastTriggers'."]:
    """Retrieve triggers for a specific broadcast.

    Use this tool to get a list of triggers associated with a particular broadcast in the Customerio service. Useful for understanding the actions set for a broadcast."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/broadcasts/{broadcast_id}/triggers".format(  # noqa: UP032
            broadcast_id=broadcast_identifier
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def update_customer_attributes(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'updateAttributeMetadata'."]:
    """Add or update customer attribute metadata in your workspace.

    Use this tool to add new customer attributes or update existing ones. It helps in managing customer data like names and emails, enhancing data understanding for AI tools, and setting sensitivity levels for premium users.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["UPDATECUSTOMERATTRIBUTES"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPDATECUSTOMERATTRIBUTES"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPDATECUSTOMERATTRIBUTES"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.customer.io/v1/data_index/attributes",
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["UPDATECUSTOMERATTRIBUTES"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def update_event_metadata(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'updateEventMetadata'."]:
    """Update or add new events in the workspace.

    This tool allows you to update existing events or add new ones in the Customerio workspace. It is useful for managing customer actions and integrating new events. Events must be associated with customers via Pipelines or Track APIs to appear in the Data Index.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["UPDATEEVENTMETADATA"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPDATEEVENTMETADATA"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPDATEEVENTMETADATA"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.customer.io/v1/data_index/events",
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["UPDATEEVENTMETADATA"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def check_email_suppression(
    context: ToolContext,
    email_to_check_suppression: Annotated[
        str, "The email address to check for suppression status and reasons."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getSuppression'."]:
    """Retrieve suppression status and reason for an email.

    Use this tool to find out if an email address has been suppressed by the email service provider (ESP) and the reasons for its suppression."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/esp/search_suppression/{email_address}".format(  # noqa: UP032
            email_address=email_to_check_suppression
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def find_suppressed_email_addresses(
    context: ToolContext,
    suppression_reason: Annotated[
        str, "Specify the reason for email address suppression, such as bounces or spam reports."
    ],
    max_results_per_page: Annotated[
        int | None, "The maximum number of suppression records to retrieve per page, up to 1000."
    ] = 100,
    skip_records: Annotated[
        int | None, "The number of records to skip before retrieving results."
    ] = 0,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getSuppressionByType'."]:
    """Retrieve email addresses suppressed for specific reasons.

    Use this tool to identify and retrieve email addresses suppressed by the Email Service Provider for reasons such as bounces, blocks, spam reports, or invalid addresses. Supports pagination for large datasets."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/esp/suppression/{suppression_type}".format(  # noqa: UP032
            suppression_type=suppression_reason
        ),
        method="GET",
        params=remove_none_values({"limit": max_results_per_page, "offset": skip_records}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def remove_email_suppression(
    context: ToolContext,
    email_address_to_remove: Annotated[
        str,
        "The email address to remove from the suppression list, allowing future communications.",
    ],
    suppression_reason: Annotated[
        str, "The reason the email address was suppressed (e.g., 'bounces', 'spam_reports')."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteSuppression'."]:
    """Remove an email address from the suppression list.

    Use this tool to remove a specific email address from the email service provider's suppression list, allowing future communications to be sent to it."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/esp/suppression/{suppression_type}/{email_address}".format(  # noqa: UP032
            suppression_type=suppression_reason, email_address=email_address_to_remove
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def suppress_email_at_esp(
    context: ToolContext,
    email_address_to_suppress: Annotated[
        str, "The email address of the person you want to suppress at the ESP."
    ],
    suppression_reason: Annotated[
        str,
        "Specify the reason for suppressing the email address, such as 'bounces' or 'spam_reports'.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'postSuppression'."]:
    """Suppress an email address at the email service provider.

    Use this tool to suppress an email address at the email service provider (ESP). It ensures that the email address will no longer receive emails through the ESP, while allowing the contact to remain in your Customer.io workspace."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/esp/suppression/{suppression_type}/{email_address}".format(  # noqa: UP032
            suppression_type=suppression_reason, email_address=email_address_to_suppress
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def list_exports(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listExports'."]:
    """Retrieve a list of exports for people or campaign metrics.

    This tool is used to obtain a list of exports, which are point-in-time records of people or campaign metrics. Call this tool when you need detailed information about exports from Customerio."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/exports",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_export_info(
    context: ToolContext,
    export_id_to_access: Annotated[
        int, "The unique ID of the export you want to access in Customerio."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getExport'."]:
    """Returns information about a specific export from Customerio.

    Use this tool to fetch details about a particular export by providing the export ID. It retrieves comprehensive information related to the specified export."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/exports/{export_id}".format(export_id=export_id_to_access),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def download_export_signed_link(
    context: ToolContext,
    export_identifier: Annotated[
        int, "The unique ID of the export you want to access and download. Must be an integer."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'downloadExport'."]:
    """Retrieve a temporary signed link to download an export.

    Use this tool to get a signed link for downloading an export from Customerio. The link is only valid for 15 minutes, so it should be used promptly."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/exports/{export_id}/download".format(  # noqa: UP032
            export_id=export_identifier
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def export_customer_data(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'exportPeopleData'."]:
    """Export customer data based on specified filters.

    Use this tool to export customer data by providing filters and attributes. It returns metadata useful for initiating the data download process.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["EXPORTCUSTOMERDATA"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["EXPORTCUSTOMERDATA"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["EXPORTCUSTOMERDATA"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.customer.io/v1/exports/customers",
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["EXPORTCUSTOMERDATA"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def export_delivery_data(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'exportDeliveriesData'."]:
    """Initiates export of delivery data for newsletters and campaigns.

    This tool is used to start an export of delivery data for newsletters, campaigns, or actions based on given filters. Data spans a specified time range, with default and maximum limits. Use it to obtain delivery insights over a specified timeframe.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["EXPORTDELIVERYDATA"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["EXPORTDELIVERYDATA"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["EXPORTDELIVERYDATA"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.customer.io/v1/exports/deliveries",
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["EXPORTDELIVERYDATA"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def upload_csv_to_customerio(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'import'."]:
    """Upload a CSV file to Customerio for bulk data processing.

    Use this tool to upload a CSV file containing people, events, objects, or relationships to Customerio. The CSV must be hosted at a short-lived public URL, ideally expiring 2 hours after the upload. The endpoint performs basic validations and queues the import for processing, which occurs in multiple stages. You will receive a confirmation and a URL to check the import status. Any errors or warnings during the import can be accessed through downloadable CSV reports available via the export endpoints.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["UPLOADCSVTOCUSTOMERIO"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPLOADCSVTOCUSTOMERIO"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPLOADCSVTOCUSTOMERIO"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.customer.io/v1/imports",
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["UPLOADCSVTOCUSTOMERIO"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_import_status(
    context: ToolContext,
    import_id: Annotated[
        int, "The ID of the import to lookup from a previously queued import operation."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getImport'."]:
    """Retrieve the status of an import operation.

    Use this tool to get information on the status and results of a CSV file import operation, including the success of the row imports."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/imports/{import_id}".format(import_id=import_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_allowlist_ips(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getCioAllowlist'."]:
    """Retrieve IP addresses to allowlist for secure access.

    Use this tool to obtain a list of IP addresses that should be allowlisted when configuring firewall settings or using a custom SMTP provider's IP management to deny unknown IPs. This is applicable to all message types and webhooks, except push notifications."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/info/ip_addresses",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def fetch_message_deliveries(
    context: ToolContext,
    beginning_timestamp: Annotated[
        int | None,
        "The beginning timestamp in Unix format for your query. Returns deliveries created after this time.",  # noqa: E501
    ] = None,
    desired_metrics: Annotated[
        str | None,
        "Specifies the metrics to retrieve. Options include: attempted, sent, delivered, opened, clicked, converted, bounced, spammed, unsubscribed, dropped, failed, undeliverable.",  # noqa: E501
    ] = None,
    ending_timestamp_for_query: Annotated[
        int | None,
        "The ending timestamp for your query. If not specified, it defaults to the current time.",
    ] = None,
    filter_by_action_id: Annotated[
        int | None,
        "Specify the action ID to filter the message deliveries. This narrows the results to messages associated with the given action.",  # noqa: E501
    ] = None,
    filter_by_campaign_id: Annotated[
        int | None,
        "The ID of the campaign to filter message deliveries. Use this to retrieve data for a specific campaign only.",  # noqa: E501
    ] = None,
    filter_by_newsletter_id: Annotated[
        int | None, "An integer representing the ID of the newsletter to filter deliveries for."
    ] = None,
    item_type_for_metrics: Annotated[
        str | None,
        "Specify the item type to return metrics for, such as 'email', 'webhook', 'twilio', 'slack', 'push', or 'in_app'. Leave empty for all types.",  # noqa: E501
    ] = None,
    page_token: Annotated[
        str | None, "The token to fetch the specified page of delivery results."
    ] = None,
    results_per_page_limit: Annotated[
        int | None, "Specifies the maximum number of results to retrieve per page."
    ] = 50,
    return_drafts_only: Annotated[
        bool | None, "Set to true to return drafts instead of active or sent messages."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listMessages'."]:
    """Retrieve a list of message deliveries and their metrics.

    This tool retrieves a list of message deliveries, including metrics, within a specified time range in your workspace. Use it to analyze message performance over the most recent six months or a defined period. If no specific time range is provided, it defaults to the last six months."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/messages",
        method="GET",
        params=remove_none_values({
            "start": page_token,
            "limit": results_per_page_limit,
            "type": item_type_for_metrics,
            "metric": desired_metrics,
            "drafts": return_drafts_only,
            "campaign_id": filter_by_campaign_id,
            "newsletter_id": filter_by_newsletter_id,
            "action_id": filter_by_action_id,
            "start_ts": beginning_timestamp,
            "end_ts": ending_timestamp_for_query,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_delivery_message_info(
    context: ToolContext,
    message_identifier: Annotated[
        str,
        "The unique identifier for a specific message instance to retrieve its information and metrics.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getMessage'."]:
    """Retrieve metrics and details for a specific message delivery.

    Call this tool to get information and delivery metrics for a specific instance of a message intended for an individual recipient."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/messages/{message_id}".format(  # noqa: UP032
            message_id=message_identifier
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_archived_message(
    context: ToolContext,
    message_id: Annotated[str, "The unique identifier for the message to be retrieved."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getArchivedMessage'."]:
    """Retrieve an archived copy of a message delivery.

    Fetches the archived version of a delivery from Customerio, providing details like the message body, recipient, and associated metrics. Limited to 100 requests per day."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/messages/{message_id}/archived_message".format(  # noqa: UP032
            message_id=message_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_newsletters(
    context: ToolContext,
    max_results_per_page: Annotated[
        int | None, "The maximum number of newsletters to retrieve per page, up to 100."
    ] = None,
    sort_order: Annotated[
        str | None,
        "Specify the order to sort results: `asc` for chronological, `desc` for reverse.",
    ] = None,
    start_token: Annotated[
        str | None,
        "Token to retrieve a specific page of newsletter results. Use the `next` property from previous responses as this token.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listNewsletters'."]:
    """Retrieve a list of newsletters and their metadata.

    Use this tool to obtain a comprehensive list of newsletters along with detailed metadata. Ideal for managing or reviewing newsletter information."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/newsletters",
        method="GET",
        params=remove_none_values({
            "limit": max_results_per_page,
            "sort": sort_order,
            "start": start_token,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def retrieve_newsletter_metadata(
    context: ToolContext,
    newsletter_identifier: Annotated[
        int, "The unique identifier for the newsletter to retrieve metadata."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getNewsletters'."]:
    """Retrieve metadata for an individual newsletter.

    Call this tool to get detailed information about a specific newsletter using its ID."""
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/newsletters/{newsletter_id}".format(  # noqa: UP032
            newsletter_id=newsletter_identifier
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def delete_newsletter(
    context: ToolContext,
    newsletter_identifier: Annotated[
        int, "The unique identifier of the newsletter you want to delete."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deletetNewsletters'."]:
    """Delete an individual newsletter and its associated data.

    Use this tool to delete a specific newsletter, including its content, settings, and metrics. It will be removed from segments, and its templates will be erased from the Message Library. Additionally, any undelivered in-app messages will be canceled."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/newsletters/{newsletter_id}".format(  # noqa: UP032
            newsletter_id=newsletter_identifier
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_newsletter_metrics(
    context: ToolContext,
    newsletter_identifier: Annotated[
        int,
        "The identifier for the specific newsletter to retrieve metrics for. Expected to be an integer.",  # noqa: E501
    ],
    item_type_for_metrics: Annotated[
        str | None,
        "Specify the type of item to return metrics for, such as 'email', 'webhook', 'twilio', etc. If not provided, metrics for all types are returned.",  # noqa: E501
    ] = None,
    number_of_time_periods: Annotated[
        int | None,
        "The number of time periods to return metrics for. Minimum is 2. Defaults to max: 24 hours, 45 days, 12 weeks, 121 months. Use this to specify the time span for newsletter metrics.",  # noqa: E501
    ] = None,
    time_period_unit: Annotated[
        str | None, "The unit of time to report metrics (options: hours, days, weeks, months)."
    ] = "days",
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getNewsletterMetrics'."]:
    """Retrieve metrics for a specific newsletter over time.

    This tool retrieves a list of metrics for an individual newsletter over specified time intervals, such as days or weeks, presented from oldest to newest. It is useful to analyze the performance of newsletters over time, requiring at least two time steps for valid data retrieval."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/newsletters/{newsletter_id}/metrics".format(  # noqa: UP032
            newsletter_id=newsletter_identifier
        ),
        method="GET",
        params=remove_none_values({
            "period": time_period_unit,
            "steps": number_of_time_periods,
            "type": item_type_for_metrics,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_newsletter_link_metrics(
    context: ToolContext,
    newsletter_identifier: Annotated[
        int, "The identifier of the newsletter to retrieve metrics for. Must be an integer."
    ],
    include_unique_customers: Annotated[
        bool | None,
        "If true, response includes only unique customer results (each customer counted once); if false, includes total click results.",  # noqa: E501
    ] = False,
    number_of_periods: Annotated[
        int | None,
        "The number of periods to return metrics for. Defaults to maximum available, or 12 if in months. Maximums: 24 hours, 45 days, 12 weeks, or 121 months.",  # noqa: E501
    ] = None,
    time_unit_for_report: Annotated[
        str | None,
        "The unit of time for your report. Options are 'hours', 'days', 'weeks', or 'months'.",
    ] = "days",
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getNewsletterLinks'."]:
    """Retrieve metrics for link clicks in a newsletter.

    This tool fetches metrics for link clicks within a newsletter, providing both total counts and series data over specified periods (e.g., days, weeks). Useful for analyzing newsletter performance over time."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/newsletters/{newsletter_id}/metrics/links".format(  # noqa: UP032
            newsletter_id=newsletter_identifier
        ),
        method="GET",
        params=remove_none_values({
            "period": time_unit_for_report,
            "steps": number_of_periods,
            "unique": include_unique_customers,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_newsletter_variants(
    context: ToolContext,
    newsletter_identifier: Annotated[
        int, "The unique integer identifier of a newsletter to fetch its content variants."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listNewsletterVariants'."]:
    """Fetch content variants for a specified newsletter.

    Use this tool to retrieve different content variants of a newsletter, useful for accessing multi-language versions or A/B test variations."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/newsletters/{newsletter_id}/contents".format(  # noqa: UP032
            newsletter_id=newsletter_identifier
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_newsletter_message_metadata(
    context: ToolContext,
    newsletter_identifier: Annotated[
        int, "The unique identifier of the newsletter to retrieve delivery information for."
    ],
    begin_query_timestamp: Annotated[
        int | None,
        "The Unix timestamp marking the start of the time range for your query. Without this, data defaults to the earliest available from 6 months prior.",  # noqa: E501
    ] = None,
    ending_timestamp_for_query: Annotated[
        int | None,
        "The ending timestamp for your query in Unix format. It specifies the end of the time range for retrieving message delivery data.",  # noqa: E501
    ] = None,
    metrics_to_return: Annotated[
        str | None,
        "Specify one or more metrics to return, such as 'attempted', 'sent', 'delivered', etc.",
    ] = None,
    pagination_start_token: Annotated[
        str | None,
        "The token to specify the start of the result page to return. Use the `next` value from previous responses for pagination.",  # noqa: E501
    ] = None,
    results_per_page_limit: Annotated[
        int | None, "The maximum number of message delivery results to retrieve per page."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getNewsletterMsgMeta'."]:
    """Retrieve delivery info for messages sent from a newsletter.

    Use this tool to get information about individual message deliveries from a specific newsletter. You can specify a time range using `start_ts` and `end_ts`, otherwise, it defaults to a 6-month period from the first delivery. For longer ranges, up to 12 months of data will be returned from the most recent delivery. Timestamps indicate delivery creation, not the actual send time."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/newsletters/{newsletter_id}/messages".format(  # noqa: UP032
            newsletter_id=newsletter_identifier
        ),
        method="GET",
        params=remove_none_values({
            "start": pagination_start_token,
            "limit": results_per_page_limit,
            "metric": metrics_to_return,
            "start_ts": begin_query_timestamp,
            "end_ts": ending_timestamp_for_query,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_newsletter_variant_info(
    context: ToolContext,
    message_identifier_in_newsletter: Annotated[
        int,
        "Identifier for a message within a newsletter, used for A/B tests or multi-language editions.",  # noqa: E501
    ],
    newsletter_identifier: Annotated[
        int,
        "The unique identifier for a newsletter. Required to retrieve specific variant information.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getNewsletterVariant'."]:
    """Retrieve variant details of a specific newsletter.

    Use this tool to obtain details about a specific variant of a newsletter, which could represent a language option or part of an A/B test."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/newsletters/{newsletter_id}/contents/{content_id}".format(  # noqa: UP032
            newsletter_id=newsletter_identifier, content_id=message_identifier_in_newsletter
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def update_newsletter_content(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    newsletter_identifier: Annotated[
        int | None,
        "The identifier of the newsletter you want to update.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    message_content_id: Annotated[
        int | None,
        "The identifier for a message within a newsletter, used in A/B tests or multiple language variants. Retrieve IDs via getNewsletters.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'updateNewsletterVariant'."]:
    """Update a newsletter variant's content.

    Use this tool to update the content of a specific newsletter variant, such as a version in a different language or part of an A/B test. Ideal for modifying the body or detail changes in a newsletter.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["UPDATENEWSLETTERCONTENT"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not newsletter_identifier:
        missing_params.append(("newsletter_identifier", "path"))
    if not message_content_id:
        missing_params.append(("message_content_id", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(f"Required parameters validation failed: {param_details}"),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPDATENEWSLETTERCONTENT"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPDATENEWSLETTERCONTENT"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.customer.io/v1/newsletters/{newsletter_id}/contents/{content_id}".format(  # noqa: UP032
            newsletter_id=newsletter_identifier, content_id=message_content_id
        ),
        method="PUT",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["UPDATENEWSLETTERCONTENT"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_newsletter_variant_translation(
    context: ToolContext,
    language_tag: Annotated[
        str, "The language tag of a newsletter variant. Leave empty for default language."
    ],
    newsletter_identifier: Annotated[
        int, "The unique identifier of a newsletter to retrieve its specific language variant."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getNewsletterVariantTranslation'."]:
    """Get information on a newsletter's language variant.

    Use this tool to obtain details about a particular language variant of a newsletter. Ideal for retrieving specific translations of newsletter content."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/newsletters/{newsletter_id}/language/{language}".format(  # noqa: UP032
            newsletter_id=newsletter_identifier, language=language_tag
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def update_newsletter_variant_translation(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    newsletter_identifier: Annotated[
        int | None,
        "The unique identifier for a newsletter that you want to update the translation for.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    language_tag: Annotated[
        str | None,
        "A language tag for the newsletter variant. If omitted, defaults to the company's default language. An error is returned if the language variant doesn't exist.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'updateNewsletterVariantTranslation'."
]:
    """Update a newsletter variant's translation.

    Use this tool to update the translation for a specific variant of a newsletter. This is applicable when your newsletter does not include A/B tests. For A/B tests, you should use a separate tool. Call this tool when you need to modify the language content of a newsletter variant for a given language.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["UPDATENEWSLETTERVARIANTTRANSLATION"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not newsletter_identifier:
        missing_params.append(("newsletter_identifier", "path"))
    if not language_tag:
        missing_params.append(("language_tag", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(f"Required parameters validation failed: {param_details}"),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["UPDATENEWSLETTERVARIANTTRANSLATION"]
                + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["UPDATENEWSLETTERVARIANTTRANSLATION"]
                + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.customer.io/v1/newsletters/{newsletter_id}/language/{language}".format(  # noqa: UP032
            newsletter_id=newsletter_identifier, language=language_tag
        ),
        method="PUT",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["UPDATENEWSLETTERVARIANTTRANSLATION"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_newsletter_test_groups(
    context: ToolContext,
    newsletter_identifier: Annotated[
        int, "The unique identifier of a newsletter to retrieve its test group details."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getNewsletterTestGroups'."]:
    """Retrieve test group details for a specific newsletter.

    Use this tool to obtain information about each test group within a specific newsletter, including content IDs for each group. Ideal for analyzing or verifying test group configurations in newsletters."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/newsletters/{newsletter_id}/test_groups".format(  # noqa: UP032
            newsletter_id=newsletter_identifier
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def retrieve_newsletter_language_variant(
    context: ToolContext,
    ab_test_group_id: Annotated[
        str, "The unique ID of the A/B test group for retrieving the language variant."
    ],
    language_tag: Annotated[
        str,
        "Specify the language tag of the newsletter variant. Use an empty string to default to your primary language.",  # noqa: E501
    ],
    newsletter_identifier: Annotated[
        int,
        "Specify the unique identifier of the newsletter to retrieve its language variant details.",
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'getNewsletterVariantTranslationTest'."
]:
    """Get info on a newsletter's language variant in A/B test.

    Use this tool to obtain details about a specific language variant of a newsletter that is part of an A/B test. It requires the newsletter ID, test group ID, and language code."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/newsletters/{newsletter_id}/test_group/{test_group_id}/language/{language}".format(  # noqa: UP032
            newsletter_id=newsletter_identifier,
            test_group_id=ab_test_group_id,
            language=language_tag,
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def update_newsletter_test_translation(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    newsletter_identifier: Annotated[
        int | None,
        "The unique identifier for the newsletter. Use this to specify which newsletter to update.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    ab_test_group_id: Annotated[
        str | None,
        "The identifier for the A/B test group to update the newsletter translation for.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    newsletter_language_tag: Annotated[
        str | None,
        "Specify a language tag for the newsletter translation. Utilize an empty string to default to your system's language. Invalid tags result in an error.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'updateNewsletterTestTranslation'."]:
    """Update a newsletter's translation for A/B testing.

    This tool updates the translation of a specific newsletter variant within an A/B test. It's used when you need to modify the language content for different test groups in newsletter campaigns.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["UPDATENEWSLETTERTESTTRANSLATION"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not newsletter_identifier:
        missing_params.append(("newsletter_identifier", "path"))
    if not ab_test_group_id:
        missing_params.append(("ab_test_group_id", "path"))
    if not newsletter_language_tag:
        missing_params.append(("newsletter_language_tag", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(f"Required parameters validation failed: {param_details}"),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["UPDATENEWSLETTERTESTTRANSLATION"]
                + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["UPDATENEWSLETTERTESTTRANSLATION"]
                + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.customer.io/v1/newsletters/{newsletter_id}/test_group/{test_group_id}/language/{language}".format(  # noqa: UP032
            newsletter_id=newsletter_identifier,
            test_group_id=ab_test_group_id,
            language=newsletter_language_tag,
        ),
        method="PUT",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["UPDATENEWSLETTERTESTTRANSLATION"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_newsletter_variant_metrics(
    context: ToolContext,
    newsletter_identifier: Annotated[
        int, "The unique identifier for the newsletter to fetch metrics for."
    ],
    newsletter_message_id: Annotated[
        int,
        "The ID of a message in a newsletter, used for identifying variants or languages within a newsletter. Useful for A/B tests or multilingual content.",  # noqa: E501
    ],
    item_type_for_metrics: Annotated[
        str | None,
        "Specify the type of item to return metrics for (e.g., email, webhook, etc.). If left empty, metrics for all types are returned.",  # noqa: E501
    ] = None,
    number_of_period_steps: Annotated[
        int | None,
        "The number of time periods to return, requiring a minimum of 2 steps. Maximum limits apply based on the period type.",  # noqa: E501
    ] = None,
    reporting_period_unit: Annotated[
        str | None,
        "The time unit for the report, such as 'hours', 'days', 'weeks', or 'months'. Used to define the granularity of the metrics.",  # noqa: E501
    ] = "days",
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getVariantMetrics'."]:
    """Fetch metrics for a specific newsletter variant.

    This tool retrieves metrics for an individual newsletter variant, such as a language variation or A/B test version. It provides total metrics and stepped metrics over a specified time period, which are arranged chronologically. It requires at least two steps to retrieve data."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/newsletters/{newsletter_id}/contents/{content_id}/metrics".format(  # noqa: UP032
            newsletter_id=newsletter_identifier, content_id=newsletter_message_id
        ),
        method="GET",
        params=remove_none_values({
            "period": reporting_period_unit,
            "steps": number_of_period_steps,
            "type": item_type_for_metrics,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_newsletter_variant_click_metrics(
    context: ToolContext,
    message_content_identifier: Annotated[
        int,
        "The ID of a specific message within a newsletter, useful for A/B tests or multilingual newsletters. Retrieve from newsletter details.",  # noqa: E501
    ],
    newsletter_identifier: Annotated[
        int, "The unique integer identifier of a specific newsletter to retrieve click metrics."
    ],
    item_type_for_metrics: Annotated[
        str | None,
        "The type of item to return metrics for. Options are: email, webhook, twilio, slack, push, in_app. When left empty, metrics for all types are included.",  # noqa: E501
    ] = None,
    number_of_periods: Annotated[
        int | None,
        "Specify the number of time periods to retrieve data for. Defaults to the maximum if not specified, or 12 for months. Maximum limits: 24 hours, 45 days, 12 weeks, or 121 months.",  # noqa: E501
    ] = None,
    time_unit_for_report: Annotated[
        str | None,
        "The unit of time for generating the report. Options are: hours, days, weeks, months.",
    ] = "days",
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getVariantLinks'."]:
    """Get link click metrics for a newsletter variant.

    Retrieve metrics related to link clicks for an individual newsletter variant, such as language variations or A/B test messages. By default, the data covers up to 45 days. Specify the period and steps to customize the data range."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/newsletters/{newsletter_id}/contents/{content_id}/metrics/links".format(  # noqa: UP032
            newsletter_id=newsletter_identifier, content_id=message_content_identifier
        ),
        method="GET",
        params=remove_none_values({
            "period": time_unit_for_report,
            "steps": number_of_periods,
            "type": item_type_for_metrics,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_object_types(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getObjectTypes'."]:
    """Retrieve a list of object types and their IDs.

    Use this tool to obtain a list of all available object types in your system along with their incrementing IDs. This is useful when you need to query, create, or modify specific object types by their ID."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/object_types",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def find_workspace_objects(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    page_start_token: Annotated[
        str | None,
        "Token for the page of results to return. Use the `next` property from a prior response to continue paging.  Only used when mode is 'execute'.",  # noqa: E501
    ] = None,
    maximum_results_per_page: Annotated[
        int | None,
        "The maximum number of results to retrieve per page.  Only used when mode is 'execute'.",
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getObjectsFilter'."]:
    """Find objects in your workspace using filter conditions.

    This tool is used to find and return a list of object IDs based on specified filter conditions in your Customerio workspace. It allows paging through results and setting limits on the number of objects returned. Useful for locating, creating, or modifying objects based on specific criteria.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires query parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required query parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["FINDWORKSPACEOBJECTS"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required query parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["FINDWORKSPACEOBJECTS"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["FINDWORKSPACEOBJECTS"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.customer.io/v1/objects",
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["FINDWORKSPACEOBJECTS"],
        params=remove_none_values({"start": page_start_token, "limit": maximum_results_per_page}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_related_people(
    context: ToolContext,
    object_identifier: Annotated[
        str,
        "The ID of the object. This can be `object_id` or `cio_object_id` based on the `id_type` query parameter. Defaults to `object_id`.",  # noqa: E501
    ],
    object_type_identifier: Annotated[
        int,
        "The ID representing the object type, such as 'Companies' or 'Accounts'. Starts from 1 and increments for each new type.",  # noqa: E501
    ],
    identification_type: Annotated[
        str | None,
        "Specifies whether the object identifier is an `object_id` or a `cio_object_id`. Choose between these two options.",  # noqa: E501
    ] = "object_id",
    maximum_results_per_page: Annotated[
        int | None, "The maximum number of results to retrieve per page. Specify an integer value."
    ] = None,
    pagination_start_token: Annotated[
        str | None,
        "Token for starting the page of results. Use the 'next' property from a response to paginate.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getObjectRelationships'."]:
    """Retrieve people related to a specified object.

    Use this tool to get a list of people related to a specific object by providing the object type and object ID. Useful for exploring object relationships in Customerio."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/objects/{object_type_id}/{object_id}/relationships".format(  # noqa: UP032
            object_type_id=object_type_identifier, object_id=object_identifier
        ),
        method="GET",
        params=remove_none_values({
            "start": pagination_start_token,
            "limit": maximum_results_per_page,
            "id_type": identification_type,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_object_attributes(
    context: ToolContext,
    object_identifier: Annotated[
        str,
        "The unique identifier for the object, which can be either `object_id` or `cio_object_id`, depending on the id_type specified in query params.",  # noqa: E501
    ],
    object_type_identifier: Annotated[
        int,
        "The ID representing the object type, beginning at 1 for each new type, like 'Companies' or 'Accounts'.",  # noqa: E501
    ],
    object_id_type: Annotated[
        str | None, "Specify the type of ID used for the object: 'object_id' or 'cio_object_id'."
    ] = "object_id",
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getObjectAttributes'."]:
    """Retrieve a list of attributes for a specific object.

    Use this tool to get attributes of an object, such as account name, billing date, etc., by specifying the object type and ID."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/objects/{object_type_id}/{object_id}/attributes".format(  # noqa: UP032
            object_type_id=object_type_identifier, object_id=object_identifier
        ),
        method="GET",
        params=remove_none_values({"id_type": object_id_type}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def create_webhook(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'createWebhook'."]:
    """Create a new webhook configuration for reporting.

    Use this tool to set up a new webhook configuration within the Customerio service for reporting purposes.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["CREATEWEBHOOK"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATEWEBHOOK"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATEWEBHOOK"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.customer.io/v1/reporting_webhooks",
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["CREATEWEBHOOK"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def list_reporting_webhooks(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listWebhooks'."]:
    """Retrieve a list of reporting webhooks.

    Use this tool to get a list of all reporting webhooks configured in your Customerio account. It should be called when you need to access or manage existing reporting webhooks."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/reporting_webhooks",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_webhook_info(
    context: ToolContext,
    webhook_identifier: Annotated[
        int,
        "The unique identifier of the webhook you want to retrieve information for. This should be an integer.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getWebhook'."]:
    """Get detailed information about a specific webhook.

    This tool retrieves information about a specific reporting webhook from Customerio. It should be called when you need details about a particular webhook identified by its webhook ID."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/reporting_webhooks/{webhook_id}".format(  # noqa: UP032
            webhook_id=webhook_identifier
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def update_reporting_webhook(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    webhook_identifier: Annotated[
        int | None,
        "The unique identifier for the specific webhook to be updated.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'updateWebhook'."]:
    """Update the configuration of a reporting webhook.

    Use this tool to modify the settings of a reporting webhook, such as enabling or disabling events or changing the webhook URL.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["UPDATEREPORTINGWEBHOOK"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not webhook_identifier:
        missing_params.append(("webhook_identifier", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(f"Required parameters validation failed: {param_details}"),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPDATEREPORTINGWEBHOOK"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPDATEREPORTINGWEBHOOK"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.customer.io/v1/reporting_webhooks/{webhook_id}".format(  # noqa: UP032
            webhook_id=webhook_identifier
        ),
        method="PUT",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["UPDATEREPORTINGWEBHOOK"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def delete_reporting_webhook(
    context: ToolContext,
    webhook_identifier: Annotated[
        int, "The unique identifier for the reporting webhook to be deleted."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteWebhook'."]:
    """Delete a reporting webhook's configuration.

    Use this tool to remove the configuration of a specific reporting webhook by its ID. Call this when a webhook is no longer needed and should be deleted from the setup."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/reporting_webhooks/{webhook_id}".format(  # noqa: UP032
            webhook_id=webhook_identifier
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def create_manual_segment(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'createManSegment'."]:
    """Create a manual segment with name and description.

    Use this tool to create an empty manual segment by specifying its name and description. Ideal for organizing contacts or data into new categories.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["CREATEMANUALSEGMENT"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATEMANUALSEGMENT"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATEMANUALSEGMENT"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.customer.io/v1/segments",
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["CREATEMANUALSEGMENT"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_all_segments(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listSegments'."]:
    """Retrieve a list of all segments for your account.

    Call this tool to get a list of all segments associated with your Customerio account. Use it to fetch and review segment data."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/segments",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_segment_info(
    context: ToolContext,
    segment_identifier: Annotated[
        int, "The ID for a segment. Find this on its page in the dashboard or using the App API."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getSegment'."]:
    """Retrieve information about a specific segment.

    This tool retrieves detailed information about a specific segment using its segment ID. It should be called when segment information is needed for analysis or decision-making."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/segments/{segment_id}".format(  # noqa: UP032
            segment_id=segment_identifier
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def delete_manual_segment(
    context: ToolContext,
    segment_identifier: Annotated[
        int,
        "The ID of the segment to delete, found under 'Usage' in the Segment page on the dashboard or via the App API.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteManSegment'."]:
    """Delete a specified manual segment by ID.

    Use this tool to delete a specific manual segment in Customerio by providing the segment ID. It's useful for removing outdated or unwanted segments."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/segments/{segment_id}".format(  # noqa: UP032
            segment_id=segment_identifier
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def find_segment_dependencies(
    context: ToolContext,
    segment_identifier: Annotated[
        int, "The ID for a segment, found on its dashboard page or via the App API."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getSegmentDependencies'."]:
    """Identify campaigns and newsletters using a segment.

    This tool identifies which campaigns and newsletters are utilizing a specified segment in Customerio. It should be called when you need to determine the dependencies of a segment within your marketing strategies."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/segments/{segment_id}/used_by".format(  # noqa: UP032
            segment_id=segment_identifier
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_segment_customer_count(
    context: ToolContext,
    segment_id: Annotated[
        int,
        "The unique identifier for the segment to retrieve the customer count. Find this ID on the segment's page or via the App API.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getSegmentCount'."]:
    """Retrieve the customer count for a specific segment.

    Use this tool to obtain the number of customers belonging to a particular segment identified by segment_id. This can help in analyzing segment size and its potential impact."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/segments/{segment_id}/customer_count".format(  # noqa: UP032
            segment_id=segment_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_segment_members(
    context: ToolContext,
    segment_identifier: Annotated[
        int,
        "The unique identifier for a segment. Find this ID on the segment's page in the dashboard, under *Usage*.",  # noqa: E501
    ],
    maximum_results_per_page: Annotated[
        int | None, "Specify the maximum number of customer identifiers to retrieve per page."
    ] = 1000,
    pagination_token: Annotated[
        str | None,
        "Token to specify the start of the page of results. Use the `next` value from a previous response to paginate.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getSegmentMembership'."]:
    """Retrieve customer details from a specific segment.

    Use this tool to get a list of customer identifiers in a specified segment. It returns identifiers for each person in the segment, providing more comprehensive information than just IDs. Useful for understanding customer segmentation."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/segments/{segment_id}/membership".format(  # noqa: UP032
            segment_id=segment_identifier
        ),
        method="GET",
        params=remove_none_values({"start": pagination_token, "limit": maximum_results_per_page}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_sender_list(
    context: ToolContext,
    max_results_per_page: Annotated[
        int | None,
        "The maximum number of sender results to retrieve per page. Specify an integer value.",
    ] = None,
    pagination_token: Annotated[
        str | None,
        "Token for the page of results to return. Use the `next` property from the response for pagination.",  # noqa: E501
    ] = None,
    results_sort_order: Annotated[
        str | None, "Sort results: 'asc' for chronological, 'desc' for reverse chronological order."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listSenders'."]:
    """Retrieve a list of senders from your workspace.

    This tool retrieves a list of senders in your workspace, representing the identities from which messages are sent. Use this to manage or display sender information."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/sender_identities",
        method="GET",
        params=remove_none_values({
            "start": pagination_token,
            "limit": max_results_per_page,
            "sort": results_sort_order,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_sender_info(
    context: ToolContext,
    sender_identifier: Annotated[
        int, "The unique identifier for a sender, required to fetch their information."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getSender'."]:
    """Retrieve information about a specific sender by ID.

    Use this tool to get detailed information for a specific sender using their ID, which is helpful for email management and verification processes."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/sender_identities/{sender_id}".format(  # noqa: UP032
            sender_id=sender_identifier
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_sender_usage(
    context: ToolContext,
    sender_identifier: Annotated[
        int,
        "The unique identifier for the sender to retrieve associated campaigns and newsletters.",
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getSenderUsage'."]:
    """Retrieve campaigns and newsletters using a specific sender.

    Use this tool to obtain lists of campaigns and newsletters that utilize a particular sender identity. It provides insights into where a sender is actively used, helping in managing and analyzing sender strategies."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/sender_identities/{sender_id}/used_by".format(  # noqa: UP032
            sender_id=sender_identifier
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def list_snippets_workspace(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listSnippets'."]:
    """Retrieve a list of reusable content snippets from your workspace.

    Use this tool to obtain snippets, such as common footers, which are reusable content pieces in your workspace."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/snippets",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def update_or_create_snippet(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'updateSnippets'."]:
    """Update or create a snippet with a unique name.

    Use this tool to update an existing snippet or create a new one. Pass a unique `name` and corresponding `value`. If the snippet already exists, its value will be updated; otherwise, a new snippet will be created.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["UPDATEORCREATESNIPPET"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPDATEORCREATESNIPPET"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPDATEORCREATESNIPPET"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.customer.io/v1/snippets",
        method="PUT",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["UPDATEORCREATESNIPPET"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def remove_unused_snippet(
    context: ToolContext,
    snippet_name: Annotated[
        str, "The name of the snippet to be removed. Must be unused to avoid errors."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteSnippet'."]:
    """Removes an unused snippet from the system.

    This tool removes a snippet that is not in use. If the snippet is currently in use, an error will be returned."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/snippets/{snippet_name}".format(snippet_name=snippet_name),  # noqa: UP032
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_subscription_topics(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getTopics'."]:
    """Retrieve subscription topics from your workspace.

    Use this tool to get the list of all subscription topics available in your workspace. It will return an empty array if no topics exist."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/subscription_topics",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def list_transactional_messages(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listTransactional'."]:
    """Retrieve your list of transactional message IDs.

    This tool retrieves a list of your transactional message IDs used for triggering individual deliveries. It does not include delivery instances themselves."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/transactional",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_transactional_message(
    context: ToolContext,
    transactional_message_id: Annotated[
        int,
        "The ID of the transactional message, found in the UI or URL, e.g., `/transactional/3/templates/139` has an ID of 3.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getTransactional'."]:
    """Retrieve details of a transactional message.

    Call this tool to get information about an individual transactional message using its ID."""
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/transactional/{transactional_id}".format(  # noqa: UP032
            transactional_id=transactional_message_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_transactional_message_variants(
    context: ToolContext,
    transactional_message_id: Annotated[
        int,
        "The ID of the transactional message, found in the UI or URL, e.g., `/transactional/3/templates/139` means ID is 3.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listTransactionalVariants'."]:
    """Retrieve content variants of a transactional message.

    This tool is used to obtain the different language variants of a transactional message's content. It should be called when you need to access the available language or format options for a specific message."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/transactional/{transactional_id}/contents".format(  # noqa: UP032
            transactional_id=transactional_message_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def update_transactional_email(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    transactional_email_id: Annotated[
        int | None,
        "The ID of your transactional email. Found in the UI or URL of the transactional message.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    content_variant_id: Annotated[
        int | None,
        "The unique identifier for the specific content version of your transactional email, found in the message URL.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'updateTransactional'."]:
    """Overwrite a transactional email's body with new content.

    Use this tool to update and fully overwrite the body of an existing transactional email. Ensure the updated content is tested as it will affect all future transactional email requests.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["UPDATETRANSACTIONALEMAIL"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not transactional_email_id:
        missing_params.append(("transactional_email_id", "path"))
    if not content_variant_id:
        missing_params.append(("content_variant_id", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(f"Required parameters validation failed: {param_details}"),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPDATETRANSACTIONALEMAIL"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPDATETRANSACTIONALEMAIL"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.customer.io/v1/transactional/{transactional_id}/content/{content_id}".format(  # noqa: UP032
            transactional_id=transactional_email_id, content_id=content_variant_id
        ),
        method="PUT",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["UPDATETRANSACTIONALEMAIL"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_transactional_variant(
    context: ToolContext,
    language_tag: Annotated[
        str,
        "Specify the language tag for the message variant. Use an empty string for the default language. If the variant does not exist, an error is returned.",  # noqa: E501
    ],
    transactional_message_id: Annotated[
        int,
        "The identifier of the transactional message, found in the UI or URL, e.g., `/transactional/3/templates/139` has an ID of 3.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getTransactionalVariant'."]:
    """Fetch translation details of a transactional message.

    Use this tool to obtain details about a translation of a specific transactional message, including its content. It's useful when you need to access different language variants of transactional messages."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/transactional/{transactional_id}/language/{language}".format(  # noqa: UP032
            transactional_id=transactional_message_id, language=language_tag
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def update_transactional_message_variant(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    transactional_message_id: Annotated[
        int | None,
        "The identifier of the transactional message. Found in the UI or URL of the message, e.g., `/transactional/3/templates/139` where the ID is 3.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    language_tag: Annotated[
        str | None,
        "Specify a language tag for a language variant. If not provided, default language is used. Errors if variant does not exist.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'updateTransactionalVariant'."]:
    """Fully update a language variant of a transactional message.

    Use this tool to overwrite the body and details of a specific language variant for an existing transactional message. This is useful for ensuring the message content is up-to-date and accurate across different languages.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["UPDATETRANSACTIONALMESSAGEVARIANT"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not transactional_message_id:
        missing_params.append(("transactional_message_id", "path"))
    if not language_tag:
        missing_params.append(("language_tag", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(f"Required parameters validation failed: {param_details}"),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["UPDATETRANSACTIONALMESSAGEVARIANT"]
                + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["UPDATETRANSACTIONALMESSAGEVARIANT"]
                + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.customer.io/v1/transactional/{transactional_id}/language/{language}".format(  # noqa: UP032
            transactional_id=transactional_message_id, language=language_tag
        ),
        method="PUT",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["UPDATETRANSACTIONALMESSAGEVARIANT"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_transactional_message_metrics(
    context: ToolContext,
    transactional_message_id: Annotated[
        int,
        "The identifier of the transactional message. Found in the UI or URL, e.g., `/transactional/3/templates/139` means an ID of 3.",  # noqa: E501
    ],
    number_of_periods: Annotated[
        int | None,
        "The number of periods to retrieve metrics for. Defaults to the maximum available, or 12 if the period is in months. Maximums are 24 hours, 45 days, 12 weeks, or 121 months. Days start at 00:00 EST. Weeks start at 00:00 EST on Sunday. Months start at 00:00 EST on the 1st of the month.",  # noqa: E501
    ] = None,
    time_unit_for_report: Annotated[
        str | None,
        "Specify the unit of time for the report, such as 'hours', 'days', 'weeks', or 'months'.",
    ] = "days",
) -> Annotated[dict[str, Any], "Response from the API endpoint 'transactionalMetrics'."]:
    """Retrieve metrics for a transactional message over time periods.

    This tool retrieves metrics for a specified transactional message across defined time steps. It is useful for analyzing message performance over days, weeks, etc., from the oldest to the newest period."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/transactional/{transactional_id}/metrics".format(  # noqa: UP032
            transactional_id=transactional_message_id
        ),
        method="GET",
        params=remove_none_values({"period": time_unit_for_report, "steps": number_of_periods}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_transactional_link_metrics(
    context: ToolContext,
    transactional_message_id: Annotated[
        int,
        "The identifier for the transactional message, found in the UI or URL (e.g., in `/transactional/3/templates/139`, the ID is 3).",  # noqa: E501
    ],
    include_only_unique_customers: Annotated[
        bool | None,
        "Return only unique customer results if true; false includes all click instances.",
    ] = False,
    number_of_periods: Annotated[
        int | None,
        "Specify the number of periods to return metrics for. Cannot be fewer than 2 periods. Defaults to the maximum available, or 12 if the period is in months. Maximums: 24 hours, 45 days, 12 weeks, or 121 months.",  # noqa: E501
    ] = None,
    time_unit_for_report: Annotated[
        str | None, "The unit of time for the report. Options are: hours, days, weeks, or months."
    ] = "days",
) -> Annotated[dict[str, Any], "Response from the API endpoint 'transactionalLinks'."]:
    """Retrieve metrics for clicked links in transactional messages.

    This tool returns metrics for links clicked from a transactional message, including totals and metrics over specified time periods. Useful for analyzing link engagement trends over days, weeks, etc. Cannot request fewer than two periods (e.g., days or weeks)."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/transactional/{transactional_id}/metrics/links".format(  # noqa: UP032
            transactional_id=transactional_message_id
        ),
        method="GET",
        params=remove_none_values({
            "period": time_unit_for_report,
            "steps": number_of_periods,
            "unique": include_only_unique_customers,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_transactional_message_deliveries(
    context: ToolContext,
    transactional_message_id: Annotated[
        int,
        "The unique identifier for the transactional message, found in the UI or URL, e.g., '/transactional/3/templates/139' where the ID is 3.",  # noqa: E501
    ],
    beginning_timestamp: Annotated[
        int | None,
        "The start time for the query, specified as a Unix timestamp. Limits the query to data starting from this time.",  # noqa: E501
    ] = None,
    broadcast_state: Annotated[
        str | None,
        "Specifies the state of the broadcast to filter results. Options are 'failed', 'sent', 'drafted', or 'attempted'.",  # noqa: E501
    ] = None,
    max_results_per_page: Annotated[
        int | None, "The maximum number of results to return per page, as an integer."
    ] = None,
    page_token: Annotated[
        str | None,
        "Specify the token for the page of results you want to return. Use the `next` property from previous responses as the value to paginate.",  # noqa: E501
    ] = None,
    query_ending_timestamp: Annotated[
        int | None,
        "The ending timestamp for the query, determining the end of the time range for message data retrieval.",  # noqa: E501
    ] = None,
    return_metrics: Annotated[
        str | None,
        "Specify one or more metrics to return, such as 'sent', 'delivered', or 'clicked'.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'transactionalMessages'."]:
    """Fetch delivery details for transactional messages.

    Retrieve information about individual message deliveries from a transactional message. Use optional parameters to specify a time range for the message data, otherwise, data from the last 6 months is returned by default."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/transactional/{transactional_id}/messages".format(  # noqa: UP032
            transactional_id=transactional_message_id
        ),
        method="GET",
        params=remove_none_values({
            "start": page_token,
            "limit": max_results_per_page,
            "metric": return_metrics,
            "state": broadcast_state,
            "start_ts": beginning_timestamp,
            "end_ts": query_ending_timestamp,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def list_workspaces(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listWorkspaces'."]:
    """Retrieve a list of workspaces in your account.

    Use this tool to get information about all workspaces available in your Customerio account. It provides a list that can be used to view or manage workspaces."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/workspaces",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def create_new_collection(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'addCollection'."]:
    """Create a new data collection in Customerio.

    Use this tool to create a new collection in Customerio by either providing direct data or a URL for downloading CSV or JSON data. Ensure the collection does not exceed 10 MB, and individual rows are under 10 KB.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["CREATENEWCOLLECTION"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATENEWCOLLECTION"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATENEWCOLLECTION"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.customer.io/v1/collections",
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["CREATENEWCOLLECTION"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def list_collections(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getCollections'."]:
    """Retrieve a list of all collections including names and schemas.

    Use this tool to obtain all existing collections, providing both their names and schemas. Useful for managing database structures or viewing collection configurations."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/collections",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def retrieve_collection_details(
    context: ToolContext,
    collection_identifier: Annotated[
        int, "The unique identifier for a specific collection to retrieve its details."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getCollection'."]:
    """Retrieve details about a specific collection.

    This tool retrieves information about a collection, including its schema and name, without including the content of the collection. It should be used when you need information about the structure and title of a collection."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/collections/{collection_id}".format(  # noqa: UP032
            collection_id=collection_identifier
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def delete_collection(
    context: ToolContext,
    collection_id: Annotated[int, "The unique identifier for the collection to be deleted."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteCollection'."]:
    """Delete a collection and its contents.

    Use this tool to remove a collection and all its contents from the system. Ensure the collection is not referenced in active campaign messages or broadcasts to avoid disrupting communication."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/collections/{collection_id}".format(  # noqa: UP032
            collection_id=collection_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def update_collection_info(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    collection_identifier: Annotated[
        int | None,
        "The unique identifier for the collection to be updated.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'updateCollection'."]:
    """Update collection name or replace its contents in Customerio.

    Use this tool to update the name or fully replace the contents of a specific collection in Customerio. Be careful when changing the collection name if it's referenced in active campaigns, as it will cause the references to return an empty data set. Ensure the collection size is within 10 MB and individual rows are no more than 10 KB.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["UPDATECOLLECTIONINFO"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not collection_identifier:
        missing_params.append(("collection_identifier", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(f"Required parameters validation failed: {param_details}"),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPDATECOLLECTIONINFO"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPDATECOLLECTIONINFO"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.customer.io/v1/collections/{collection_id}".format(  # noqa: UP032
            collection_id=collection_identifier
        ),
        method="PUT",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["UPDATECOLLECTIONINFO"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def retrieve_collection_contents(
    context: ToolContext,
    collection_identifier: Annotated[
        int, "The unique identifier for the collection to retrieve contents from."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getCollectionContents'."]:
    """Retrieve contents of a specified collection.

    Use this tool to fetch the data stored in a specific collection on the Customerio platform. It returns each row as a JSON object, ideal for accessing stored information quickly."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/collections/{collection_id}/content".format(  # noqa: UP032
            collection_id=collection_identifier
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def replace_collection_contents(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    collection_identifier: Annotated[
        int | None,
        "The unique identifier for the collection whose contents are being replaced. This is required for identifying the specific collection to update.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'updateCollectionContents'."]:
    """Replace the entire contents of a data collection.

    Use this tool to completely replace the existing contents of a data collection by specifying the new keys and values. Ideal for cases where a full update is required. Keep in mind the size limitations: collections must not exceed 10 MB and no single row more than 10 KB.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["REPLACECOLLECTIONCONTENTS"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not collection_identifier:
        missing_params.append(("collection_identifier", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(f"Required parameters validation failed: {param_details}"),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["REPLACECOLLECTIONCONTENTS"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["REPLACECOLLECTIONCONTENTS"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.customer.io/v1/collections/{collection_id}/content".format(  # noqa: UP032
            collection_id=collection_identifier
        ),
        method="PUT",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["REPLACECOLLECTIONCONTENTS"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_people_by_email(
    context: ToolContext,
    search_email_address: Annotated[
        str,
        "The email address to find in the workspace. Returns a list of individuals matching this email.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getPeopleEmail'."]:
    """Retrieve a list of people matching an email address.

    Use this tool to find people in your workspace based on their email address. It returns a list of individuals matching the specified email."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/customers",
        method="GET",
        params=remove_none_values({"email": search_email_address}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def filter_people_in_workspace(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    page_start_token: Annotated[
        str | None,
        "The token for the page of results to return. Use the 'next' property from responses as this value to access subsequent pages.  Only used when mode is 'execute'.",  # noqa: E501
    ] = None,
    results_per_page_limit: Annotated[
        int | None,
        "Specify the maximum number of people to retrieve per page. Limited to 1000.  Only used when mode is 'execute'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getPeopleFilter'."]:
    """Filter and search for people in your workspace.

    Use this tool to filter people by segment ID and attribute values using complex filters such as `and`, `or`, and `not`. The tool returns arrays of `identifiers` with detailed information and `ids` with only ID values. Suitable for retrieving up to 1000 people per request.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires query parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required query parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["FILTERPEOPLEINWORKSPACE"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required query parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["FILTERPEOPLEINWORKSPACE"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["FILTERPEOPLEINWORKSPACE"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.customer.io/v1/customers",
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["FILTERPEOPLEINWORKSPACE"],
        params=remove_none_values({"start": page_start_token, "limit": results_per_page_limit}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_customer_profile_attributes(
    context: ToolContext,
    customer_identifier: Annotated[
        str, "The unique identifier of the customer to fetch their profile attributes."
    ],
    customer_id_type: Annotated[
        str | None,
        "Specifies the type of `customer_id` to reference a person. Options: 'id', 'email', 'cio_id'. Default is 'id' if not provided.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getPersonAttributes'."]:
    """Retrieve a customer's profile attributes.

    This tool fetches a list of attributes for a specified customer profile. Useful for creating segments or using in message templates."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/customers/{customer_id}/attributes".format(  # noqa: UP032
            customer_id=customer_identifier
        ),
        method="GET",
        params=remove_none_values({"id_type": customer_id_type}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_person_relationships(
    context: ToolContext,
    customer_id: Annotated[
        str, "The unique identifier for the customer whose relationships you wish to retrieve."
    ],
    max_results_per_page: Annotated[
        int | None, "The maximum number of results to retrieve per page."
    ] = None,
    pagination_start_token: Annotated[
        str | None,
        "Token to specify the page of results to return. Use the `next` property's value from a previous response to get subsequent pages.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getPersonRelationships'."]:
    """Retrieve a list of objects a person is related to.

    Use this tool to obtain a list of relationships associated with a specific person. It supports pagination for retrieving results in multiple pages. Note that duplicates may appear across pages."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/customers/{customer_id}/relationships".format(  # noqa: UP032
            customer_id=customer_id
        ),
        method="GET",
        params=remove_none_values({"start": pagination_start_token, "limit": max_results_per_page}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_customer_info(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getPeopleById'."]:
    """Retrieve attributes and devices for specified customers by ID.

    Use this tool to get detailed attributes and devices information for up to 100 customers by their IDs. If a provided ID does not exist, it will be omitted in the response.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["GETCUSTOMERINFO"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["GETCUSTOMERINFO"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["GETCUSTOMERINFO"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.customer.io/v1/customers/attributes",
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["GETCUSTOMERINFO"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_customer_segments(
    context: ToolContext,
    customer_identifier: Annotated[
        str, "The unique ID of the customer for segment retrieval in Customerio."
    ],
    customer_id_type: Annotated[
        str | None,
        "Specifies the type of customer identifier to use ('id', 'email', or 'cio_id'). Default is 'id'.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getPersonSegments'."]:
    """Retrieve segments of a specific customer from Customerio.

    Use this tool to get a list of segments that a specified customer profile is a part of. This can be useful for understanding customer categorization and targeting within the Customerio platform."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/customers/{customer_id}/segments".format(  # noqa: UP032
            customer_id=customer_identifier
        ),
        method="GET",
        params=remove_none_values({"id_type": customer_id_type}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def retrieve_customer_messages(
    context: ToolContext,
    customer_identifier: Annotated[
        str, "The unique ID of the customer whose message deliveries you want to retrieve."
    ],
    customer_id_type: Annotated[
        str | None,
        "Specifies the type of customer_id used to reference a person. Options: 'id', 'email', 'cio_id'. Defaults to 'id' if not provided.",  # noqa: E501
    ] = None,
    max_results_per_page: Annotated[
        int | None,
        "The maximum number of results to retrieve per page. This limits the number of messages returned in a single response.",  # noqa: E501
    ] = 50,
    pagination_token: Annotated[
        str | None,
        "Token for the page of results to return. Use the `next` property from previous responses to get the next page.",  # noqa: E501
    ] = None,
    query_end_timestamp: Annotated[
        int | None,
        "The ending timestamp (in integer format) for the query to limit data retrieval to specific time ranges.",  # noqa: E501
    ] = None,
    starting_timestamp: Annotated[
        int | None,
        "The beginning timestamp for the query in integer format, used to filter messages by start date.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getPersonMessages'."]:
    """Retrieve deliveries sent to a customer within a time range.

    Use parameters to specify the time range for the messages you want to retrieve. If no time range is provided, it defaults to the most recent 6 months. The tool returns data on when deliveries were created, which may differ from when they were sent."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/customers/{customer_id}/messages".format(  # noqa: UP032
            customer_id=customer_identifier
        ),
        method="GET",
        params=remove_none_values({
            "id_type": customer_id_type,
            "start": pagination_token,
            "limit": max_results_per_page,
            "start_ts": starting_timestamp,
            "end_ts": query_end_timestamp,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_customer_activities(
    context: ToolContext,
    customer_id: Annotated[
        str, "The unique identifier for the customer whose activities you want to retrieve."
    ],
    activity_type_filter: Annotated[
        str | None,
        "Filter activities by specific type, such as 'add_relationship' or 'attribute_change'.",
    ] = None,
    customer_id_type: Annotated[
        str | None,
        "Specify the type of `customer_id` used to reference a person (e.g., `id`, `email`, or `cio_id`). Defaults to `id` if unspecified.",  # noqa: E501
    ] = None,
    event_or_attribute_name: Annotated[
        str | None,
        "Specify the event or attribute name to search for within activities of type `event` or `attribute_update`.",  # noqa: E501
    ] = None,
    max_results_per_page: Annotated[
        int | None, "Specify the maximum number of activity results to retrieve per page."
    ] = 10,
    start_token: Annotated[
        str | None,
        "Token to specify which page of results to return. Use the `next` property from a previous response.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getPersonActivities'."]:
    """Retrieve recent activities for a customer.

    This tool returns a list of activities performed by or for a specified customer, such as attribute changes and message sends. It provides activity history from the past 30 days, with potential inclusion of older data."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/customers/{customer_id}/activities".format(  # noqa: UP032
            customer_id=customer_id
        ),
        method="GET",
        params=remove_none_values({
            "id_type": customer_id_type,
            "start": start_token,
            "limit": max_results_per_page,
            "type": activity_type_filter,
            "name": event_or_attribute_name,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["CUSTOMERIO_API_KEY"])
async def get_subscription_preferences(
    context: ToolContext,
    customer_identifier: Annotated[
        str, "The ID of the customer to retrieve subscription preferences for."
    ],
    accept_language: Annotated[
        str | None,
        "Language tag for translating content. If not specified, defaults to the subscription center's language.",  # noqa: E501
    ] = None,
    customer_id_type: Annotated[
        str | None,
        "Type of customer_id used to reference a person, e.g., 'id', 'email', or 'cio_id'. Defaults to 'id'.",  # noqa: E501
    ] = None,
    translation_language: Annotated[
        str | None,
        "Specify the language tag for translating the subscription preferences content. If not provided, the default language is used.",  # noqa: E501
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'getPersonSubscriptionPreferences'."
]:
    """Retrieve a person's subscription preferences.

    Returns a list of a person's subscription preferences, including headers, topic names, and descriptions. The data is translated if a language is specified in the query."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.customer.io/v1/customers/{customer_id}/subscription_preferences".format(  # noqa: UP032
            customer_id=customer_identifier
        ),
        method="GET",
        params=remove_none_values({"id_type": customer_id_type, "language": translation_language}),
        headers=remove_none_values({
            "Accept-Language": accept_language,
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("CUSTOMERIO_API_KEY")
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}
