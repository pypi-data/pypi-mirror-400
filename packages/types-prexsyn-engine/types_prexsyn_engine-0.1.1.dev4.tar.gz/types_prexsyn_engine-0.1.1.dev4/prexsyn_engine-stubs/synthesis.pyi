import enum
from collections.abc import Sequence
from typing import TypeAlias, overload

from .types import Mol, MolSet, Reaction

class PostfixNotationItemType(enum.Enum):
    Molecule = ...
    Reaction = ...

class PostfixNotation:
    def __init__(self) -> None: ...
    def type(self, index: int) -> PostfixNotationItemType: ...
    def append_mol(self, mol: Mol) -> None: ...
    def append_reaction(self, reaction: Reaction) -> None: ...
    def extend(self, other: "PostfixNotation") -> None: ...
    def __getitem__(self, index: int) -> Mol | Reaction: ...
    def __len__(self) -> int: ...
    def to_list(self) -> list[Mol | Reaction]: ...
    def count_reactions(self) -> int: ...
    def count_building_blocks(self) -> int: ...

class PushReactionException: ...

MolSetVector: TypeAlias = Sequence[MolSet]

class Synthesis:
    def __init__(self) -> None: ...
    def get_postfix_notation(self) -> PostfixNotation: ...
    def get_stack(self) -> MolSetVector: ...
    def push_mol(self, mol: Mol) -> None: ...
    def push_reaction(self, reaction: Reaction, max_products: int = 8) -> None: ...
    def push_synthesis(self, synthesis: "Synthesis") -> None: ...
    def top(self, index: int = 0) -> MolSet: ...
    def stack_size(self) -> int: ...
    def count_reactions(self) -> int: ...
    def count_building_blocks(self) -> int: ...

class SynthesisVector(Sequence[Synthesis]):
    @overload
    def __getitem__(self, index: int) -> Synthesis: ...
    @overload
    def __getitem__(self, index: slice) -> list[Synthesis]: ...
    def __len__(self) -> int: ...
    def get_all_products(self) -> tuple[list[Mol], list[int]]: ...
