#version 430 core

/*
 * ============================================================================
 * PHYSICS ENGINE COMPUTE SHADER - RESEARCH GRADE
 * Extended complex math support + stable integrator + momentum-conserving collision system
 * ============================================================================
 */

layout(local_size_x = 16, local_size_y = 1, local_size_z = 1) in;

// ============================================================================
// DATA STRUCTURES (std430 layout)
// ============================================================================

struct Object {
    vec2 position;           // World position (x, y)
    vec2 velocity;           // Velocity vector (vx, vy)
    float mass;              // Object mass
    float charge;            // Electrical charge
    int visualSkinType;      // Rendering skin type
    int collisionShapeType;  // Collision shape type
    vec4 visualData;         // Visual properties (.x=width/radius, .y=height/sides, .z=rotation, .w=angular velocity)
    vec4 collisionData;      // Collision data (.x=last ax, .y=last ay, .z/.w=user data)
    vec4 color;              // RGBA color
    int equationID;          // ID of physics equation to use
    int _pad1;               // Padding
    int _padEnd[2];          // Additional padding
};

struct EquationMapping {
    int tokenOffset_ax;      int tokenCount_ax;      int constantOffset_ax;      int _pad1;
    int tokenOffset_ay;      int tokenCount_ay;      int constantOffset_ay;      int _pad2;
    int tokenOffset_angular; int tokenCount_angular; int constantOffset_angular; int _pad3;
    int tokenOffset_r;       int tokenCount_r;       int constantOffset_r;       int _pad4;
    int tokenOffset_g;       int tokenCount_g;       int constantOffset_g;       int _pad5;
    int tokenOffset_b;       int tokenCount_b;       int constantOffset_b;       int _pad6;
    int tokenOffset_a;       int tokenCount_a;       int constantOffset_a;       int _pad7;
};

struct Constraint {
    int type;                // Constraint type (distance, boundary, angle)
    int targetObjectID;      // Target object ID (for distance/angle constraints)
    float param1;            // Parameter 1 (distance/boundary min/angle min)
    float param2;            // Parameter 2 (boundary max/angle max)
    float param3;            // Parameter 3 (boundary min y)
    float param4;            // Parameter 4 (boundary max y)
    int _pad1;
    int _pad2;
};

struct ObjectConstraints {
    int objectID;            // Object ID this mapping belongs to
    int numConstraints;      // Number of constraints for this object
    int constraintOffset;    // Offset into global constraint array
    int _pad;                // Padding
};

// ============================================================================
// COLLISION SYSTEM STRUCTURES
// ============================================================================

struct CollisionProperties {
    int enabled;             // Whether collisions are enabled (0/1)
    int shapeType;           // Collision shape type (1=circle, 2=AABB, 3=polygon)
    float restitution;       // Bounciness coefficient (0.0-1.0)
    float friction;          // Friction coefficient (0.0-1.0)
    float mass_factor;       // Mass scaling factor
    int _pad1;
    int _pad2;
    int _pad3;
};

struct CollisionInfo {
    bool hasCollision;       // Whether a collision occurred
    vec2 normal;             // Collision normal (direction from A to B)
    float penetration;       // Penetration depth
    int otherObjectID;       // ID of the other object
};

// ============================================================================
// NEW: CONTACT POINT STRUCTURE FOR WARM STARTING
// ============================================================================

struct ContactPoint {
    vec2 normal;             // Contact normal (from A to B)
    vec2 position;           // Contact position in world space
    float penetration;       // Penetration depth
    float accumulatedNormalImpulse;  // Accumulated impulse for warm starting
    float accumulatedTangentImpulse; // Accumulated friction impulse
    int frameCount;          // How many frames this contact has been active
};

// ============================================================================
// SHADER STORAGE BUFFERS (SSBOs)
// ============================================================================

layout(std430, binding = 0) readonly buffer ObjectsIn { Object objectsIn[]; };
layout(std430, binding = 1) writeonly buffer ObjectsOut { Object objectsOut[]; };
layout(std430, binding = 2) readonly buffer AllEquationTokens { int allTokens[]; };
layout(std430, binding = 3) readonly buffer AllEquationConstants { float allConstants[]; };
layout(std430, binding = 4) readonly buffer EquationMappings { EquationMapping mappings[256]; };
layout(std430, binding = 5) readonly buffer Constraints { Constraint constraints[]; };
layout(std430, binding = 6) readonly buffer ObjectConstraintMappings { ObjectConstraints objectConstraints[]; };
layout(std430, binding = 7) readonly buffer CollisionProps { CollisionProperties collisionProps[]; };
// NEW: Contact persistence buffer for warm starting
layout(std430, binding = 8) buffer ContactBuffer { ContactPoint contacts[]; };

// ============================================================================
// UNIFORMS (External Parameters)
// ============================================================================

uniform float uDt;           // Time step (delta time)
uniform float uTime;         // Current simulation time
uniform float k;             // Spring constant
uniform float b;             // Damping coefficient
uniform float g;             // Gravity strength
uniform vec2 uGravityDir;    // Gravity direction vector
uniform float uRestitution;  // Global restitution (bounciness)
uniform float uCoupling;     // Coupling strength between objects
uniform vec2 uExternalForce; // External force applied to all objects
uniform float uDriveFreq;    // Driving force frequency
uniform float uDriveAmp;     // Driving force amplitude
uniform int uEquationMode;   // Equation mode (0=custom, 1=default)
uniform int uNumObjects;     // Current number of active objects
// NEW: Collision system parameters
uniform int uEnableWarmStart;// Enable contact warm starting (0/1)
uniform int uMaxContactIterations; // Max iterations for contact resolution

// ============================================================================
// CONSTANTS
// ============================================================================

// Token types for RPN evaluation
const int TOKEN_NUMBER = 0;
const int TOKEN_VARIABLE = 1;
const int TOKEN_OBJECT_REF = 2;
const int TOKEN_ADD = 3;
const int TOKEN_SUB = 4;
const int TOKEN_MUL = 5;
const int TOKEN_DIV = 6;
const int TOKEN_NEG = 7;
const int TOKEN_POW = 8;
const int TOKEN_SIN = 9;
const int TOKEN_COS = 10;
const int TOKEN_TAN = 11;
const int TOKEN_SQRT = 12;
const int TOKEN_LOG = 13;
const int TOKEN_EXP = 14;
const int TOKEN_ABS = 15;
const int TOKEN_MIN = 16;
const int TOKEN_MAX = 17;
const int TOKEN_CLAMP = 18;
const int TOKEN_FLOOR = 19;
const int TOKEN_CEIL = 20;
const int TOKEN_FRAC = 21;
const int TOKEN_MOD = 22;
const int TOKEN_ATAN2 = 23;
const int TOKEN_REAL = 24;
const int TOKEN_IMAG = 25;
const int TOKEN_CONJ = 26;
const int TOKEN_ARG = 27;
const int TOKEN_SIGN = 28;
const int TOKEN_STEP = 29;
const int TOKEN_OPEN_PAREN = 30;
const int TOKEN_CLOSE_PAREN = 31;
const int TOKEN_COMMA = 32;
const int TOKEN_DERIVATIVE = 33;

// Variable hash codes for fast lookup
const int VAR_HASH_X = 1;
const int VAR_HASH_Y = 2;
const int VAR_HASH_VX = 3;
const int VAR_HASH_VY = 4;
const int VAR_HASH_AX = 5;
const int VAR_HASH_AY = 6;
const int VAR_HASH_T = 7;
const int VAR_HASH_THETA = 8;
const int VAR_HASH_OMEGA = 27;
const int VAR_HASH_MASS = 22;
const int VAR_HASH_CHARGE = 23;
const int VAR_HASH_R = 9;
const int VAR_HASH_G = 10;
const int VAR_HASH_B = 11;
const int VAR_HASH_A = 12;
const int VAR_HASH_VIS_X = 100;
const int VAR_HASH_VIS_Y = 101;
const int VAR_HASH_PI = 17;
const int VAR_HASH_E = 18;
const int VAR_HASH_I = 16;
const int VAR_HASH_K = 19;
const int VAR_HASH_B_DAMP = 20;
const int VAR_HASH_G_GRAV = 21;
const int VAR_HASH_COUPLING = 24;
const int VAR_HASH_FREQ = 25;
const int VAR_HASH_AMP = 26;

// System limits
const int MAX_RPN_STACK_SIZE = 64;
const int MAX_TOKEN_BUFFER_SIZE = 10000;
const int MAX_CONSTANT_BUFFER_SIZE = 10000;
const int MAX_EQUATION_COUNT = 256;
const float PI = 3.14159265359;
const float E = 2.71828182846;
const float EPSILON = 1e-6;
const float SAFE_MIN_VALUE = 1e-6;
const float SAFE_MAX_EXP = 50.0;
const float DERIVATIVE_H = 1e-4;
const int MAX_DERIV_EXPR_SIZE = 500;
const int CONSTRAINT_DISTANCE = 0;
const int CONSTRAINT_BOUNDARY = 1;
const int CONSTRAINT_ANGLE = 2;
const float CONSTRAINT_STIFFNESS = 0.8;
const int MAX_CONSTRAINT_ITERATIONS = 3;

// Collision shape types
const int COLLISION_NONE = 0;
const int COLLISION_CIRCLE = 1;
const int COLLISION_AABB = 2;
const int COLLISION_POLYGON = 3;

// NEW: Contact system constants
const int MAX_CONTACTS_PER_OBJECT = 4;
const float CONTACT_PERSISTENCE_THRESHOLD = 0.1; // Distance threshold for contact persistence
const int MAX_CONTACT_FRAMES = 5; // How many frames to keep a contact alive

// ============================================================================
// UTILITY FUNCTIONS (Numerical Safety)
// ============================================================================

// Safe division with zero check
float safeDivide(float numerator, float denominator) { 
    return (abs(denominator) < EPSILON) ? 0.0 : (numerator / denominator);
}

// Safe power with non-negative base
float safePow(float base, float exponent) { 
    return pow(max(0.0, base), exponent);
}

// Safe logarithm with minimum value
float safeLog(float value) { 
    return log(max(SAFE_MIN_VALUE, value));
}

// Safe exponential with range clamping
float safeExp(float value) { 
    return exp(clamp(value, -SAFE_MAX_EXP, SAFE_MAX_EXP));
}

// Check for invalid floating point values
bool isInvalidFloat(float value) { 
    return isinf(value) || isnan(value);
}

// Sanitize 2D vector by replacing invalid components with zero
vec2 sanitizeVec2(vec2 v) { 
    if (isInvalidFloat(v.x)) v.x = 0.0;
    if (isInvalidFloat(v.y)) v.y = 0.0; 
    return v;
}

// Sanitize 4D vector by replacing invalid components with zero
vec4 sanitizeVec4(vec4 v) { 
    if (isInvalidFloat(v.x)) v.x = 0.0;
    if (isInvalidFloat(v.y)) v.y = 0.0;
    if (isInvalidFloat(v.z)) v.z = 0.0; 
    if (isInvalidFloat(v.w)) v.w = 0.0; 
    return v;
}

// Sign function with proper zero handling
float signFunc(float x) { return (x > 0.0) ? 1.0 : ((x < 0.0) ? -1.0 : 0.0); }

// Step function (Heaviside)
float stepFunc(float x) { return (x >= 0.0) ? 1.0 : 0.0; }

// ============================================================================
// COMPLEX MATH UTILITIES
// ============================================================================

// Complex addition
vec2 cAdd(vec2 a, vec2 b) { return a + b; }

// Complex subtraction
vec2 cSub(vec2 a, vec2 b) { return a - b; }

// Complex multiplication: (a+bi)(c+di) = (ac-bd) + (ad+bc)i
vec2 cMul(vec2 a, vec2 b) {
    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
}

// Complex division
vec2 cDiv(vec2 a, vec2 b) {
    float denom = b.x * b.x + b.y * b.y;
    if (abs(denom) < EPSILON) return vec2(0.0);
    return vec2((a.x * b.x + a.y * b.y) / denom, (a.y * b.x - a.x * b.y) / denom);
}

// Complex logarithm: ln(z) = ln|z| + i*arg(z)
vec2 cLog(vec2 z) {
    float r = length(z);
    float theta = atan(z.y, z.x);
    return vec2(safeLog(r), theta);
}

// Complex exponential: e^(a+bi) = e^a * (cos(b) + i*sin(b))
vec2 cExp(vec2 z) {
    float ea = safeExp(z.x);
    return vec2(ea * cos(z.y), ea * sin(z.y));
}

// Complex power: a^b = exp(b * ln(a))
vec2 cPow(vec2 base, vec2 exponent) {
    if (length(base) < EPSILON) return vec2(0.0);
    return cExp(cMul(exponent, cLog(base)));
}

// Complex sine: sin(a+bi) = sin(a)cosh(b) + i*cos(a)sinh(b)
vec2 cSin(vec2 z) {
    return vec2(sin(z.x) * cosh(z.y), cos(z.x) * sinh(z.y));
}

// Complex cosine: cos(a+bi) = cos(a)cosh(b) - i*sin(a)sinh(b)
vec2 cCos(vec2 z) {
    return vec2(cos(z.x) * cosh(z.y), -sin(z.x) * sinh(z.y));
}

// ============================================================================
// OBJECT PROPERTY ACCESSOR
// ============================================================================

// Get property value from another object
float getObjectProperty(int targetIndex, int propertyHash, int currentObject) {
    // Validate object index
    if (targetIndex < 0 || targetIndex >= uNumObjects) return 0.0;
    if (targetIndex == currentObject) return 0.0; // Don't reference self
    
    Object p = objectsIn[targetIndex];
    
    // Return property based on hash code
    switch (propertyHash) {
        case VAR_HASH_X: return p.position.x;
        case VAR_HASH_Y: return p.position.y;
        case VAR_HASH_VX: return p.velocity.x;
        case VAR_HASH_VY: return p.velocity.y;
        case VAR_HASH_AX: return p.collisionData.x;
        case VAR_HASH_AY: return p.collisionData.y;
        case VAR_HASH_MASS: return p.mass;
        case VAR_HASH_CHARGE: return p.charge;
        case VAR_HASH_THETA: return p.visualData.z;
        case VAR_HASH_OMEGA: return p.visualData.w;
        case VAR_HASH_R: return p.color.r;
        case VAR_HASH_G: return p.color.g;
        case VAR_HASH_B: return p.color.b;
        case VAR_HASH_A: return p.color.a;
        case VAR_HASH_VIS_X: return p.visualData.x;
        case VAR_HASH_VIS_Y: return p.visualData.y;
    }
    return 0.0;
}

// ============================================================================
// INLINE RPN EVALUATOR (For Numerical Derivatives)
// ============================================================================

// Evaluate derivative expression for numerical differentiation
vec2 evaluateDerivativeExpression(
    float x, float y, float vx, float vy, float ax_prev, float ay_prev,
    float rotation, float angular_vel, vec4 color,
    float mass, float charge, int objectIndex,
    int componentType, int exprOffset, int exprCount, int constantOffset
) {
    // Validate expression parameters
    if (exprCount <= 0 || exprCount > MAX_DERIV_EXPR_SIZE) return vec2(0.0);
    
    // Local evaluation stack (2 floats per complex number)
    float dstack[128]; 
    bool dIsComplex[64];
    int dstackPtr = 0;
    int dComplexPtr = 0;
    int dtokenIdx = exprOffset;
    
    // Process each token in the expression
    for (int di = 0; di < exprCount; ++di) {
        // Safety checks
        if (dtokenIdx >= MAX_TOKEN_BUFFER_SIZE) break;
        if (dstackPtr >= 126) return vec2(0.0);
        
        int dtoken = allTokens[dtokenIdx++];
        
        // --- LITERALS AND VARIABLES ---
        if (dtoken == TOKEN_NUMBER) {
            // Push constant value
            int dconstIdx = allTokens[dtokenIdx++];
            int dglobalConstIdx = constantOffset + dconstIdx;
            float val = 0.0;
            if (dglobalConstIdx >= 0 && dglobalConstIdx < MAX_CONSTANT_BUFFER_SIZE) {
                val = allConstants[dglobalConstIdx];
            }
            dstack[dstackPtr++] = isInvalidFloat(val) ? 0.0 : val;
            dIsComplex[dComplexPtr++] = false;
        }
        else if (dtoken == TOKEN_VARIABLE) {
            // Push variable value
            int dvarHash = allTokens[dtokenIdx++];
            
            // Handle imaginary unit 'i'
            if (dvarHash == VAR_HASH_I) {
                dstack[dstackPtr++] = 0.0; // real
                dstack[dstackPtr++] = 1.0; // imag
                dIsComplex[dComplexPtr++] = true;
                continue;
            }
            
            // Get variable value based on hash
            float dvalue = 0.0;
            switch(dvarHash) {
                case VAR_HASH_X: dvalue = x; break;
                case VAR_HASH_Y: dvalue = y; break;
                case VAR_HASH_VX: dvalue = vx; break;
                case VAR_HASH_VY: dvalue = vy; break;
                case VAR_HASH_AX: dvalue = ax_prev; break;
                case VAR_HASH_AY: dvalue = ay_prev; break;
                case VAR_HASH_T: dvalue = uTime; break;
                case VAR_HASH_THETA: dvalue = rotation; break;
                case VAR_HASH_OMEGA: dvalue = angular_vel; break;
                case VAR_HASH_R: dvalue = color.r; break;
                case VAR_HASH_G: dvalue = color.g; break;
                case VAR_HASH_B: dvalue = color.b; break;
                case VAR_HASH_A: dvalue = color.a; break;
                case VAR_HASH_PI: dvalue = PI; break;
                case VAR_HASH_E: dvalue = E; break;
                case VAR_HASH_K: dvalue = k; break;
                case VAR_HASH_B_DAMP: dvalue = b; break;
                case VAR_HASH_G_GRAV: dvalue = g; break;
                case VAR_HASH_MASS: dvalue = mass; break;
                case VAR_HASH_CHARGE: dvalue = charge; break;
                case VAR_HASH_COUPLING: dvalue = uCoupling; break;
                case VAR_HASH_FREQ: dvalue = uDriveFreq; break;
                case VAR_HASH_AMP: dvalue = uDriveAmp; break;
            }
            dstack[dstackPtr++] = dvalue;
            dIsComplex[dComplexPtr++] = false;
        }
        else if (dtoken == TOKEN_OBJECT_REF) {
            // Push referenced object property
            int dobjIndex = allTokens[dtokenIdx++];
            int dpropHash = allTokens[dtokenIdx++];
            float dvalue = getObjectProperty(dobjIndex, dpropHash, objectIndex);
            dstack[dstackPtr++] = isInvalidFloat(dvalue) ? 0.0 : dvalue;
            dIsComplex[dComplexPtr++] = false;
        }
        
        // --- BINARY OPERATORS ---
        else if (dtoken == TOKEN_ADD || dtoken == TOKEN_SUB || dtoken == TOKEN_MUL || dtoken == TOKEN_DIV || dtoken == TOKEN_POW) {
            // Need at least two operands
            if (dComplexPtr < 2) { dstack[0]=0.0; dstackPtr=1; dComplexPtr=1; continue; }
            
            // Extract operands (may be complex)
            bool b_c = dIsComplex[--dComplexPtr];
            bool a_c = dIsComplex[dComplexPtr-1];
            
            vec2 b_val = b_c ? vec2(dstack[dstackPtr-2], dstack[dstackPtr-1]) : vec2(dstack[dstackPtr-1], 0.0);
            dstackPtr -= (b_c ? 2 : 1);
            vec2 a_val = a_c ? vec2(dstack[dstackPtr-2], dstack[dstackPtr-1]) : vec2(dstack[dstackPtr-1], 0.0);
            dstackPtr -= (a_c ? 2 : 1);
            
            vec2 res = vec2(0.0);
            bool res_c = (a_c || b_c);
            
            // Apply operation
            if (dtoken == TOKEN_ADD) res = cAdd(a_val, b_val);
            else if (dtoken == TOKEN_SUB) res = cSub(a_val, b_val);
            else if (dtoken == TOKEN_MUL) {
                res = cMul(a_val, b_val);
                res_c = true; // Multiplication always produces complex
            }
            else if (dtoken == TOKEN_DIV) {
                res = cDiv(a_val, b_val);
                res_c = true; // Division always produces complex
            }
            else if (dtoken == TOKEN_POW) {
                // Use complex power if either operand is complex or base is negative
                if (a_c || b_c || a_val.x < 0.0) {
                    res = cPow(a_val, b_val);
                    res_c = true;
                } else {
                    // Real power for positive base
                    res = vec2(safePow(a_val.x, b_val.x), 0.0);
                    res_c = false;
                }
            }

            // Push result back to stack
            if (res_c) {
                dstack[dstackPtr++] = res.x;
                dstack[dstackPtr++] = res.y;
                dIsComplex[dComplexPtr-1] = true;
            } else {
                dstack[dstackPtr++] = res.x;
                dIsComplex[dComplexPtr-1] = false;
            }
        }
        
        // --- UNARY OPERATORS ---
        else if (dtoken == TOKEN_SIN || dtoken == TOKEN_COS || dtoken == TOKEN_EXP || dtoken == TOKEN_NEG) {
            // Need at least one operand
            if (dComplexPtr < 1) { dstack[0]=0.0; dstackPtr=1; dComplexPtr=1; continue; }
            
            bool a_c = dIsComplex[dComplexPtr-1];
            vec2 a_val = a_c ? vec2(dstack[dstackPtr-2], dstack[dstackPtr-1]) : vec2(dstack[dstackPtr-1], 0.0);
            dstackPtr -= (a_c ? 2 : 1);
            vec2 res = vec2(0.0);
            bool res_c = a_c;

            // Apply unary operation
            if (dtoken == TOKEN_NEG) { res = vec2(-a_val.x, -a_val.y); }
            else if (dtoken == TOKEN_SIN) { res = cSin(a_val); res_c = true; }
            else if (dtoken == TOKEN_COS) { res = cCos(a_val); res_c = true; }
            else if (dtoken == TOKEN_EXP) { res = cExp(a_val); res_c = true; }

            // Push result back to stack
            if (res_c) {
                dstack[dstackPtr++] = res.x;
                dstack[dstackPtr++] = res.y;
                dIsComplex[dComplexPtr-1] = true;
            } else {
                dstack[dstackPtr++] = res.x;
                dIsComplex[dComplexPtr-1] = false;
            }
        }
        
        // --- DERIVATIVE OPERATOR (skip nested derivatives) ---
        else if (dtoken == TOKEN_DERIVATIVE) {
            // Skip nested derivative evaluation for simplicity
            if (dtokenIdx + 3 < MAX_TOKEN_BUFFER_SIZE) {
                dtokenIdx += 3;
                int nested_count = allTokens[dtokenIdx++];
                dtokenIdx += nested_count;
                di += nested_count + 3;
            }
            dstack[dstackPtr++] = 0.0;
            dIsComplex[dComplexPtr++] = false;
        }
    }
    
    // Return final result
    if (dstackPtr <= 0) return vec2(0.0);
    if (dIsComplex[0]) return vec2(dstack[0], dstack[1]);
    return vec2(dstack[0], 0.0);
}

// ============================================================================
// MAIN RPN EVALUATOR (Full Feature Set)
// ============================================================================

// Evaluate RPN expression for a specific physics component (ax, ay, angular, color)
float evaluateRPNComponent(
    float x, float y, float vx, float vy, float ax_prev, float ay_prev,
    float rotation, float angular_vel, vec4 color,
    float mass, float charge, int objectIndex,
    int componentType,
    int tokenOffset, int tokenCount, int constantOffset
) {
    // Validate expression parameters
    if (tokenCount <= 0 || tokenCount > 1000) {
        // Return defaults for invalid expressions
        if (componentType == 2) return 0.0; // angular
        if (componentType >= 3 && componentType <= 6) return 1.0; // color channels
        return 0.0;
    }
    
    // Evaluation stack (128 floats = 64 complex numbers max)
    float stack[128];
    int stackPtr = 0;
    bool isComplex[64];
    int complexStackPtr = 0;
    
    int tokenIdx = tokenOffset;
    
    // Process each token in RPN order
    for (int i = 0; i < tokenCount; ++i) {
        // Safety checks
        if (tokenIdx >= MAX_TOKEN_BUFFER_SIZE) return 0.0;
        if (stackPtr >= 126) return 0.0; // Stack overflow guard
        
        int tokenType = allTokens[tokenIdx++];
        
        // ====================================================================
        // LITERALS AND VARIABLES
        // ====================================================================
        if (tokenType == TOKEN_NUMBER) {
            // Push constant value
            int constIdx = allTokens[tokenIdx++];
            int globalConstIdx = constantOffset + constIdx;
            float value = 0.0;
            if (globalConstIdx >= 0 && globalConstIdx < MAX_CONSTANT_BUFFER_SIZE) {
                value = allConstants[globalConstIdx];
            }
            if (isInvalidFloat(value)) value = 0.0;
            stack[stackPtr++] = value;
            isComplex[complexStackPtr++] = false;
        }
        else if (tokenType == TOKEN_VARIABLE) {
            // Push variable value
            int varHash = allTokens[tokenIdx++];
            float value = 0.0;
            
            // Handle imaginary unit 'i'
            if (varHash == VAR_HASH_I) {
                stack[stackPtr++] = 0.0; // real
                stack[stackPtr++] = 1.0; // imag
                isComplex[complexStackPtr++] = true;
                continue; 
            }
            
            // Get variable value based on hash
            switch(varHash) {
                case VAR_HASH_X: value = x; break;
                case VAR_HASH_Y: value = y; break;
                case VAR_HASH_VX: value = vx; break;
                case VAR_HASH_VY: value = vy; break;
                case VAR_HASH_AX: value = ax_prev; break;
                case VAR_HASH_AY: value = ay_prev; break;
                case VAR_HASH_T: value = uTime; break;
                case VAR_HASH_THETA: value = rotation; break;
                case VAR_HASH_OMEGA: value = angular_vel; break;
                case VAR_HASH_R: value = color.r; break;
                case VAR_HASH_G: value = color.g; break;
                case VAR_HASH_B: value = color.b; break;
                case VAR_HASH_A: value = color.a; break;
                case VAR_HASH_PI: value = PI; break;
                case VAR_HASH_E: value = E; break;
                case VAR_HASH_K: value = k; break;
                case VAR_HASH_B_DAMP: value = b; break;
                case VAR_HASH_G_GRAV: value = g; break;
                case VAR_HASH_MASS: value = mass; break;
                case VAR_HASH_CHARGE: value = charge; break;
                case VAR_HASH_COUPLING: value = uCoupling; break;
                case VAR_HASH_FREQ: value = uDriveFreq; break;
                case VAR_HASH_AMP: value = uDriveAmp; break;
            }
            stack[stackPtr++] = value;
            isComplex[complexStackPtr++] = false;
        }
        else if (tokenType == TOKEN_OBJECT_REF) {
            // Push referenced object property
            int objIndex = allTokens[tokenIdx++];
            int propHash = allTokens[tokenIdx++];
            float value = getObjectProperty(objIndex, propHash, objectIndex);
            if (isInvalidFloat(value)) value = 0.0;
            stack[stackPtr++] = value;
            isComplex[complexStackPtr++] = false;
        }
        
        // ====================================================================
        // NUMERICAL DERIVATIVE (Complex-Aware)
        // ====================================================================
        else if (tokenType == TOKEN_DERIVATIVE) {
            int wrtVarHash = allTokens[tokenIdx++];  // Variable to differentiate with respect to
            int order = allTokens[tokenIdx++];       // Derivative order (1st, 2nd, etc.)
            int method = allTokens[tokenIdx++];      // Numerical method (center diff, forward, etc.)
            int exprCount = allTokens[tokenIdx++];   // Number of tokens in expression
            int exprOffset = tokenIdx;               // Expression start offset
            
            float h = DERIVATIVE_H;
            vec2 derivValue = vec2(0.0);
            
            // Currently only support first-order central difference
            if (order == 1 && exprCount > 0 && exprCount <= MAX_DERIV_EXPR_SIZE) {
                // Save original values
                float x_orig = x, y_orig = y, vx_orig = vx, vy_orig = vy;
                float ax_orig = ax_prev, ay_orig = ay_prev;
                float rotation_orig = rotation, angular_vel_orig = angular_vel;
                vec4 color_orig = color;
                
                // Macro to perturb the target variable
                #define PERTURB(var, delta) \
                if (wrtVarHash == VAR_HASH_X) x = x_orig + delta; \
                else if (wrtVarHash == VAR_HASH_Y) y = y_orig + delta; \
                else if (wrtVarHash == VAR_HASH_VX) vx = vx_orig + delta; \
                else if (wrtVarHash == VAR_HASH_VY) vy = vy_orig + delta; \
                else if (wrtVarHash == VAR_HASH_AX) ax_prev = ax_orig + delta; \
                else if (wrtVarHash == VAR_HASH_AY) ay_prev = ay_orig + delta; \
                else if (wrtVarHash == VAR_HASH_THETA) rotation = rotation_orig + delta; \
                else if (wrtVarHash == VAR_HASH_OMEGA) angular_vel = angular_vel_orig + delta; \
                else if (wrtVarHash == VAR_HASH_R) color.r = color_orig.r + delta; \
                else if (wrtVarHash == VAR_HASH_G) color.g = color_orig.g + delta; \
                else if (wrtVarHash == VAR_HASH_B) color.b = color_orig.b + delta; \
                else if (wrtVarHash == VAR_HASH_A) color.a = color_orig.a + delta;
                
                // f(x+h)
                PERTURB(wrtVarHash, h);
                vec2 val_plus = evaluateDerivativeExpression(
                    x, y, vx, vy, ax_prev, ay_prev, rotation, angular_vel, color,
                    mass, charge, objectIndex, componentType, exprOffset, exprCount, constantOffset
                );
                
                // f(x-h)
                PERTURB(wrtVarHash, -h);
                vec2 val_minus = evaluateDerivativeExpression(
                    x, y, vx, vy, ax_prev, ay_prev, rotation, angular_vel, color,
                    mass, charge, objectIndex, componentType, exprOffset, exprCount, constantOffset
                );
                
                // Restore original values
                x = x_orig; y = y_orig; vx = vx_orig; vy = vy_orig;
                ax_prev = ax_orig; ay_prev = ay_orig;
                rotation = rotation_orig; angular_vel = angular_vel_orig;
                color = color_orig;

                // Central difference: (f(x+h) - f(x-h)) / (2h)
                derivValue = (val_plus - val_minus) / (2.0 * h);
            }
            
            // Push derivative result (always complex to be safe)
            stack[stackPtr++] = derivValue.x;
            stack[stackPtr++] = derivValue.y;
            isComplex[complexStackPtr++] = true;
            
            // Skip the expression tokens we just processed
            tokenIdx += exprCount;
            i += exprCount + 3;
        }
        
        // ====================================================================
        // BINARY OPERATORS
        // ====================================================================
        else if (tokenType == TOKEN_ADD || tokenType == TOKEN_SUB || tokenType == TOKEN_MUL || tokenType == TOKEN_DIV) {
            // Need at least two operands
            if (complexStackPtr < 2) { stack[0] = 0.0; stackPtr = 1; complexStackPtr = 1; continue; }
            
            bool b_c = isComplex[--complexStackPtr];
            bool a_c = isComplex[complexStackPtr-1];
            
            // Extract operands
            vec2 b_val = b_c ? vec2(stack[stackPtr-2], stack[stackPtr-1]) : vec2(stack[stackPtr-1], 0.0);
            stackPtr -= (b_c ? 2 : 1);
            vec2 a_val = a_c ? vec2(stack[stackPtr-2], stack[stackPtr-1]) : vec2(stack[stackPtr-1], 0.0);
            stackPtr -= (a_c ? 2 : 1);
            
            vec2 res = vec2(0.0);
            bool res_c = (a_c || b_c); 

            // Apply operation
            if (tokenType == TOKEN_ADD) res = cAdd(a_val, b_val);
            else if (tokenType == TOKEN_SUB) res = cSub(a_val, b_val);
            else if (tokenType == TOKEN_MUL) {
                res = cMul(a_val, b_val);
                res_c = true; // Multiplication always produces complex
            }
            else if (tokenType == TOKEN_DIV) {
                res = cDiv(a_val, b_val);
                res_c = true; // Division always produces complex
            }

            // Push result
            if (res_c) {
                stack[stackPtr++] = res.x;
                stack[stackPtr++] = res.y;
                isComplex[complexStackPtr-1] = true;
            } else {
                stack[stackPtr++] = res.x;
                isComplex[complexStackPtr-1] = false;
            }
        }
        
        // ====================================================================
        // POWER OPERATOR (Complex-Aware)
        // ====================================================================
        else if (tokenType == TOKEN_POW) {
            // Need at least two operands
            if (complexStackPtr < 2) { stack[0] = 0.0; stackPtr = 1; complexStackPtr = 1; continue; }
            
            bool b_c = isComplex[--complexStackPtr];
            bool a_c = isComplex[complexStackPtr-1];
            
            vec2 b_val = b_c ? vec2(stack[stackPtr-2], stack[stackPtr-1]) : vec2(stack[stackPtr-1], 0.0);
            stackPtr -= (b_c ? 2 : 1);
            vec2 a_val = a_c ? vec2(stack[stackPtr-2], stack[stackPtr-1]) : vec2(stack[stackPtr-1], 0.0);
            stackPtr -= (a_c ? 2 : 1);
            
            // Use complex power if any operand is complex OR base is negative
            if (a_c || b_c || a_val.x < 0.0) {
                vec2 res = cPow(a_val, b_val);
                stack[stackPtr++] = res.x;
                stack[stackPtr++] = res.y;
                isComplex[complexStackPtr-1] = true;
            } else {
                // Real power for positive base
                stack[stackPtr++] = safePow(a_val.x, b_val.x);
                isComplex[complexStackPtr-1] = false;
            }
        }
        
        // ====================================================================
        // UNARY OPERATORS (Complex-Aware)
        // ====================================================================
        else if (tokenType == TOKEN_NEG || tokenType == TOKEN_SIN || tokenType == TOKEN_COS || 
                 tokenType == TOKEN_TAN || tokenType == TOKEN_EXP || tokenType == TOKEN_LOG ||
                 tokenType == TOKEN_SQRT || tokenType == TOKEN_ABS) {
            
            // Need at least one operand
            if (complexStackPtr < 1) { stack[0] = 0.0; stackPtr = 1; complexStackPtr = 1; continue; }
            
            bool a_c = isComplex[complexStackPtr-1];
            vec2 a_val = a_c ? vec2(stack[stackPtr-2], stack[stackPtr-1]) : vec2(stack[stackPtr-1], 0.0);
            stackPtr -= (a_c ? 2 : 1);
            vec2 res = vec2(0.0);
            bool res_c = a_c; // Inherit complexity by default

            // Apply unary operation
            if (tokenType == TOKEN_NEG) { res = vec2(-a_val.x, -a_val.y); }
            else if (tokenType == TOKEN_SIN) { res = cSin(a_val); res_c = true; }
            else if (tokenType == TOKEN_COS) { res = cCos(a_val); res_c = true; }
            else if (tokenType == TOKEN_EXP) { res = cExp(a_val); res_c = true; }
            else if (tokenType == TOKEN_LOG) { res = cLog(a_val); res_c = true; }
            else if (tokenType == TOKEN_SQRT) { res = cPow(a_val, vec2(0.5, 0.0)); res_c = true; }
            else if (tokenType == TOKEN_TAN) { 
                 // tan(z) = sin(z)/cos(z)
                 vec2 s = cSin(a_val);
                 vec2 c = cCos(a_val);
                 res = cDiv(s, c);
                 res_c = true;
            }
            else if (tokenType == TOKEN_ABS) {
                // Absolute value/magnitude of complex number
                res.x = length(a_val);
                res_c = false; // Magnitude is always real
            }

            // Push result
            if (res_c) {
                stack[stackPtr++] = res.x;
                stack[stackPtr++] = res.y;
                isComplex[complexStackPtr-1] = true;
            } else {
                stack[stackPtr++] = res.x;
                isComplex[complexStackPtr-1] = false;
            }
        }
        
        // ====================================================================
        // REAL-VALUED UNARY OPERATORS
        // ====================================================================
        else if (tokenType == TOKEN_FLOOR) {
            if (!isComplex[complexStackPtr-1]) stack[stackPtr-1] = floor(stack[stackPtr-1]);
        }
        else if (tokenType == TOKEN_CEIL) {
            if (!isComplex[complexStackPtr-1]) stack[stackPtr-1] = ceil(stack[stackPtr-1]);
        }
        else if (tokenType == TOKEN_FRAC) {
            if (!isComplex[complexStackPtr-1]) stack[stackPtr-1] = fract(stack[stackPtr-1]);
        }
        else if (tokenType == TOKEN_SIGN) {
            if (!isComplex[complexStackPtr-1]) stack[stackPtr-1] = signFunc(stack[stackPtr-1]);
        }
        else if (tokenType == TOKEN_STEP) {
            if (!isComplex[complexStackPtr-1]) stack[stackPtr-1] = stepFunc(stack[stackPtr-1]);
        }
        
        // ====================================================================
        // REAL-VALUED BINARY OPERATORS
        // ====================================================================
        else if (tokenType == TOKEN_MOD) {
            if (complexStackPtr < 2) continue;
            complexStackPtr--;
            float b_val = stack[--stackPtr], a_val = stack[--stackPtr];
            stack[stackPtr++] = (abs(b_val) < EPSILON) ? 0.0 : mod(a_val, b_val);
            isComplex[complexStackPtr-1] = false;
        }
        else if (tokenType == TOKEN_MIN || tokenType == TOKEN_MAX) {
            if (complexStackPtr < 2) continue;
            complexStackPtr--;
            float b_val = stack[--stackPtr], a_val = stack[--stackPtr];
            stack[stackPtr++] = (tokenType == TOKEN_MIN) ? min(a_val, b_val) : max(a_val, b_val);
            isComplex[complexStackPtr-1] = false;
        }
        else if (tokenType == TOKEN_ATAN2) {
             if (complexStackPtr < 2) continue;
             complexStackPtr--;
             float x_val = stack[--stackPtr], y_val = stack[--stackPtr];
             stack[stackPtr++] = atan(y_val, x_val);
             isComplex[complexStackPtr-1] = false;
        }
        else if (tokenType == TOKEN_CLAMP) {
            if (complexStackPtr < 3) continue;
            complexStackPtr -= 2;
            float max_val = stack[--stackPtr];
            float min_val = stack[--stackPtr];
            float val = stack[--stackPtr];
            stack[stackPtr++] = clamp(val, min_val, max_val);
            isComplex[complexStackPtr-1] = false;
        }
        
        // ====================================================================
        // COMPLEX-SPECIFIC OPERATORS
        // ====================================================================
        else if (tokenType == TOKEN_REAL) {
            // Extract real part of complex number
            if (complexStackPtr < 1) continue;
            if (isComplex[complexStackPtr-1]) {
                stackPtr--; // Remove imaginary part
                isComplex[--complexStackPtr] = false; // Mark as real
            }
        }
        else if (tokenType == TOKEN_IMAG) {
            // Extract imaginary part of complex number
            if (complexStackPtr < 1) continue;
            if (isComplex[complexStackPtr-1]) {
                float imag = stack[stackPtr-1];
                stackPtr--; 
                stack[stackPtr-1] = imag; // Replace real with imaginary part
                isComplex[--complexStackPtr] = false;
            } else {
                stack[stackPtr-1] = 0.0; // Real numbers have 0 imaginary part
            }
        }
        else if (tokenType == TOKEN_CONJ) {
            // Complex conjugate
            if (complexStackPtr < 1) continue;
            if (isComplex[complexStackPtr-1]) {
                stack[stackPtr-1] = -stack[stackPtr-1]; // Negate imaginary part
            }
        }
        else if (tokenType == TOKEN_ARG) {
            // Argument/phase of complex number
            if (complexStackPtr < 1) continue;
            if (isComplex[complexStackPtr-1]) {
                float imag = stack[--stackPtr], real = stack[stackPtr-1];
                stack[stackPtr-1] = atan(imag, real);
                isComplex[--complexStackPtr] = false;
            } else {
                // Real numbers: 0 for positive, π for negative
                stack[stackPtr-1] = (stack[stackPtr-1] >= 0.0) ? 0.0 : PI;
            }
        }
    }
    
    // Extract final result from stack
    float result = (stackPtr > 0) ? stack[0] : 0.0;
    if (isInvalidFloat(result)) {
        // Return defaults for invalid results
        if (componentType >= 3 && componentType <= 6) return 1.0; // color channels
        return 0.0;
    }
    
    // Clamp color channels to [0, 1]
    if (componentType >= 3 && componentType <= 6) result = clamp(result, 0.0, 1.0);
    
    return result;
}

// ============================================================================
// DEFAULT PHYSICS (Simple Spring-Mass-Damper System)
// ============================================================================

// Calculate default physics (gravity + damping)
vec2 calculateDefaultPhysics(vec2 pos, vec2 vel, float mass) {
    vec2 acceleration = vec2(0.0);
    acceleration += uGravityDir * g;  // Gravity
    acceleration -= vel * b;           // Damping
    return acceleration;
}

// ============================================================================
// CONSTRAINT SOLVERS
// ============================================================================

// Solve distance constraint between two objects
void solveDistanceConstraint(inout vec2 pos, inout vec2 vel, Constraint c, int objectIndex) {
    if (c.targetObjectID < 0 || c.targetObjectID >= uNumObjects) return;
    if (c.targetObjectID == objectIndex) return;
    
    Object target = objectsIn[c.targetObjectID];
    vec2 targetPos = target.position;
    
    // Desired distance (parameter 1)
    float desiredDistance = c.param1;
    
    // Calculate current offset and distance
    vec2 currentOffset = targetPos - pos;
    float currentDistance = length(currentOffset);
    
    if (currentDistance < EPSILON) return;
    
    // Calculate desired offset vector
    vec2 desiredOffset = normalize(currentOffset) * desiredDistance;
    
    // Position correction (move toward desired distance)
    vec2 error = currentOffset - desiredOffset;
    pos -= error * CONSTRAINT_STIFFNESS;
 
    // Velocity damping (reduce relative velocity along constraint axis)
    vec2 targetVel = target.velocity;
    vec2 relativeVel = vel - targetVel;
    float damping = 0.8;
    vel -= dot(relativeVel, normalize(error + vec2(EPSILON))) * normalize(error + vec2(EPSILON)) * damping;
}

// Solve boundary/box constraint
void solveBoundaryConstraint(inout vec2 pos, inout vec2 vel, Constraint c) {
    // Extract boundary coordinates
    float x1 = c.param1;
    float x2 = c.param2;
    float y1 = c.param3;
    float y2 = c.param4;
    float minX = min(x1, x2);
    float maxX = max(x1, x2);
    float minY = min(y1, y2);
    float maxY = max(y1, y2);
    
    const float elasticity = 0.7;  // Bounce coefficient
    const float friction = 0.95;   // Wall friction
    
    // Check and resolve X boundaries
    if (pos.x < minX) { 
        pos.x = minX; 
        vel.x = abs(vel.x) * elasticity; 
        vel.y *= friction; 
    } 
    else if (pos.x > maxX) { 
        pos.x = maxX; 
        vel.x = -abs(vel.x) * elasticity; 
        vel.y *= friction; 
    }
    
    // Check and resolve Y boundaries
    if (pos.y < minY) { 
        pos.y = minY; 
        vel.y = abs(vel.y) * elasticity; 
        vel.x *= friction; 
    } 
    else if (pos.y > maxY) { 
        pos.y = maxY; 
        vel.y = -abs(vel.y) * elasticity; 
        vel.x *= friction; 
    }
}

// Solve angular constraint (restrict rotation angle)
void solveAngleConstraint(inout vec2 pos, inout vec2 vel, Constraint c, vec2 originalPos) {
    float minAngle = c.param1;
    float maxAngle = c.param2;
    
    // Calculate current angle from original position
    vec2 dir = pos - originalPos;
    float radius = length(dir);
    if (radius < EPSILON) return;
    
    float currentAngle = atan(dir.y, dir.x);
    currentAngle = mod(currentAngle + 2.0 * PI, 2.0 * PI);
    
    // Normalize angle bounds
    float normMinAngle = mod(minAngle + 2.0 * PI, 2.0 * PI);
    float normMaxAngle = mod(maxAngle + 2.0 * PI, 2.0 * PI);
    
    bool outsideBounds = false;
    float correctedAngle = currentAngle;
    
    // Check if angle is outside allowed range
    if (normMinAngle <= normMaxAngle) {
        // Normal case: min < max
        if (currentAngle < normMinAngle || currentAngle > normMaxAngle) {
            outsideBounds = true;
            // Choose closest boundary
            float distToMin = abs(currentAngle - normMinAngle);
            float distToMax = abs(currentAngle - normMaxAngle);
            correctedAngle = (distToMin < distToMax) ? normMinAngle : normMaxAngle;
        }
    } else {
        // Wrap-around case: min > max (crossing 0/2π)
        if (currentAngle < normMinAngle && currentAngle > normMaxAngle) {
            outsideBounds = true;
            float distToMin = abs(currentAngle - normMinAngle);
            float distToMax = abs(currentAngle - normMaxAngle);
            correctedAngle = (distToMin < distToMax) ? normMinAngle : normMaxAngle;
        }
    }
    
    // Apply correction if needed
    if (outsideBounds) {
        // Move to boundary angle
        pos = originalPos + vec2(cos(correctedAngle), sin(correctedAngle)) * radius;
        
        // Apply friction to velocity (only keep tangential component)
        vec2 radialDir = normalize(pos - originalPos);
        vec2 tangentDir = vec2(-radialDir.y, radialDir.x);
        vel = tangentDir * dot(vel, tangentDir) * 0.9;
    }
}

// Apply all constraints for an object
void applyConstraints(inout vec2 pos, inout vec2 vel, int objectIndex, vec2 originalPos) {
    ObjectConstraints pc = objectConstraints[objectIndex];
    if (pc.numConstraints <= 0) return;
    
    // Multiple iterations for constraint stability
    for (int iter = 0; iter < MAX_CONSTRAINT_ITERATIONS; iter++) {
        for (int i = 0; i < pc.numConstraints; i++) {
            int constraintIdx = pc.constraintOffset + i;
            Constraint c = constraints[constraintIdx];
            
            if (c.type == CONSTRAINT_DISTANCE) solveDistanceConstraint(pos, vel, c, objectIndex);
            else if (c.type == CONSTRAINT_BOUNDARY) solveBoundaryConstraint(pos, vel, c);
            else if (c.type == CONSTRAINT_ANGLE) solveAngleConstraint(pos, vel, c, originalPos);
        }
    }
}

// ============================================================================
// COLLISION DETECTION FUNCTIONS (UNCHANGED - KEEP YOUR EXISTING CODE)
// ============================================================================

// Circle-Circle collision detection
CollisionInfo detectCircleCircle(vec2 posA, float radiusA, vec2 posB, float radiusB, int objB)
{
    CollisionInfo info;
    info.hasCollision = false;
    info.otherObjectID = objB;
    
    // Calculate distance between centers
    vec2 delta = posB - posA;
    float distSq = dot(delta, delta);
    float radiusSum = radiusA + radiusB;
    
    // Check if circles overlap
    if (distSq < radiusSum * radiusSum && distSq > EPSILON)
    {
        float dist = sqrt(distSq);
        info.hasCollision = true;
        info.normal = delta / dist;           // Collision normal (A→B)
        info.penetration = radiusSum - dist;  // Overlap depth
    }
    
    return info;
}

// Axis-Aligned Bounding Box collision detection
CollisionInfo detectAABBAABB(vec2 posA, vec2 halfExtA, vec2 posB, vec2 halfExtB, int objB)
{
    CollisionInfo info;
    info.hasCollision = false;
    info.otherObjectID = objB;
    
    // Calculate separation vector
    vec2 delta = posB - posA;
    vec2 overlap = halfExtA + halfExtB - abs(delta);
    
    // Check for overlap on both axes
    if (overlap.x > 0.0 && overlap.y > 0.0)
    {
        info.hasCollision = true;
        
        // Resolve along minimum penetration axis
        if (overlap.x < overlap.y)
        {
            info.normal = vec2(sign(delta.x), 0.0);
            info.penetration = overlap.x;
        }
        else
        {
            info.normal = vec2(0.0, sign(delta.y));
            info.penetration = overlap.y;
        }
    }
    
    return info;
}

// Project polygon onto axis (Separating Axis Theorem helper)
vec2 projectPolygon(vec2 center, float radius, int sides, float rotation, vec2 axis)
{
    float minProj = 1e10;
    float maxProj = -1e10;
    
    float angleStep = 2.0 * PI / float(sides);
    
    // Project each vertex onto axis
    for (int i = 0; i < sides; i++)
    {
        float angle = rotation + float(i) * angleStep;
        vec2 vertex = center + radius * vec2(cos(angle), sin(angle));
        float proj = dot(vertex, axis);
        minProj = min(minProj, proj);
        maxProj = max(maxProj, proj);
    }
    
    return vec2(minProj, maxProj);
}

// Get polygon edge normal
vec2 getPolygonNormal(int side, int totalSides, float rotation)
{
    float angleStep = 2.0 * PI / float(totalSides);
    float angle = rotation + float(side) * angleStep;
    
    // Calculate edge vector
    vec2 edge = vec2(cos(angle + angleStep), sin(angle + angleStep)) - 
                vec2(cos(angle), sin(angle));
    
    // Return perpendicular (normal) to edge
    return normalize(vec2(-edge.y, edge.x));
}

// Polygon-Polygon SAT collision detection
CollisionInfo detectPolygonPolygon(
    vec2 posA, float radiusA, int sidesA, float rotA,
    vec2 posB, float radiusB, int sidesB, float rotB,
    int objB)
{
    CollisionInfo info;
    info.hasCollision = false;
    info.otherObjectID = objB;
    info.penetration = 1e10;
    
    // Test all edge normals from both polygons
    int totalTests = sidesA + sidesB;
    
    for (int i = 0; i < totalTests; i++)
    {
        vec2 axis;
        
        if (i < sidesA)
            axis = getPolygonNormal(i, sidesA, rotA);
        else
            axis = getPolygonNormal(i - sidesA, sidesB, rotB);
        
        // Project both polygons onto axis
        vec2 projA = projectPolygon(posA, radiusA, sidesA, rotA, axis);
        vec2 projB = projectPolygon(posB, radiusB, sidesB, rotB, axis);
        
        // Check for separating axis
        if (projA.y < projB.x || projB.y < projA.x)
            return info; // Separating axis found, no collision
        
        // Calculate overlap
        float overlap = min(projA.y, projB.y) - max(projA.x, projB.x);
        
        // Track minimum overlap (minimum translation vector)
        if (overlap < info.penetration)
        {
            info.penetration = overlap;
            info.normal = axis;
            
            // Ensure normal points from A to B
            if (dot(posB - posA, axis) < 0.0)
                info.normal = -axis;
        }
    }
    
    info.hasCollision = true;
    return info;
}

// Circle-AABB collision detection
CollisionInfo detectCircleAABB(vec2 circlePos, float radius, 
                                vec2 boxPos, vec2 halfExt, int objB)
{
    CollisionInfo info;
    info.hasCollision = false;
    info.otherObjectID = objB;
    
    // Find closest point on AABB to circle center
    vec2 closest = clamp(circlePos, boxPos - halfExt, boxPos + halfExt);
    vec2 delta = circlePos - closest;
    float distSq = dot(delta, delta);
    
    if (distSq < radius * radius)
    {
        float dist = sqrt(distSq);
        info.hasCollision = true;
        
        if (dist > EPSILON)
        {
            // Circle center outside AABB
            info.normal = delta / dist;
            info.penetration = radius - dist;
        }
        else
        {
            // Circle center inside AABB - push out nearest edge
            vec2 toEdge = boxPos - circlePos;
            vec2 absToEdge = abs(toEdge);
            vec2 edgeDist = halfExt - absToEdge;
            
            if (edgeDist.x < edgeDist.y)
            {
                info.normal = vec2(sign(toEdge.x), 0.0);
                info.penetration = radius + edgeDist.x;
            }
            else
            {
                info.normal = vec2(0.0, sign(toEdge.y));
                info.penetration = radius + edgeDist.y;
            }
        }
    }
    
    return info;
}

// Circle-Polygon SAT collision detection
CollisionInfo detectCirclePolygon(vec2 circlePos, float circleRadius,
                                  vec2 polyPos, float polyRadius, 
                                  int polySides, float polyRot, int objB)
{
    CollisionInfo info;
    info.hasCollision = false;
    info.otherObjectID = objB;
    info.penetration = 1e10;
    
    // Test polygon edge normals
    float angleStep = 2.0 * PI / float(polySides);
    
    for (int i = 0; i < polySides; i++)
    {
        vec2 axis = getPolygonNormal(i, polySides, polyRot);
        
        // Project circle onto axis (capsule projection)
        float circleProj = dot(circlePos, axis);
        vec2 circleProjRange = vec2(circleProj - circleRadius, 
                                     circleProj + circleRadius);
        
        // Project polygon onto axis
        vec2 polyProj = projectPolygon(polyPos, polyRadius, polySides, polyRot, axis);
        
        // Check for separation
        if (circleProjRange.y < polyProj.x || polyProj.y < circleProjRange.x)
            return info;
        
        // Calculate overlap
        float overlap = min(circleProjRange.y, polyProj.y) - 
                       max(circleProjRange.x, polyProj.x);
        
        // Track minimum overlap
        if (overlap < info.penetration)
        {
            info.penetration = overlap;
            info.normal = axis;
            if (dot(polyPos - circlePos, axis) < 0.0)
                info.normal = -axis;
        }
    }
    
    // Test axis from circle center to closest polygon vertex
    vec2 closestVertex = polyPos;
    float closestDistSq = 1e10;
    
    // Find closest polygon vertex to circle center
    for (int i = 0; i < polySides; i++)
    {
        float angle = polyRot + float(i) * angleStep;
        vec2 vertex = polyPos + polyRadius * vec2(cos(angle), sin(angle));
        float distSq = dot(vertex - circlePos, vertex - circlePos);
        
        if (distSq < closestDistSq)
        {
            closestDistSq = distSq;
            closestVertex = vertex;
        }
    }
    
    // Test axis from circle center to closest vertex
    vec2 axis = normalize(circlePos - closestVertex);
    float circleProj = dot(circlePos, axis);
    vec2 circleProjRange = vec2(circleProj - circleRadius, circleProj + circleRadius);
    vec2 polyProj = projectPolygon(polyPos, polyRadius, polySides, polyRot, axis);
    
    // Final separation check
    if (circleProjRange.y < polyProj.x || polyProj.y < circleProjRange.x)
        return info;
    
    float overlap = min(circleProjRange.y, polyProj.y) - 
                   max(circleProjRange.x, polyProj.x);
    
    if (overlap < info.penetration)
    {
        info.penetration = overlap;
        info.normal = axis;
        if (dot(polyPos - circlePos, axis) < 0.0)
            info.normal = -axis;
    }
    
    info.hasCollision = true;
    return info;
}

// Master collision detection dispatcher
CollisionInfo detectCollision(Object objA, Object objB, int objIndexB)
{
    CollisionInfo info;
    info.hasCollision = false;
    
    // Get collision properties for both objects
    CollisionProperties propsA = collisionProps[gl_GlobalInvocationID.x];
    CollisionProperties propsB = collisionProps[objIndexB];
    
    // Check if collisions are enabled for both objects
    if (propsA.enabled == 0 || propsB.enabled == 0)
        return info;
    
    int shapeA = propsA.shapeType;
    int shapeB = propsB.shapeType;
    
    // Skip if either object has no collision shape
    if (shapeA == COLLISION_NONE || shapeB == COLLISION_NONE)
        return info;
    
    // Dispatch to appropriate collision detection function based on shape types
    if (shapeA == COLLISION_CIRCLE && shapeB == COLLISION_CIRCLE)
    {
        // Circle vs Circle
        info = detectCircleCircle(objA.position, objA.visualData.x,
                                  objB.position, objB.visualData.x, objIndexB);
    }
    // AABB vs AABB
    else if (shapeA == COLLISION_AABB && shapeB == COLLISION_AABB)
    {
        vec2 halfExtA = objA.visualData.xy * 0.5;
        vec2 halfExtB = objB.visualData.xy * 0.5;
        info = detectAABBAABB(objA.position, halfExtA, 
                             objB.position, halfExtB, objIndexB);
    }
    // Polygon vs Polygon
    else if (shapeA == COLLISION_POLYGON && shapeB == COLLISION_POLYGON)
    {
        info = detectPolygonPolygon(
            objA.position, objA.visualData.x, int(objA.visualData.y), objA.visualData.z,
            objB.position, objB.visualData.x, int(objB.visualData.y), objB.visualData.z,
            objIndexB);
    }
    // Circle vs AABB
    else if (shapeA == COLLISION_CIRCLE && shapeB == COLLISION_AABB)
    {
        vec2 halfExtB = objB.visualData.xy * 0.5;
        info = detectCircleAABB(objA.position, objA.visualData.x,
                               objB.position, halfExtB, objIndexB);
    }
    else if (shapeA == COLLISION_AABB && shapeB == COLLISION_CIRCLE)
    {
        // Swap roles and flip normal
        vec2 halfExtA = objA.visualData.xy * 0.5;
        info = detectCircleAABB(objB.position, objB.visualData.x,
                               objA.position, halfExtA, objIndexB);
        info.normal = -info.normal; // Flip normal
    }
    // Circle vs Polygon
    else if (shapeA == COLLISION_CIRCLE && shapeB == COLLISION_POLYGON)
    {
        info = detectCirclePolygon(objA.position, objA.visualData.x,
                                   objB.position, objB.visualData.x,
                                   int(objB.visualData.y), objB.visualData.z,
                                   objIndexB);
    }
    else if (shapeA == COLLISION_POLYGON && shapeB == COLLISION_CIRCLE)
    {
        info = detectCirclePolygon(objB.position, objB.visualData.x,
                                   objA.position, objA.visualData.x,
                                   int(objA.visualData.y), objA.visualData.z,
                                   objIndexB);
        info.normal = -info.normal; // Flip normal
    }
    // AABB vs Polygon (simplified - treat polygon as circle for collision)
    else if (shapeA == COLLISION_AABB && shapeB == COLLISION_POLYGON)
    {
        vec2 halfExtA = objA.visualData.xy * 0.5;
        info = detectCircleAABB(objB.position, objB.visualData.x,
                               objA.position, halfExtA, objIndexB);
        info.normal = -info.normal; // Flip normal
    }
    else if (shapeA == COLLISION_POLYGON && shapeB == COLLISION_AABB)
    {
        vec2 halfExtB = objB.visualData.xy * 0.5;
        info = detectCircleAABB(objA.position, objA.visualData.x,
                               objB.position, halfExtB, objIndexB);
    }
    
    return info;
}

// ============================================================================
// NEW: RESEARCH-GRADE COLLISION RESOLUTION SYSTEM
// ============================================================================

// ============================================================================
// BASIC COLLISION RESPONSE (Momentum-Conserving)
// ============================================================================

// Apply collision response to two objects (conserves momentum and energy)
void applyCollisionResponse(
    inout vec2 posA, inout vec2 velA, float massA,
    inout vec2 posB, inout vec2 velB, float massB,
    vec2 normal, float penetration,
    float restitution, float friction
) {
    // Ensure valid masses
    if (massA < EPSILON || massB < EPSILON) return;
    
    // ========================================================================
    // 1. POSITION CORRECTION (Separating objects)
    // ========================================================================
    const float positionCorrectionFactor = 0.8;  // Baumgarte stabilization
    const float penetrationSlop = 0.001;         // Allow small penetration
    
    if (penetration > penetrationSlop) {
        float totalMass = massA + massB;
        float invTotalMass = 1.0 / totalMass;
        
        // Calculate correction vector
        vec2 correction = (penetration - penetrationSlop) * positionCorrectionFactor * normal;
        
        // Apply position correction based on mass ratio
        posA -= correction * (massB * invTotalMass);
        posB += correction * (massA * invTotalMass);
    }
    
    // ========================================================================
    // 2. VELOCITY CORRECTION (Impulse-based, conserves momentum)
    // ========================================================================
    // Relative velocity
    vec2 relativeVel = velB - velA;
    float velocityAlongNormal = dot(relativeVel, normal);
    
    // Only resolve if objects are moving toward each other
    if (velocityAlongNormal > 0.0) return;
    
    // Calculate impulse scalar (conserves momentum and energy)
    float e = min(max(restitution, 0.0), 1.0);  // Clamp restitution
    float impulseScalar = -(1.0 + e) * velocityAlongNormal;
    impulseScalar /= (1.0 / massA + 1.0 / massB);
    
    // Apply impulse to both velocities (equal and opposite)
    vec2 impulse = impulseScalar * normal;
    velA -= impulse / massA;
    velB += impulse / massB;
    
    // ========================================================================
    // 3. FRICTION (Coulomb model)
    // ========================================================================
    if (friction > 0.0) {
        // Recompute relative velocity after normal impulse
        relativeVel = velB - velA;
        
        // Tangent vector (perpendicular to normal)
        vec2 tangent = relativeVel - normal * dot(relativeVel, normal);
        float tangentLength = length(tangent);
        
        if (tangentLength > EPSILON) {
            tangent = normalize(tangent);
            
            // Relative velocity in tangent direction
            float relVelTangent = dot(relativeVel, tangent);
            
            // Friction impulse scalar
            float frictionImpulse = -relVelTangent * friction;
            frictionImpulse /= (1.0 / massA + 1.0 / massB);
            
            // Coulomb's law: friction impulse cannot exceed normal impulse
            float maxFriction = abs(impulseScalar) * friction;
            frictionImpulse = clamp(frictionImpulse, -maxFriction, maxFriction);
            
            // Apply friction impulse
            vec2 frictionVec = frictionImpulse * tangent;
            velA -= frictionVec / massA;
            velB += frictionVec / massB;
        }
    }
}

// ============================================================================
// SIMPLIFIED COLLISION RESOLUTION FOR PARALLEL EXECUTION
// ============================================================================

// This version handles collisions in a thread-safe way by only modifying
// the current object and letting the other object handle its own updates
void resolveCollisionSimple(
    inout vec2 posA, inout vec2 velA, float massA,
    Object objB, int objBIndex,
    CollisionInfo collision
) {
    if (!collision.hasCollision) return;
    
    // Get collision properties
    CollisionProperties propsA = collisionProps[gl_GlobalInvocationID.x];
    CollisionProperties propsB = collisionProps[objBIndex];
    
    // Effective restitution and friction
    float restitution = min(propsA.restitution, propsB.restitution);
    float friction = sqrt(propsA.friction * propsB.friction);
    
    // Other object's state
    vec2 posB = objB.position;
    vec2 velB = objB.velocity;
    float massB = max(EPSILON, objB.mass);
    
    // Copy state for local processing
    vec2 tempPosA = posA;
    vec2 tempVelA = velA;
    vec2 tempPosB = posB;
    vec2 tempVelB = velB;
    
    // Apply collision response
    applyCollisionResponse(
        tempPosA, tempVelA, massA,
        tempPosB, tempVelB, massB,
        collision.normal, collision.penetration,
        restitution, friction
    );
    
    // Update this object's state
    posA = tempPosA;
    velA = tempVelA;
    
    // Note: The other object (objB) will handle its own update in its thread
    // This ensures momentum is conserved across the entire system
}

// ============================================================================
// ANALYTICAL ELASTIC COLLISION FORMULA (For perfect conservation)
// ============================================================================

// Perfectly elastic collision for circles (conserves both momentum and energy)
void resolveElasticCollision(
    inout vec2 posA, inout vec2 velA, float massA,
    inout vec2 posB, inout vec2 velB, float massB,
    vec2 normal, float penetration
) {
    // Position correction
    const float positionPush = 0.5;
    if (penetration > 0.0) {
        float totalMass = massA + massB;
        posA -= normal * penetration * positionPush * (massB / totalMass);
        posB += normal * penetration * positionPush * (massA / totalMass);
    }
    
    // Relative velocity along collision normal
    vec2 relativeVel = velB - velA;
    float velocityAlongNormal = dot(relativeVel, normal);
    
    // If objects are separating, no impulse needed
    if (velocityAlongNormal > 0.0) return;
    
    // Perfectly elastic collision formulas (conserves both momentum and energy)
    float totalMass = massA + massB;
    float massRatioA = (massA - massB) / totalMass;
    float massRatioB = (2.0 * massB) / totalMass;
    float massRatioC = (2.0 * massA) / totalMass;
    float massRatioD = (massB - massA) / totalMass;
    
    // Apply velocity changes
    vec2 impulseA = normal * velocityAlongNormal;
    vec2 impulseB = normal * velocityAlongNormal;
    
    velA = velA + massRatioB * impulseA;
    velB = velB - massRatioC * impulseB;
}

// ============================================================================
// CONTACT PERSISTENCE SYSTEM (Optional, for stability)
// ============================================================================

// Find a persistent contact in the contact buffer
int findPersistentContact(int objectA, int objectB, vec2 normal) {
    int baseIndex = objectA * MAX_CONTACTS_PER_OBJECT;
    
    for (int i = 0; i < MAX_CONTACTS_PER_OBJECT; i++) {
        int contactIndex = baseIndex + i;
        if (contactIndex >= contacts.length()) break;
        
        ContactPoint contact = contacts[contactIndex];
        
        // Check if this contact is between the same objects
        // and has a similar normal direction
        if (contact.frameCount > 0 && dot(contact.normal, normal) > 0.9) {
            return contactIndex;
        }
    }
    
    return -1; // No persistent contact found
}

// Update or create a contact point
void updateContactPoint(int objectA, int objectB, vec2 normal, vec2 position, float penetration) {
    int baseIndex = objectA * MAX_CONTACTS_PER_OBJECT;
    int oldestIndex = baseIndex;
    int oldestFrameCount = 9999;
    
    // Find slot for this contact
    for (int i = 0; i < MAX_CONTACTS_PER_OBJECT; i++) {
        int contactIndex = baseIndex + i;
        if (contactIndex >= contacts.length()) break;
        
        ContactPoint contact = contacts[contactIndex];
        
        // If this slot is empty or matches our contact, use it
        if (contact.frameCount == 0 || dot(contact.normal, normal) > 0.9) {
            // Update existing contact
            contacts[contactIndex].normal = normal;
            contacts[contactIndex].position = position;
            contacts[contactIndex].penetration = penetration;
            contacts[contactIndex].frameCount = min(contact.frameCount + 1, MAX_CONTACT_FRAMES);
            return;
        }
        
        // Track the oldest contact for replacement
        if (contact.frameCount < oldestFrameCount) {
            oldestFrameCount = contact.frameCount;
            oldestIndex = contactIndex;
        }
    }
    
    // Replace the oldest contact
    if (oldestIndex >= 0 && oldestIndex < contacts.length()) {
        contacts[oldestIndex].normal = normal;
        contacts[oldestIndex].position = position;
        contacts[oldestIndex].penetration = penetration;
        contacts[oldestIndex].frameCount = 1;
        contacts[oldestIndex].accumulatedNormalImpulse = 0.0;
        contacts[oldestIndex].accumulatedTangentImpulse = 0.0;
    }
}

// Age out old contacts
void ageContacts(int objectIndex) {
    int baseIndex = objectIndex * MAX_CONTACTS_PER_OBJECT;
    
    for (int i = 0; i < MAX_CONTACTS_PER_OBJECT; i++) {
        int contactIndex = baseIndex + i;
        if (contactIndex >= contacts.length()) break;
        
        // Decrement frame count, remove if too old
        if (contacts[contactIndex].frameCount > 0) {
            contacts[contactIndex].frameCount--;
            if (contacts[contactIndex].frameCount == 0) {
                // Reset contact
                contacts[contactIndex].accumulatedNormalImpulse = 0.0;
                contacts[contactIndex].accumulatedTangentImpulse = 0.0;
            }
        }
    }
}

// ============================================================================
// MAIN COMPUTE SHADER ENTRY POINT - UPDATED WITH FIXED COLLISION RESOLUTION
// ============================================================================

void main() {
    uint gid = gl_GlobalInvocationID.x;
    
    // Early exit if beyond active object count
    if (int(gid) >= uNumObjects) return;
    
    // Read current object state
    Object p = objectsIn[gid];
    vec2 pos = p.position;
    vec2 vel = p.velocity;
    float mass = max(EPSILON, p.mass);
    float charge = p.charge;
    float rotation = p.visualData.z;
    float angular_vel = p.visualData.w;
    vec4 color = p.color;
    int objectIndex = int(gid);
    vec2 originalPos = pos;
    
    // Initialize physics variables
    vec2 acceleration = vec2(0.0);
    float angular_accel = 0.0;
    vec4 new_color = color;
    
    // ========================================================================
    // PHYSICS EQUATION EVALUATION (UNCHANGED)
    // ========================================================================
    if (uEquationMode == 0) {
        // Custom equation mode
        int eqID = p.equationID;
        bool isValidEquation = (eqID >= 0 && eqID < MAX_EQUATION_COUNT) && 
                              (mappings[eqID].tokenCount_ax > 0 || 
                               mappings[eqID].tokenCount_ay > 0 ||
                               mappings[eqID].tokenCount_angular > 0 ||
                               mappings[eqID].tokenCount_r > 0 ||
                               mappings[eqID].tokenCount_g > 0 ||
                               mappings[eqID].tokenCount_b > 0 ||
                               mappings[eqID].tokenCount_a > 0);
        
        if (!isValidEquation) {
            // Use default physics if equation is invalid
            acceleration = calculateDefaultPhysics(pos, vel, mass);
        } else {
            // Evaluate custom physics equation components
            EquationMapping mapping = mappings[eqID];
            float ax = 0.0;
            float ay = 0.0;
            
            // Evaluate X acceleration component
            if (mapping.tokenCount_ax > 0) {
                ax = evaluateRPNComponent(pos.x, pos.y, vel.x, vel.y, p.collisionData.x, p.collisionData.y,
                                        rotation, angular_vel, color, mass, charge, objectIndex,
                                        0, mapping.tokenOffset_ax, mapping.tokenCount_ax, mapping.constantOffset_ax);
            }
            
            // Evaluate Y acceleration component
            if (mapping.tokenCount_ay > 0) {
                ay = evaluateRPNComponent(pos.x, pos.y, vel.x, vel.y, p.collisionData.x, p.collisionData.y,
                                        rotation, angular_vel, color, mass, charge, objectIndex,
                                        1, mapping.tokenOffset_ay, mapping.tokenCount_ay, mapping.constantOffset_ay);
            }
            
            acceleration = sanitizeVec2(vec2(ax, ay));
            
            // Evaluate angular acceleration
            if (mapping.tokenCount_angular > 0) {
                angular_accel = evaluateRPNComponent(pos.x, pos.y, vel.x, vel.y, p.collisionData.x, p.collisionData.y,
                                                   rotation, angular_vel, color, mass, charge, objectIndex,
                                                   2, mapping.tokenOffset_angular, mapping.tokenCount_angular, mapping.constantOffset_angular);
                angular_accel = isInvalidFloat(angular_accel) ? 0.0 : angular_accel;
            }
            
            // Evaluate color components (dynamic coloring)
            if (mapping.tokenCount_r > 0) {
                new_color.r = evaluateRPNComponent(pos.x, pos.y, vel.x, vel.y, p.collisionData.x, p.collisionData.y,
                                                 rotation, angular_vel, color, mass, charge, objectIndex,
                                                 3, mapping.tokenOffset_r, mapping.tokenCount_r, mapping.constantOffset_r);
            }
            if (mapping.tokenCount_g > 0) {
                new_color.g = evaluateRPNComponent(pos.x, pos.y, vel.x, vel.y, p.collisionData.x, p.collisionData.y,
                                                 rotation, angular_vel, color, mass, charge, objectIndex,
                                                 4, mapping.tokenOffset_g, mapping.tokenCount_g, mapping.constantOffset_g);
            }
            if (mapping.tokenCount_b > 0) {
                new_color.b = evaluateRPNComponent(pos.x, pos.y, vel.x, vel.y, p.collisionData.x, p.collisionData.y,
                                                 rotation, angular_vel, color, mass, charge, objectIndex,
                                                 5, mapping.tokenOffset_b, mapping.tokenCount_b, mapping.constantOffset_b);
            }
            if (mapping.tokenCount_a > 0) {
                new_color.a = evaluateRPNComponent(pos.x, pos.y, vel.x, vel.y, p.collisionData.x, p.collisionData.y,
                                                 rotation, angular_vel, color, mass, charge, objectIndex,
                                                 6, mapping.tokenOffset_a, mapping.tokenCount_a, mapping.constantOffset_a);
            }
            
            new_color = sanitizeVec4(new_color);
        }
    } else {
        // Default physics mode (simple spring-mass-damper)
        acceleration = calculateDefaultPhysics(pos, vel, mass);
    }
    
    acceleration = sanitizeVec2(acceleration);
    
    // ========================================================================
    // STABLE INTEGRATION (Symplectic Euler - Energy Conserving)
    // ========================================================================
    
    // 1. Update VELOCITY first using current acceleration
    vec2 new_vel = vel + acceleration * uDt;
    new_vel = sanitizeVec2(new_vel);
    
    // 2. Use NEW VELOCITY to update POSITION (energy-conserving)
    vec2 new_pos = pos + new_vel * uDt;
    new_pos = sanitizeVec2(new_pos);
    
    // 3. Same for angular motion
    float new_angular_vel = angular_vel + angular_accel * uDt;
    float new_rotation = rotation + new_angular_vel * uDt;
    new_rotation = mod(new_rotation, 2.0 * PI);  // Wrap rotation
    
    // ========================================================================
    // WORLD BOUNDARIES
    // ========================================================================
    const vec2 world_min = vec2(-1000000.0, -1000000.0);
    const vec2 world_max = vec2(1000000.0, 1000000.0);
    const float boundary_friction = 0.95;
    
    // X boundaries
    if (new_pos.x < world_min.x) { 
        new_pos.x = world_min.x; 
        new_vel.x = abs(new_vel.x) * uRestitution; 
        new_vel.y *= boundary_friction; 
    } 
    else if (new_pos.x > world_max.x) { 
        new_pos.x = world_max.x; 
        new_vel.x = -abs(new_vel.x) * uRestitution; 
        new_vel.y *= boundary_friction; 
    }
    
    // Y boundaries
    if (new_pos.y < world_min.y) { 
        new_pos.y = world_min.y; 
        new_vel.y = abs(new_vel.y) * uRestitution; 
        new_vel.x *= boundary_friction; 
    } 
    else if (new_pos.y > world_max.y) { 
        new_pos.y = world_max.y; 
        new_vel.y = -abs(new_vel.y) * uRestitution; 
        new_vel.x *= boundary_friction; 
    }
    
    // ========================================================================
    // CONSTRAINT RESOLUTION (UNCHANGED)
    // ========================================================================
    applyConstraints(new_pos, new_vel, objectIndex, originalPos);
    
    // ========================================================================
    // COLLISION SYSTEM - FIXED TO PREVENT DOUBLE-RESOLUTION
    // ========================================================================
    
    // Age out old contacts for this object
    if (uEnableWarmStart == 1) {
        ageContacts(objectIndex);
    }
    
    vec2 collision_pos = new_pos;
    vec2 collision_vel = new_vel;
    
    // CRITICAL FIX: Only check objects with HIGHER indices
    // This ensures each collision pair is processed exactly once
    for (int i = objectIndex + 1; i < uNumObjects; i++) {
        Object other = objectsIn[i];
        
        // Detect collision
        CollisionInfo collision = detectCollision(p, other, i);
        
        if (collision.hasCollision) {
            // Get collision properties
            CollisionProperties propsA = collisionProps[objectIndex];
            CollisionProperties propsB = collisionProps[i];
            
            // Get other object's state
            vec2 other_pos = other.position;
            vec2 other_vel = other.velocity;
            float other_mass = max(EPSILON, other.mass);
            
            // Choose resolution method
            float restitution = min(propsA.restitution, propsB.restitution);
            float friction = sqrt(propsA.friction * propsB.friction);
            
            // Make local copies for collision resolution
            vec2 temp_pos_a = collision_pos;
            vec2 temp_vel_a = collision_vel;
            vec2 temp_pos_b = other_pos;
            vec2 temp_vel_b = other_vel;
            
            // Apply collision response to both objects
            applyCollisionResponse(
                temp_pos_a, temp_vel_a, mass,
                temp_pos_b, temp_vel_b, other_mass,
                collision.normal, collision.penetration,
                restitution, friction
            );
            
            // Update THIS object's state
            collision_pos = temp_pos_a;
            collision_vel = temp_vel_a;
            
            // ATOMIC UPDATE: Store the impulse to be applied
            // Instead of directly writing, we'll accumulate the velocity change
            vec2 delta_vel_b = temp_vel_b - other_vel;
            vec2 delta_pos_b = temp_pos_b - other_pos;
            
            // Use atomic operations or shared memory to accumulate changes
            // For now, we'll use a conservative approach:
            // Only the lower-index thread writes, which we guarantee by our loop structure
            
            // Since we're in thread objectIndex and i > objectIndex,
            // thread i hasn't processed its collisions yet, so this is safe
            objectsOut[i].position = temp_pos_b;
            objectsOut[i].velocity = temp_vel_b;
            
            // Preserve other object's properties
            objectsOut[i].mass = other_mass;
            objectsOut[i].charge = other.charge;
            objectsOut[i].visualSkinType = other.visualSkinType;
            objectsOut[i].collisionShapeType = other.collisionShapeType;
            objectsOut[i].visualData = other.visualData;
            objectsOut[i].collisionData = other.collisionData;
            objectsOut[i].color = other.color;
            objectsOut[i].equationID = other.equationID;
            objectsOut[i]._pad1 = 0;
            objectsOut[i]._padEnd[0] = 0;
            objectsOut[i]._padEnd[1] = 0;
            
            // Update contact persistence if enabled
            if (uEnableWarmStart == 1) {
                vec2 contact_position = 0.5 * (collision_pos + other_pos);
                updateContactPoint(objectIndex, i, collision.normal, 
                                  contact_position, collision.penetration);
            }
        }
    }
    
    // REMOVED: The second collision loop that was causing double-resolution
    // We no longer need to check i < objectIndex because all pairs are
    // processed exactly once in the loop above
    
    // Apply the collision-corrected state
    new_pos = sanitizeVec2(collision_pos);
    new_vel = sanitizeVec2(collision_vel);
    
    // ========================================================================
    // FINAL SANITY CHECKS
    // ========================================================================
    
    // Ensure velocities aren't excessive
    float maxSpeed = 1000.0;
    float currentSpeed = length(new_vel);
    if (currentSpeed > maxSpeed) {
        new_vel = normalize(new_vel) * maxSpeed;
    }
    
    // ========================================================================
    // WRITE UPDATED OBJECT STATE 
    // ========================================================================
    objectsOut[gid].position = new_pos;
    objectsOut[gid].velocity = new_vel;
    objectsOut[gid].mass = mass;
    objectsOut[gid].charge = charge;
    objectsOut[gid].visualSkinType = p.visualSkinType;
    objectsOut[gid].collisionShapeType = p.collisionShapeType;
    objectsOut[gid].visualData.x = p.visualData.x;
    objectsOut[gid].visualData.y = p.visualData.y;
    objectsOut[gid].visualData.z = new_rotation;
    objectsOut[gid].visualData.w = new_angular_vel;
    objectsOut[gid].collisionData.x = acceleration.x;
    objectsOut[gid].collisionData.y = acceleration.y;
    objectsOut[gid].collisionData.z = p.collisionData.z;
    objectsOut[gid].collisionData.w = p.collisionData.w;
    objectsOut[gid].color = new_color;
    objectsOut[gid].equationID = p.equationID;
    objectsOut[gid]._pad1 = 0;
    objectsOut[gid]._padEnd[0] = 0;
    objectsOut[gid]._padEnd[1] = 0;
}

// ============================================================================
// END OF RESEARCH-GRADE COLLISION SYSTEM
// ============================================================================