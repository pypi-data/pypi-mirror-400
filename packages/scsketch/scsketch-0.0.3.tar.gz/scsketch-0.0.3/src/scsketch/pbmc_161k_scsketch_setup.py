{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b3de346e-39fd-403a-bf53-78371cdb75cd",
   "metadata": {},
   "outputs": [],
   "source": [
    "# pbmc_161k_scsketch_setup.py\n",
    "# Robust, sparse-friendly setup + benchmarks for the CELLxGENE PBMC 161k dataset\n",
    "\n",
    "import os, time\n",
    "from pathlib import Path\n",
    "import numpy as np\n",
    "import scanpy as sc\n",
    "\n",
    "# ---- Thread caps (helps stability on laptops) ----\n",
    "os.environ.setdefault(\"OMP_NUM_THREADS\", \"4\")\n",
    "os.environ.setdefault(\"OPENBLAS_NUM_THREADS\", \"4\")\n",
    "os.environ.setdefault(\"MKL_NUM_THREADS\", \"4\")\n",
    "os.environ.setdefault(\"VECLIB_MAXIMUM_THREADS\", \"4\")\n",
    "os.environ.setdefault(\"NUMEXPR_NUM_THREADS\", \"4\")\n",
    "\n",
    "# ---- Optional memory reporter ----\n",
    "try:\n",
    "    import psutil\n",
    "    PSUTIL = True\n",
    "except Exception:\n",
    "    PSUTIL = False\n",
    "\n",
    "def mem_report(tag=\"\"):\n",
    "    if not PSUTIL: \n",
    "        return\n",
    "    rss_gb = psutil.Process().memory_info().rss / 1e9\n",
    "    print(f\"[mem] {tag} RSS ≈ {rss_gb:.2f} GB\")\n",
    "\n",
    "# ---- Download if needed ----\n",
    "URL  = \"https://datasets.cellxgene.cziscience.com/6d790453-b593-4c5d-a2a0-d4c4f891292f.h5ad\"\n",
    "DATA = Path(\"nygc_multimodal_pbmc.h5ad\")\n",
    "LITE = Path(\"nygc_pbmc_161k_lite.h5ad\")\n",
    "\n",
    "def maybe_download():\n",
    "    if DATA.exists():\n",
    "        return\n",
    "    import urllib.request\n",
    "    print(f\"Downloading {URL} ...\")\n",
    "    urllib.request.urlretrieve(URL, DATA)\n",
    "    print(\"Done.\\n\")\n",
    "\n",
    "# ---- Sparse-safe helpers ----\n",
    "from scipy import sparse\n",
    "from scipy.stats import t as student_t\n",
    "\n",
    "def ensure_sparse_float32_X(adata):\n",
    "    \"\"\"Make adata.X CSR float32 (saves RAM; required for fast ops).\"\"\"\n",
    "    if not sparse.isspmatrix(adata.X):\n",
    "        adata.X = sparse.csr_matrix(adata.X)\n",
    "    if adata.X.dtype != np.float32:\n",
    "        adata.X = adata.X.astype(np.float32, copy=False)\n",
    "\n",
    "def cast_umap_float32(adata):\n",
    "    if \"X_umap\" in adata.obsm:\n",
    "        adata.obsm[\"X_umap\"] = adata.obsm[\"X_umap\"].astype(np.float32, copy=False)\n",
    "\n",
    "def write_lite(adata, path: Path):\n",
    "    \"\"\"Drop heavy extras; keep X/obs/var/UMAP for faster reloads.\"\"\"\n",
    "    print(\"\\nWriting lightweight copy for fast iteration...\")\n",
    "    ad = adata.copy()\n",
    "    if ad.raw is not None:\n",
    "        ad.raw = None\n",
    "    if hasattr(ad, \"layers\") and ad.layers is not None:\n",
    "        for k in list(ad.layers.keys()):\n",
    "            del ad.layers[k]\n",
    "    # keep neighbors/umap if present\n",
    "    ad.write(path, compression=\"gzip\")\n",
    "    print(f\"Saved: {path}\")\n",
    "\n",
    "# ---- Benchmarks (sparse, vectorized) ----\n",
    "def precompute_gene_stats(X):\n",
    "    \"\"\"Return (mean_x, std_x) for sparse X without densifying.\"\"\"\n",
    "    n = X.shape[0]\n",
    "    mean_x = np.asarray(X.mean(axis=0)).ravel().astype(np.float64)\n",
    "    sumsq_x = np.asarray(X.power(2).sum(axis=0)).ravel().astype(np.float64)\n",
    "    var_x   = (sumsq_x - n * (mean_x ** 2)) / max(n - 1, 1)\n",
    "    std_x   = np.sqrt(np.maximum(var_x, 1e-12))\n",
    "    return mean_x, std_x\n",
    "\n",
    "def sketch_latency_sparse(adata, n_repeats=3, layer=None, seed=42):\n",
    "    \"\"\"Time correlation + p-value computation for random 2D direction (sparse).\"\"\"\n",
    "    assert \"X_umap\" in adata.obsm, \"Need adata.obsm['X_umap']\"\n",
    "    X = adata.layers[layer] if layer else adata.X\n",
    "    if not sparse.isspmatrix(X):\n",
    "        X = sparse.csr_matrix(X)\n",
    "    n = X.shape[0]\n",
    "    U = adata.obsm[\"X_umap\"]\n",
    "\n",
    "    mean_x, std_x = precompute_gene_stats(X)\n",
    "    rng = np.random.default_rng(seed)\n",
    "    times = []\n",
    "\n",
    "    for _ in range(n_repeats):\n",
    "        v = rng.normal(size=2); v /= np.linalg.norm(v)\n",
    "        proj = U @ v  # (n,)\n",
    "        mean_p = float(proj.mean())\n",
    "        std_p  = float(proj.std(ddof=1))\n",
    "\n",
    "        t0 = time.perf_counter()\n",
    "        projX = (proj.reshape(1, -1) @ X).A1\n",
    "        cov   = projX - n * mean_p * mean_x\n",
    "        r     = cov / ((n - 1) * std_p * std_x)\n",
    "\n",
    "        tstat = r * np.sqrt((n - 2) / np.clip(1 - r**2, 1e-12, 1.0))\n",
    "        _p    = 2 * student_t.sf(np.abs(tstat), df=n - 2)  # not used further here\n",
    "        times.append(time.perf_counter() - t0)\n",
    "\n",
    "    return float(np.median(times)), float(np.mean(times))\n",
    "\n",
    "def sketch_latency_chunked(adata, block=2000, seed=7):\n",
    "    \"\"\"Process genes in chunks to bound peak memory (timing only).\"\"\"\n",
    "    assert \"X_umap\" in adata.obsm, \"Need adata.obsm['X_umap']\"\n",
    "    X = adata.X\n",
    "    if not sparse.isspmatrix(X):\n",
    "        X = sparse.csr_matrix(X)\n",
    "    n, g = X.shape\n",
    "    U = adata.obsm[\"X_umap\"]\n",
    "    v = np.array([1.0, 0.0], dtype=np.float32)  # fixed dir for reproducibility\n",
    "    proj = U @ v\n",
    "\n",
    "    mean_x = np.asarray(X.mean(axis=0)).ravel().astype(np.float64)\n",
    "    sumsq_x = np.asarray(X.power(2).sum(axis=0)).ravel().astype(np.float64)\n",
    "    var_x   = (sumsq_x - n * (mean_x ** 2)) / max(n - 1, 1)\n",
    "    std_x   = np.sqrt(np.maximum(var_x, 1e-12))\n",
    "    mean_p  = float(proj.mean())\n",
    "    std_p   = float(proj.std(ddof=1))\n",
    "\n",
    "    t0 = time.perf_counter()\n",
    "    for start in range(0, g, block):\n",
    "        stop = min(start + block, g)\n",
    "        X_blk = X[:, start:stop]\n",
    "        projX_blk = (proj.reshape(1, -1) @ X_blk).A1\n",
    "        cov_blk   = projX_blk - n * mean_p * mean_x[start:stop]\n",
    "        r_blk     = cov_blk / ((n - 1) * std_p * std_x[start:stop])\n",
    "        _ = r_blk  # timing only\n",
    "    return time.perf_counter() - t0\n",
    "\n",
    "def main():\n",
    "    maybe_download()\n",
    "\n",
    "    print(\"Loading AnnData...\")\n",
    "    t0 = time.perf_counter()\n",
    "    adata = sc.read_h5ad(DATA)\n",
    "    t1 = time.perf_counter()\n",
    "    print(f\"Loaded in {t1 - t0:.1f}s\")\n",
    "    print(adata)\n",
    "    mem_report(\"after load\")\n",
    "\n",
    "    # Quick peek at metadata\n",
    "    print(\"\\n.obs columns:\", list(adata.obs.columns)[:15], \"...\")\n",
    "    if \"cell_type\" in adata.obs:\n",
    "        print(\"\\nTop cell_type counts:\")\n",
    "        print(adata.obs[\"cell_type\"].value_counts().head(10))\n",
    "\n",
    "    # Ensure sparse + float32 + float32 UMAP\n",
    "    ensure_sparse_float32_X(adata)\n",
    "    cast_umap_float32(adata)\n",
    "    mem_report(\"after cast\")\n",
    "\n",
    "    # Confirm UMAP present (this dataset already has it)\n",
    "    if \"X_umap\" not in adata.obsm_keys():\n",
    "        print(\"\\nNo UMAP found. Computing neighbors/UMAP (one-time) ...\")\n",
    "        sc.pp.pca(adata, n_comps=50, svd_solver=\"arpack\")\n",
    "        sc.pp.neighbors(adata, n_neighbors=15, n_pcs=50, metric=\"cosine\")\n",
    "        sc.tl.umap(adata, min_dist=0.5, spread=1.0)\n",
    "        print(\"UMAP computed.\")\n",
    "        mem_report(\"after UMAP\")\n",
    "\n",
    "    # Write a lightweight copy (first run only)\n",
    "    if not LITE.exists():\n",
    "        write_lite(adata, LITE)\n",
    "\n",
    "    # ---- Benchmarks ----\n",
    "    print(\"\\n=== Sparse timing: FULL gene set ===\")\n",
    "    med, mean = sketch_latency_sparse(adata, n_repeats=3)\n",
    "    print(f\"Median sketch→corr+pvals: {med:.3f}s (mean {mean:.3f}s)\")\n",
    "    mem_report(\"post full timing\")\n",
    "\n",
    "    print(\"\\n=== Sparse timing: HVG 5000 (quick-iter) ===\")\n",
    "    ad_fast = adata.copy()\n",
    "    sc.pp.highly_variable_genes(ad_fast, n_top_genes=5000, flavor=\"seurat_v3\", subset=True)\n",
    "    med_f, mean_f = sketch_latency_sparse(ad_fast, n_repeats=3)\n",
    "    print(f\"{ad_fast.shape}  median {med_f:.3f}s (mean {mean_f:.3f}s)\")\n",
    "    mem_report(\"post HVG timing\")\n",
    "\n",
    "    print(\"\\n=== Chunked timing over ALL genes (2k blocks) ===\")\n",
    "    secs = sketch_latency_chunked(adata, block=2000)\n",
    "    print(f\"Processed all genes in chunks: {secs:.3f}s\")\n",
    "    mem_report(\"post chunk timing\")\n",
    "\n",
    "    # ---- scSketch launch hint ----\n",
    "    print(\"\\n>>> In your notebook, run:\")\n",
    "    print(\"from scsketch import view  # or scSketch.view depending on your API\")\n",
    "    print(\"view(adata)                # starts the interactive UI\")\n",
    "    print(\"\\n✅ Done.\")\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.13.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
