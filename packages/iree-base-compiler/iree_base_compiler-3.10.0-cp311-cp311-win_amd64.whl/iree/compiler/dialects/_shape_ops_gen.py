
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union, Optional as _Optional


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "shape"

@_ods_cext.register_operation(_Dialect)
class AddOp(_ods_ir.OpView):
  r"""
  Adds two sizes or indices. If either operand is an error it will be
  propagated to the result. The operands can be of type `size` or `index`. If
  at least one of the operands can hold an error, i.e. if it is of type
  `size`, the result must be of type `size`. If error propagation is not
  possible because both operands are of type `index` then the result may be
  of type `size` or `index`.
  """

  OPERATION_NAME = "shape.add"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def add(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AddOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AnyOp(_ods_ir.OpView):
  r"""
  This operation takes multiple input shapes or extent tensors and returns
  some combination of their dimensions. This can be best seen with examples
  below.
  
  The result is undefined, but still side-effect free, in cases where the
  inputs have differing ranks or differ in extents of shared dimensions.
  
  Example:
  ```mlir
  %s0 = shape.any [2,?], [?,3] // [2,3]
  %s1 = shape.any [?,?], [1,2] // [1,2]
  ```
  """

  OPERATION_NAME = "shape.any"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, inputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def any(result, inputs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return AnyOp(result=result, inputs=inputs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AssumingAllOp(_ods_ir.OpView):
  r"""
  Used to simplify constraints as any single failing precondition is enough
  to prevent execution.
  
  "assuming" operations represent an execution order restriction to the
  compiler, information for dependent code to rely on (by assuming), and
  nothing else. They should not exist after a program is fully lowered and
  ready to execute.
  
  Example:
  ```mlir
  %w0 = shape.cstr_broadcastable [2,2], [3,1,2] // Passing
  %w1 = shape.cstr_broadcastable [2,2], [3,2] // Failure
  %w2 = shape.cstr_eq [1,2], [1,2], [1,2] // Passing
  %wf = shape.assuming_all %w0, %w1 // Failure
  %wt = shape.assuming_all %w0, %w2 // Passing
  ```
  """

  OPERATION_NAME = "shape.assuming_all"

  _ODS_REGIONS = (0, True)

  def __init__(self, inputs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def assuming_all(inputs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AssumingAllOp(inputs=inputs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AssumingOp(_ods_ir.OpView):
  r"""
  Executes the region assuming all witnesses are true.
  
  "assuming" operations represent an execution order restriction to the
  compiler, information for dependent code to rely on (by assuming), and
  nothing else. They should not exist after a program is fully lowered and
  ready to execute.
  """

  OPERATION_NAME = "shape.assuming"

  _ODS_REGIONS = (1, True)

  def __init__(self, results_, witness, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(witness)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def witness(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def results_(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def doRegion(self) -> _ods_ir.Region:
    return self.regions[0]

def assuming(results_, witness, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, AssumingOp]:
  op = AssumingOp(results_=results_, witness=witness, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class AssumingYieldOp(_ods_ir.OpView):
  r"""
  This yield operation represents a return operation within the
  `shape.assuming` operation region. The operation takes variable number of
  operands and produces no results. The operand number and types must match
  the number and types of parent `shape.assuming` results.
  """

  OPERATION_NAME = "shape.assuming_yield"

  _ODS_REGIONS = (0, True)

  def __init__(self, operands_, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def assuming_yield(operands_, *, loc=None, ip=None) -> AssumingYieldOp:
  return AssumingYieldOp(operands_=operands_, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class BroadcastOp(_ods_ir.OpView):
  r"""
  Returns the broadcasted shape for input shapes or extent tensors. The rest
  of this description is simplified for the 2 input case but can be extended
  to more inputs. Both operands can be of type `shape.shape` or
  `tensor<?xindex>`. The result is of type `shape.shape` and, if both
  operands are tensors, may be of type `tensor<?xindex>`.
  
  If the two operand shapes are of different rank the smaller one is padded
  with 1's from the left. The resulting broadcasted shape is then defined as
  
      result[i] = lhs[i] if lhs[i] == rhs[i]
                = lhs[i] if rhs[i] == 1
                = rhs[i] if lhs[i] == 1.
  
  In case the resulting shape is undefined, i.e. if corresponding extents are
  different from each other but none is 1, the result is an error shape.
  Likewise error values are propagated if any of the operands holds an error
  value. If the result type is an extent tensor (and can therefore not hold
  the error value) the behavior may be undefined. The optional string
  attribute can be used to describe the error case.
  """

  OPERATION_NAME = "shape.broadcast"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, shapes, *, error=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(shapes))
    _ods_context = _ods_get_default_loc_context(loc)
    if error is not None: attributes["error"] = (error if (
        isinstance(error, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(error, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def shapes(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def error(self) -> _Optional[_ods_ir.StringAttr]:
    if "error" not in self.operation.attributes:
      return None
    return self.operation.attributes["error"]

  @error.setter
  def error(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["error"] = value
    elif "error" in self.operation.attributes:
      del self.operation.attributes["error"]

  @error.deleter
  def error(self):
    del self.operation.attributes["error"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def broadcast(result, shapes, *, error=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BroadcastOp(result=result, shapes=shapes, error=error, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConcatOp(_ods_ir.OpView):
  r"""
  Creates a shape whose dimensions consist of first the dimensions from `lhs`
  followed by the dimensions of `rhs`.
  
  Example:
  concat([2,3], [4,5]) -> [2,3,4,5]
  concat([], []) -> []
  concat([], [4,5,6]) -> [4,5,6]
  """

  OPERATION_NAME = "shape.concat"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def concat(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ConcatOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConstShapeOp(_ods_ir.OpView):
  r"""
  Creates a constant shape or extent tensor. The individual extents are given
  as the `shape` attribute. The number of these values equals the shape's
  rank.
  
  ```mlir
  %0 = shape.const_shape [] : !shape.shape
  %1 = shape.const_shape [1, 2, 3] : !shape.shape
  %2 = shape.const_shape [4, 5, 6] : tensor<3xindex>
  ```
  """

  OPERATION_NAME = "shape.const_shape"

  _ODS_REGIONS = (0, True)

  def __init__(self, shape, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["shape"] = (shape if (
    isinstance(shape, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IndexElementsAttr')) else
      _ods_ir.AttrBuilder.get('IndexElementsAttr')(shape, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def shape(self) -> _ods_ir.DenseIntElementsAttr:
    return self.operation.attributes["shape"]

  @shape.setter
  def shape(self, value: _ods_ir.DenseIntElementsAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["shape"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def const_shape(shape, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ConstShapeOp(shape=shape, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConstSizeOp(_ods_ir.OpView):
  r"""
  Creates a `shape.size` type representing the constant size given by `value`.
  
  ```mlir
  %x = shape.const_size 10
  ```
  """

  OPERATION_NAME = "shape.const_size"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IndexAttr')) else
      _ods_ir.AttrBuilder.get('IndexAttr')(value, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def const_size(value, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ConstSizeOp(value=value, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConstWitnessOp(_ods_ir.OpView):
  r"""
  This operation represents a statically known witness result. This can be
  often used to canonicalize/fold constraint and assuming code that will always
  pass.
  
  ```mlir
  %0 = shape.const_shape [1,2,3]
  %1 = shape.const_shape [1,2,3]
  %w0 = shape.cstr_eq(%0, %1) // Can be folded to "const_witness true"
  %w1 = shape.const_witness true
  %w2 = shape.assuming_all(%w0, %w2) // Can be folded to "const_witness true"
  ```
  """

  OPERATION_NAME = "shape.const_witness"

  _ODS_REGIONS = (0, True)

  def __init__(self, passing, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["passing"] = (passing if (
    isinstance(passing, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(passing, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def passing(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["passing"]

  @passing.setter
  def passing(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["passing"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def const_witness(passing, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ConstWitnessOp(passing=passing, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CstrBroadcastableOp(_ods_ir.OpView):
  r"""
  Given input shapes or extent tensors, return a witness specifying if they
  are broadcastable. This broadcastable follows the same logic as what
  shape.broadcast documents.
  
  "cstr" operations represent runtime assertions.
  
  Example:
  ```mlir
  %w0 = shape.cstr_broadcastable [2,2], [3,1,2] // Passing
  %w1 = shape.cstr_broadcastable [2,2], [3,2] // Failure
  ```
  """

  OPERATION_NAME = "shape.cstr_broadcastable"

  _ODS_REGIONS = (0, True)

  def __init__(self, shapes, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(shapes))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def shapes(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cstr_broadcastable(shapes, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CstrBroadcastableOp(shapes=shapes, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CstrEqOp(_ods_ir.OpView):
  r"""
  Given 1 or more input shapes, determine if all shapes are the exact same.
  
  "cstr" operations represent runtime assertions.
  
  Example:
  ```mlir
  %w0 = shape.cstr_eq [1,2], [1,2], [1,2] // Passing
  %w1 = shape.cstr_eq [2,2], [1,2] // Failure
  ```
  """

  OPERATION_NAME = "shape.cstr_eq"

  _ODS_REGIONS = (0, True)

  def __init__(self, shapes, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(shapes))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def shapes(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cstr_eq(shapes, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CstrEqOp(shapes=shapes, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CstrRequireOp(_ods_ir.OpView):
  r"""
  Represents a runtime assertion that an i1 is true. It returns a
  !shape.witness to order this assertion.
  
  For simplicity, prefer using other cstr_* ops if they are available for a
  given constraint.
  
  Example:
  ```mlir
  %bool = ...
  %w0 = shape.cstr_require %bool, "msg" // Passing if `%bool` is true.
  ```
  
  Since this op can be used to express many different possible assertions
  (depending on whatever computation calculated `pred`), the `msg`
  should clarify the nature of the assertion for users.
  """

  OPERATION_NAME = "shape.cstr_require"

  _ODS_REGIONS = (0, True)

  def __init__(self, pred, msg, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(pred)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["msg"] = (msg if (
    isinstance(msg, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(msg, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def pred(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def msg(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["msg"]

  @msg.setter
  def msg(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["msg"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cstr_require(pred, msg, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CstrRequireOp(pred=pred, msg=msg, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DebugPrintOp(_ods_ir.OpView):
  r"""
  Prints the input dim or shape and passes through input.
  
  Note: This is intended for testing and debugging only.
  """

  OPERATION_NAME = "shape.debug_print"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def debug_print(output, input, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return DebugPrintOp(output=output, input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DimOp(_ods_ir.OpView):
  r"""
  Gets the extent indexed by `dim` from the shape of the `value` operand. If
  the index is error or out-of-bound then it returns an invalid size if the
  return type carries error information else the behavior is undefined.
  
  This is a convenience op that performs the equivalent of getting the extent
  of a shape (e.g., `dim(x, i) == get_extent(shape_of(x), i)`).
  """

  OPERATION_NAME = "shape.dim"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, index, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    operands.append(index)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def index(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def extent(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def dim(value, index, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return DimOp(value=value, index=index, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DivOp(_ods_ir.OpView):
  r"""
  Divides two sizes or indices. If either operand is an error it will be
  propagated to the result. The operands can be of type `size` or `index`.
  If at least one of the operands can hold an error, i.e. if it is of type
  `size`, the result must be of type `size`. If error propagation is not
  possible because both operands are of type `index` then the result may be
  of type  `size` or `index`. If both operands and result are of type
  `index`, their runtime values could be negative. The result is rounded
  toward negative infinity, i.e. floor(lhs / rhs), such that
  
      div(lhs, rhs) * rhs + mod(lhs, rhs) = lhs
  
  always holds. If any of the values is of type `size`, the behavior for
  negative value is undefined.
  """

  OPERATION_NAME = "shape.div"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def div(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return DivOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FromExtentTensorOp(_ods_ir.OpView):
  r"""
  Creates a shape from a 1D integral tensor of extents. The rank of the
  resulting shape equals the number of elements in the tensor, and the
  extents match the values of the elements.
  """

  OPERATION_NAME = "shape.from_extent_tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value[_ods_ir.RankedTensorType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def from_extent_tensor(input, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return FromExtentTensorOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FromExtentsOp(_ods_ir.OpView):
  r"""
  Creates a shape from multiple SSA values representing the extents of
  the shape.
  
  ```mlir
  // Rank 2 shape.
  %s0 = shape.from_extents %a, %b
  // Rank 0 shape.
  %s1 = shape.from_extents
  ```
  """

  OPERATION_NAME = "shape.from_extents"

  _ODS_REGIONS = (0, True)

  def __init__(self, extents, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(extents))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def extents(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def shape(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def from_extents(extents, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return FromExtentsOp(extents=extents, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FuncOp(_ods_ir.OpView):
  r"""
  An operation with a name containing a single `SSACFG` region which
  represents a shape transfer function or helper function for shape transfer
  function.
  """

  OPERATION_NAME = "shape.func"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, function_type, *, arg_attrs=None, res_attrs=None, sym_visibility=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["function_type"] = (function_type if (
    isinstance(function_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_475')) else
      _ods_ir.AttrBuilder.get('anonymous_475')(function_type, context=_ods_context))
    if arg_attrs is not None: attributes["arg_attrs"] = (arg_attrs if (
        isinstance(arg_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(arg_attrs, context=_ods_context))
    if res_attrs is not None: attributes["res_attrs"] = (res_attrs if (
        isinstance(res_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(res_attrs, context=_ods_context))
    if sym_visibility is not None: attributes["sym_visibility"] = (sym_visibility if (
        isinstance(sym_visibility, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(sym_visibility, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def function_type(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["function_type"]

  @function_type.setter
  def function_type(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["function_type"] = value

  @builtins.property
  def arg_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "arg_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["arg_attrs"]

  @arg_attrs.setter
  def arg_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["arg_attrs"] = value
    elif "arg_attrs" in self.operation.attributes:
      del self.operation.attributes["arg_attrs"]

  @arg_attrs.deleter
  def arg_attrs(self):
    del self.operation.attributes["arg_attrs"]

  @builtins.property
  def res_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "res_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["res_attrs"]

  @res_attrs.setter
  def res_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["res_attrs"] = value
    elif "res_attrs" in self.operation.attributes:
      del self.operation.attributes["res_attrs"]

  @res_attrs.deleter
  def res_attrs(self):
    del self.operation.attributes["res_attrs"]

  @builtins.property
  def sym_visibility(self) -> _Optional[_ods_ir.StringAttr]:
    if "sym_visibility" not in self.operation.attributes:
      return None
    return self.operation.attributes["sym_visibility"]

  @sym_visibility.setter
  def sym_visibility(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["sym_visibility"] = value
    elif "sym_visibility" in self.operation.attributes:
      del self.operation.attributes["sym_visibility"]

  @sym_visibility.deleter
  def sym_visibility(self):
    del self.operation.attributes["sym_visibility"]

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def func(sym_name, function_type, *, arg_attrs=None, res_attrs=None, sym_visibility=None, loc=None, ip=None) -> FuncOp:
  return FuncOp(sym_name=sym_name, function_type=function_type, arg_attrs=arg_attrs, res_attrs=res_attrs, sym_visibility=sym_visibility, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class FunctionLibraryOp(_ods_ir.OpView):
  r"""
  Represents a list of shape functions and the ops whose shape transfer
  functions they represent.
  
  Example:
  
  ```mlir
  shape.function_library {
    func @same_result_shape(%arg: !shape.value_shape) -> !shape.shape {
      %0 = shape_of %arg : !shape.value_shape -> !shape.shape
      return %0 : !shape.shape
    }
  } mapping {
    std.atan = @same_result_shape
  }
  ```
  """

  OPERATION_NAME = "shape.function_library"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, mapping, *, sym_visibility=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    if sym_visibility is not None: attributes["sym_visibility"] = (sym_visibility if (
        isinstance(sym_visibility, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(sym_visibility, context=_ods_context))
    attributes["mapping"] = (mapping if (
    isinstance(mapping, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DictionaryAttr')) else
      _ods_ir.AttrBuilder.get('DictionaryAttr')(mapping, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def sym_visibility(self) -> _Optional[_ods_ir.StringAttr]:
    if "sym_visibility" not in self.operation.attributes:
      return None
    return self.operation.attributes["sym_visibility"]

  @sym_visibility.setter
  def sym_visibility(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["sym_visibility"] = value
    elif "sym_visibility" in self.operation.attributes:
      del self.operation.attributes["sym_visibility"]

  @sym_visibility.deleter
  def sym_visibility(self):
    del self.operation.attributes["sym_visibility"]

  @builtins.property
  def mapping(self) -> _ods_ir.DictAttr:
    return self.operation.attributes["mapping"]

  @mapping.setter
  def mapping(self, value: _ods_ir.DictAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mapping"] = value

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def function_library(sym_name, mapping, *, sym_visibility=None, loc=None, ip=None) -> FunctionLibraryOp:
  return FunctionLibraryOp(sym_name=sym_name, mapping=mapping, sym_visibility=sym_visibility, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GetExtentOp(_ods_ir.OpView):
  r"""
  Gets the extent indexed by `dim` from the `shape` operand. If the shape is
  an error then it returns an invalid size.
  """

  OPERATION_NAME = "shape.get_extent"

  _ODS_REGIONS = (0, True)

  def __init__(self, shape, dim, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(shape)
    operands.append(dim)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def shape(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def dim(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def extent(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def get_extent(shape, dim, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GetExtentOp(shape=shape, dim=dim, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class IndexToSizeOp(_ods_ir.OpView):
  r"""
  Converts a standard index to a `shape.size`. This operation and its
  inverse, `size_to_index`, facilitate index conversion between the standard
  and the shape dialect.
  
  The behavior is undefined for negative indices.
  """

  OPERATION_NAME = "shape.index_to_size"

  _ODS_REGIONS = (0, True)

  def __init__(self, arg, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(arg)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def arg(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def index_to_size(arg, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return IndexToSizeOp(arg=arg, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class IsBroadcastableOp(_ods_ir.OpView):
  r"""
  Given multiple input shapes or extent tensors, return a predicate
  specifying if they are broadcastable. This broadcastable follows the same
  logic as what shape.broadcast documents.
  
  Concretely, shape.is_broadcastable returning true implies that
  shape.broadcast will not give an error, and shape.cstr_broadcastable will
  not result in an assertion failure. Similarly, false implies an error or
  assertion failure.
  
  Example:
  ```mlir
  %true = shape.is_broadcastable [2,2], [3,1,2]
  %false = shape.is_broadcastable [2,2], [3,2]
  ```
  """

  OPERATION_NAME = "shape.is_broadcastable"

  _ODS_REGIONS = (0, True)

  def __init__(self, shapes, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(shapes))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def shapes(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def is_broadcastable(shapes, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return IsBroadcastableOp(shapes=shapes, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MaxOp(_ods_ir.OpView):
  r"""
  Computes the elementwise maximum of two sizes or shapes with equal ranks.
  If either operand is an error, then an error will be propagated to the
  result. If the input types mismatch or the ranks do not match, then the
  result is an error.
  """

  OPERATION_NAME = "shape.max"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def max(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MaxOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MeetOp(_ods_ir.OpView):
  r"""
  An operation that computes the least general shape or dim of input operands.
  This effectively asserts that corresponding static dimensions are equal.
  The behavior is to match each element of the shape/size and propagate the
  most restrictive information, returning an invalid shape if there are
  contradictory requirements. E.g., using pseudo code
  
  ```
  shape.meet([*], [*]) -> [*]
  shape.meet([*], [1, ?]) -> [1, ?]
  shape.meet([1, 2], [1, ?]) -> [1, 2]
  shape.meet([*], [1, 2]) -> [1, 2]
  shape.meet([], []) -> []
  shape.meet([], [*]) -> []
  shape.meet([], [?, ?]) -> [invalid]
  shape.meet([1, ?], [2, ?, ?]) -> [invalid]
  ```
  
  `shape.meet` also allows specifying an optional error string, that may be
  used to return an error to the user upon mismatch of dimensions.
  
  ```mlir
  %c = shape.meet %a, %b, error="<reason>" : !shape.shape, !shape.shape -> !shape.shape
  ```
  """

  OPERATION_NAME = "shape.meet"

  _ODS_REGIONS = (0, True)

  def __init__(self, arg0, arg1, *, error=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(arg0)
    operands.append(arg1)
    _ods_context = _ods_get_default_loc_context(loc)
    if error is not None: attributes["error"] = (error if (
        isinstance(error, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(error, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def arg0(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def arg1(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def error(self) -> _Optional[_ods_ir.StringAttr]:
    if "error" not in self.operation.attributes:
      return None
    return self.operation.attributes["error"]

  @error.setter
  def error(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["error"] = value
    elif "error" in self.operation.attributes:
      del self.operation.attributes["error"]

  @error.deleter
  def error(self):
    del self.operation.attributes["error"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def meet(arg0, arg1, *, error=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MeetOp(arg0=arg0, arg1=arg1, error=error, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MinOp(_ods_ir.OpView):
  r"""
  Computes the elementwise minimum of two sizes or shapes with equal ranks.
  If either operand is an error, then an error will be propagated to the
  result. If the input types mismatch or the ranks do not match, then the
  result is an error.
  """

  OPERATION_NAME = "shape.min"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def min(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MinOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MulOp(_ods_ir.OpView):
  r"""
  Multiplies two sizes or indices. If either operand is an error it will be
  propagated to the result. The operands can be of type `size` or `index`. If
  at least one of the operands can hold an error, i.e. if it is of type
  `size`, the result must be of type `size`. If error propagation is not
  possible because both operands are of type `index` then the result may be
  of type `size` or `index`.
  """

  OPERATION_NAME = "shape.mul"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mul(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MulOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class NumElementsOp(_ods_ir.OpView):
  r"""
  Returns the number of elements for a given shape which is the product of
  its extents. If the argument is of type `shape` then the result will be of
  type `size` and potential errors will be propagated. Otherwise, if the
  argument is and extent tensor `tensor<?xindex>` then the result will be of
  type `index`.
  """

  OPERATION_NAME = "shape.num_elements"

  _ODS_REGIONS = (0, True)

  def __init__(self, shape, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(shape)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def shape(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def num_elements(shape, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return NumElementsOp(shape=shape, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RankOp(_ods_ir.OpView):
  r"""
  Returns the rank of the shape or extent tensor, i.e. the number of extents.
  """

  OPERATION_NAME = "shape.rank"

  _ODS_REGIONS = (0, True)

  def __init__(self, shape, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(shape)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def shape(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rank(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def rank(shape, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return RankOp(shape=shape, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ReduceOp(_ods_ir.OpView):
  r"""
  An operation that takes as input a shape or extent tensor, and a number of
  initial values. This operation has a region that is applied repeatedly for
  every extent of the input. Starting with the initial values, the individual
  extents are then aggregated as defined by the associated region.
  
  Conceptually this op performs the following reduction:
  
  ```
  res[] = init;
  for (int i = 0, i < shape.rank(); i++) {
    res = reduce(i, shape[i], res[0], ..., res[n]);
  }
  ```
  
  Where `reduce` represents the region attached and the result of the reduce
  op is the last computed output of the reduce region. As an example, the
  number of elements can be computed as follows:
  
  ```mlir
  func.func @reduce(%shape : !shape.shape, %init : !shape.size) ->
      !shape.size {
    %num_elements = shape.reduce(%shape, %init) -> !shape.size  {
      ^bb0(%index: index, %dim: !shape.size, %acc: !shape.size):
        %updated_acc = "shape.mul"(%acc, %dim) :
          (!shape.size, !shape.size) -> !shape.size
        shape.yield %updated_acc : !shape.size
    }
    return %num_elements : !shape.size
  }
  ```
  """

  OPERATION_NAME = "shape.reduce"

  _ODS_REGIONS = (1, True)

  def __init__(self, result, shape, initVals, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(shape)
    operands.extend(_get_op_results_or_values(initVals))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def shape(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def initVals(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def reduce(result, shape, init_vals, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, ReduceOp]:
  op = ReduceOp(result=result, shape=shape, initVals=init_vals, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class ReturnOp(_ods_ir.OpView):
  r"""
  The `shape.return` operation represents a return operation within a
  function.  The operation takes variable number of operands and produces no
  results.
  """

  OPERATION_NAME = "shape.return"

  _ODS_REGIONS = (0, True)

  def __init__(self, operands_, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def return_(operands_, *, loc=None, ip=None) -> ReturnOp:
  return ReturnOp(operands_=operands_, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ShapeEqOp(_ods_ir.OpView):
  r"""
  Takes one or more shape or extent tensor operands and determines whether
  they are equal. When extent tensors are compared to shapes they are
  regarded as their equivalent non-error shapes. Error shapes can be tested
  for equality like any other shape value, meaning that the error value is
  equal to itself.
  """

  OPERATION_NAME = "shape.shape_eq"

  _ODS_REGIONS = (0, True)

  def __init__(self, shapes, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(shapes))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def shapes(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def shape_eq(shapes, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ShapeEqOp(shapes=shapes, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ShapeOfOp(_ods_ir.OpView):
  r"""
  The operation takes a value or a shaped operand as an argument and it
  returns a shape or extent tensor.
  """

  OPERATION_NAME = "shape.shape_of"

  _ODS_REGIONS = (0, True)

  def __init__(self, arg, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(arg)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def arg(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def shape_of(arg, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ShapeOfOp(arg=arg, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SizeToIndexOp(_ods_ir.OpView):
  r"""
  Converts a `shape.size` to a standard index. This operation and its
  inverse, `index_to_size`, facilitate index conversion between the standard
  and the shape dialect. The behavior is undefined for unknown and invalid
  arguments.
  """

  OPERATION_NAME = "shape.size_to_index"

  _ODS_REGIONS = (0, True)

  def __init__(self, arg, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(arg)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def arg(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IndexType]:
    return self.operation.results[0]

def size_to_index(arg, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return SizeToIndexOp(arg=arg, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SplitAtOp(_ods_ir.OpView):
  r"""
  Splits a shape at a given dimension `index`, returning two shapes. If
  `index` is negative, it is treated as indexing from the back of the shape.
  This negative-handling behavior is important when handling unranked shapes,
  where the positive index is not necessarily knowable due to a dynamic
  number of leading dimensions. If the result is in extent tensor form out of
  bounds indices result in undefined behavior.
  
  Examples:
  - split_at([4,5,6], index=0) -> [], [4,5,6]
  - split_at([4,5,6], index=1) -> [4], [5,6]
  - split_at([4,5,6], index=2) -> [4,5], [6]
  - split_at([4,5,6], index=3) -> [4,5,6], []
  - split_at([4,5,6], index=4) -> error
  - split_at([4,5,6], index=-1) -> [4,5], [6]
  - split_at([4,5,6], index=-2) -> [4], [5,6]
  - split_at([4,5,6], index=-3) -> [], [4,5,6]
  - split_at([4,5,6], index=-4) -> error
  
  Requires:
  - `index` is in the range [-rank(operand),rank(operand)]
  """

  OPERATION_NAME = "shape.split_at"

  _ODS_REGIONS = (0, True)

  def __init__(self, head, tail, operand, index, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    operands.append(index)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(head)
    results.append(tail)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def index(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def head(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

  @builtins.property
  def tail(self) -> _ods_ir.OpResult:
    return self.operation.results[1]

def split_at(head, tail, operand, index, *, loc=None, ip=None) -> _ods_ir.OpResultList:
  return SplitAtOp(head=head, tail=tail, operand=operand, index=index, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class ToExtentTensorOp(_ods_ir.OpView):
  r"""
  Converts a shape to a 1D integral tensor of extents. The number of elements
  in the tensor equals the rank of the shape, and the elements equal the
  extents of the shape.
  
  If the shape represents an error, this op's behavior is undefined.
  """

  OPERATION_NAME = "shape.to_extent_tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def to_extent_tensor(result, input, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ToExtentTensorOp(result=result, input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ValueAsShapeOp(_ods_ir.OpView):
  r"""
  The operations takes a ValueShape and returns a Shape corresponding to the
  value.  If the input value cannot be shape (e.g., not a 1D tensor of
  integral value representing sizes) then this propagages the error shape.
  E.g.,
  
  ```mlir
  // The following
  %0 = arith.constant dense<[1,2]> : tensor<2xi32>
  %shape = shape.value_as_shape %0 : tensor<2xi32> -> !shape.shape
  // is equivalent to
  %shape' = shape.const_shape [1, 2] : !shape.shape
  ```
  
  This operation is the complement of `shape_of` wrt ValueShape values.
  """

  OPERATION_NAME = "shape.value_as_shape"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, arg, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(arg)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def arg(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def value_as_shape(result, arg, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ValueAsShapeOp(result=result, arg=arg, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ValueOfOp(_ods_ir.OpView):
  r"""
  The operation takes !shape.value_shape, a.k.a. (value, shape) tuple as an
  argument, and returns its value. The behavior is undefined for unknown and
  invalid arguments.
  """

  OPERATION_NAME = "shape.value_of"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, arg, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(arg)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def arg(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def value_of(result, arg, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ValueOfOp(result=result, arg=arg, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class WithOp(_ods_ir.OpView):
  r"""
  Returns ValueShape with the shape updated to match the shape operand. That
  is a new ValueShape tuple is created with value equal to `operand`'s
  value and shape equal to `shape`. If the ValueShape and given `shape` are
  non-conformant, then the returned ValueShape will represent an error of
  this mismatch. Similarly if either inputs are in an error state, then an
  error is propagated.
  
  Usage:
    %0 = shape.with_shape %1, %2 : tensor<...>, !shape.shape
  
  This is used, for example, where one combines shape function calculations
  and/or call one shape function from another. E.g.,
  
  ```mlir
  func.func @shape_foobah(%a: !shape.value_shape,
                     %b: !shape.value_shape,
                     %c: !shape.value_shape) -> !shape.shape {
    %0 = call @shape_foo(%a, %b) :
      (!shape.value_shape, !shape.value_shape) -> !shape.shape
    %1 = shape.with_shape %b, %0 : !shape.value_shape, !shape.shape
    %2 = call @shape_bah(%c, %1) :
      (!shape.value_shape, !shape.value_shape) -> !shape.shape
    return %2 : !shape.shape
  }
  ```
  
  This op need not be a refinement of the shape. In non-error cases the input
  ValueShape's value and shape are conformant and so too for the output, but
  the result may be less specified than `operand`'s shape as `shape` is
  merely used to construct the new ValueShape. If join behavior is desired
  then a join op should be used.
  """

  OPERATION_NAME = "shape.with_shape"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, shape, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    operands.append(shape)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def shape(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def with_shape(operand, shape, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return WithOp(operand=operand, shape=shape, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class YieldOp(_ods_ir.OpView):
  OPERATION_NAME = "shape.yield"

  _ODS_REGIONS = (0, True)

  def __init__(self, operands_, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def yield_(operands_, *, loc=None, ip=None) -> YieldOp:
  return YieldOp(operands_=operands_, loc=loc, ip=ip)
