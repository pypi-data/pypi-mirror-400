"""
Type stubs for diskcache_rs package

This package provides a high-performance disk cache implementation in Rust
with Python bindings, compatible with python-diskcache API.
"""

from pathlib import Path
from typing import Any, Dict, Iterator, List, Optional, Union

# Version
__version__: str

# Main Cache Classes
class Cache:
    """High-performance disk cache compatible with python-diskcache API"""

    def __init__(
        self,
        directory: Optional[Union[str, Path]] = None,
        timeout: float = 60.0,
        disk_min_file_size: int = 32768,
        **kwargs: Any,
    ) -> None: ...
    def __contains__(self, key: Any) -> bool: ...
    def __enter__(self) -> Cache: ...
    def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None: ...
    def __getitem__(self, key: Any) -> Any: ...
    def __setitem__(self, key: Any, value: Any) -> None: ...
    def __delitem__(self, key: Any) -> None: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __len__(self) -> int: ...
    def get(self, key: Any, default: Any = None, retry: bool = False) -> Any: ...
    def set(
        self, key: Any, value: Any, expire: Optional[float] = None, retry: bool = False
    ) -> bool: ...
    def add(
        self, key: Any, value: Any, expire: Optional[float] = None, retry: bool = False
    ) -> bool: ...
    def delete(self, key: Any, retry: bool = False) -> bool: ...
    def pop(
        self,
        key: Any,
        default: Any = None,
        expire: Optional[float] = None,
        retry: bool = False,
    ) -> Any: ...
    def clear(self, retry: bool = False) -> int: ...
    def close(self) -> None: ...
    def exists(self, key: Any) -> bool: ...
    def keys(self) -> Iterator[Any]: ...
    def values(self) -> Iterator[Any]: ...
    def items(self) -> Iterator[tuple[Any, Any]]: ...
    def iterkeys(self) -> Iterator[Any]: ...
    def itervalues(self) -> Iterator[Any]: ...
    def iteritems(self) -> Iterator[tuple[Any, Any]]: ...
    def expire(self, now: Optional[float] = None) -> int: ...
    def evict(self, tag: Optional[str] = None) -> int: ...
    def stats(self, enable: bool = True, reset: bool = False) -> tuple[int, int]: ...
    def volume(self) -> int: ...
    def reset(self, key: str, value: Any = None) -> None: ...
    def touch(
        self, key: Any, expire: Optional[float] = None, retry: bool = False
    ) -> bool: ...
    def incr(
        self,
        key: Any,
        delta: Union[int, float] = 1,
        default: Union[int, float] = 0,
        retry: bool = False,
    ) -> Union[int, float]: ...
    def decr(
        self,
        key: Any,
        delta: Union[int, float] = 1,
        default: Union[int, float] = 0,
        retry: bool = False,
    ) -> Union[int, float]: ...

    # Properties
    @property
    def directory(self) -> Path: ...

class FanoutCache:
    """Fanout cache implementation for better concurrency"""

    def __init__(
        self,
        directory: Optional[Union[str, Path]] = None,
        shards: int = 8,
        timeout: float = 60.0,
        **kwargs: Any,
    ) -> None: ...
    def __contains__(self, key: Any) -> bool: ...
    def __enter__(self) -> FanoutCache: ...
    def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None: ...
    def __getitem__(self, key: Any) -> Any: ...
    def __setitem__(self, key: Any, value: Any) -> None: ...
    def __delitem__(self, key: Any) -> None: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __len__(self) -> int: ...
    def get(self, key: Any, default: Any = None, retry: bool = False) -> Any: ...
    def set(
        self, key: Any, value: Any, expire: Optional[float] = None, retry: bool = False
    ) -> bool: ...
    def add(
        self, key: Any, value: Any, expire: Optional[float] = None, retry: bool = False
    ) -> bool: ...
    def delete(self, key: Any, retry: bool = False) -> bool: ...
    def pop(
        self,
        key: Any,
        default: Any = None,
        expire: Optional[float] = None,
        retry: bool = False,
    ) -> Any: ...
    def clear(self, retry: bool = False) -> int: ...
    def close(self) -> None: ...
    def exists(self, key: Any) -> bool: ...
    def keys(self) -> Iterator[Any]: ...
    def values(self) -> Iterator[Any]: ...
    def items(self) -> Iterator[tuple[Any, Any]]: ...
    def expire(self, now: Optional[float] = None) -> int: ...
    def evict(self, tag: Optional[str] = None) -> int: ...
    def stats(self, enable: bool = True, reset: bool = False) -> tuple[int, int]: ...
    def volume(self) -> int: ...
    def reset(self, key: str, value: Any = None) -> None: ...
    def touch(
        self, key: Any, expire: Optional[float] = None, retry: bool = False
    ) -> bool: ...
    def incr(
        self,
        key: Any,
        delta: Union[int, float] = 1,
        default: Union[int, float] = 0,
        retry: bool = False,
    ) -> Union[int, float]: ...
    def decr(
        self,
        key: Any,
        delta: Union[int, float] = 1,
        default: Union[int, float] = 0,
        retry: bool = False,
    ) -> Union[int, float]: ...

# Fast Cache Classes
class FastCache(Cache):
    """Ultra-fast cache implementation with optimized storage backends"""

    pass

class FastFanoutCache(FanoutCache):
    """Ultra-fast fanout cache implementation"""

    pass

# Pickle Cache
class PickleCache:
    """High-performance pickle cache with expiration support"""

    def __init__(self, cache_dir: Union[str, Path] = "pickle_cache") -> None: ...
    def cache_object(self, key: str, obj: Any, expire_hours: float = 24.0) -> None: ...
    def get_cached_object(self, key: str) -> Optional[Any]: ...
    def clear_cache(self) -> None: ...
    def is_expired(self, key: str) -> bool: ...
    def delete_object(self, key: str) -> bool: ...
    def list_cached_objects(self) -> List[str]: ...
    def get_cache_stats(self) -> Dict[str, Any]: ...

# Utility Functions
def cache_object(
    key: str,
    obj: Any,
    expire_hours: float = 24.0,
    cache_dir: Union[str, Path] = "pickle_cache",
) -> None:
    """Cache an object with expiration"""
    ...

def get_cached_object(
    key: str, cache_dir: Union[str, Path] = "pickle_cache"
) -> Optional[Any]:
    """Retrieve a cached object"""
    ...

def clear_cache(cache_dir: Union[str, Path] = "pickle_cache") -> None:
    """Clear all cached objects"""
    ...

# Rust Functions (from _diskcache_rs module)
def rust_pickle_dumps(obj: Any) -> Any:
    """High-performance pickle serialization using Rust"""
    ...

def rust_pickle_loads(data: Any) -> Any:
    """High-performance pickle deserialization using Rust"""
    ...

# Backward compatibility
DiskCache = Cache

# All exports
__all__ = [
    "Cache",
    "FanoutCache",
    "FastCache",
    "FastFanoutCache",
    "PickleCache",
    "cache_object",
    "get_cached_object",
    "clear_cache",
    "rust_pickle_dumps",
    "rust_pickle_loads",
    "DiskCache",
]
