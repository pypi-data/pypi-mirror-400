from __future__ import annotations

import json
import subprocess
from typing import Dict, Any, List

from pentestai.plugins.base import Plugin
from pentestai.core.artifacts import Artifact, now_iso, save_artifact, ws_paths


class HttpxPlugin(Plugin):
    name = "httpx"

    def run(self, ctx, args: Dict[str, Any]) -> Dict[str, Any]:
        paths = ws_paths(ctx.workspace)
        in_file = paths["artifacts"] / "recon_subdomains.txt"
        if not in_file.exists():
            raise RuntimeError("Missing recon_subdomains.txt. Run: pentestai recon run")

        out_jsonl = paths["artifacts"] / "recon_httpx.jsonl"

        # flags from ctx.vars (set by CLI)
        threads = int(ctx.vars.get("httpx_threads", 50))
        timeout = int(ctx.vars.get("httpx_timeout", 10))
        follow = bool(ctx.vars.get("httpx_follow_redirects", True))
        status_code = bool(ctx.vars.get("httpx_status_code", True))
        dry_run = bool(ctx.vars.get("dry_run", False))
        verbose = bool(ctx.vars.get("verbose", False))

        # Build command
        cmd = [
            "httpx",
            "-l", str(in_file),
            "-silent",
            "-json",
            "-o", str(out_jsonl),
            "-threads", str(threads),
            "-timeout", str(timeout),
        ]

        # Follow redirects
        # NOTE: httpx uses -fr (follow redirects) in many versions; if yours differs, adjust once here.
        if follow:
            cmd.append("-fr")

        # Include status code
        # NOTE: -sc prints status code in stdout; json output still contains status_code fields in many builds.
        if status_code:
            cmd.append("-sc")

        if verbose:
            print(f"[HttpxPlugin] cmd: {' '.join(cmd)}")
            print(f"[HttpxPlugin] dry_run={dry_run} threads={threads} timeout={timeout} follow={follow} status_code={status_code}")

        # Run
        stderr_tail = ""
        if not dry_run:
            r = subprocess.run(cmd, capture_output=True, text=True)
            stderr_tail = (r.stderr or "")[-2000:]
        else:
            # In dry-run, don't execute, but keep artifact structure consistent
            stderr_tail = "[dry-run] httpx not executed"

        # Parse jsonl results (if present)
        items: List[dict] = []
        if out_jsonl.exists():
            for line in out_jsonl.read_text(encoding="utf-8", errors="ignore").splitlines():
                line = line.strip()
                if not line:
                    continue
                try:
                    items.append(json.loads(line))
                except Exception:
                    # ignore malformed lines
                    pass

        urls = sorted({it.get("url") for it in items if it.get("url")})
        art = Artifact(
            kind="recon.live",
            created_at=now_iso(),
            data={"items": items, "urls": urls, "count": len(urls)},
            meta={
                "cmd": cmd,
                "stderr": stderr_tail,
                "flags": {
                    "threads": threads,
                    "timeout": timeout,
                    "follow_redirects": follow,
                    "status_code": status_code,
                    "dry_run": dry_run,
                },
            },
        )
        save_artifact(paths["artifacts"] / "recon_live.json", art)
        return art.model_dump()
