# GraphScout + PlanValidator Validation Loop
# ============================================
# 
# This demonstrates GraphScout's intelligent routing being validated
# in a loop by PlanValidator with boolean scoring. GraphScout has
# access to a rich set of agents for building optimal execution paths.
#
# DUAL VALIDATION APPROACH:
# ==========================
# 1. GraphScout (numeric mode): Fast path discovery and ranking
# 2. PlanValidator: Comprehensive validation with boolean criteria
#
# ALTERNATIVE: GraphScout Boolean Mode
# =====================================
# For simpler workflows or stronger safety, use GraphScout's built-in
# boolean scoring instead of (or in addition to) PlanValidator:
#
#   scoring_mode: "boolean"           # Enable deterministic mode
#   require_critical: true            # Safety + input checks mandatory
#   important_threshold: 0.8          # 80% capability match required
#   strict_mode: false                # Allow efficiency/history to be optional
#
# Benefits of GraphScout Boolean vs PlanValidator:
# - Faster (no LLM calls for validation)
# - More deterministic (rule-based checks)
# - Lower overhead for simple workflows
# - Still provides audit trails
#
# Use PlanValidator when you need:
# - Complex multi-dimensional validation
# - LLM-powered reasoning about path quality
# - Customizable validation presets
# - Dimension-level scoring (completeness, coherence, etc.)
#
# See docs/SCORING_ARCHITECTURE.md for detailed comparison.

orchestrator:
  id: graphscout-validated-routing
  strategy: sequential
  agents:
    - routing_validation_loop
    - path_executor            # Execute the validated path from GraphScout
    - execution_report

agents:
  # Main validation loop: GraphScout proposes paths, PlanValidator evaluates
  - id: routing_validation_loop
    type: loop
    max_loops: 4
    score_threshold: 0.35
    persist_across_runs: true
    fallback_score: 0.15
    timeout_score: 0.10
    
    # Boolean scoring - simplified for consistent local LLM evaluation
    scoring:
      preset: lenient
      context: loop_convergence
      custom_weights:
        improvement.better_than_previous: 0.45
        convergence.within_tolerance: 0.35
        stability.consistent_direction: 0.20
    
    past_loops_metadata:
      loop_number: "{{ get_loop_number() }}"
      score: "{{ score }}"
      timestamp: "{{ timestamp }}"
      insights: "{{ insights }}"
      improvements: "{{ improvements }}"
      mistakes: "{{ mistakes }}"
    
    internal_workflow:
      orchestrator:
        id: scout-validate-cycle
        strategy: sequential
        agents: [query_classifier, graphscout_router, path_validator_moderate]
      
      agents:
        # Classify the query to help GraphScout
        - id: query_classifier
          type: local_llm
          model: openai/gpt-oss-20b
          model_url: http://localhost:1234
          provider: lm_studio
          temperature: 0.3
          prompt: |
            Classify the query to guide intelligent routing:
            
            Query: {{ get_input() }}
            
            {% if has_past_loops() %}
            ## Previous Validation Feedback ({{ get_past_loops() | length }} attempts)
            {% for past_loop in get_past_loops() %}
            Loop {{ past_loop.loop_number }}: Score {{ past_loop.score }}
            Issues: {{ past_loop.mistakes }}
            {% endfor %}
            {% endif %}
            
            Analyze:
            1. Query complexity (simple/moderate/complex)
            2. Required capabilities (search, reasoning, memory, generation)
            3. Data dependencies (sequential vs parallel)
            4. Expected output format
            
            Return JSON with classification.
          params:
            structured_output:
              enabled: true
              mode: prompt
              schema:
                required: [response]
                optional:
                  confidence: number
        
        # GraphScout selects optimal execution path
        - id: graphscout_router
          type: graph-scout
          params:
            k_beam: 6
            max_depth: 3
            commit_margin: 0.1
            require_terminal: true
            score_weights:
              llm: 0.5
              heuristics: 0.25
              prior: 0.15
              cost: 0.05
              latency: 0.05
            safety_profile: default
            cost_budget_tokens: 1500
            latency_budget_ms: 8000
            max_preview_tokens: 250
            evaluation_model: "local_llm"
            evaluation_model_name: "openai/gpt-oss-20b"
            validation_model: "local_llm"
            validation_model_name: "openai/gpt-oss-20b"
            llm_evaluation_enabled: true
            provider: lm_studio
            model_url: http://localhost:1234
            fallback_to_heuristics: true
          prompt: |
            Select the optimal execution path using available agents.
            
            Query: {{ input }}
            Classification: {{ safe_get_response('query_classifier', 'Unknown', previous_outputs) }}
            
            {% if has_past_loops() %}
            ## Validation Feedback (Iteration {{ get_loop_number() }})
            
            {% set last_loop = get_past_loops()[-1] %}
            Previous score: {{ last_loop.score }}
            
            {% if "has_all_required_steps" in last_loop.mistakes %}
            ⚠ Missing required steps - ensure complete workflow
            {% endif %}
            {% if "uses_appropriate_agents" in last_loop.mistakes %}
            ⚠ Suboptimal agent selection - review agent capabilities
            {% endif %}
            {% if "includes_fallback_path" in last_loop.mistakes %}
            ⚠ Add error handling and fallback paths
            {% endif %}
            {% if "handles_edge_cases" in last_loop.mistakes %}
            ⚠ Consider edge cases and alternative scenarios
            {% endif %}
            {% if "logical_agent_sequence" in last_loop.mistakes %}
            ⚠ Fix agent ordering - check dependencies
            {% endif %}
            {% endif %}
            
            **Available Agents** (choose the best path):
            
            **Data Retrieval:**
            - web_search: DuckDuckGo search for current information
            - memory_reader: Retrieve relevant past context
            
            **Analysis & Reasoning:**
            - deep_analyzer: Multi-perspective analysis and reasoning
            - technical_specialist: Technical domain expertise
            - business_analyst: Business strategy and requirements
            
            **Memory Management:**
            - memory_writer: Store important findings for future use
            
            **Content Generation:**
            - content_synthesizer: Combine multiple sources into coherent output
            - report_generator: Generate structured reports (REQUIRED for terminal paths)
            
            **Validation & Quality:**
            - fact_checker: Verify claims and validate information
            - quality_reviewer: Review output for completeness
            
            **Selection Criteria:**
            1. Match agents to query requirements
            2. Ensure logical sequence (dependencies flow correctly)
            3. Include error handling where needed
            4. Optimize for cost and latency
            5. MUST end with terminal agent (report_generator or content_synthesizer)
            
            Return path selection with detailed reasoning.
        
        # Validate GraphScout's path with boolean scoring
        - id: path_validator_moderate
          type: plan_validator
          llm_model:  openai/gpt-oss-20b
          model_url: http://localhost:1234
          provider: lm_studio
          temperature: 0.2
          timeout: 60
          scoring_preset: lenient
          scoring_context: graphscout
          # Simplified criteria for reliable evaluation
          custom_weights:
            completeness.has_all_required_steps: 0.50
            efficiency.uses_appropriate_agents: 0.30
            coherence.logical_agent_sequence: 0.20

  # Generate execution report
  - id: execution_report
    type: local_llm
    model: openai/gpt-oss-20b
    model_url: http://localhost:1234
    provider: lm_studio
    temperature: 0.3
    prompt: |
      # GraphScout Validated Routing Report
      
      {% if previous_outputs.routing_validation_loop %}
      {% set loop = previous_outputs.routing_validation_loop %}
      
      ## Validation Summary
      - Iterations Required: {{ loop.loops_completed }}
      - Final Score: {{ (loop.final_score | default(0)) | round(3) }}
      - Status: {{ 'APPROVED ✓' if loop.threshold_met else 'NEEDS WORK ✗' }}
      
      ## GraphScout's Final Path
      {% if loop.response.result.graphscout_router %}
      {{ loop.response.result.graphscout_router }}
      {% endif %}
      
      ## Boolean Validation Details
      {% if loop.response.result.path_validator_moderate %}
      {% set val = loop.response.result.path_validator_moderate %}
      
      **Assessment:** {{ val.overall_assessment | default('UNKNOWN') }}
      **Score:** {{ (val.validation_score | default(0)) | round(3) }}
      
      ### Dimension Performance
      {% if val.dimension_scores %}
      {% for dim, data in val.dimension_scores.items() %}
      - {{ dim|title }}: {{ (data.percentage | default(0)) | round(0) }}%
      {% endfor %}
      {% endif %}
      
      ### Quality Metrics
      - Passed: {{ val.passed_criteria|length }}/15 criteria
      {% if val.failed_criteria %}
      - Failed: {{ val.failed_criteria|length }} criteria
        {% for criterion in val.failed_criteria %}
        - {{ criterion }}
        {% endfor %}
      {% endif %}
      {% endif %}
      
      ## Path Evolution
      {% if loop.response.past_loops and loop.response.past_loops|length > 1 %}
      {% for past in loop.response.past_loops %}
      **Iteration {{ past.loop_number | default('?') }}**: {{ past.score | default(0) }}
      {% if past.improvements %}
      Improvements: {{ past.improvements }}
      {% endif %}
      {% endfor %}
      {% endif %}
      
      ---
      
      ## Execution Results
      
      {% if previous_outputs.path_executor %}
      {% set executor = previous_outputs.path_executor %}
      
      **Execution Status:** {{ 'SUCCESS ✓' if executor.status == 'success' else 'FAILED ✗' }}
      **Agents Executed:** {{ executor.executed_path | default([]) | length }}
      
      {% if executor.executed_path %}
      **Path Execution:**
      {% for agent_id in executor.executed_path %}
      - {{ agent_id }}
      {% endfor %}
      
      **Final Result:**
      {{ executor.result | default('No result available') }}
      {% else %}
      The validated path was not executed (validation threshold not met or execution error).
      {% endif %}
      {% else %}
      PathExecutor did not run (validation loop may have failed).
      {% endif %}
      
      ---
      
      ## Your Analysis
      
      Provide:
      1. Why this path is optimal for the query
      2. How GraphScout improved across iterations
      3. Key strengths of the final path
      4. Whether the path was successfully executed and produced results
      5. Readiness for production execution
      
      {% else %}
      No validation loop results available.
      {% endif %}
    params:
      structured_output:
        enabled: true
        mode: prompt
        schema:
          required: [response]
          optional:
            confidence: number

  # PathExecutor: Execute the validated path from the routing loop
  - id: path_executor
    type: path_executor
    path_source: routing_validation_loop
    on_agent_failure: continue
    prompt: |
      Execute the validated path from GraphScout:
      
      {% if previous_outputs.routing_validation_loop %}
      {% set loop = previous_outputs.routing_validation_loop %}
      Path to execute: {{ loop.response.result.graphscout_router.response if loop.response.result.graphscout_router else 'No path available' }}
      {% endif %}

  # Supporting agents that GraphScout can route to
  - id: web_search
    type: duckduckgo
    capabilities: [data_retrieval, web_search]
    prompt: |
      {{ input }}

  - id: memory_reader
    type: memory
    namespace: graphscout_validated
    memory_preset: episodic
    config:
      operation: read
      vector: true
      top_k: 5
    prompt: |
      Retrieve context for: {{ input }}

  - id: deep_analyzer
    type: local_llm
    capabilities: [reasoning, analysis, critical_thinking]
    model: openai/gpt-oss-20b
    model_url: http://localhost:1234
    provider: lm_studio
    prompt: |
      Provide deep multi-perspective analysis:
      
      Query: {{ input }}
      
      {% if previous_outputs.web_search %}
      Context: {{ safe_get(previous_outputs, 'web_search.result', 'No web search results') }}
      {% endif %}
      
      {% if previous_outputs.memory_reader %}
      Historical Context: {{ safe_get_response('memory_reader', 'No historical context', previous_outputs) }}
      {% endif %}
      
      Analyze from:
      1. Technical perspective
      2. Business perspective
      3. Risk perspective
      4. Innovation perspective
    params:
      structured_output:
        enabled: true
        mode: prompt
        schema:
          required: [response]
          optional:
            confidence: number

  - id: technical_specialist
    type: local_llm
    capabilities: [technical_analysis, architecture, implementation]
    model: openai/gpt-oss-20b
    model_url: http://localhost:1234
    provider: lm_studio
    prompt: |
      Provide technical specialist analysis:
      
      {{ input }}
      
      {% if previous_outputs %}
      Context: {{ previous_outputs }}
      {% endif %}
      
      Focus on:
      - Technical feasibility
      - Architecture recommendations
      - Implementation approach
      - Technology stack
    params:
      structured_output:
        enabled: true
        mode: prompt
        schema:
          required: [response]
          optional:
            confidence: number

  - id: business_analyst
    type: local_llm
    capabilities: [business_analysis, requirements, strategy]
    model: openai/gpt-oss-20b
    model_url: http://localhost:1234
    provider: lm_studio
    prompt: |
      Business analysis for:
      
      {{ input }}
      
      Provide:
      1. Business objectives
      2. Stakeholder analysis
      3. Success criteria
      4. ROI considerations
    params:
      structured_output:
        enabled: true
        mode: prompt
        schema:
          required: [response]
          optional:
            confidence: number

  - id: memory_writer
    type: memory
    namespace: graphscout_validated
    memory_preset: episodic
    config:
      operation: write
      vector: true
    prompt: |
      Store findings: {{ previous_outputs }}

  - id: content_synthesizer
    type: local_llm
    capabilities: [answer_emit, synthesis, response_generation]
    model: openai/gpt-oss-20b
    model_url: http://localhost:1234
    provider: lm_studio
    prompt: |
      Synthesize comprehensive response:
      
      Query: {{ input }}
      
      Available Information:
      {{ previous_outputs }}
      
      Create coherent, well-structured response.
    params:
      structured_output:
        enabled: true
        mode: prompt
        schema:
          required: [response]
          optional:
            confidence: number

  - id: report_generator
    type: local_llm
    capabilities: [answer_emit, reporting, documentation]
    model: openai/gpt-oss-20b
    model_url: http://localhost:1234
    provider: lm_studio
    prompt: |
      Generate structured report for:
      
      {{ input }}
      
      Data: {{ previous_outputs }}
      
      Format as professional report with sections.
    params:
      structured_output:
        enabled: true
        mode: prompt
        schema:
          required: [response]
          optional:
            confidence: number

  - id: fact_checker
    type: local_llm
    capabilities: [validation, verification]
    model: openai/gpt-oss-20b
    model_url: http://localhost:1234
    provider: lm_studio
    prompt: |
      Fact-check and validate:
      
      {{ previous_outputs }}
      
      Verify accuracy and identify any issues.
    params:
      structured_output:
        enabled: true
        mode: prompt
        schema:
          required: [response]
          optional:
            confidence: number

  - id: quality_reviewer
    type: local_llm
    capabilities: [quality_control, review]
    model: openai/gpt-oss-20b
    model_url: http://localhost:1234
    provider: lm_studio
    prompt: |
      Review for quality:
      
      {{ previous_outputs }}
      
      Check completeness, accuracy, and coherence.
    params:
      structured_output:
        enabled: true
        mode: prompt
        schema:
          required: [response]
          optional:
            confidence: number

# ============================================================================
# How This Works
# ============================================================================
#
# 1. User query comes in
# 2. Query classifier analyzes requirements
# 3. GraphScout evaluates 9 available agents and selects optimal path
# 4. PlanValidator scores the path with 15 boolean criteria
# 5. If score < 0.85, loop repeats with validation feedback
# 6. GraphScout adjusts path based on failed criteria
# 7. Process continues until high-quality path is found
# 8. Execution report shows evolution and final path quality
#
# Benefits:
# - GraphScout has rich agent ecosystem (9 specialized agents)
# - Validation ensures quality before execution
# - Feedback loop enables continuous improvement
# - Boolean scoring provides deterministic, auditable results
# - Final path is guaranteed to meet quality standards
#
# ============================================================================
