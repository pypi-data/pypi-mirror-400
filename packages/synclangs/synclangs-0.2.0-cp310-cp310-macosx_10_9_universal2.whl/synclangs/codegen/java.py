"""Java code generator for SyncLangs types."""

from __future__ import annotations


from synclangs.codegen.base import CodeGenerator
from synclangs.parser.ast import (
    ConstDef,
    ConstValue,
    EnumDef,
    FunctionDef,
    InterfaceDef,
    ListTypeExpr,
    MapTypeExpr,
    Module,
    NullableTypeExpr,
    PrimitiveType,
    PrimitiveTypeExpr,
    TypeDef,
    TypeExpr,
    TypeRef,
    VoidType,
)


class JavaGenerator(CodeGenerator):
    """Generate Java classes from SyncLangs AST."""

    def __init__(
        self,
        file_extension: str = ".java",
        package_name: str = "types",
    ) -> None:
        self._file_extension = file_extension
        self._package_name = package_name

    def generate(self, module: Module) -> str:
        """Generate Java source code for a module."""
        lines: list[str] = [
            "// Auto-generated by SyncLangs - DO NOT EDIT",
            "",
            f"package {self._package_name};",
            "",
        ]

        # Collect imports needed
        java_imports = self._collect_imports(module)
        for imp in sorted(java_imports):
            lines.append(f"import {imp};")
        if java_imports:
            lines.append("")

        # Generate constants as a Constants class
        if module.constants:
            lines.append("public final class Constants {")
            lines.append("    private Constants() {}")
            lines.append("")
            for const_def in module.constants:
                lines.extend(self._generate_constant(const_def))
            lines.append("}")
            lines.append("")

        # Generate enums
        for enum_def in module.enums:
            lines.extend(self._generate_enum(enum_def))
            lines.append("")

        # Generate classes for types
        for type_def in module.types:
            lines.extend(self._generate_type(type_def))
            lines.append("")

        # Generate interfaces
        for interface_def in module.interfaces:
            lines.extend(self._generate_interface(interface_def))
            lines.append("")

        # Generate function type interfaces (functional interfaces)
        for fn_def in module.functions:
            lines.extend(self._generate_function_type(fn_def))
            lines.append("")

        return "\n".join(lines).rstrip() + "\n"

    def _generate_type(self, type_def: TypeDef) -> list[str]:
        """Generate a Java class for a type definition."""
        lines: list[str] = []
        if type_def.doc_comment:
            lines.extend(self._format_javadoc(type_def.doc_comment, ""))

        # Build extends and implements clauses
        extends_clause = ""
        implements_clause = ""
        if type_def.extends:
            extends_clause = f" extends {type_def.extends}"
        if type_def.implements:
            implements_clause = f" implements {', '.join(type_def.implements)}"

        lines.append(f"public class {type_def.name}{extends_clause}{implements_clause} {{")

        # Generate fields
        for field in type_def.fields:
            if field.doc_comment:
                lines.extend(self._format_javadoc(field.doc_comment, "    "))
            java_type, is_optional = self._field_type(field.type_expr)
            lines.append(f"    private {java_type} {field.name};")

        lines.append("")

        # Generate default constructor
        lines.append(f"    public {type_def.name}() {{}}")
        lines.append("")

        # Generate getters and setters
        for field in type_def.fields:
            java_type, _ = self._field_type(field.type_expr)
            getter_name = f"get{self._to_pascal_case(field.name)}"
            setter_name = f"set{self._to_pascal_case(field.name)}"
            
            lines.append(f"    public {java_type} {getter_name}() {{")
            lines.append(f"        return this.{field.name};")
            lines.append("    }")
            lines.append("")
            lines.append(f"    public void {setter_name}({java_type} {field.name}) {{")
            lines.append(f"        this.{field.name} = {field.name};")
            lines.append("    }")
            lines.append("")

        lines.append("}")
        return lines

    def _generate_interface(self, interface_def: InterfaceDef) -> list[str]:
        """Generate a Java interface definition."""
        lines: list[str] = []
        if interface_def.doc_comment:
            lines.extend(self._format_javadoc(interface_def.doc_comment, ""))
        lines.append(f"public interface {interface_def.name} {{")

        # Generate method signatures
        for fn_def in interface_def.functions:
            if fn_def.doc_comment:
                lines.extend(self._format_javadoc(fn_def.doc_comment, "    "))
            signature = self._function_signature(fn_def)
            lines.append(f"    {signature}")
            lines.append("")

        lines.append("}")
        return lines

    def _generate_function_type(self, fn_def: FunctionDef) -> list[str]:
        """Generate a Java functional interface for a function type."""
        lines: list[str] = []
        if fn_def.doc_comment:
            lines.extend(self._format_javadoc(fn_def.doc_comment, ""))

        type_name = f"{fn_def.name[0].upper()}{fn_def.name[1:]}Fn"
        lines.append("@FunctionalInterface")
        lines.append(f"public interface {type_name} {{")
        
        signature = self._function_signature(fn_def)
        lines.append(f"    {signature}")
        
        lines.append("}")
        return lines

    def _function_signature(self, fn_def: FunctionDef) -> str:
        """Generate a Java method signature."""
        params = ", ".join(
            f"{self._type_to_java(p.type_expr)} {p.name}"
            for p in fn_def.params
        )

        return_type = self._return_type_to_java(fn_def.return_type)
        return f"{return_type} {fn_def.name}({params});"

    def _return_type_to_java(self, return_type: TypeExpr | VoidType) -> str:
        """Convert a return type to Java."""
        if isinstance(return_type, VoidType):
            return "void"
        return self._type_to_java(return_type)

    def _collect_imports(self, module: Module) -> set[str]:
        """Collect Java imports needed for the module."""
        imports: set[str] = set()

        # Check for List usage
        for type_def in module.types:
            for field in type_def.fields:
                self._collect_type_imports(field.type_expr, imports)

        for interface_def in module.interfaces:
            for field in interface_def.fields:
                self._collect_type_imports(field.type_expr, imports)
            for fn_def in interface_def.functions:
                for param in fn_def.params:
                    self._collect_type_imports(param.type_expr, imports)
                if not isinstance(fn_def.return_type, VoidType):
                    self._collect_type_imports(fn_def.return_type, imports)

        for fn_def in module.functions:
            for param in fn_def.params:
                self._collect_type_imports(param.type_expr, imports)
            if not isinstance(fn_def.return_type, VoidType):
                self._collect_type_imports(fn_def.return_type, imports)

        return imports

    def _collect_type_imports(self, type_expr: TypeExpr, imports: set[str]) -> None:
        """Collect imports for a type expression."""
        if isinstance(type_expr, ListTypeExpr):
            imports.add("java.util.List")
            self._collect_type_imports(type_expr.element_type, imports)
        elif isinstance(type_expr, MapTypeExpr):
            imports.add("java.util.Map")
            self._collect_type_imports(type_expr.key_type, imports)
            self._collect_type_imports(type_expr.value_type, imports)
        elif isinstance(type_expr, NullableTypeExpr):
            self._collect_type_imports(type_expr.inner_type, imports)

    def _generate_constant(self, const_def: ConstDef) -> list[str]:
        """Generate a Java constant definition."""
        lines: list[str] = []
        if const_def.doc_comment:
            lines.extend(self._format_javadoc(const_def.doc_comment, "    "))
        java_type = self._type_to_java(const_def.type_expr)
        value = self._const_value_to_java(const_def.value)
        lines.append(f"    public static final {java_type} {const_def.name} = {value};")
        return lines

    def _generate_enum(self, enum_def: EnumDef) -> list[str]:
        """Generate a Java enum definition."""
        lines: list[str] = []
        if enum_def.doc_comment:
            lines.extend(self._format_javadoc(enum_def.doc_comment, ""))
        lines.append(f"public enum {enum_def.name} {{")
        
        variants = []
        for variant in enum_def.variants:
            if variant.doc_comment:
                lines.extend(self._format_javadoc(variant.doc_comment, "    "))
            variants.append(f"    {variant.name}")
        
        # Join variants with commas, last one gets semicolon
        if variants:
            for i, variant in enumerate(variants):
                if i < len(variants) - 1:
                    lines.append(f"{variant},")
                else:
                    lines.append(f"{variant};")
        
        lines.append("}")
        return lines

    def _const_value_to_java(self, value: ConstValue) -> str:
        """Convert a constant value to Java literal."""
        if isinstance(value.value, str):
            return f'"{value.value}"'
        if isinstance(value.value, bool):
            return "true" if value.value else "false"
        if isinstance(value.value, float):
            return f"{value.value}d"
        return str(value.value)

    def _field_type(self, type_expr: TypeExpr) -> tuple[str, bool]:
        """Return the Java type and optional flag for a field."""
        if isinstance(type_expr, NullableTypeExpr):
            inner_type = self._type_to_java(type_expr.inner_type)
            return inner_type, True
        return self._type_to_java(type_expr), False

    def _type_to_java(self, type_expr: TypeExpr) -> str:
        """Convert a type expression to a Java type."""
        if isinstance(type_expr, PrimitiveTypeExpr):
            return self._primitive_to_java(type_expr.primitive)
        if isinstance(type_expr, ListTypeExpr):
            inner = self._type_to_java(type_expr.element_type)
            return f"List<{self._box_type(inner)}>"
        if isinstance(type_expr, MapTypeExpr):
            key = self._type_to_java(type_expr.key_type)
            value = self._type_to_java(type_expr.value_type)
            return f"Map<{self._box_type(key)}, {self._box_type(value)}>"
        if isinstance(type_expr, NullableTypeExpr):
            inner = self._type_to_java(type_expr.inner_type)
            return self._box_type(inner)
        if isinstance(type_expr, TypeRef):
            return type_expr.name
        raise TypeError(f"Unsupported type expression: {type_expr}")

    def _primitive_to_java(self, primitive: PrimitiveType) -> str:
        """Map primitive SyncLangs types to Java types."""
        mapping = {
            PrimitiveType.STRING: "String",
            PrimitiveType.INT: "long",
            PrimitiveType.FLOAT: "double",
            PrimitiveType.BOOL: "boolean",
            PrimitiveType.ANY: "Object",
        }
        return mapping[primitive]

    def _box_type(self, java_type: str) -> str:
        """Convert primitive types to their boxed equivalents for generics."""
        boxing = {
            "int": "Integer",
            "long": "Long",
            "float": "Float",
            "double": "Double",
            "boolean": "Boolean",
            "byte": "Byte",
            "short": "Short",
            "char": "Character",
        }
        return boxing.get(java_type, java_type)

    def _to_pascal_case(self, name: str) -> str:
        """Convert a name to PascalCase."""
        if name and name[0].islower():
            return name[0].upper() + name[1:]
        return name

    def _format_javadoc(self, text: str, indent: str) -> list[str]:
        """Format a Javadoc comment with the provided indentation."""
        lines = text.splitlines()
        if len(lines) == 1:
            return [f"{indent}/** {lines[0]} */"]
        formatted = [f"{indent}/**"]
        formatted.extend(f"{indent} * {line}" for line in lines)
        formatted.append(f"{indent} */")
        return formatted
