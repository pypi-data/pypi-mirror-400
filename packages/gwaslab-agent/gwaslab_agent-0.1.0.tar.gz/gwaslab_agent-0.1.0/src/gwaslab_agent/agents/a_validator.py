import ast
import re
from typing import List, Optional
from gwaslab_agent.tools.g_tools import (
    HARMONIZER_SET,
    DOWNSTREAM_SET,
    PLOTTER_SET,
    FILTERER_SET,
    UTILITY_SET
)
from gwaslab_agent.core.g_base_agent import BaseAgent
from gwaslab.info.g_Log import Log

class Validator(BaseAgent):
    """
    Validator for Planner-generated Python scripts.
    
    The Validator performs comprehensive validation of Python scripts generated by Planner,
    ensuring they are safe, syntactically correct, and follow GWASLab best practices.
    It also resolves reference path placeholders using PathManager.
    
    Validation Process:
    -------------------
    The validation follows a multi-stage process:
    
    1. **Code Extraction**: Extracts Python code from markdown code blocks or plain text
    2. **Placeholder Resolution**: Resolves {REF:description} placeholders to actual file paths
    3. **Forbidden Pattern Check**: Detects patterns that should not appear (imports, data loading)
    4. **Syntax Validation**: Validates Python syntax using AST parsing
    5. **AST Structure Validation**: Validates code structure and method calls
    6. **Method Call Validation**: Validates GWASLab method calls and arguments against tool schemas
    7. **Operation Check**: Ensures the script contains actual operations (not just comments)
    
    Each stage builds upon the previous one, with early termination if critical errors are found.
    """
    
    def __init__(self, llm=None, pathmanager=None, full_schema=None, check_required_args=False,
                 log=None, history=None, archive=None, verbose=True):
        """
        Initialize Validator.
        
        Parameters
        ----------
        llm : optional
            LLM instance (kept for signature compatibility but not used)
        pathmanager : optional
            PathManager for resolving reference path placeholders
        full_schema : dict, optional
            Full schema dictionary mapping method names to their argument schemas
        check_required_args : bool, default False
            Whether to check for required arguments
        log : Log, optional
            Logger instance
        history : list, optional
            Conversation history
        archive : list, optional
            Archive for permanent storage
        verbose : bool, default True
            Verbose flag
        """
        # Initialize BaseAgent
        super().__init__(
            llm=llm,
            log=log or Log(),
            history=history,
            archive=archive,
            verbose=verbose
        )
        
        # PathManager for resolving reference path placeholders
        self.pathmanager = pathmanager
        # Full schema dictionary mapping method names to their argument schemas
        # Schema format: {"type": "object", "properties": {...}, "required": [...]}
        self.full_schema = full_schema if full_schema is not None else {}
        # Whether to check for required arguments (default: False - no checking)
        self.check_required_args = check_required_args
        
        # Build valid_sumstats_methods from tool sets defined in g_tools.py
        self.valid_sumstats_methods = (
            HARMONIZER_SET |
            DOWNSTREAM_SET |
            PLOTTER_SET |
            FILTERER_SET |
            UTILITY_SET
        )
        
        # Forbidden patterns (should not appear in generated scripts)
        self.forbidden_patterns = [
            (r'import\s+gwaslab', 'Should not include imports - sumstats is already loaded'),
            (r'gl\.Sumstats\s*\(', 'Should not include data loading - sumstats is already loaded'),
            (r'Sumstats\s*\(', 'Should not include data loading - sumstats is already loaded'),
        ]
    
    def run(self, user_request: str, planner_code: str) -> tuple[str, str]:
        """
        Main entry point for validation - implements BaseAgent.run() interface.
        
        This is a wrapper around validate() to match the BaseAgent interface.
        
        Parameters
        ----------
        user_request : str
            The original user request
        planner_code : str
            The Python code to validate
            
        Returns
        -------
        tuple[str, str]
            (validation_status, validated_code)
        """
        return self.validate(user_request, planner_code)
        
    def validate(self, user_request: str, planner_code: str) -> tuple[str, str]:
        """
        Validate the Planner-generated Python code and resolve reference path placeholders.
        
        This is the main validation method that orchestrates the entire validation pipeline.
        It performs validation in the following order:
        
        1. **Code Extraction** (`_extract_python_code`):
           - Extracts Python code from markdown code blocks (```python ... ```)
           - Falls back to plain text if no code blocks are found
           - Detects Python-like patterns (sumstats., def, =, etc.)
           - Returns None if no valid Python code is detected
        
        2. **Placeholder Resolution** (`_resolve_placeholders`):
           - Scans code for {REF:description} placeholders
           - Queries PathManager to resolve each placeholder to actual file paths
           - Replaces placeholders with resolved paths (properly escaped)
           - Collects errors if any placeholders cannot be resolved
        
        3. **Forbidden Pattern Check** (`_check_forbidden_patterns`):
           - Checks for forbidden patterns using regex:
             * `import gwaslab` - Should not import gwaslab (already loaded)
             * `gl.Sumstats(` - Should not load data (sumstats already available)
             * `Sumstats(` - Should not load data (sumstats already available)
           - Returns list of error messages for any forbidden patterns found
        
        4. **Syntax Validation** (`_validate_syntax`):
           - Uses Python's AST parser to validate syntax
           - Catches SyntaxError exceptions and formats error messages
           - Returns detailed error messages with line/column information
           - If syntax errors exist, validation stops early
        
        5. **AST Structure Validation** (`_validate_ast`):
           - Parses code into AST (Abstract Syntax Tree)
           - Uses CodeValidatorVisitor to traverse the AST
           - Validates method calls, imports, and code structure
           - Checks for gwaslab imports (should not be present)
        
        6. **Method Call Validation** (`_validate_method_calls`):
           - Uses MethodCallValidatorVisitor to find GWASLab method calls
           - Validates method calls on sumstats and filtered objects
           - Checks required arguments are provided
           - Validates argument names against schema (catches typos)
           - Provides helpful error messages with suggestions for typos
        
        7. **Operation Check** (`_has_operations`):
           - Verifies script contains actual operations (not just comments)
           - Looks for method calls (pattern: .method_name())
           - Looks for assignments (pattern: variable = ...)
           - Filters out comment-only lines
        
        Parameters
        ----------
        user_request : str
            The original user request (for context, currently not used in validation logic)
        planner_code : str
            The Python code generated by Planner (may include markdown formatting)
            
        Returns
        -------
        tuple[str, str]
            (validation_status, validated_code)
            - validation_status: 
              * "VALID" if all validation checks pass
              * "VALIDATION FAILED:\n<error1>\n<error2>..." if validation fails
              * "ERROR: No Python code found..." if no code can be extracted
            - validated_code: 
              * The code with placeholders resolved to actual file paths
              * Original code if no placeholders were found
              * Original code if placeholder resolution failed (errors will be in status)
        
        Examples
        --------
        >>> validator = Validator(pathmanager=pathmanager)
        >>> status, code = validator.validate("plot manhattan", "sumstats.plot_manhattan()")
        >>> print(status)  # "VALID"
        >>> print(code)    # "sumstats.plot_manhattan()"
        
        >>> status, code = validator.validate("clump", 'sumstats.clump(ref_path="{REF:LD panel EAS hg38}")')
        >>> print(status)  # "VALID"
        >>> print(code)    # 'sumstats.clump(ref_path="/path/to/ld/panel.vcf.gz")'
        
        >>> status, code = validator.validate("load data", "import gwaslab")
        >>> print(status)  # "VALIDATION FAILED:\nForbidden pattern detected: Should not include imports..."
        """
        errors = []
        
        # 1. Extract Python code from markdown code blocks if present
        code = self._extract_python_code(planner_code)
        
        if not code:
            return ("ERROR: No Python code found in the planner output. Expected Python code in a code block or as plain text.", planner_code)
        
        # 2. Resolve reference path placeholders
        code, placeholder_errors = self._resolve_placeholders(code)
        if placeholder_errors:
            errors.extend(placeholder_errors)
        
        # 3. Check for forbidden patterns (data loading, imports)
        errors.extend(self._check_forbidden_patterns(code))
        
        # 4. Validate Python syntax
        syntax_errors = self._validate_syntax(code)
        if syntax_errors:
            errors.extend(syntax_errors)
            # If syntax is invalid, stop here
            if errors:
                return ("VALIDATION FAILED:\n" + "\n".join(errors), code)
        
        # 5. Parse AST and validate structure
        try:
            tree = ast.parse(code)
            errors.extend(self._validate_ast(tree))
        except SyntaxError as e:
            # Already caught in syntax validation, but handle gracefully
            pass
        
        # 6. Validate GWASLab method calls and arguments against schemas
        if not errors:  # Only validate method calls if syntax is valid
            try:
                tree = ast.parse(code)
                method_call_errors = self._validate_method_calls(tree)
                errors.extend(method_call_errors)
            except SyntaxError as e:
                # Already caught in syntax validation, but handle gracefully
                pass
        
        # 7. Check for basic structure (at least some operations)
        if not self._has_operations(code):
            errors.append("Script appears to be empty or contains only comments. Expected at least one operation on sumstats.")
        
        if errors:
            return ("VALIDATION FAILED:\n" + "\n".join(errors), code)
        
        return ("VALID", code)
    
    def _extract_python_code(self, text: str) -> Optional[str]:
        """
        Extract Python code from text, handling markdown code blocks.
        
        This method handles multiple input formats:
        1. Markdown code blocks: ```python ... ``` or ``` ... ```
        2. Plain Python code (no markdown formatting)
        
        Detection Strategy:
        - First attempts to find markdown code blocks using regex pattern
        - If no code blocks found, checks if text looks like Python code
        - Python-like patterns include: 'sumstats.', 'def ', '=', '(', ')', '#'
        - Validates first line starts with comment, 'sumstats', or contains '=' or '('
        
        Parameters
        ----------
        text : str
            Text that may contain Python code in markdown blocks or as plain text
            
        Returns
        -------
        Optional[str]
            Extracted Python code, or None if no valid Python code is detected
        """
        # Try to find Python code block
        python_block_pattern = r"```(?:python)?\s*(.*?)```"
        match = re.search(python_block_pattern, text, re.DOTALL)
        if match:
            return match.group(1).strip()
        
        # If no code block, check if the entire text looks like Python code
        # (contains common Python keywords/patterns)
        text_stripped = text.strip()
        if not text_stripped:
            return None
            
        # Check for Python-like patterns
        has_python_patterns = any(
            keyword in text for keyword in ['sumstats.', 'def ', '=', '(', ')', '#']
        )
        
        if has_python_patterns:
            # Check if it starts with a comment or looks like Python code
            first_line = text_stripped.split('\n')[0].strip()
            if (first_line.startswith('#') or 
                first_line.startswith('sumstats') or
                '=' in first_line or
                '(' in first_line):
                return text_stripped
        
        return None
    
    def _check_forbidden_patterns(self, code: str) -> List[str]:
        """
        Check for forbidden patterns that should not appear in generated scripts.
        
        Forbidden Patterns:
        -------------------
        1. `import gwaslab` - GWASLab is already imported, sumstats object is available
        2. `gl.Sumstats(...)` - Data loading should not be included (sumstats already loaded)
        3. `Sumstats(...)` - Data loading should not be included (sumstats already loaded)
        
        These patterns are checked using case-insensitive regex matching.
        
        Parameters
        ----------
        code : str
            The Python code to check
            
        Returns
        -------
        List[str]
            List of error messages for each forbidden pattern found (empty if none found)
        """
        errors = []
        
        for pattern, message in self.forbidden_patterns:
            if re.search(pattern, code, re.IGNORECASE):
                errors.append(f"Forbidden pattern detected: {message}")
        
        return errors
    
    def _validate_syntax(self, code: str) -> List[str]:
        """
        Validate Python syntax using AST parsing.
        
        This method uses Python's built-in AST parser to check for syntax errors.
        If syntax is invalid, the parser will raise a SyntaxError with detailed
        information about the error location (line number and column).
        
        Parameters
        ----------
        code : str
            The Python code to validate
            
        Returns
        -------
        List[str]
            List of syntax error messages (empty if syntax is valid)
            Format: "Python syntax error: <message> at line <lineno>, column <offset>"
        """
        errors = []
        
        try:
            ast.parse(code)
        except SyntaxError as e:
            errors.append(f"Python syntax error: {e.msg} at line {e.lineno}, column {e.offset}")
        except Exception as e:
            errors.append(f"Error parsing Python code: {str(e)}")
        
        return errors
    
    def _validate_ast(self, tree: ast.AST) -> List[str]:
        """
        Validate AST structure and method calls using a visitor pattern.
        
        This method uses CodeValidatorVisitor to traverse the Abstract Syntax Tree
        and validate the code structure. The visitor checks:
        - Method calls on objects (allows any method - GWASLab has many methods)
        - Variable assignments (tracks variables for potential future validation)
        - Import statements (flags gwaslab imports as errors)
        
        The validation is lenient - it allows method calls that might not be in
        the known method sets, since GWASLab has many methods that may not be
        explicitly listed.
        
        Parameters
        ----------
        tree : ast.AST
            The parsed AST tree from ast.parse()
            
        Returns
        -------
        List[str]
            List of validation error messages (empty if structure is valid)
        """
        errors = []
        visitor = CodeValidatorVisitor(self.valid_sumstats_methods)
        visitor.visit(tree)
        errors.extend(visitor.errors)
        return errors
    
    def _has_operations(self, code: str) -> bool:
        """
        Check if code contains actual operations (not just comments or empty).
        
        This method filters out comments and blank lines, then checks for:
        1. Method calls: Pattern `.method_name(` (e.g., `sumstats.plot_manhattan()`)
        2. Assignments: Pattern `variable = ...` (e.g., `filtered = sumstats.filter_value(...)`)
        
        This ensures the script is not empty or comment-only, which would indicate
        the planner failed to generate actual code.
        
        Parameters
        ----------
        code : str
            The Python code to check
            
        Returns
        -------
        bool
            True if code contains operations, False if it's empty or comment-only
        """
        # Remove comments and blank lines
        lines = [line for line in code.split('\n') 
                if line.strip() and not line.strip().startswith('#')]
        
        # Check for method calls, assignments, or other operations
        has_operations = False
        for line in lines:
            # Check for method calls
            if re.search(r'\.\w+\s*\(', line):
                has_operations = True
                break
            # Check for assignments
            if '=' in line and not line.strip().startswith('#'):
                has_operations = True
                break
        
        return has_operations
    
    def _resolve_placeholders(self, code: str) -> tuple[str, List[str]]:
        """
        Resolve reference path placeholders in the code using PathManager.
        
        This method handles the resolution of {REF:description} placeholders that
        Planner may include in generated scripts. For example:
        - `{REF:LD panel for EAS population hg38}` → `/path/to/ld/panel.vcf.gz`
        - `{REF:chain file hg19 to hg38}` → `/path/to/chain/file.chain.gz`
        
        Resolution Process:
        -------------------
        1. **Pattern Matching**: Finds all {REF:description} placeholders using regex
        2. **PathManager Query**: For each placeholder, queries PathManager with:
           "Resolve reference file path for: <description>"
        3. **Path Extraction**: Extracts the resolved path from PathManager's response
           using multiple fallback patterns:
           - Pattern 1: "Path:" or "Resolved Path:" followed by path
           - Pattern 2: Paths in markdown code blocks: `path`
           - Pattern 3: Absolute paths starting with / (with common file extensions)
           - Pattern 4: Paths in markdown table rows containing "✅ Found"
        4. **Path Replacement**: Replaces placeholders with resolved paths, properly
           escaped for use in Python strings (handles backslashes, quotes)
        
        Error Handling:
        --------------
        - If PathManager is not available, returns error (but keeps original code)
        - If path cannot be extracted from PathManager response, adds error message
        - If PathManager query fails, captures exception and adds error message
        - All errors are collected and returned, but code is still returned (may have
          unresolved placeholders if errors occurred)
        
        Parameters
        ----------
        code : str
            The Python code that may contain placeholders in format {REF:description}
            
        Returns
        -------
        tuple[str, List[str]]
            (resolved_code, errors)
            - resolved_code: Code with successfully resolved placeholders replaced
              with actual file paths (as Python strings). Unresolved placeholders
              remain unchanged if errors occurred.
            - errors: List of error messages for placeholders that couldn't be resolved.
              Empty list if all placeholders were resolved successfully.
        
        Examples
        --------
        >>> code = 'sumstats.clump(ref_path="{REF:LD panel EAS hg38}")'
        >>> resolved, errors = validator._resolve_placeholders(code)
        >>> print(resolved)  # 'sumstats.clump(ref_path="/home/user/.gwaslab/EAS.ALL.hg38.vcf.gz")'
        >>> print(errors)    # []
        """
        errors = []
        placeholder_pattern = r'\{REF:([^}]+)\}'
        placeholders = re.findall(placeholder_pattern, code)
        
        if not placeholders:
            return code, errors
        
        if self.pathmanager is None:
            errors.append("Reference path placeholders found but PathManager is not available. Cannot resolve placeholders.")
            return code, errors
        
        # Resolve each placeholder
        resolved_paths = {}
        for placeholder_desc in placeholders:
            try:
                query = f"Resolve reference file path for: {placeholder_desc.strip()}"
                result = self.pathmanager.run(query, verbose=False, return_message=True, if_print=False)
                
                if isinstance(result, dict) and "message" in result:
                    resolved_path = self._extract_path_from_message(result["message"])
                    if resolved_path:
                        resolved_paths[placeholder_desc] = self._clean_path(resolved_path)
                    else:
                        errors.append(f"Could not extract path from PathManager response for: {placeholder_desc}. Response: {result['message'][:200]}")
                else:
                    errors.append(f"PathManager did not return expected format for: {placeholder_desc}")
            except Exception as e:
                errors.append(f"Error resolving placeholder '{placeholder_desc}': {str(e)}")
        
        # Replace placeholders in code
        resolved_code = self._replace_placeholders(code, resolved_paths)
        return resolved_code, errors
    
    def _extract_path_from_message(self, message: str) -> Optional[str]:
        """
        Extract file path from PathManager response message using multiple patterns.
        
        Tries patterns in order of specificity:
        1. "Path:" or "Resolved Path:" labels (with or without backticks)
        2. Paths in markdown code blocks
        3. Absolute paths with common file extensions
        4. Paths in table rows with "Found" markers
        """
        # Pattern 1: "Path:" or "Resolved Path:" labels
        patterns = [
            r'(?:Path|Resolved Path):\s*`([^`\n]+)`',  # With backticks
            r'(?:Path|Resolved Path):\s*([/][^\n\'"]+)',  # Without backticks
            r'`([/][^`\n]+)`',  # Markdown code blocks
            r'([/][^\s\n`\'"]+(?:\.(?:vcf|gz|fa|chain|gtf|tsv|txt|bcf|bam|bed)[^`\s\'"]*)?)',  # Absolute paths with extensions
        ]
        
        for pattern in patterns:
            match = re.search(pattern, message, re.IGNORECASE)
            if match:
                return match.group(1).strip()
        
        # Pattern 4: Table rows with "Found" markers
        for line in message.split('\n'):
            if '✅ Found' in line or 'Found' in line:
                match = re.search(r'([/][^\s`\'"]+)', line)
                if match:
                    return match.group(1).strip()
        
        return None
    
    def _clean_path(self, path: str) -> str:
        """
        Clean extracted path by removing quotes, backticks, and whitespace.
        
        Removes all quote characters (single, double, backticks) from the path
        as they should not be part of file paths.
        """
        if not path:
            return ""
        
        # Remove quotes and backticks from both ends
        quote_chars = ["'", '"', '`']
        while path and (path[0] in quote_chars or path[-1] in quote_chars):
            if path[0] in quote_chars:
                path = path[1:]
            if path and path[-1] in quote_chars:
                path = path[:-1]
            path = path.strip()
        
        # Remove any remaining quote characters (shouldn't be in paths anyway)
        for char in quote_chars:
            path = path.replace(char, "")
        
        return path.strip()
    
    def _replace_placeholders(self, code: str, resolved_paths: dict) -> str:
        """
        Replace placeholders in code with resolved paths, properly escaped.
        
        Handles three cases:
        1. Placeholder inside double quotes: escape double quotes and backslashes
        2. Placeholder inside single quotes: escape single quotes and backslashes
        3. Placeholder not in quotes: wrap in single quotes and escape all quotes
        """
        resolved_code = code
        
        for placeholder_desc, clean_path in resolved_paths.items():
            placeholder = f"{{REF:{placeholder_desc}}}"
            escaped_placeholder = re.escape(placeholder)
            
            # Check if placeholder is inside quotes
            double_quote_pattern = f'"[^"]*{escaped_placeholder}[^"]*"'
            single_quote_pattern = f"'[^']*{escaped_placeholder}[^']*'"
            
            if re.search(double_quote_pattern, resolved_code):
                # Inside double quotes: escape backslashes and double quotes
                escaped_path = clean_path.replace('\\', '\\\\').replace('"', '\\"')
                resolved_code = resolved_code.replace(placeholder, escaped_path)
            elif re.search(single_quote_pattern, resolved_code):
                # Inside single quotes: escape backslashes and single quotes
                escaped_path = clean_path.replace('\\', '\\\\').replace("'", "\\'")
                resolved_code = resolved_code.replace(placeholder, escaped_path)
            else:
                # Not in quotes: wrap in single quotes and escape all special chars
                escaped_path = clean_path.replace('\\', '\\\\').replace("'", "\\'").replace('"', '\\"')
                resolved_code = resolved_code.replace(placeholder, f"'{escaped_path}'")
        
        return resolved_code
    
    def _validate_method_calls(self, tree: ast.AST) -> List[str]:
        """
        Validate GWASLab method calls and their arguments against tool schemas.
        
        This method traverses the AST to find method calls on sumstats or filtered
        objects, then validates that:
        1. The method name exists in the schema (if schema is available)
        2. Required arguments are provided (if check_required_args is True)
        3. Argument names are valid (no typos) - invalid args are ignored
        
        Parameters
        ----------
        tree : ast.AST
            The parsed AST tree from ast.parse()
            
        Returns
        -------
        List[str]
            List of validation error messages (empty if all method calls are valid)
        """
        errors = []
        visitor = MethodCallValidatorVisitor(
            self.full_schema, 
            self.valid_sumstats_methods,
            check_required_args=self.check_required_args
        )
        visitor.visit(tree)
        errors.extend(visitor.errors)
        return errors


class CodeValidatorVisitor(ast.NodeVisitor):
    """
    AST visitor to validate Python code structure.
    
    This visitor traverses the Abstract Syntax Tree (AST) of the Python code
    and performs structural validation. It uses the visitor pattern to inspect
    different types of AST nodes.
    
    Validation Checks:
    ------------------
    1. **Method Calls** (`visit_Call`):
       - Allows method calls on any object (sumstats, filtered objects, DataFrames)
       - Recognizes common pandas methods (query, iloc, loc, head, tail, etc.)
       - Does not restrict GWASLab methods (allows all, since GWASLab has many methods)
    
    2. **Variable Assignments** (`visit_Assign`):
       - Tracks variable assignments for potential future validation
       - Currently lenient - allows any variable names
       - Could be extended to validate variable usage patterns
    
    3. **Import Statements** (`visit_Import`, `visit_ImportFrom`):
       - Flags gwaslab imports as errors (should not be present)
       - Checks both `import gwaslab` and `from gwaslab import ...`
       - Other imports are allowed (e.g., pandas, numpy if needed)
    
    The visitor is intentionally lenient to allow flexibility in generated scripts,
    while still catching common mistakes like importing gwaslab when it's not needed.
    """
    
    def __init__(self, valid_methods: set):
        self.valid_methods = valid_methods
        self.errors = []
        self.variables = set(['sumstats'])  # Track known variables
        
    def visit_Call(self, node: ast.Call):
        """
        Validate method calls in the AST.
        
        This method is called for every function/method call in the code.
        It checks:
        - If the call is a method call (has an attribute, e.g., `obj.method()`)
        - If the method is a known pandas method (query, iloc, loc, etc.)
        - Currently allows all method calls (lenient validation)
        
        The validation is lenient because GWASLab has many methods that may not
        be explicitly listed in the valid_methods set, and we want to allow
        flexibility in the generated scripts.
        
        Parameters
        ----------
        node : ast.Call
            AST node representing a function/method call
        """
        # Check if this is a method call on sumstats or a filtered object
        if isinstance(node.func, ast.Attribute):
            method_name = node.func.attr
            
            # Check if calling on a known variable (sumstats or filtered variants)
            if isinstance(node.func.value, ast.Name):
                var_name = node.func.value.id
                # If it's a new variable being assigned, we'll track it
                # For now, we allow calls on any variable (could be filtered sumstats)
                
                # Warn about unknown methods (but don't fail - methods might be valid GWASLab methods not in our list)
                # We'll be lenient here since GWASLab has many methods
                pass
            
            # Check for common pandas DataFrame methods (these are OK)
            pandas_methods = {'query', 'iloc', 'loc', 'head', 'tail', 'tolist', 'to_csv', 'shape', 'columns'}
            if method_name in pandas_methods:
                pass  # These are valid pandas methods
            # Otherwise, we allow it - GWASLab has many methods we might not have listed
        
        self.generic_visit(node)
    
    def visit_Assign(self, node: ast.Assign):
        """
        Track variable assignments in the AST.
        
        This method is called for every assignment statement in the code.
        Currently, it tracks variable names but doesn't perform strict validation.
        This could be extended in the future to:
        - Validate variable naming conventions
        - Check for unused variables
        - Validate assignment patterns (e.g., filtered sumstats assignments)
        
        Parameters
        ----------
        node : ast.Assign
            AST node representing an assignment statement
        """
        for target in node.targets:
            if isinstance(target, ast.Name):
                var_name = target.id
                # Track variables that might be used later
                # We don't restrict variable names, but we could validate they're used correctly
                pass
        
        self.generic_visit(node)
    
    def visit_Import(self, node: ast.Import):
        """
        Check for gwaslab imports (should not be present).
        
        This method flags any `import gwaslab` or `import gwaslab.*` statements
        as errors, since the sumstats object is already loaded and available
        in the execution context.
        
        Parameters
        ----------
        node : ast.Import
            AST node representing an import statement
        """
        for alias in node.names:
            if alias.name == 'gwaslab' or alias.name.startswith('gwaslab'):
                self.errors.append("Should not include 'import gwaslab' - sumstats is already loaded")
    
    def visit_ImportFrom(self, node: ast.ImportFrom):
        """
        Check for gwaslab imports from statements (should not be present).
        
        This method flags any `from gwaslab import ...` statements as errors,
        since the sumstats object is already loaded and available in the
        execution context.
        
        Parameters
        ----------
        node : ast.ImportFrom
            AST node representing a from-import statement
        """
        if node.module and ('gwaslab' in node.module):
            self.errors.append("Should not include 'from gwaslab import ...' - sumstats is already loaded")


class MethodCallValidatorVisitor(ast.NodeVisitor):
    """
    AST visitor to validate GWASLab method calls and their arguments against schemas.
    
    This visitor specifically validates:
    - Method calls on sumstats or filtered sumstats objects
    - Argument names match schema properties
    - Required arguments are provided
    - Provides helpful error messages for typos and missing arguments
    """
    
    def __init__(self, full_schema: dict, valid_methods: set, check_required_args: bool = False):
        """
        Initialize the method call validator.
        
        Parameters
        ----------
        full_schema : dict
            Dictionary mapping method names to their argument schemas
            Format: {method_name: {"type": "object", "properties": {...}, "required": [...]}}
        valid_methods : set
            Set of valid GWASLab method names (for reference, but validation is lenient)
        check_required_args : bool
            Whether to check for required arguments (default: False - no checking)
        """
        self.full_schema = full_schema
        self.valid_methods = valid_methods
        self.check_required_args = check_required_args
        self.errors = []
        self.variables = set(['sumstats'])  # Track known variables that might be sumstats objects
    
    def visit_Call(self, node: ast.Call):
        """
        Validate method calls against schemas.
        
        This method:
        1. Identifies method calls on sumstats or filtered objects
        2. Extracts method name and arguments
        3. Validates against schema if available
        4. Checks required arguments and valid argument names
        """
        # Check if this is a method call (has an attribute)
        if isinstance(node.func, ast.Attribute):
            method_name = node.func.attr
            
            # Check if calling on a known sumstats variable
            if isinstance(node.func.value, ast.Name):
                var_name = node.func.value.id
                
                # If it's sumstats or a filtered variable, validate the method call
                if var_name in self.variables or var_name.startswith(('filtered', 'significant', 'common', 'novel', 'subset')):
                    # Validate this method call
                    self._validate_method_call(method_name, node, var_name)
        
        self.generic_visit(node)
    
    def _validate_method_call(self, method_name: str, node: ast.Call, var_name: str):
        """
        Validate a specific method call against its schema.
        
        Parameters
        ----------
        method_name : str
            Name of the method being called
        node : ast.Call
            AST node representing the method call
        var_name : str
            Name of the variable the method is called on
        """
        # Get schema for this method
        if method_name not in self.full_schema:
            # Method not in schema - this is OK, GWASLab has many methods
            # We'll be lenient and allow it
            return
        
        schema_data = self.full_schema[method_name]
        if not isinstance(schema_data, dict):
            return
        
        # Convert schema format: doc_params_all dict -> JSON schema format
        # doc_params_all is {param_name: {type, description, default, required, ...}}
        # We need {properties: {param_name: {...}}, required: [...]}
        if "properties" in schema_data:
            # Already in JSON schema format
            properties = schema_data.get("properties", {})
            required = schema_data.get("required", [])
        else:
            # Convert from doc_params_all format to JSON schema format
            # doc_params_all is a dict where keys are parameter names
            # Each param_info has: {type, description, default, required, ...}
            properties = {}
            required = []
            for param_name, param_info in schema_data.items():
                if not isinstance(param_info, dict):
                    continue
                # param_info is a dict with type, description, default, etc.
                # Create a clean property schema (remove "required" key if present, as it's not part of JSON schema properties)
                prop_schema = {k: v for k, v in param_info.items() if k != "required"}
                properties[param_name] = prop_schema
                # Check if this parameter is required
                # In doc_params_all format, "required" is a boolean field in param_info
                # According to g_docstring_parser.py line 443: v["required"] = v.get("default") is None
                # So if "required" key exists, use it; otherwise infer from default
                if "required" in param_info:
                    is_required = param_info["required"]
                else:
                    # If "required" not explicitly set, infer from default
                    # No default or default is None means required
                    is_required = param_info.get("default") is None
                if is_required:
                    required.append(param_name)
        
        # Extract arguments from the call
        call_args = self._extract_call_arguments(node)
        
        # Check required arguments (only if check_required_args is enabled)
        if self.check_required_args:
            for req_arg in required:
                if req_arg not in call_args:
                    self.errors.append(
                        f"Method '{method_name}' called on '{var_name}' is missing required argument: '{req_arg}'"
                    )
        
        # Check for invalid argument names (typos)
        # Note: Invalid arguments are ignored rather than causing errors
        # Note: Invalid arguments are ignored rather than causing errors
        # This allows for flexibility in method calls and future API changes
        for arg_name in call_args.keys():
            if arg_name not in properties:
                # Invalid argument found, but we'll ignore it instead of erroring
                # This allows for:
                # 1. Future API changes where new arguments might be added
                # 2. Flexibility in method calls
                # 3. Methods that accept **kwargs or have dynamic arguments
                pass
    
    def _extract_call_arguments(self, node: ast.Call) -> dict:
        """
        Extract arguments from a method call AST node.
        
        Handles keyword arguments. Positional arguments are not validated
        against schema since we can't easily map them to parameter names
        without the function signature.
        
        Parameters
        ----------
        node : ast.Call
            AST node representing the method call
            
        Returns
        -------
        dict
            Dictionary mapping argument names to their values (AST nodes)
        """
        args = {}
        
        # Handle keyword arguments
        for keyword in node.keywords:
            arg_name = keyword.arg
            if arg_name:  # Skip **kwargs
                args[arg_name] = keyword.value
        
        # Note: Positional arguments are allowed but won't be validated
        # against schema since we can't map them to parameter names easily
        
        return args
    
    def _similar_names(self, name1: str, name2: str) -> bool:
        """
        Check if two names are similar (for typo detection).
        
        Uses simple heuristics:
        - Same length with 1-2 character differences
        - One is a substring of the other with small difference
        
        Parameters
        ----------
        name1 : str
            First name to compare
        name2 : str
            Second name to compare
            
        Returns
        -------
        bool
            True if names are similar (likely typo)
        """
        if name1 == name2:
            return True
        
        # Check if one is contained in the other (with small length difference)
        if abs(len(name1) - len(name2)) <= 2:
            if name1 in name2 or name2 in name1:
                return True
        
        # Check character-level similarity (simple Levenshtein-like)
        if len(name1) == len(name2):
            diff = sum(c1 != c2 for c1, c2 in zip(name1, name2))
            if diff <= 2:  # Allow 1-2 character differences
                return True
        
        return False
    
    def visit_Assign(self, node: ast.Assign):
        """
        Track variable assignments to identify filtered sumstats objects.
        
        This helps identify variables that might be filtered sumstats objects,
        so we can validate method calls on them as well.
        """
        for target in node.targets:
            if isinstance(target, ast.Name):
                var_name = target.id
                # Track variables that might be filtered sumstats
                # We'll be conservative and track common patterns
                if var_name.startswith(('filtered', 'significant', 'common', 'novel', 'subset')):
                    self.variables.add(var_name)
        
        self.generic_visit(node)
