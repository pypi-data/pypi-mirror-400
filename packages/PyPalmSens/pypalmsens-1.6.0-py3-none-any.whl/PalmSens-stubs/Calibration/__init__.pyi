import typing, clr, abc
from System.Collections.Generic import IDictionary_2, ICollection_1, KeyValuePair_2, IEnumerator_1, List_1, Dictionary_2
from System import Array_1
from PalmSens.Devices import EISSettings, DeviceCapabilities, EISSettingsPS3, EISSettingsPS4
from PalmSens.Techniques import ImpedimetricIterationMethodBase
from PalmSens.Plottables import EISData
from PalmSens.Comm import ClientConnection, ClientConnectionNexus
from System.Threading.Tasks import Task, Task_1
from PalmSens import PotentialRanges, CurrentRange, PotentialRange
from PalmSens.Data import DataArrayType

class CalibrationSteps(IDictionary_2[int, str], abc.ABC):
    NoCalibration : int
    @property
    def Count(self) -> int: ...
    @property
    def CurrentStep(self) -> int: ...
    @CurrentStep.setter
    def CurrentStep(self, value: int) -> int: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def Item(self) -> str: ...
    @Item.setter
    def Item(self, value: str) -> str: ...
    @property
    def Keys(self) -> ICollection_1[int]: ...
    @property
    def NSteps(self) -> int: ...
    @property
    def Values(self) -> ICollection_1[str]: ...
    def Clear(self) -> None: ...
    def Contains(self, item: KeyValuePair_2[int, str]) -> bool: ...
    def ContainsKey(self, key: int) -> bool: ...
    def CopyTo(self, array: Array_1[KeyValuePair_2[int, str]], arrayIndex: int) -> None: ...
    def CurrentStepToString(self) -> str: ...
    def GetDescription(self, calibrationType: int) -> str: ...
    def GetEnumerator(self) -> IEnumerator_1[KeyValuePair_2[int, str]]: ...
    @abc.abstractmethod
    def GetMethodFile(self, calibrationStep: int) -> str: ...
    def GetMethodFileCurrentStep(self) -> str: ...
    def Reset(self) -> None: ...
    def SetNextStep(self) -> bool: ...
    def TryGetValue(self, key: int, value: clr.Reference[str]) -> bool: ...
    # Skipped Add due to it being static, abstract and generic.

    Add : Add_MethodGroup
    class Add_MethodGroup:
        @typing.overload
        def __call__(self, item: KeyValuePair_2[int, str]) -> None:...
        @typing.overload
        def __call__(self, key: int, value: str) -> None:...

    # Skipped Remove due to it being static, abstract and generic.

    Remove : Remove_MethodGroup
    class Remove_MethodGroup:
        @typing.overload
        def __call__(self, key: int) -> bool:...
        @typing.overload
        def __call__(self, item: KeyValuePair_2[int, str]) -> bool:...



class CalibrationStepsNexus(CalibrationSteps):
    def __init__(self) -> None: ...
    @property
    def Count(self) -> int: ...
    @property
    def CurrentStep(self) -> int: ...
    @CurrentStep.setter
    def CurrentStep(self, value: int) -> int: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def Item(self) -> str: ...
    @Item.setter
    def Item(self, value: str) -> str: ...
    @property
    def Keys(self) -> ICollection_1[int]: ...
    @property
    def NSteps(self) -> int: ...
    @property
    def Values(self) -> ICollection_1[str]: ...
    def GetMethodFile(self, calibrationStep: int) -> str: ...


class CalibrationStepsPS3(CalibrationSteps):
    def __init__(self, diagnosticsMode: bool) -> None: ...
    ACCoupled : int
    CFfilter2 : int
    CFfilter3 : int
    CFfilter4 : int
    CFfilter5 : int
    FilterAc0 : int
    FilterAc1 : int
    FilterAc2 : int
    HSTAB : int
    PGA1 : int
    PGA2 : int
    PGA3 : int
    PGAoffsetACstep1 : int
    PGAoffsetACstep2 : int
    PGAoffsetDCstep1 : int
    PGAoffsetDCstep2 : int
    PhaseDelay12 : int
    PhaseDelay16 : int
    @property
    def Count(self) -> int: ...
    @property
    def CurrentStep(self) -> int: ...
    @CurrentStep.setter
    def CurrentStep(self, value: int) -> int: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def Item(self) -> str: ...
    @Item.setter
    def Item(self, value: str) -> str: ...
    @property
    def Keys(self) -> ICollection_1[int]: ...
    @property
    def NSteps(self) -> int: ...
    @property
    def Values(self) -> ICollection_1[str]: ...
    def GetMethodFile(self, calibrationStep: int) -> str: ...


class CalibrationStepsPS4(CalibrationSteps):
    def __init__(self) -> None: ...
    CABLE : int
    CR4 : int
    CR5 : int
    CR6 : int
    CR7 : int
    @property
    def Count(self) -> int: ...
    @property
    def CurrentStep(self) -> int: ...
    @CurrentStep.setter
    def CurrentStep(self, value: int) -> int: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def Item(self) -> str: ...
    @Item.setter
    def Item(self, value: str) -> str: ...
    @property
    def Keys(self) -> ICollection_1[int]: ...
    @property
    def NSteps(self) -> int: ...
    @property
    def Values(self) -> ICollection_1[str]: ...
    def GetMethodFile(self, calibrationStep: int) -> str: ...


class EISCalibration(abc.ABC):
    def __init__(self, eisSettings: EISSettings) -> None: ...
    @abc.abstractmethod
    def CorrectMeasuredValue(self, method: ImpedimetricIterationMethodBase, hwRevision: int, Zre: clr.Reference[float], Zim: clr.Reference[float], URe: float, UIm: float, IRe: float, IIm: float, phase: clr.Reference[float], Z: clr.Reference[float]) -> None: ...
    @abc.abstractmethod
    def GetDefaultValues(self, capabilities: DeviceCapabilities) -> EISCalibration: ...
    @abc.abstractmethod
    def GetValuesAsString(self) -> str: ...
    @abc.abstractmethod
    def ParseResult(self, eisData: EISData, calibrationStep: int, result: clr.Reference[float], message: clr.Reference[str]) -> bool: ...
    @abc.abstractmethod
    def ReadValuesFromEEPROM(self, clientConnection: ClientConnection) -> None: ...
    def ReadValuesFromEEPROMAsync(self, clientConnection: ClientConnection) -> Task: ...
    @abc.abstractmethod
    def ValidateAllValues(self, clientConnection: ClientConnection) -> bool: ...
    @abc.abstractmethod
    def WriteAllValuesToEEPROM(self, clientConnection: ClientConnection) -> None: ...
    def WriteAllValuesToEEPROMAsync(self, clientConnection: ClientConnection) -> Task: ...


class EISCalibrationNexus(EISCalibration):
    def __init__(self, eisSettings: EISSettings) -> None: ...

    class CompModes(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...

        # Values:
        Comp_None : EISCalibrationNexus.CompModes # 0
        Comp_Tau_lp : EISCalibrationNexus.CompModes # 1
        Comp_Tau_Tau : EISCalibrationNexus.CompModes # 2
        Comp_Polynomial : EISCalibrationNexus.CompModes # 3
        Comp_EquCircuit : EISCalibrationNexus.CompModes # 4


    class NexusEISComp:
        def __init__(self) -> None: ...
        Coefs : Array_1[float]
        mode : EISCalibrationNexus.CompModes

    _eisdata : List_1[EISData]
    _frequency_arr : Array_1[float]
    _modulus_arr : Array_1[float]
    _phase_arr : Array_1[float]
    CrToReg : Dictionary_2[int, ClientConnectionNexus.NexusReg]
    ModulusComp : EISCalibrationNexus.NexusEISComp
    PrToReg : Dictionary_2[PotentialRanges, ClientConnectionNexus.NexusReg]
    @property
    def ClientConnection(self) -> ClientConnectionNexus: ...
    @ClientConnection.setter
    def ClientConnection(self, value: ClientConnectionNexus) -> ClientConnectionNexus: ...
    def CompensateEIS_CR_Polynomial(self, CR: CurrentRange, frequency: Array_1[float], modulus: Array_1[float], phase: Array_1[float], modulus_order: int, phase_order: int) -> bool: ...
    def CompensateEIS_PR_Polynomial(self, PR: PotentialRange, frequency: Array_1[float], modulus: Array_1[float], phase: Array_1[float], modulus_order: int, phase_order: int) -> bool: ...
    def CorrectMeasuredValue(self, method: ImpedimetricIterationMethodBase, hwRevision: int, Zre: clr.Reference[float], Zim: clr.Reference[float], URe: float, UIm: float, IRe: float, IIm: float, phase: clr.Reference[float], Z: clr.Reference[float]) -> None: ...
    def DisableEISCompensation(self, clientConnection: ClientConnectionNexus) -> None: ...
    def eis_comp_reg_to_bytes(self, mode: EISCalibrationNexus.CompModes, coefs: Array_1[float], invert: bool = ...) -> Array_1[int]: ...
    def eis_comp_reg_to_string(self, mode: EISCalibrationNexus.CompModes, coefs: Array_1[float]) -> str: ...
    def EnableEISCompensation(self, clientConnection: ClientConnectionNexus) -> None: ...
    def float_to_bytes(self, val: float) -> Array_1[int]: ...
    def float_to_reg_string(self, value: float) -> str: ...
    def GetDefaultValues(self, capabilities: DeviceCapabilities) -> EISCalibration: ...
    def GetValuesAsString(self) -> str: ...
    def int_to_bytes(self, val: int) -> Array_1[int]: ...
    def long_to_bytes(self, val: int) -> Array_1[int]: ...
    def ParseResult(self, eisData: EISData, calibrationStep: int, result: clr.Reference[float], message: clr.Reference[str]) -> bool: ...
    def ProcessEISData(self, eisdata: List_1[EISData]) -> bool: ...
    def ReadValuesFromEEPROM(self, clientConnection: ClientConnection) -> None: ...
    def SetEISData(self, eisdata: List_1[EISData]) -> None: ...
    def ValidateAllValues(self, clientConnection: ClientConnection) -> bool: ...
    def WriteAllValuesToEEPROM(self, clientConnection: ClientConnection) -> None: ...
    def WriteEISCompReg(self, clientConnection: ClientConnectionNexus, reg: ClientConnectionNexus.NexusReg, modulus_mode: EISCalibrationNexus.CompModes, modulus_coefs: Array_1[float], phase_mode: EISCalibrationNexus.CompModes, phase_coefs: Array_1[float]) -> None: ...


class EISCalibrationPS3(EISCalibration):
    def __init__(self, eisSettings: EISSettings) -> None: ...
    acCoupledFreq0 : float
    FilterAcFreq0 : Array_1[float]
    FilterCFFreq0 : Array_1[float]
    HSTABFreq0 : float
    PGAGainFreq0 : Array_1[float]
    PGAoffsetCorrectionAcCoupled : int
    PGAoffsetCorrectionDcCoupled : int
    @property
    def AcCoupledIsEnabled(self) -> bool: ...
    @property
    def EISSettingsPS3(self) -> EISSettingsPS3: ...
    @staticmethod
    def CheckWithinRegion(defaultValue: float, result: float) -> bool: ...
    def ConvertValuesForEEPROM(self, values: Array_1[float], magnitudes: Array_1[int]) -> Array_1[int]: ...
    def CorrectMeasuredValue(self, method: ImpedimetricIterationMethodBase, hwRevision: int, Zre: clr.Reference[float], Zim: clr.Reference[float], URe: float, UIm: float, IRe: float, IIm: float, phase: clr.Reference[float], Z: clr.Reference[float]) -> None: ...
    def GetDefaultValues(self, capab: DeviceCapabilities) -> EISCalibration: ...
    def GetValuesAsString(self) -> str: ...
    def ParseResult(self, freqScan: EISData, calibrationStep: int, result: clr.Reference[float], message: clr.Reference[str]) -> bool: ...
    def ReadValuesFromEEPROM(self, conn: ClientConnection) -> None: ...
    def ReadValuesFromEEPROMAsync(self, conn: ClientConnection) -> Task: ...
    def ValidateAllValues(self, conn: ClientConnection) -> bool: ...
    def WriteAllValuesToEEPROM(self, clientConnection: ClientConnection) -> None: ...
    def WriteAllValuesToEEPROMAsync(self, clientConnection: ClientConnection) -> Task: ...


class EISCalibrationPS4(EISCalibration):
    def __init__(self, eisSettings: EISSettings) -> None: ...
    CableFreq0 : float
    CRCaps : Array_1[float]
    CRFreq0 : Dictionary_2[int, float]
    CRResistances : Array_1[float]
    PS4EISCALIBRATION : bool
    PS4EISCALIBRATION2 : bool
    @property
    def EISSettingsPS4(self) -> EISSettingsPS4: ...
    def CorrectMeasuredValue(self, method: ImpedimetricIterationMethodBase, hwRevision: int, Zre: clr.Reference[float], Zim: clr.Reference[float], URe: float, UIm: float, IRe: float, IIm: float, phase: clr.Reference[float], Z: clr.Reference[float]) -> None: ...
    def DoubleToUInt16(self, val: float, valHigh: clr.Reference[int], valLow: clr.Reference[int], magnitude: clr.Reference[int]) -> None: ...
    def GetDefaultValues(self, capabilities: DeviceCapabilities) -> EISCalibration: ...
    def GetValuesAsString(self) -> str: ...
    def ParseResult(self, eisData: EISData, calibrationStep: int, result: clr.Reference[float], message: clr.Reference[str]) -> bool: ...
    def ReadValuesFromEEPROM(self, clientConnection: ClientConnection) -> None: ...
    def ReadValuesFromEEPROMAsync(self, clientConnection: ClientConnection) -> Task: ...
    def UInt16ToDouble(self, valHigh: int, valLow: int, magnitude: int) -> float: ...
    def ValidateAllValues(self, clientConnection: ClientConnection) -> bool: ...
    def WriteAllValuesToEEPROM(self, clientConnection: ClientConnection) -> None: ...
    def WriteAllValuesToEEPROMAsync(self, clientConnection: ClientConnection) -> Task: ...


class EISDataExtenstions(abc.ABC):
    @staticmethod
    def GetEISValuesOfType(eisData: EISData, type: DataArrayType) -> Array_1[float]: ...


class PalmSensBiPotCalibration:
    def __init__(self) -> None: ...
    ADCFactor : float
    ADCOffset : float
    DACFactor : float
    DACOffset : float
    def GetCorrectedPSBiPotCurrent(self, value: float) -> float: ...
    def GetCorrectedPSBiPotPotential(self, value: float) -> float: ...
    @staticmethod
    def GetPalmSensBiPotCalibration(clientConnection: ClientConnection) -> PalmSensBiPotCalibration: ...
    @staticmethod
    def GetPalmSensBiPotCalibrationAsync(clientConnection: ClientConnection) -> Task_1[PalmSensBiPotCalibration]: ...
    def ReadValues(self, conn: ClientConnection) -> None: ...
    def ReadValuesAsync(self, conn: ClientConnection) -> Task: ...
    def ReadValuesFromSettings(self) -> None: ...
    def WriteValues(self, conn: ClientConnection) -> None: ...
    def WriteValuesAsync(self, conn: ClientConnection) -> Task: ...
