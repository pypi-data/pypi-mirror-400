# Licensed under the MIT License
# https://github.com/craigahobbs/bare-script/blob/main/LICENSE


# $function: qrcodeDraw
# $group: qrcode.bare
# $doc: Draw a QR code at the specified position and size
# $arg message: The QR code message or the QR code matrix
# $arg x: The X-coordinate, in pixels, of the left-side of the QR code
# $arg y: The Y-coordinate, in pixels, of the top of the QR code
# $arg size: The size of the QR code, in pixels
# $arg level: Optional (default is 'low'). The error correction level: 'low', 'medium', 'quartile', or 'high'.
function qrcodeDraw(message, x, y, size, level):
    # Get the QR code pixel matrix
    matrix = if(systemType(message) == 'string', qrcodeMatrix(message, level), message)
    qrcodeSize = arrayLength(matrix)

    # Draw the white background
    drawStyle('none', 0, 'white')
    drawRect(x, y, size, size)

    # Draw the black pixels
    # Note: The standard recommendation is a 4-module quiet zone on all sides.
    drawStyle('none', 0, 'black')
    ixRow = 0
    pixelSize = size / (qrcodeSize + 8)
    borderSize = pixelSize * 4
    precision = 6
    pixelSizeRound = mathRound(pixelSize, precision)
    while ixRow < qrcodeSize:
        ixCol = 0
        while ixCol < qrcodeSize:
            pixelValue = arrayGet(arrayGet(matrix, ixRow), ixCol)
            if pixelValue:
                pixelLeft = mathRound(borderSize + x + ixCol * pixelSize, precision)
                pixelTop = mathRound(borderSize + y + ixRow * pixelSize, precision)
                drawPathRect(pixelLeft, pixelTop, pixelSizeRound, pixelSizeRound)
            endif
            ixCol = ixCol + 1
        endwhile
        ixRow = ixRow + 1
    endwhile
endfunction


# $function: qrcodeElements
# $group: qrcode.bare
# $doc: Generate the element model for a QR code
# $arg message: The QR code message or the QR code matrix
# $arg size: The size of the QR code, in pixels
# $arg level: Optional (default is 'low'). The error correction level: 'low', 'medium', 'quartile', or 'high'.
# $return: The QR code SVG [element model](https://github.com/craigahobbs/element-model#readme)
function qrcodeElements(message, size, level):
    # Get the QR code pixel matrix
    matrix = if(systemType(message) == 'string', qrcodeMatrix(message, level), message)
    qrcodeSize = arrayLength(matrix)

    # Compute the black pixel paths
    # Note: The standard recommendation is a 4-module quiet zone on all sides.
    cellPaths = []
    ixRow = 0
    pixelSize = size / (qrcodeSize + 8)
    borderSize = pixelSize * 4
    precision = 6
    while ixRow < qrcodeSize:
        ixCol = 0
        while ixCol < qrcodeSize:
            pixelValue = arrayGet(arrayGet(matrix, ixRow), ixCol)
            if pixelValue:
                pixelLeft = borderSize + ixCol * pixelSize
                pixelTop = borderSize + ixRow * pixelSize
                arrayPush(cellPaths, arrayJoin([ \
                    'M', numberToFixed(pixelLeft, precision), numberToFixed(pixelTop, precision), \
                    'H', numberToFixed(pixelLeft + pixelSize, precision), \
                    'V', numberToFixed(pixelTop + pixelSize, precision), \
                    'H', numberToFixed(pixelLeft, precision), \
                    'Z' \
                ], ' '))
            endif
            ixCol = ixCol + 1
        endwhile
        ixRow = ixRow + 1
    endwhile

    # Create the QR code SVG element model
    return { \
        'svg': 'svg', \
        'attr': {'width': size, 'height': size}, \
        'elem': [ \
            { \
                'svg': 'rect', \
                'attr': { \
                    'x': '0', 'y': '0', 'width': size, 'height': size, \
                    'fill': 'white', 'stroke': 'none', 'stroke-width': '0', 'stroke-dasharray': 'none' \
                } \
            }, \
            { \
                'svg': 'path', \
                'attr': { \
                    'fill': 'black', 'stroke': 'none', 'stroke-width': '0', 'stroke-dasharray': 'none', \
                    'd': arrayJoin(cellPaths, ' ') \
                } \
            } \
        ] \
    }
endfunction


# $function: qrcodeMatrix
# $group: qrcode.bare
# $doc: Generate a QR code pixel matrix
# $arg message: The QR code message
# $arg level: Optional (default is 'low'). The error correction level: 'low', 'medium', 'quartile', or 'high'.
# $return: The QR code pixel matrix
function qrcodeMatrix(message, level):
    level = if(level != null, level, 'low')

    # Find the QR code model that fits the message bits (mode, version, message, terminator)
    qrcode = null
    for qrcodeFind in qrcodeVersions:
        messageBits = qrcodeMessageBits(qrcodeFind, level, message)
        if messageBits != null:
            qrcode = qrcodeFind
            break
        endif
    endfor
    if qrcode == null:
        systemLogDebug('qrcode.bare: qrcodeMatrix - Message too long (' + stringLength(message) + ')')
        return null
    endif
    size = objectGet(qrcode, 'size')
    alignmentPatterns = objectGet(qrcode, 'alignmentPatterns')
    totalCodewords = objectGet(objectGet(qrcode, level), 'totalCodewords')

    # Create the pixel matrix
    matrix = []
    ixRow = 0
    while ixRow < size:
        arrayPush(matrix, arrayNewSize(size, null))
        ixRow = ixRow + 1
    endwhile

    # Position squares
    qrcodeMatrixPositionSquare(matrix, 3, 3)
    qrcodeMatrixPositionSquare(matrix, 3, size - 4)
    qrcodeMatrixPositionSquare(matrix, size - 4, 3)

    # Alignment patterns
    if alignmentPatterns:
        ixLast = arrayLength(alignmentPatterns) - 1
        for alignX, ixAX in alignmentPatterns:
            for alignY, ixAY in alignmentPatterns:
                if !(ixAX == 0 && ixAY == 0) && !(ixAX == 0 && ixAY == ixLast) && !(ixAX == ixLast && ixAY == 0):
                    qrcodeMatrixAlignmentPattern(matrix, alignX, alignY)
                endif
            endfor
        endfor
    endif

    # Timing strips
    qrcodeMatrixTimingStrips(matrix)

    # Format strips - use mask 0 as placeholder bits for qrcodeDataPixels
    qrcodeMatrixFormatStrips(matrix, level, 0)

    # Version blocks
    qrcodeMatrixVersionBlocks(matrix, qrcode)

    # Compute the data pixels
    dataPixels = qrcodeDataPixels(matrix)

    # Compute the data bits
    dataBits = qrcodeDataBits(qrcode, level, message)

    # Add the data remainder bits
    remainderLength = arrayLength(dataPixels) - totalCodewords * 8
    if remainderLength > 0:
        arrayExtend(dataBits, arrayNewSize(remainderLength, 0))
    endif

    # Compute the penalty for each mask
    bestMatrix = null
    bestPenalty = null
    mask = 0
    while mask < 8:
        # Set full data bits with mask
        maskMatrix = jsonParse(jsonStringify(matrix))
        qrcodeMatrixPixels(maskMatrix, dataPixels, dataBits, mask)

        # Set the format strips bits
        qrcodeMatrixFormatStrips(maskMatrix, level, mask)

        # Compute the mask's penalty
        maskPenalty = qrcodeMatrixPenalty(maskMatrix)
        if bestPenalty == null || maskPenalty < bestPenalty:
            bestMatrix = maskMatrix
            bestPenalty = maskPenalty
        endif

        mask = mask + 1
    endwhile

    return bestMatrix
endfunction


# Set a position square's pixels
function qrcodeMatrixPositionSquare(matrix, x, y):
    qrcodeMatrixSquare(matrix, x - 4, y - 4, 9, 0)
    qrcodeMatrixSquare(matrix, x - 3, y - 3, 7, 1)
    qrcodeMatrixSquare(matrix, x - 2, y - 2, 5, 0)
    qrcodeMatrixSquare(matrix, x - 1, y - 1, 3, 1)
endfunction


# Set an alignment pattern's pixels
function qrcodeMatrixAlignmentPattern(matrix, x, y):
    qrcodeMatrixSquare(matrix, x - 2, y - 2, 5, 1)
    qrcodeMatrixSquare(matrix, x - 1, y - 1, 3, 0)
    qrcodeMatrixSquare(matrix, x, y, 1, 1)
endfunction


# Set a solid square's pixels
function qrcodeMatrixSquare(matrix, x, y, size, colorValue):
    xEnd = mathMin(arrayLength(matrix), x + size)
    yEnd = mathMin(arrayLength(matrix), y + size)
    iy = mathMax(0, y)
    while iy < yEnd:
        ix = mathMax(0, x)
        while ix < xEnd:
            arraySet(arrayGet(matrix, iy), ix, colorValue)
            ix = ix + 1
        endwhile
        iy = iy + 1
    endwhile
endfunction


# Set the timing strip pixels
function qrcodeMatrixTimingStrips(matrix):
    size = arrayLength(matrix)
    ix = 8
    ixEnd = size - 8
    while ix < ixEnd:
        arraySet(arrayGet(matrix, 6), ix, if(ix % 2, 0, 1))
        arraySet(arrayGet(matrix, ix), 6, if(ix % 2, 0, 1))
        ix = ix + 1
    endwhile
endfunction


# Set the format strips pixels
function qrcodeMatrixFormatStrips(matrix, level, mask):
    size = arrayLength(matrix)

    # The "dark pixel"
    arraySet(arrayGet(matrix, size - 8), 8, 1)

    # Set the format strip bits
    formatStripBits = objectGet(objectGet(qrcodeMatrixFormatStripsBitsTable, level), stringNew(mask))
    pixelsTopLeft = [ \
        [0, 8], [1, 8], [2, 8], [3, 8], [4, 8], [5, 8], [7, 8], [8, 8], \
        [8, 7], [8, 5], [8, 4], [8, 3], [8, 2], [8, 1], [8, 0] \
    ]
    pixelsNonTopLeft = [ \
        [8, size - 1], [8, size - 2], [8, size - 3], [8, size - 4], [8, size - 5], [8, size - 6], [8, size - 7], [size - 8, 8], \
        [size - 7, 8], [size - 6, 8], [size - 5, 8], [size - 4, 8], [size - 3, 8], [size - 2, 8], [size - 1, 8] \
    ]
    qrcodeMatrixPixels(matrix, pixelsTopLeft, formatStripBits)
    qrcodeMatrixPixels(matrix, pixelsNonTopLeft, formatStripBits)
endfunction


# Format strip bits lookup table
qrcodeMatrixFormatStripsBitsTable = { \
    'low': { \
        '0': [1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0], \
        '1': [1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1], \
        '2': [1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0], \
        '3': [1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1], \
        '4': [1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1], \
        '5': [1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0], \
        '6': [1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], \
        '7': [1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0] \
    }, \
    'medium': { \
        '0': [1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0], \
        '1': [1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1], \
        '2': [1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0], \
        '3': [1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1], \
        '4': [1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1], \
        '5': [1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0], \
        '6': [1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1], \
        '7': [1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0] \
    }, \
    'quartile': { \
        '0': [0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1], \
        '1': [0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0], \
        '2': [0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1], \
        '3': [0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0], \
        '4': [0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0], \
        '5': [0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1], \
        '6': [0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0], \
        '7': [0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1] \
    }, \
    'high': { \
        '0': [0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1], \
        '1': [0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0], \
        '2': [0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1], \
        '3': [0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0], \
        '4': [0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0], \
        '5': [0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1], \
        '6': [0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0], \
        '7': [0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1] \
    } \
}


# Set the version blocks pixels
function qrcodeMatrixVersionBlocks(matrix, qrcode):
    version = objectGet(qrcode, 'version')
    versionBits = objectGet(qrcodeMatrixVersionBitsTable, stringNew(version))
    if versionBits:
        size = arrayLength(matrix)
        bottomLeftPixels = [ \
            [5, size - 9], [5, size - 10], [5, size - 11], [4, size - 9], [4, size - 10], [4, size - 11], \
            [3, size - 9], [3, size - 10], [3, size - 11], [2, size - 9], [2, size - 10], [2, size - 11], \
            [1, size - 9], [1, size - 10], [1, size - 11], [0, size - 9], [0, size - 10], [0, size - 11] \
        ]
        topRightPixels = [ \
            [size - 9, 5], [size - 10, 5], [size - 11, 5], [size - 9, 4], [size - 10, 4], [size - 11, 4], \
            [size - 9, 3], [size - 10, 3], [size - 11, 3], [size - 9, 2], [size - 10, 2], [size - 11, 2], \
            [size - 9, 1], [size - 10, 1], [size - 11, 1], [size - 9, 0], [size - 10, 0], [size - 11, 0] \
        ]
        qrcodeMatrixPixels(matrix, bottomLeftPixels, versionBits)
        qrcodeMatrixPixels(matrix, topRightPixels, versionBits)
    endif
endfunction


# Version bits lookup table
qrcodeMatrixVersionBitsTable = { \
    '7': [0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0], \
    '10': [0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1], \
    '15': [0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0] \
}


# Set a pixel array's pixels
function qrcodeMatrixPixels(matrix, pixels, bits, mask):
    for bitValue, ixBit in bits:
        pixel = arrayGet(pixels, ixBit)
        ix = arrayGet(pixel, 0)
        iy = arrayGet(pixel, 1)

        # Apply an XOR mask, if requested
        if mask != null:
            if mask == 0:
                maskBit = if((iy + ix) % 2, 0, 1)
            elif mask == 1:
                maskBit = if(iy % 2, 0, 1)
            elif mask == 2:
                maskBit = if(ix % 3, 0, 1)
            elif mask == 3:
                maskBit = if((iy + ix) % 3, 0, 1)
            elif mask == 4:
                maskBit = if((mathFloor(iy / 2) + mathFloor(ix / 3)) % 2, 0, 1)
            elif mask == 5:
                maskBit = if((iy * ix) % 2 + (iy * ix) % 3, 0, 1)
            elif mask == 6:
                maskBit = if((((iy * ix) % 2) + ((iy * ix) % 3)) % 2, 0, 1)
            else: # mask == 7
                maskBit = if((((iy + ix) % 2) + ((iy * ix) % 3)) % 2, 0, 1)
            endif
            bitValue = bitValue ^ maskBit
        endif

        # Set the pixel
        arraySet(arrayGet(matrix, iy), ix, bitValue)
    endfor
endfunction


# Get the list of available data pixel positions in the QR code
function qrcodeDataPixels(matrix):
    dataPixels = []
    size = arrayLength(matrix)

    # Iterate pixel pairs - up and down, right to left
    x = size - 1
    y = size - 1
    up = true
    while true:
        # Add the pixel pair (right then left) if its unused
        if arrayGet(arrayGet(matrix, y), x) == null:
            arrayPush(dataPixels, [x, y])
        endif
        if x > 0 && arrayGet(arrayGet(matrix, y), x - 1) == null:
            arrayPush(dataPixels, [x - 1, y])
        endif

        # Move the pixel pair
        if (up && y == 0) || (!up && y == size - 1):
            up = !up
            x = x - 2
            if x == 6:
                x = 5
            elif x < 0:
                break
            endif
        else:
            y = y + if(up, -1, 1)
        endif
    endwhile

    return dataPixels
endfunction


# Get the full data bits (includes mode, size, message, terminator, padding, ec)
function qrcodeDataBits(qrcode, level, message):
    ecLevel = objectGet(qrcode, level)
    totalMessageCodewords = objectGet(ecLevel, 'totalMessageCodewords')
    errorCodewordsPerBlock = objectGet(ecLevel, 'errorCodewordsPerBlock')
    blockGroups = objectGet(ecLevel, 'blockGroups')

    # Compute the message bits
    messageBits = qrcodeMessageBits(qrcode, level, message)

    # Padding bits
    paddingBits = []
    remainingBitCount = totalMessageCodewords * 8 - arrayLength(messageBits)
    byteCount = mathFloor(remainingBitCount / 8)
    ix = 0
    while ix < byteCount:
        padValue = if(ix % 2, 17, 236)
        padBits = qrcodeBytesToBits([padValue])
        arrayExtend(paddingBits, padBits)
        ix = ix + 1
    endwhile

    # Compute the full data bytes
    fullMessageBits = []
    arrayExtend(fullMessageBits, messageBits)
    arrayExtend(fullMessageBits, paddingBits)
    fullMessageBytes = qrcodeBitsToBytes(fullMessageBits)

    # Data group/block interleaving and error correction codeword generation
    allDataBlocks = []
    allECBlocks = []
    maxDataBlocks = 0
    byteIndex = 0
    for blockGroup in blockGroups:
        blockCount = objectGet(blockGroup, 'blockCount')
        dataCodewordsPerBlock = objectGet(blockGroup, 'dataCodewordsPerBlock')
        ixBlock = 0
        while ixBlock < blockCount:
            # Extract data bytes for this block
            blockDataBytes = arraySlice(fullMessageBytes, byteIndex, byteIndex + dataCodewordsPerBlock)
            maxDataBlocks = mathMax(maxDataBlocks, arrayLength(blockDataBytes))
            arrayPush(allDataBlocks, blockDataBytes)

            # Generate error correction codewords
            ecCodewords = qrcodeRSEncode(blockDataBytes, errorCodewordsPerBlock)
            arrayPush(allECBlocks, ecCodewords)

            byteIndex = byteIndex + dataCodewordsPerBlock
            ixBlock = ixBlock + 1
        endwhile
    endfor

    # Interleave data blocks
    interleaved = []
    ixByte = 0
    while ixByte < maxDataBlocks:
        for dataBlock in allDataBlocks:
            if ixByte < arrayLength(dataBlock):
                arrayPush(interleaved, arrayGet(dataBlock, ixByte))
            endif
        endfor
        ixByte = ixByte + 1
    endwhile

    # Interleave error correction blocks
    ixByte = 0
    while ixByte < errorCodewordsPerBlock:
        for ecBlock in allECBlocks:
            if ixByte < arrayLength(ecBlock):
                arrayPush(interleaved, arrayGet(ecBlock, ixByte))
            endif
        endfor
        ixByte = ixByte + 1
    endwhile

    # Convert back to bits
    return qrcodeBytesToBits(interleaved)
endfunction


# Get the terminated message bits (mode, size, message, terminator)
function qrcodeMessageBits(qrcode, level, message):
    version = objectGet(qrcode, 'version')
    totalMessageCodewords = objectGet(objectGet(qrcode, level), 'totalMessageCodewords')

    # Determine the message mode
    # Note: Kanji and ECI modes not supported
    if regexMatch(qrcodeModeNumericRegex, message):
        modeBits = [0, 0, 0, 1]
        messageBits = qrcodeModeNumericBits(message)
        messageSize = stringLength(message)
        sizeBitsLength = if(version < 10, 10, if(version < 27, 12, 14))
    elif regexMatch(qrcodeModeAlphanumericRegex, message):
        modeBits = [0, 0, 1, 0]
        messageBits = qrcodeModeAlphanumericBits(message)
        messageSize = stringLength(message)
        sizeBitsLength = if(version < 10, 9, if(version < 27, 11, 13))
    else:
        modeBits = [0, 1, 0, 0]
        messageBytes = stringEncode(message)
        messageBits = qrcodeBytesToBits(messageBytes)
        messageSize = arrayLength(messageBytes)
        sizeBitsLength = if(version < 10, 8, 16)
    endif

    # Add terminator (min(4, remaining) zeros)
    usedBitCount = arrayLength(modeBits) + sizeBitsLength + arrayLength(messageBits)
    remainingBitCount = totalMessageCodewords * 8 - usedBitCount
    if remainingBitCount < 0:
        return null
    endif
    termLen = mathMin(4, remainingBitCount)
    terminatorBits = arrayNewSize(termLen, 0)

    # Add bit padding (zeros to align to multiple of 8)
    usedBitCount = usedBitCount + termLen
    alignZeros = (8 - (usedBitCount % 8)) % 8
    alignBits = arrayNewSize(alignZeros, 0)

    # Compute the total message bits
    totalMessageBits = []
    arrayExtend(totalMessageBits, modeBits)
    arrayExtend(totalMessageBits, qrcodeBytesToBits([messageSize], sizeBitsLength))
    arrayExtend(totalMessageBits, messageBits)
    arrayExtend(totalMessageBits, terminatorBits)
    arrayExtend(totalMessageBits, alignBits)
    return totalMessageBits
endfunction


# Mode determination regex
qrcodeModeNumericRegex = regexNew('^[0-9]+$')
qrcodeModeAlphanumericRegex = regexNew('^[0-9A-Z $%*+-./:]+$')
qrcodeModeAlphanumericStr = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:'


# Numeric mode message encoding
function qrcodeModeNumericBits(message):
    messageBits = []
    messageLength = stringLength(message)
    ixChar = 0
    while ixChar < messageLength:
        chunk = stringSlice(message, ixChar, mathMin(messageLength, ixChar + 3))
        chunkLength = stringLength(chunk)
        chunkValue = numberParseInt(chunk)
        if chunkLength == 1:
            arrayExtend(messageBits, qrcodeBytesToBits([chunkValue], 4))
        elif chunkLength == 2:
            arrayExtend(messageBits, qrcodeBytesToBits([chunkValue], 7))
        else: # chunkLength == 3
            arrayExtend(messageBits, qrcodeBytesToBits([chunkValue], 10))
        endif
        ixChar = ixChar + 3
    endwhile
    return messageBits
endfunction


# Numeric mode message encoding
function qrcodeModeAlphanumericBits(message):
    messageBits = []
    messageLength = stringLength(message)
    messageLengthMinusOne = messageLength - 1
    ixChar = 0
    while ixChar < messageLength:
        value1 = stringIndexOf(qrcodeModeAlphanumericStr, stringSlice(message, ixChar, ixChar + 1))
        value2 = if(ixChar < messageLengthMinusOne, stringIndexOf(qrcodeModeAlphanumericStr, stringSlice(message, ixChar + 1, ixChar + 2)))
        if value2 == null:
            arrayExtend(messageBits, qrcodeBytesToBits([value1], 6))
        else:
            arrayExtend(messageBits, qrcodeBytesToBits([45 * value1 + value2], 11))
        endif
        ixChar = ixChar + 2
    endwhile
    return messageBits
endfunction


# Convert a byte value array to bit array
function qrcodeBytesToBits(bytes, bitsLength):
    bitsLength = if(bitsLength, bitsLength, 8)
    bits = []
    for byteValue in bytes:
        reversedBits = []
        ixBit = 0
        while ixBit < bitsLength:
            arrayPush(reversedBits, byteValue & 1)
            byteValue = byteValue >> 1
            ixBit = ixBit + 1
        endwhile
        arrayExtend(bits, arrayReverse(reversedBits))
    endfor
    return bits
endfunction


# Convert bit array to byte array
function qrcodeBitsToBytes(bits):
    bytes = []
    ixBit = 0
    bitsLength = arrayLength(bits)
    while ixBit < bitsLength:
       byteBits = arraySlice(bits, ixBit, mathMin(ixBit + 8, bitsLength))
       arrayExtend(byteBits, arrayNewSize(8 - arrayLength(byteBits), 0))
       byteValue = numberParseInt(arrayJoin(byteBits, ''), 2)
       arrayPush(bytes, byteValue)
       ixBit = ixBit + 8
    endwhile
    return bytes
endfunction


# Compute the masked matrix penalty
function qrcodeMatrixPenalty(matrix):
    size = arrayLength(matrix)
    penalty = 0

    # Compute row penalties
    for row in matrix:
        stringRow = arrayJoin(row, '')

        # Penalty 1: Five or more same-colored modules in a row
        for runMatch in regexMatchAll(qrcodeMatrixPenaltyRunRegex, stringRow):
            penalty = penalty + 3 + (stringLength(objectGet(objectGet(runMatch, 'groups'), '0')) - 5)
        endfor

        # Penalty 3: Finder-like patterns (1011101 with 4 white modules on either side)
        penalty = penalty + 40 * arrayLength(regexMatchAll(qrcodeMatrixPenaltyPatternRegex, stringRow))
    endfor

    # Compute column penalties - also count dark modules
    darkCount = 0
    twoBySize = size - 1
    ix = 0
    while ix < size:
        column = []
        iy = 0
        while iy < size:
            row = arrayGet(matrix, iy)
            bit = arrayGet(row, ix)
            arrayPush(column, bit)

            # Penalty 2: 2x2 blocks of same color
            row2 = if(ix < twoBySize && iy < twoBySize, arrayGet(matrix, iy + 1))
            if row2 && bit == arrayGet(row, ix + 1) && bit == arrayGet(row2, ix) && bit == arrayGet(row2, ix + 1):
                penalty = penalty + 3
            endif

            # Count "dark" pixels
            darkCount = darkCount + bit

            iy = iy + 1
        endwhile
        stringColumn = arrayJoin(column, '')

        # Penalty 1: Five or more same-colored modules in a column
        for runMatch in regexMatchAll(qrcodeMatrixPenaltyRunRegex, stringColumn):
            penalty = penalty + 3 + (stringLength(objectGet(objectGet(runMatch, 'groups'), '0')) - 5)
        endfor

        # Penalty 3: Finder-like patterns (1011101 with 4 white modules on either side)
        penalty = penalty + 40 * arrayLength(regexMatchAll(qrcodeMatrixPenaltyPatternRegex, stringColumn))

        ix = ix + 1
    endwhile

    # Penalty 4: Proportion of dark modules
    darkPercent = (darkCount * 100) / (size * size)
    penalty = penalty + mathFloor(mathAbs(darkPercent - 50) / 5) * 10

    return penalty
endfunction


# QR matrix scorinn pattern regular expressions
qrcodeMatrixPenaltyRunRegex = regexNew('(?:0{5,}|1{5,})')
qrcodeMatrixPenaltyPatternRegex = regexNew('(?:10111010000|00001011101)')


# Generate Reed-Solomon error correction codewords
function qrcodeRSEncode(bytesIn, numCodewords):
    # Copy input message and append zero bytes for EC codewords
    bytesOut = arrayCopy(bytesIn)
    arrayExtend(bytesOut, arrayNewSize(numCodewords, 0))

    # Get the generator polynomial coefficients (stored as alpha exponents)
    genExponents = objectGet(qrcodeRSGeneratorPolynomials, stringNew(numCodewords))
    lenGen = arrayLength(genExponents)
    lenMsg = arrayLength(bytesIn)

    # Perform Reed-Solomon division (long division in GF(256))
    i = 0
    while i < lenMsg:
        leadCoef = arrayGet(bytesOut, i)
        if leadCoef != 0:
            # Precompute log of leading coefficient for faster GF multiplication
            logLead = arrayGet(qrcodeGaloisFieldLogTable, leadCoef)

            # Apply generator polynomial (skip j=0 term — it's always 1)
            j = 1
            while j < lenGen:
                oldVal = arrayGet(bytesOut, i + j)

                # Convert generator coefficient from alpha exponent to field element
                genCoefExp = arrayGet(genExponents, j)
                genCoef = if(genCoefExp == 0, 1, arrayGet(qrcodeGaloisFieldExpTable, genCoefExp))

                # GF multiply: leadCoef * genCoef → using log tables
                productExp = (logLead + arrayGet(qrcodeGaloisFieldLogTable, genCoef)) % 255
                product = arrayGet(qrcodeGaloisFieldExpTable, productExp)

                # XOR with existing value (subtraction in GF(2^8))
                arraySet(bytesOut, i + j, oldVal ^ product)

                j = j + 1
            endwhile
        endif

        i = i + 1
    endwhile

    # Return only the error correction codewords (the remainder)
    return arraySlice(bytesOut, lenMsg)
endfunction


# Reed-Solomon error correction codeword count (string) to generator polynomial exponents
qrcodeRSGeneratorPolynomials = { \
    '10': [1, 251, 67, 46, 61, 118, 70, 64, 94, 32, 45], \
    '15': [1, 8, 183, 61, 91, 202, 37, 51, 58, 58, 237, 140, 124, 5, 99, 105], \
    '16': [1, 120, 104, 107, 109, 102, 161, 76, 3, 91, 191, 147, 169, 182, 194, 225, 120], \
    '18': [1, 215, 234, 158, 94, 184, 97, 118, 170, 79, 187, 152, 148, 252, 179, 5, 98, 96, 153], \
    '20': [1, 17, 60, 79, 50, 61, 163, 26, 187, 202, 180, 221, 225, 83, 239, 156, 164, 212, 212, 188, 190], \
    '22': [1, 210, 171, 247, 242, 93, 230, 14, 109, 221, 53, 200, 74, 8, 172, 98, 80, 219, 134, 160, 105, 165, 231], \
    '24': [1, 229, 121, 135, 48, 211, 117, 251, 126, 159, 180, 169, 152, 192, 226, 228, 218, 111, 0, 117, 232, 87, 96, 227, 21], \
    '26': [1, 173, 125, 158, 2, 103, 182, 118, 17, 145, 201, 111, 28, 165, 53, 161, 21, 245, 142, 13, 102, 48, 227, 153, 145, 218, 70], \
    '28': [1, 168, 223, 200, 104, 224, 234, 108, 180, 110, 190, 195, 147, 205, 27, 232, 201, 21, 43, 245, 87, 42, 195, 212, 119, 242, 37, 9, 123], \
    '30': [1, 41, 173, 145, 152, 216, 31, 179, 182, 50, 48, 110, 86, 239, 96, 222, 125, 42, 173, 226, 193, 224, 130, 156, 37, 251, 216, 238, 40, 192, 180] \
}


# GF(256) EXP table
qrcodeGaloisFieldExpTable = [ \
    1, 2, 4, 8, 16, 32, 64, 128, 29, 58, 116, 232, 205, 135, 19, 38, 76, 152, 45, 90, 180, 117, 234, 201, 143, 3, 6, 12, \
    24, 48, 96, 192, 157, 39, 78, 156, 37, 74, 148, 53, 106, 212, 181, 119, 238, 193, 159, 35, 70, 140, 5, 10, 20, 40, 80, \
    160, 93, 186, 105, 210, 185, 111, 222, 161, 95, 190, 97, 194, 153, 47, 94, 188, 101, 202, 137, 15, 30, 60, 120, 240, \
    253, 231, 211, 187, 107, 214, 177, 127, 254, 225, 223, 163, 91, 182, 113, 226, 217, 175, 67, 134, 17, 34, 68, 136, 13, \
    26, 52, 104, 208, 189, 103, 206, 129, 31, 62, 124, 248, 237, 199, 147, 59, 118, 236, 197, 151, 51, 102, 204, 133, 23, \
    46, 92, 184, 109, 218, 169, 79, 158, 33, 66, 132, 21, 42, 84, 168, 77, 154, 41, 82, 164, 85, 170, 73, 146, 57, 114, \
    228, 213, 183, 115, 230, 209, 191, 99, 198, 145, 63, 126, 252, 229, 215, 179, 123, 246, 241, 255, 227, 219, 171, 75, \
    150, 49, 98, 196, 149, 55, 110, 220, 165, 87, 174, 65, 130, 25, 50, 100, 200, 141, 7, 14, 28, 56, 112, 224, 221, 167, \
    83, 166, 81, 162, 89, 178, 121, 242, 249, 239, 195, 155, 43, 86, 172, 69, 138, 9, 18, 36, 72, 144, 61, 122, 244, 245, \
    247, 243, 251, 235, 203, 139, 11, 22, 44, 88, 176, 125, 250, 233, 207, 131, 27, 54, 108, 216, 173, 71, 142, 1 \
]


# GF(256) LOG table
qrcodeGaloisFieldLogTable = [ \
    null, 0, 1, 25, 2, 50, 26, 198, 3, 223, 51, 238, 27, 104, 199, 75, 4, 100, 224, 14, 52, 141, 239, 129, 28, 193, 105, \
    248, 200, 8, 76, 113, 5, 138, 101, 47, 225, 36, 15, 33, 53, 147, 142, 218, 240, 18, 130, 69, 29, 181, 194, 125, 106, \
    39, 249, 185, 201, 154, 9, 120, 77, 228, 114, 166, 6, 191, 139, 98, 102, 221, 48, 253, 226, 152, 37, 179, 16, 145, 34, \
    136, 54, 208, 148, 206, 143, 150, 219, 189, 241, 210, 19, 92, 131, 56, 70, 64, 30, 66, 182, 163, 195, 72, 126, 110, \
    107, 58, 40, 84, 250, 133, 186, 61, 202, 94, 155, 159, 10, 21, 121, 43, 78, 212, 229, 172, 115, 243, 167, 87, 7, 112, \
    192, 247, 140, 128, 99, 13, 103, 74, 222, 237, 49, 197, 254, 24, 227, 165, 153, 119, 38, 184, 180, 124, 17, 68, 146, \
    217, 35, 32, 137, 46, 55, 63, 209, 91, 149, 188, 207, 205, 144, 135, 151, 178, 220, 252, 190, 97, 242, 86, 211, 171, \
    20, 42, 93, 158, 132, 60, 57, 83, 71, 109, 65, 162, 31, 45, 67, 216, 183, 123, 164, 118, 196, 23, 73, 236, 127, 12, \
    111, 246, 108, 161, 59, 82, 41, 157, 85, 170, 251, 96, 134, 177, 187, 204, 62, 90, 203, 89, 95, 176, 156, 169, 160, \
    81, 11, 245, 22, 235, 122, 117, 44, 215, 79, 174, 213, 233, 230, 231, 173, 232, 116, 214, 244, 234, 168, 80, 88, 175 \
]


# QR Code version information table
# 0 - Version
# 1 - Size
# 2 - Alignment Pattern Center Positions
qrcodeVersionTable = [ \
    [2, 25, 6, 18], \
    [3, 29, 6, 22], \
    [5, 37, 6, 30], \
    [7, 45, 6, 22, 38], \
    [10, 57, 6, 28, 50], \
    [15, 77, 6, 26, 48, 70] \
]


# Error correction configuration table
# 0 - Version
# 1 - EC Level
# 2 - Total Number of Data Codewords for this Version and EC Level
# 3 - EC Codewords Per Block
# 4 - Number of Blocks in Group 1
# 5 - Number of Data Codewords in Each of Group 1's Blocks
# 6 - Number of Blocks in Group 2
# 7 - Number of Data Codewords in Each of Group 2's Blocks
qrcodeErrorCorrectionTable = [ \
    [2, 'low', 34, 10, 1, 34, null, null], \
    [2, 'medium', 28, 16, 1, 28, null, null], \
    [2, 'quartile', 22, 22, 1, 22, null, null], \
    [2, 'high', 16, 28, 1, 16, null, null], \
    [3, 'low', 55, 15, 1, 55, null, null], \
    [3, 'medium', 44, 26, 1, 44, null, null], \
    [3, 'quartile', 34, 18, 2, 17, null, null], \
    [3, 'high', 26, 22, 2, 13, null, null], \
    [5, 'low', 108, 26, 1, 108, null, null], \
    [5, 'medium', 86, 24, 2, 43, null, null], \
    [5, 'quartile', 62, 18, 2, 15, 2, 16], \
    [5, 'high', 46, 22, 2, 11, 2, 12], \
    [7, 'low', 156, 20, 2, 78, null, null], \
    [7, 'medium', 124, 18, 4, 31, null, null], \
    [7, 'quartile', 88, 18, 2, 14, 4, 15], \
    [7, 'high', 66, 26, 4, 13, 1, 14], \
    [10, 'low', 274, 18, 2, 68, 2, 69], \
    [10, 'medium', 216, 26, 4, 43, 1, 44], \
    [10, 'quartile', 154, 24, 6, 19, 2, 20], \
    [10, 'high', 122, 28, 6, 15, 2, 16], \
    [15, 'low', 523, 22, 5, 87, 1, 88], \
    [15, 'medium', 415, 24, 5, 41, 5, 42], \
    [15, 'quartile', 295, 30, 5, 24, 7, 25], \
    [15, 'high', 223, 24, 11, 12, 7, 13] \
]


# QR code models sorted ascending by version
function qrcodeVersionsCreate():
    versions = []
    for row in qrcodeVersionTable:
        # Create the QR code model
        version = arrayGet(row, 0)
        qrcode = { \
            'version': version, \
            'size': arrayGet(row, 1), \
            'alignmentPatterns': arraySlice(row, 2) \
        }
        arrayPush(versions, qrcode)

        # Add the error correction configurations
        for ecRow in qrcodeErrorCorrectionTable:
            ecVersion = arrayGet(ecRow, 0)
            if ecVersion == version:
                level = arrayGet(ecRow, 1)
                totalDataCodewords = arrayGet(ecRow, 2)
                ecCodewordsPerBlock = arrayGet(ecRow, 3)
                numBlocksGroup1 = arrayGet(ecRow, 4)
                numBlocksGroup2 = arrayGet(ecRow, 6)
                totalECCodewords = ecCodewordsPerBlock * (numBlocksGroup1 + (numBlocksGroup2 || 0))
                blockGroups = [ \
                    {'blockCount': numBlocksGroup1, 'dataCodewordsPerBlock': arrayGet(ecRow, 5)} \
                ]
                if numBlocksGroup2 != null:
                    arrayPush(blockGroups, {'blockCount': numBlocksGroup2, 'dataCodewordsPerBlock': arrayGet(ecRow, 7)})
                endif
                objectSet(qrcode, level, { \
                    'totalCodewords': totalDataCodewords + totalECCodewords, \
                    'totalMessageCodewords': totalDataCodewords, \
                    'errorCodewordsPerBlock': ecCodewordsPerBlock, \
                    'blockGroups': blockGroups \
                })
            endif
        endfor
    endfor
    return versions
endfunction
qrcodeVersions = qrcodeVersionsCreate()
