# 演变语义 (Evolution)

Typedown 不将数据视为静态产物，而是一个不断进化的时间线。

## 1. 线性演变 (`former`)

`former` 关键字将一个新实体状态链接到其上一个版本。

- **语法**: 在实体主体中使用 `former: [[QueryString]]`。
- **约束**: **必须使用全局寻址 (Global Addressing)**。
  - 🚫 **禁止**: 局部 Handle (如 `alice`)。演变关系必须跨越文件和上下文保持稳定。
  - 🚫 **禁止**: 纯字符串 ID (如 `"slug-id"`)。根据最新的 Typedown 规范，必须使用显式引用语法。
  - ✅ **允许**:
    - **Slug ID Reference**: `[[user-alice-v1]]` (最常用)
    - **UUID Reference**: `[[550e84...]]` (机器生成的唯一标识)
    - **Block Fingerprint**: `[[sha256:8f4b...]]` (基于内容的哈希，最精确)
- **语义**:
  - **身份一致性**: 新实体在逻辑上代表同一个对象的不同时间点。
  - **纯指针 (Pure Pointer)**: `former` 仅作为一个元数据链接存在，用于构建时间线。编译器**不执行**数据合并。
  - **增量原则**: 新实体必须包含完整的属性定义（或由用户显式复制）。
  - **不可变性**: 旧 ID 依然是一个有效的、不可变的快照。一旦一个 Entity 被指向（由于其已成为历史），它就不应再被修改（Append Only）。

示例

````markdown
## 版本 1

```entity Feature: id=login_v1
status: planned
```

## 版本 2

```entity Feature: id=login_v2
former: [[login_v1]]
status: in_progress
```
````

## 2. 结构派生 (`derived_from`)

> ⚠️ **Status**: **Deprecated / Removed**
>
> 在 Typedown 的早期演进中，我们决定移除基于原型继承的 `derived_from` 特性。
>
> **理由**:
>
> 1. **AI 赋能**: 随着 AI Agent 使大规模数据填充变得极其廉价且准确，通过复杂的继承树来节省字符的需求不再是第一优先级。
> 2. **显式优于隐式**: 显式的数据定义（Flattened Data）比深层嵌套的合并逻辑更具可读性，也更方便编译器进行静态分析。
> 3. **简化心智模型**: 移除合并策略（Merging Strategy）大大降低了用户的心智负担和实现复杂度。
>
> 目前编译器会识别该字段但不会执行任何合并操作。如果需要复用数据，建议使用 AI 工具进行显式填充或在 Model 级别进行重构。

## 3. 合并策略 (Merging Strategy)

**已移除 (Removed)**。

Typedown 目前采用 **显式定义 (Explicit Definition)** 策略。所有实体在物化后应被视为独立的、完整的快照。`former` 仅作为追溯时间线的元数据指针（Pointer），不触发任何属性合并。

---

## 4. 源码形态与物化 (Source vs. Materialized)

- **显式性**: 源码即真理。不要期待编译器在背后进行不可见的字段注入。
- **可追溯性**: 通过 `former` 链条，你可以利用工具（如 LSP 或 CLI）快速对比不同版本的差异。

---

## 5. 散敛规则

- **演变分叉 (错误)**: 一个 ID 不能成为两个不同实体的 `former`。时间线不可分裂。
- **演变收敛**: 多个旧版本可以演化为一个新版本（代表合并），但需谨慎处理语义冲突。
