import logging
from collections.abc import Generator
from contextlib import contextmanager
from enum import Enum
from typing import NamedTuple

from _typeshed import Incomplete
from pyomo.common.collections import ComponentMap as ComponentMap
from pyomo.common.collections import ComponentSet as ComponentSet
from pyomo.common.errors import ApplicationError as ApplicationError
from pyomo.common.errors import InvalidValueError as InvalidValueError
from pyomo.common.log import Preformatted as Preformatted
from pyomo.common.modeling import unique_component_name as unique_component_name
from pyomo.common.timing import HierarchicalTimer as HierarchicalTimer
from pyomo.common.timing import TicTocTimer as TicTocTimer
from pyomo.core.base import Any as Any
from pyomo.core.base import Block as Block
from pyomo.core.base import Component as Component
from pyomo.core.base import ConcreteModel as ConcreteModel
from pyomo.core.base import Constraint as Constraint
from pyomo.core.base import Expression as Expression
from pyomo.core.base import Objective as Objective
from pyomo.core.base import Param as Param
from pyomo.core.base import ParamData as ParamData
from pyomo.core.base import Reals as Reals
from pyomo.core.base import Var as Var
from pyomo.core.base import VarData as VarData
from pyomo.core.base import maximize as maximize
from pyomo.core.base import minimize as minimize
from pyomo.core.base import value as value
from pyomo.core.expr.numeric_expr import SumExpression as SumExpression
from pyomo.core.expr.numvalue import native_types as native_types
from pyomo.core.expr.visitor import identify_mutable_parameters as identify_mutable_parameters
from pyomo.core.expr.visitor import identify_variables as identify_variables
from pyomo.core.expr.visitor import replace_expressions as replace_expressions
from pyomo.core.util import prod as prod
from pyomo.opt import SolverFactory as SolverFactory
from pyomo.repn.parameterized_quadratic import (
    ParameterizedQuadraticRepnVisitor as ParameterizedQuadraticRepnVisitor,
)
from pyomo.repn.util import OrderedVarRecorder as OrderedVarRecorder
from pyomo.util.vars_from_expressions import get_vars_from_components as get_vars_from_components

PARAM_IS_CERTAIN_REL_TOL: float
PARAM_IS_CERTAIN_ABS_TOL: int
COEFF_MATCH_REL_TOL: float
COEFF_MATCH_ABS_TOL: int
ABS_CON_CHECK_FEAS_TOL: float
PRETRIANGULAR_VAR_COEFF_TOL: float
POINT_IN_UNCERTAINTY_SET_TOL: float
DR_POLISHING_PARAM_PRODUCT_ZERO_TOL: float
TIC_TOC_SOLVE_TIME_ATTR: str
DEFAULT_LOGGER_NAME: str
DEFAULT_SEPARATION_PRIORITY: int

class TimingData:
    hierarchical_timer_full_ids: Incomplete
    def __init__(self) -> None: ...
    def start_timer(self, full_identifier): ...
    def stop_timer(self, full_identifier): ...
    def get_total_time(self, full_identifier): ...
    def get_main_elapsed_time(self): ...

@contextmanager
def time_code(timing_data_obj, code_block_name, is_main_timer: bool = False) -> Generator[None]: ...
def get_main_elapsed_time(timing_data_obj): ...
def adjust_solver_time_settings(timing_data_obj, solver, config): ...
def revert_solver_max_time_adjustment(
    solver, original_max_time_setting, custom_setting_present, config
) -> None: ...

class PreformattedLogger(logging.Logger):
    def critical(self, msg, *args, **kwargs): ...
    def error(self, msg, *args, **kwargs): ...
    def warning(self, msg, *args, **kwargs): ...
    def info(self, msg, *args, **kwargs): ...
    def debug(self, msg, *args, **kwargs): ...
    def log(self, level, msg, *args, **kwargs): ...

def setup_pyros_logger(name=...): ...

class pyrosTerminationCondition(Enum):
    robust_feasible = 0
    robust_optimal = 1
    robust_infeasible = 2
    max_iter = 3
    subsolver_error = 4
    time_out = 5
    @property
    def message(self): ...

class SeparationStrategy(Enum):
    all_violations = ...
    max_violation = ...

class SolveMethod(Enum):
    local_solve = ...
    global_solve = ...

class ObjectiveType(Enum):
    worst_case = ...
    nominal = ...

def standardize_component_data(
    obj,
    valid_ctype,
    valid_cdatatype,
    ctype_validator=None,
    cdatatype_validator=None,
    allow_repeats: bool = False,
    from_iterable=None,
): ...
def check_components_descended_from_model(model, components, components_name, config) -> None: ...
def check_variables_continuous(model, vars, config) -> None: ...
def validate_model(model, config) -> None: ...

class VariablePartitioning(NamedTuple):
    first_stage_variables: Incomplete
    second_stage_variables: Incomplete
    state_variables: Incomplete

def validate_variable_partitioning(model, config): ...
def validate_uncertainty_specification(model, config) -> None: ...
def validate_separation_problem_options(model, config) -> None: ...
def validate_pyros_inputs(model, config): ...

class ModelData:
    original_model: Incomplete
    timing: Incomplete
    config: Incomplete
    separation_priority_order: Incomplete
    working_model: Incomplete
    def __init__(self, original_model, config, timing) -> None: ...
    def preprocess(self, user_var_partitioning): ...

def setup_quadratic_expression_visitor(
    wrt, subexpression_cache=None, var_map=None, var_order=None, sorter=None
): ...

class BoundType:
    LOWER: str
    EQ: str
    UPPER: str

def get_var_bound_pairs(var): ...
def determine_certain_and_uncertain_bound(
    domain_bound, declared_bound, uncertain_params, bound_type
): ...

BoundTriple: Incomplete

def rearrange_bound_pair_to_triple(lower_bound, upper_bound): ...
def get_var_certain_uncertain_bounds(var, uncertain_params): ...
def get_effective_var_partitioning(model_data): ...
def add_effective_var_partitioning(model_data) -> None: ...
def create_bound_constraint_expr(expr, bound, bound_type, standardize: bool = True): ...
def remove_var_declared_bound(var, bound_type) -> None: ...
def remove_all_var_bounds(var) -> None: ...
def turn_nonadjustable_var_bounds_to_constraints(model_data) -> None: ...
def turn_adjustable_var_bounds_to_constraints(model_data) -> None: ...
def replace_vars_with_params(block, var_to_param_map) -> None: ...
def setup_working_model(model_data, user_var_partitioning) -> None: ...
def standardize_inequality_constraints(model_data) -> None: ...
def standardize_equality_constraints(model_data) -> None: ...
def get_summands(expr): ...
def declare_objective_expressions(working_model, objective, sense=...) -> None: ...
def standardize_active_objective(model_data) -> None: ...
def get_all_nonadjustable_variables(working_model): ...
def get_all_first_stage_eq_cons(working_model): ...
def get_all_adjustable_variables(working_model): ...
def generate_all_decision_rule_var_data_objects(
    working_blk,
) -> Generator[Incomplete, Incomplete]: ...
def generate_all_decision_rule_eqns(working_blk) -> Generator[Incomplete, Incomplete]: ...
def get_dr_expression(working_blk, second_stage_var): ...
def get_dr_var_to_monomial_map(working_blk): ...
def check_time_limit_reached(timing_data, config): ...
def reformulate_state_var_independent_eq_cons(model_data): ...
def get_effective_uncertain_dimensions(model_data): ...
def preprocess_model_data(model_data, user_var_partitioning): ...
def log_model_statistics(model_data) -> None: ...
def add_decision_rule_variables(model_data) -> None: ...
def add_decision_rule_constraints(model_data) -> None: ...
def enforce_dr_degree(working_blk, config, degree) -> None: ...
def load_final_solution(model_data, master_soln, original_user_var_partitioning): ...
def call_solver(model, solver, config, timing_obj, timer_name, err_msg): ...

class IterationLogRecord:
    iteration: Incomplete
    objective: Incomplete
    first_stage_var_shift: Incomplete
    second_stage_var_shift: Incomplete
    dr_var_shift: Incomplete
    dr_polishing_success: Incomplete
    num_violated_cons: Incomplete
    all_sep_problems_solved: Incomplete
    global_separation: Incomplete
    max_violation: Incomplete
    elapsed_time: Incomplete
    def __init__(
        self,
        iteration,
        objective,
        first_stage_var_shift,
        second_stage_var_shift,
        dr_var_shift,
        dr_polishing_success,
        num_violated_cons,
        all_sep_problems_solved,
        global_separation,
        max_violation,
        elapsed_time,
    ) -> None: ...
    def get_log_str(self): ...
    def log(self, log_func, **log_func_kwargs) -> None: ...
    @staticmethod
    def get_log_header_str(): ...
    @staticmethod
    def log_header(log_func, with_rules: bool = True, **log_func_kwargs) -> None: ...
    @staticmethod
    def log_header_rule(log_func, fillchar: str = '-', **log_func_kwargs) -> None: ...

def copy_docstring(source_func): ...
