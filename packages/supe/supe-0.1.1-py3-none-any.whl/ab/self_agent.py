"""Formal Self (agent) class implementation for AB.

This module defines the formal ``Self`` class representing autonomous
cognitive agents within the AB system. Each Self has:

- A name and role
- A list of subscribed buffer names
- A ``think(card)`` method that returns (suggestion, strength)
- The ability to recursively call other selves

Concrete implementations (PlannerSelf, ArchitectSelf, ExecutorSelf)
demonstrate specialization patterns.
"""

from __future__ import annotations

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import Any, Callable, Dict, List, Optional, Tuple, TYPE_CHECKING

if TYPE_CHECKING:
    from .abdb import ABMemory
    from .models import Card


@dataclass
class Proposal:
    """A proposal generated by a Self's think() method.

    Attributes:
        suggestion: The suggested action or output text.
        strength: A numeric weight (higher = more confident/important).
        metadata: Optional additional context or reasoning.
    """

    suggestion: str
    strength: float
    metadata: Optional[Dict[str, Any]] = None


class Self(ABC):
    """Abstract base class for cognitive agents (selves).

    Each Self receives cards (typically awareness cards) via its
    ``think()`` method and produces proposals with a suggestion and
    strength score. Selves can subscribe to specific buffers to
    filter what information they process.
    """

    def __init__(
        self,
        name: str,
        role: Optional[str] = None,
        subscribed_buffers: Optional[List[str]] = None,
    ) -> None:
        """Initialize a Self.

        Args:
            name: Unique name for this self.
            role: Optional role description (e.g., "planner", "coder").
            subscribed_buffers: List of buffer names this self is
                interested in. If None, processes all buffers.
        """
        self.name = name
        self.role = role
        self.subscribed_buffers = subscribed_buffers or []
        self._memory: Optional["ABMemory"] = None

    def bind_memory(self, memory: "ABMemory") -> None:
        """Bind an ABMemory instance for database access."""
        self._memory = memory

    def filter_buffers(self, card: "Card") -> List:
        """Filter card buffers to only those this self subscribes to.

        If subscribed_buffers is empty, returns all buffers.
        """
        if not self.subscribed_buffers:
            return list(card.buffers)
        return [b for b in card.buffers if b.name in self.subscribed_buffers]

    @abstractmethod
    def think(self, card: "Card") -> Proposal:
        """Process a card and generate a proposal.

        Args:
            card: The input card (typically an awareness card).

        Returns:
            A Proposal with suggestion text and strength score.
        """
        pass

    def call_subself(
        self,
        target_self: "Self",
        card: "Card",
    ) -> Proposal:
        """Recursively invoke another self's think() method.

        This enables selves to delegate or collaborate with other selves.

        Args:
            target_self: The Self to invoke.
            card: The card to pass to the target self.

        Returns:
            The proposal from the target self.
        """
        # Ensure target has same memory binding
        if self._memory is not None and target_self._memory is None:
            target_self.bind_memory(self._memory)
        return target_self.think(card)


# ---------------------------------------------------------------------------
# Concrete Self implementations
# ---------------------------------------------------------------------------


class PlannerSelf(Self):
    """A self specialized in planning and structure analysis.

    The planner evaluates cards for structure, dependencies, and
    strategic importance.
    """

    def __init__(
        self,
        name: str = "planner",
        subscribed_buffers: Optional[List[str]] = None,
    ) -> None:
        super().__init__(
            name=name,
            role="planner",
            subscribed_buffers=subscribed_buffers or ["prompt", "context", "tasks"],
        )

    def think(self, card: "Card") -> Proposal:
        """Analyze card for planning and strategy."""
        buffers = self.filter_buffers(card)

        # Extract text from buffers
        texts = []
        for buf in buffers:
            try:
                texts.append(buf.payload.decode("utf-8", errors="ignore"))
            except Exception:
                pass

        combined = " ".join(texts)

        # Simple heuristic: longer context = more planning needed
        strength = min(len(combined) / 100.0, 10.0)

        # Generate planning-oriented suggestion
        if "task" in combined.lower() or "plan" in combined.lower():
            suggestion = f"[Planner] Identified planning context. Recommend structured approach."
            strength += 2.0
        else:
            suggestion = f"[Planner] General context detected. Low planning priority."

        return Proposal(
            suggestion=suggestion,
            strength=strength,
            metadata={"buffer_count": len(buffers), "text_length": len(combined)},
        )


class ArchitectSelf(Self):
    """A self specialized in design and architecture evaluation.

    The architect focuses on structural patterns, dependencies, and
    system design.
    """

    def __init__(
        self,
        name: str = "architect",
        subscribed_buffers: Optional[List[str]] = None,
    ) -> None:
        super().__init__(
            name=name,
            role="architect",
            subscribed_buffers=subscribed_buffers or ["files", "state", "context"],
        )

    def think(self, card: "Card") -> Proposal:
        """Analyze card for architecture and design patterns."""
        buffers = self.filter_buffers(card)

        texts = []
        for buf in buffers:
            try:
                texts.append(buf.payload.decode("utf-8", errors="ignore"))
            except Exception:
                pass

        combined = " ".join(texts)

        # Look for architecture-related keywords
        arch_keywords = ["class", "module", "component", "interface", "api", "schema"]
        keyword_count = sum(1 for kw in arch_keywords if kw in combined.lower())

        strength = keyword_count * 1.5

        if keyword_count > 2:
            suggestion = f"[Architect] Strong architectural patterns detected. Design review recommended."
        else:
            suggestion = f"[Architect] Limited architectural context. Low design priority."

        return Proposal(
            suggestion=suggestion,
            strength=strength,
            metadata={"keyword_matches": keyword_count},
        )


class ExecutorSelf(Self):
    """A self specialized in action execution and task completion.

    The executor focuses on immediate actions and concrete steps.
    """

    def __init__(
        self,
        name: str = "executor",
        subscribed_buffers: Optional[List[str]] = None,
    ) -> None:
        super().__init__(
            name=name,
            role="executor",
            subscribed_buffers=subscribed_buffers or ["prompt", "previous_output"],
        )

    def think(self, card: "Card") -> Proposal:
        """Analyze card for actionable items."""
        buffers = self.filter_buffers(card)

        texts = []
        for buf in buffers:
            try:
                texts.append(buf.payload.decode("utf-8", errors="ignore"))
            except Exception:
                pass

        combined = " ".join(texts)

        # Look for action-oriented keywords
        action_keywords = ["do", "run", "execute", "create", "update", "delete", "fix"]
        action_count = sum(1 for kw in action_keywords if kw in combined.lower())

        strength = action_count * 2.0

        if action_count > 0:
            suggestion = f"[Executor] Action items detected ({action_count}). Ready to execute."
            strength += 3.0
        else:
            suggestion = f"[Executor] No immediate actions detected."

        return Proposal(
            suggestion=suggestion,
            strength=strength,
            metadata={"action_count": action_count},
        )


# ---------------------------------------------------------------------------
# Self registry for dynamic self management
# ---------------------------------------------------------------------------


class SelfRegistry:
    """Registry for managing selves dynamically."""

    def __init__(self) -> None:
        self._selves: Dict[str, Self] = {}

    def register(self, self_instance: Self) -> None:
        """Register a self instance."""
        self._selves[self_instance.name] = self_instance

    def get(self, name: str) -> Optional[Self]:
        """Get a self by name."""
        return self._selves.get(name)

    def list_selves(self) -> List[str]:
        """Return list of registered self names."""
        return list(self._selves.keys())

    def think_all(self, card: "Card") -> List[Proposal]:
        """Have all registered selves think about a card.

        Returns:
            List of proposals from all selves, sorted by strength descending.
        """
        proposals = []
        for self_instance in self._selves.values():
            proposal = self_instance.think(card)
            proposals.append(proposal)
        proposals.sort(key=lambda p: p.strength, reverse=True)
        return proposals


# Global registry
self_registry = SelfRegistry()
