"""API Wrapper Tools for Box_2025_0

DO NOT EDIT THIS MODULE DIRECTLY.

THIS MODULE WAS AUTO-GENERATED BY TRANSPILING THE API WRAPPER TOOL JSON DEFINITIONS
IN THE ../wrapper_tools DIRECTORY INTO PYTHON CODE. ANY CHANGES TO THIS MODULE WILL
BE OVERWRITTEN BY THE TRANSPILER.
"""

from typing import Annotated, Any

import httpx
from arcade_tdk import ToolContext, tool
from arcade_tdk.auth import OAuth2


def remove_none_values(data: dict[str, Any]) -> dict[str, Any]:
    return {k: v for k, v in data.items() if v is not None}


@tool(requires_auth=OAuth2(id="box"))
async def list_box_doc_templates(
    context: ToolContext,
    pagination_start_marker: Annotated[
        str | None,
        "Defines the starting position for pagination of results. Requires `usemarker` to be set to `true`.",  # noqa: E501
    ] = None,
    max_items_per_page: Annotated[
        int | None,
        "Specify the maximum number of Box Doc Gen templates to return in a single page.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_docgen_templates_v2025.0'."]:
    """Retrieve Box Doc Gen templates the user collaborates on.

    Fetches a list of Box Doc Gen templates where the user is a collaborator. Useful for managing or accessing document templates in Box."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/docgen_templates",
            params=remove_none_values({
                "marker": pagination_start_marker,
                "limit": max_items_per_page,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2025.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def unmark_box_doc_template(
    context: ToolContext,
    file_id_to_unmark: Annotated[
        str, "The ID of the file that will no longer be marked as a Box Doc Gen template."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'delete_docgen_templates_id_v2025.0'."
]:
    """Unmarks a file as a Box Doc Gen template.

    This tool should be called to remove the designation of a Box file as a Doc Gen template. It confirms whether the unmarking was successful."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/docgen_templates/{template_id}".format(  # noqa: UP032
                template_id=file_id_to_unmark
            ),
            method="DELETE",
            headers=remove_none_values({
                "box-version": "2025.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_box_docgen_template_details(
    context: ToolContext,
    box_docgen_template_id: Annotated[
        str, "The ID of the Box Doc Gen template to retrieve details for."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_docgen_templates_id_v2025.0'."]:
    """Fetch details of a specific Box Doc Gen template.

    Call this tool to retrieve detailed information about a specific template from Box Doc Gen using its template ID."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/docgen_templates/{template_id}".format(  # noqa: UP032
                template_id=box_docgen_template_id
            ),
            method="GET",
            headers=remove_none_values({
                "box-version": "2025.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def list_box_docgen_template_tags(
    context: ToolContext,
    template_id: Annotated[
        str, "The unique identifier for the Box Doc Gen template whose tags you want to retrieve."
    ],
    template_version_id: Annotated[
        str | None, "The ID of the specific version of the template to retrieve tags from."
    ] = None,
    pagination_start_marker: Annotated[
        str | None,
        "Defines the starting position for results when using marker-based pagination. Must have `usemarker` set to `true`.",  # noqa: E501
    ] = None,
    maximum_items_per_page: Annotated[
        int | None,
        "Specifies the maximum number of tags to return per page from the Box Doc Gen template.",
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get_docgen_templates_id_tags_v2025.0'."
]:
    """Retrieve tags from a specific Box Doc Gen template.

    Call this tool to list all tags used in a specific Box Doc Gen template. Use it when you need to access or manage the tags associated with a given template."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/docgen_templates/{template_id}/tags".format(  # noqa: UP032
                template_id=template_id
            ),
            params=remove_none_values({
                "template_version_id": template_version_id,
                "marker": pagination_start_marker,
                "limit": maximum_items_per_page,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2025.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_box_docgen_job_details(
    context: ToolContext,
    box_doc_gen_job_id: Annotated[
        str, "The unique identifier for the Box Doc Gen job you want details for."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_docgen_jobs_id_v2025.0'."]:
    """Retrieve details of a Box Doc Gen job using its ID.

    This tool fetches detailed information about a specific Box Doc Gen job, identified by its job ID. It should be called when details about a particular document generation task in Box are needed."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/docgen_jobs/{job_id}".format(job_id=box_doc_gen_job_id),  # noqa: UP032
            method="GET",
            headers=remove_none_values({
                "box-version": "2025.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def list_box_docgen_jobs(
    context: ToolContext,
    pagination_marker: Annotated[
        str | None,
        "Starting position marker for paginating results. Requires 'usemarker' set to true.",
    ] = None,
    maximum_items_per_page: Annotated[
        int | None,
        "The maximum number of items to return per page. Specify an integer value to set the limit for pagination.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_docgen_jobs_v2025.0'."]:
    """Retrieves a list of Box Doc Gen jobs for a user.

    Use this tool to get all the Box Doc Gen job details associated with a user."""
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/docgen_jobs",
            params=remove_none_values({
                "marker": pagination_marker,
                "limit": maximum_items_per_page,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2025.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def list_template_jobs(
    context: ToolContext,
    template_identifier: Annotated[
        str, "The unique ID of the template for which jobs need to be retrieved."
    ],
    pagination_start_marker: Annotated[
        str | None,
        "Defines the starting position for pagination. Requires 'usemarker' to be set to true.",
    ] = None,
    max_items_per_page: Annotated[
        int | None, "The maximum number of items to return per page from the list of jobs."
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get_docgen_template_jobs_id_v2025.0'."
]:
    """Retrieve jobs associated with a specific document template.

    Use this tool to get a list of all user jobs linked to a particular document generation template by providing the template ID."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/docgen_template_jobs/{template_id}".format(  # noqa: UP032
                template_id=template_identifier
            ),
            params=remove_none_values({
                "marker": pagination_start_marker,
                "limit": max_items_per_page,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2025.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def list_docgen_batch_jobs(
    context: ToolContext,
    box_doc_gen_batch_id: Annotated[
        str, "The identifier for a Box Doc Gen batch used to retrieve specific job details."
    ],
    pagination_marker: Annotated[
        str | None,
        "The position marker to start returning results. Use for marker-based pagination. Requires `usemarker` set to `true`.",  # noqa: E501
    ] = None,
    maximum_items_per_page: Annotated[
        int | None,
        "The maximum number of items to return per page when retrieving Box Doc Gen jobs.",
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get_docgen_batch_jobs_id_v2025.0'."
]:
    """Retrieve details of Box Doc Gen jobs in a batch.

    Use this tool to get a list of Box Doc Gen jobs contained within a specific batch using the batch ID."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/docgen_batch_jobs/{batch_id}".format(  # noqa: UP032
                batch_id=box_doc_gen_batch_id
            ),
            params=remove_none_values({
                "marker": pagination_marker,
                "limit": maximum_items_per_page,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2025.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_box_hubs(
    context: ToolContext,
    hub_search_query: Annotated[
        str | None,
        "The string to search for specific Box Hubs. Use keywords to refine search results.",
    ] = None,
    hub_scope: Annotated[
        str | None,
        "Specifies which Box Hubs to retrieve. Options: `editable`, `view_only`, `all`. Default is `all`.",  # noqa: E501
    ] = None,
    sort_results_by: Annotated[
        str | None,
        "Field to sort Box Hubs by: `name`, `updated_at`, `last_accessed_at`, `view_count`, `relevance` (default: `relevance`).",  # noqa: E501
    ] = None,
    sort_direction: Annotated[
        str | None, "Specify the sort order: 'ASC' for ascending or 'DESC' for descending."
    ] = None,
    pagination_start_marker: Annotated[
        str | None,
        "Defines the position marker to begin returning results, used for marker-based pagination.",
    ] = None,
    max_items_per_page: Annotated[
        int | None, "The maximum number of Box Hubs to return per page. Use for pagination control."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_hubs_v2025.0'."]:
    """Retrieve all Box Hubs for the user.

    This tool retrieves all the Box Hubs associated with the requesting user. It should be called when there's a need to list or display the user's Box Hubs."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/hubs",
            params=remove_none_values({
                "query": hub_search_query,
                "scope": hub_scope,
                "sort": sort_results_by,
                "direction": sort_direction,
                "marker": pagination_start_marker,
                "limit": max_items_per_page,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2025.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_enterprise_box_hubs(
    context: ToolContext,
    search_query_for_box_hubs: Annotated[
        str | None, "The search query string to find specific Box Hubs within an enterprise."
    ] = None,
    sort_results_by: Annotated[
        str | None,
        "The field to sort the Box Hubs by. Options: 'name', 'updated_at', 'last_accessed_at', 'view_count', 'relevance'. Default is 'relevance'.",  # noqa: E501
    ] = None,
    sort_direction: Annotated[
        str | None,
        "The direction to sort results: alphabetical ascending ('ASC') or descending ('DESC').",
    ] = None,
    pagination_marker: Annotated[
        str | None,
        "The starting position marker for returning results, used in marker-based pagination.",
    ] = None,
    max_items_per_page: Annotated[
        int | None,
        "The maximum number of Box Hubs to return per page. This controls the page size for the result set.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_enterprise_hubs_v2025.0'."]:
    """Retrieve Box Hubs for an enterprise.

    This tool retrieves all Box Hubs for a specified enterprise. It should be used by admins or Hub Co-admins with GCM scope to get information about the enterprise's Box Hubs."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/enterprise_hubs",
            params=remove_none_values({
                "query": search_query_for_box_hubs,
                "sort": sort_results_by,
                "direction": sort_direction,
                "marker": pagination_marker,
                "limit": max_items_per_page,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2025.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def retrieve_box_hub_details(
    context: ToolContext,
    box_hub_identifier: Annotated[
        str, "The unique ID representing a Box Hub, found in the URL when visiting the hub."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_hubs_id_v2025.0'."]:
    """Fetch Box Hub details using its ID.

    Use this tool to obtain detailed information about a specific Box Hub by providing its unique identifier."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/hubs/{hub_id}".format(hub_id=box_hub_identifier),  # noqa: UP032
            method="GET",
            headers=remove_none_values({
                "box-version": "2025.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def delete_box_hub(
    context: ToolContext,
    box_hub_unique_id: Annotated[
        str, "The unique identifier for a Box Hub, obtainable from the hub's URL."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'delete_hubs_id_v2025.0'."]:
    """Delete a specific Box Hub using its ID.

    This tool is used to delete a specific Box Hub by providing its unique hub ID. It should be called when a user wants to remove a particular hub from the Box service."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/hubs/{hub_id}".format(hub_id=box_hub_unique_id),  # noqa: UP032
            method="DELETE",
            headers=remove_none_values({
                "box-version": "2025.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def retrieve_box_hub_collaborations(
    context: ToolContext,
    hub_identifier: Annotated[
        str, "The unique string identifier for a Box Hub, found in the Hub's URL."
    ],
    pagination_marker: Annotated[
        str | None,
        "The position marker to begin returning results, used for marker-based pagination. Ensure `usemarker` is set to `true`.",  # noqa: E501
    ] = None,
    max_items_per_page: Annotated[
        int | None,
        "The maximum number of collaboration items to return per page. Determines the page size for results.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_hub_collaborations_v2025.0'."]:
    """Retrieves collaborations for a Box Hub.

    This tool fetches all the collaborations associated with a given Box Hub. It should be called when there is a need to access or review the collaborative associations within a Box Hub."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/hub_collaborations",
            params=remove_none_values({
                "hub_id": hub_identifier,
                "marker": pagination_marker,
                "limit": max_items_per_page,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2025.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_box_hub_collaboration_details(
    context: ToolContext,
    hub_collaboration_id: Annotated[
        str,
        "The unique identifier for the specific Box Hub collaboration you want to retrieve details for.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get_hub_collaborations_id_v2025.0'."
]:
    """Retrieve details for a Box Hub collaboration by ID.

    Use this tool to obtain information about a specific Box Hub collaboration by providing the collaboration ID."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/hub_collaborations/{hub_collaboration_id}".format(  # noqa: UP032
                hub_collaboration_id=hub_collaboration_id
            ),
            method="GET",
            headers=remove_none_values({
                "box-version": "2025.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def delete_box_hub_collaboration(
    context: ToolContext,
    hub_collaboration_identifier: Annotated[
        str, "The unique identifier for the Box Hub collaboration to be deleted."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'delete_hub_collaborations_id_v2025.0'."
]:
    """Remove a specific Box Hub collaboration.

    Use this tool to delete a specific collaboration from a Box Hub by providing the collaboration ID. It should be called when you need to remove a user's collaboration access."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/hub_collaborations/{hub_collaboration_id}".format(  # noqa: UP032
                hub_collaboration_id=hub_collaboration_identifier
            ),
            method="DELETE",
            headers=remove_none_values({
                "box-version": "2025.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def retrieve_box_hub_items(
    context: ToolContext,
    hub_identifier: Annotated[
        str, "The unique ID representing a Box Hub, retrievable from the hub's URL."
    ],
    pagination_start_marker: Annotated[
        str | None,
        "Defines the starting position for results when using marker-based pagination. Requires `usemarker` to be `true`.",  # noqa: E501
    ] = None,
    maximum_items_per_page: Annotated[
        int | None,
        "The maximum number of items to return per page from a Box Hub. Specify an integer value to limit the number of items in each result set.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_hub_items_v2025.0'."]:
    """Fetch all items from a specified Box Hub.

    Use this tool to retrieve all items associated with a particular Box Hub. This is useful for accessing and managing the contents of a hub."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/hub_items",
            params=remove_none_values({
                "hub_id": hub_identifier,
                "marker": pagination_start_marker,
                "limit": maximum_items_per_page,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2025.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_enterprise_shield_lists(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_shield_lists_v2025.0'."]:
    """Retrieve all shield lists for the enterprise.

    This tool retrieves all security shield lists available within an enterprise, providing information on the protection settings implemented."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/shield_lists",
            method="GET",
            headers=remove_none_values({
                "box-version": "2025.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def retrieve_shield_list_by_id(
    context: ToolContext,
    shield_list_identifier: Annotated[
        str,
        "The unique identifier for a shield list. Retrieve this ID by calling the endpoint that lists all shield lists for your enterprise.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_shield_lists_id_v2025.0'."]:
    """Retrieve details of a specific shield list by ID.

    Use this tool to get information about a shield list using its unique ID. It's called to access details of specific shield lists when needed."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/shield_lists/{shield_list_id}".format(  # noqa: UP032
                shield_list_id=shield_list_identifier
            ),
            method="GET",
            headers=remove_none_values({
                "box-version": "2025.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def delete_shield_list_by_id(
    context: ToolContext,
    shield_list_id: Annotated[
        str,
        "The unique identifier for the shield list to be deleted. Obtainable from the response of fetching all shield lists for the enterprise.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'delete_shield_lists_id_v2025.0'."]:
    """Delete a shield list using its ID.

    Use this tool to delete a specific shield list by providing its ID. Ideal for managing and updating list configurations when a list is no longer needed."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/shield_lists/{shield_list_id}".format(  # noqa: UP032
                shield_list_id=shield_list_id
            ),
            method="DELETE",
            headers=remove_none_values({
                "box-version": "2025.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def retrieve_enterprise_archives(
    context: ToolContext,
    max_items_per_page: Annotated[
        int | None, "The maximum number of archive items to return per page when retrieving data."
    ] = None,
    pagination_start_marker: Annotated[
        str | None,
        "Defines the position marker to start returning results for pagination in archive retrieval.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_archives_v2025.0'."]:
    """Retrieve archives for an enterprise from Box.

    This tool retrieves archives for an enterprise using Box's API. It should be called when information about stored archives is needed."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/archives",
            params=remove_none_values({
                "limit": max_items_per_page,
                "marker": pagination_start_marker,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2025.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def delete_archive(
    context: ToolContext,
    archive_id: Annotated[
        str,
        "The unique identifier of the archive to be permanently deleted. This ID is required for the deletion process.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'delete_archives_id_v2025.0'."]:
    """Permanently delete an archive by ID.

    Use this tool to permanently delete an archive using its unique ID. This action cannot be undone."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/archives/{archive_id}".format(archive_id=archive_id),  # noqa: UP032
            method="DELETE",
            headers=remove_none_values({
                "box-version": "2025.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def retrieve_file_details(
    context: ToolContext,
    file_identifier: Annotated[
        str,
        "The unique identifier for a file, found in the URL of the file in the web application. Example: from `https://*.app.box.com/files/123`, use `123`.",  # noqa: E501
    ],
    included_file_attributes: Annotated[
        list[str] | None,
        "Specify attributes to include in the response as a list of strings. Additional attributes replace standard fields unless explicitly included. Metadata can be queried using 'metadata' with scope and key.",  # noqa: E501
    ] = None,
    etag_conditional_retrieval: Annotated[
        str | None,
        "Provide the last observed etag value to retrieve the file only if it has changed. Returns a 304 status if unchanged.",  # noqa: E501
    ] = None,
    shared_link_with_optional_password: Annotated[
        str | None,
        "Provide the shared link URL for the item. Use the format 'shared_link=[link]' or 'shared_link=[link]&shared_link_password=[password]' if a password is required.",  # noqa: E501
    ] = None,
    file_representations_request: Annotated[
        str | None,
        "Request specific representations of a file using hints, e.g., '[jpg?dimensions=32x32][jpg?dimensions=64x64]'.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_files_id'."]:
    """Fetch details about a specific file using its ID.

    Use this tool to get information about a file by providing its ID. It retrieves detailed metadata and properties of the file."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/files/{file_id}".format(file_id=file_identifier),  # noqa: UP032
            params=remove_none_values({"fields": included_file_attributes}),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "if-none-match": etag_conditional_retrieval,
                "boxapi": shared_link_with_optional_password,
                "x-rep-hints": file_representations_request,
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def delete_file_from_box(
    context: ToolContext,
    file_identifier: Annotated[
        str,
        "The unique ID representing a file in Box. Found in the URL when viewing a file: https://*.app.box.com/files/{file_id}.",
    ],
    ensure_no_recent_changes_etag: Annotated[
        str | None,
        "Pass the file's last observed etag value to ensure it hasn't changed before deletion. If the etag has changed, the operation will fail.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'delete_files_id'."]:
    """Delete a file from Box or move it to trash.

    This tool deletes a file from Box. Depending on enterprise settings, the file is either permanently deleted or moved to the trash. It should be called when a user requests to remove a file from their Box storage."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/files/{file_id}".format(file_id=file_identifier),  # noqa: UP032
            method="DELETE",
            headers=remove_none_values({
                "box-version": "2024.0",
                "if-match": ensure_no_recent_changes_etag,
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_file_app_associations(
    context: ToolContext,
    file_identifier: Annotated[
        str, "The unique ID representing a file in Box. Can be obtained from the file URL."
    ],
    items_per_page_limit: Annotated[
        int | None, "The maximum number of items to return per page."
    ] = None,
    pagination_marker: Annotated[
        str | None,
        "Defines the position marker for pagination. Required if using marker-based pagination. Ensure `usemarker` is set to `true`.",  # noqa: E501
    ] = None,
    filter_by_application_type: Annotated[
        str | None,
        "Specify the application type to filter and return only app items related to it.",
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get_files_id_app_item_associations'."
]:
    """Retrieve app items associated with a specific file.

    This tool retrieves all app items associated with a specified file, including those linked to its ancestors. It reveals type/ids even if the user lacks View permission on the app item, assuming the user has access to the file."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/files/{file_id}/app_item_associations".format(  # noqa: UP032
                file_id=file_identifier
            ),
            params=remove_none_values({
                "limit": items_per_page_limit,
                "marker": pagination_marker,
                "application_type": filter_by_application_type,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def download_file_content(
    context: ToolContext,
    file_identifier: Annotated[
        str,
        "The unique identifier for the file to download. Obtainable from the file's URL in the web application.",  # noqa: E501
    ],
    file_version_to_download: Annotated[
        str | None, "The specific version of the file to retrieve in binary format."
    ] = None,
    optional_access_token: Annotated[
        str | None,
        "A string for an optional access token to pre-authenticate the file download request. Ensure it's scoped for read access only.",  # noqa: E501
    ] = None,
    download_byte_range: Annotated[
        str | None,
        "Specify the byte range for the content to download in the format `bytes={start_byte}-{end_byte}` to define which section of the file to retrieve.",  # noqa: E501
    ] = None,
    shared_link_with_optional_password: Annotated[
        str | None,
        "Provide the shared link URL of the item. Include a password if required, using the format `shared_link=[link]` or `shared_link=[link]&shared_link_password=[password]`. This allows access to files not explicitly shared with the user.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_files_id_content'."]:
    """Retrieve the binary content of a specified file.

    This tool is used to download the contents of a file from a given file ID. It should be called when access to the file data in binary format is required."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/files/{file_id}/content".format(file_id=file_identifier),  # noqa: UP032
            params=remove_none_values({
                "version": file_version_to_download,
                "access_token": optional_access_token,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "range": download_byte_range,
                "boxapi": shared_link_with_optional_password,
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_upload_session_details(
    context: ToolContext,
    upload_session_id: Annotated[str, "The ID of the upload session to retrieve information for."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_files_upload_sessions_id'."]:
    """Retrieve details of a specific file upload session.

    This tool retrieves information about a file upload session using the session ID. It is useful for checking the status or details of ongoing or past file uploads."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/files/upload_sessions/{upload_session_id}".format(  # noqa: UP032
                upload_session_id=upload_session_id
            ),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def abort_upload_session(
    context: ToolContext,
    upload_session_id: Annotated[
        str,
        "The unique identifier of the upload session to be aborted. This ID is required to specify which upload session should be cancelled and its data discarded.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'delete_files_upload_sessions_id'."]:
    """Abort an upload session and discard all uploaded data.

    Use this tool to abort an ongoing upload session and discard all uploaded data. This action is irreversible, so it should be called when the user wants to cancel an upload session."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/files/upload_sessions/{upload_session_id}".format(  # noqa: UP032
                upload_session_id=upload_session_id
            ),
            method="DELETE",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_uploaded_chunks_list(
    context: ToolContext,
    upload_session_identifier: Annotated[
        str,
        "The unique identifier for the upload session. Use this to retrieve the list of uploaded chunks.",  # noqa: E501
    ],
    response_offset: Annotated[
        int | None,
        "The starting position of the response item list. Must not exceed 10000, as higher values will result in a 400 error.",  # noqa: E501
    ] = None,
    max_items_per_page: Annotated[
        int | None, "The maximum number of uploaded chunks to return per page in the response."
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get_files_upload_sessions_id_parts'."
]:
    """Retrieve the list of uploaded chunks for an upload session.

    Use this tool to get a list of file chunks that have been uploaded to a specific upload session. This is helpful for tracking upload progress and ensuring all parts are correctly uploaded."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/files/upload_sessions/{upload_session_id}/parts".format(  # noqa: UP032
                upload_session_id=upload_session_identifier
            ),
            params=remove_none_values({"offset": response_offset, "limit": max_items_per_page}),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def retrieve_file_thumbnail(
    context: ToolContext,
    file_identifier: Annotated[
        str,
        "The unique identifier for the file. You can find this ID in the file URL on the Box web application.",  # noqa: E501
    ],
    thumbnail_file_format: Annotated[
        str, "Specify the file format for the thumbnail, either 'png' or 'jpg'."
    ],
    minimum_thumbnail_height: Annotated[
        int | None,
        "Specify the minimum height for the thumbnail image required. Accepts an integer value.",
    ] = None,
    minimum_thumbnail_width: Annotated[
        int | None, "The minimum width of the thumbnail to be retrieved. Specify an integer value."
    ] = None,
    maximum_thumbnail_height: Annotated[
        int | None,
        "The maximum height of the thumbnail in pixels. Valid values depend on the specified format. For .png, maximum is 256; for .jpg, maximum is 320.",  # noqa: E501
    ] = None,
    maximum_thumbnail_width: Annotated[
        int | None,
        "The maximum width for the thumbnail image in pixels. Define the width according to the available sizes in .png or .jpg formats.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_files_id_thumbnail_id'."]:
    """Retrieves a thumbnail image of a specified file.

    This tool retrieves a thumbnail of a file in various sizes, such as 32x32, 64x64, 128x128, and 256x256 in .png format, or 32x32, 160x160, and 320x320 in .jpg format. Use this tool to get a smaller image representation of images and videos."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/files/{file_id}/thumbnail.{extension}".format(  # noqa: UP032
                file_id=file_identifier, extension=thumbnail_file_format
            ),
            params=remove_none_values({
                "min_height": minimum_thumbnail_height,
                "min_width": minimum_thumbnail_width,
                "max_height": maximum_thumbnail_height,
                "max_width": maximum_thumbnail_width,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_file_collaborations(
    context: ToolContext,
    file_identifier: Annotated[
        str,
        "The unique file ID needed to retrieve collaborations. Obtainable from the file's URL in the web app.",  # noqa: E501
    ],
    requested_fields: Annotated[
        list[str] | None,
        "A list of specific attributes to include in the response. These fields are not typically included and override the standard response fields.",  # noqa: E501
    ] = None,
    max_items_per_page: Annotated[
        int | None,
        "The maximum number of collaboration items to return per page in the response. Useful for paginating results.",  # noqa: E501
    ] = None,
    pagination_start_marker: Annotated[
        str | None,
        "Specifies the position marker for starting result pagination. Requires 'usemarker' set to 'true'.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_files_id_collaborations'."]:
    """Retrieve collaborations for a specific file.

    Fetches pending and active collaborations for a file, showing all users with access or invitations."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/files/{file_id}/collaborations".format(  # noqa: UP032
                file_id=file_identifier
            ),
            params=remove_none_values({
                "fields": requested_fields,
                "limit": max_items_per_page,
                "marker": pagination_start_marker,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_file_comments(
    context: ToolContext,
    file_identifier: Annotated[
        str,
        "The unique file ID, found in the Box web app URL, e.g., for `https://*.app.box.com/files/123`, the ID is `123`.",  # noqa: E501
    ],
    include_fields_in_response: Annotated[
        list[str] | None,
        "List of attributes to include in the response. Only specified fields and mini representation are returned.",  # noqa: E501
    ] = None,
    maximum_items_per_page: Annotated[
        int | None, "The maximum number of comments to return per page for the specified file."
    ] = None,
    response_start_offset: Annotated[
        int | None,
        "The starting point for comments retrieval. Must not exceed 10000, or a 400 error occurs.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_files_id_comments'."]:
    """Retrieve comments for a specific file.

    This tool retrieves a list of comments associated with a given file. It should be called when you need to access comments on a file identified by its ID."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/files/{file_id}/comments".format(file_id=file_identifier),  # noqa: UP032
            params=remove_none_values({
                "fields": include_fields_in_response,
                "limit": maximum_items_per_page,
                "offset": response_start_offset,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_file_tasks(
    context: ToolContext,
    file_identifier: Annotated[
        str, "The unique identifier for a file, found in the file URL on the Box web application."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_files_id_tasks'."]:
    """Retrieve all tasks associated with a specific file.

    This tool retrieves all tasks linked to a given file using its file ID. It's used when there is a need to fetch task details for file management or task tracking purposes."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/files/{file_id}/tasks".format(file_id=file_identifier),  # noqa: UP032
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def retrieve_trashed_file(
    context: ToolContext,
    file_identifier: Annotated[
        str,
        "The unique identifier of a file moved to trash, obtained from the file's URL in the web application.",  # noqa: E501
    ],
    include_attributes_in_response: Annotated[
        list[str] | None,
        "A list of attributes to include in the response. Only specified fields and mini representation fields are returned.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_files_id_trash'."]:
    """Retrieve a file that has been moved to the trash.

    This tool retrieves details of a specific file that has been directly moved to the trash. It cannot be used if one of its parent folders was trashed instead."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/files/{file_id}/trash".format(file_id=file_identifier),  # noqa: UP032
            params=remove_none_values({"fields": include_attributes_in_response}),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def permanently_delete_file_from_trash(
    context: ToolContext,
    file_identifier: Annotated[
        str,
        "The unique identifier of a file to be permanently deleted from the trash. Obtainable from the file URL.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'delete_files_id_trash'."]:
    """Permanently delete a file that is in the trash.

    This tool is used to permanently remove a file that has been moved to the trash. This action is irreversible and should be called when a file needs to be deleted without the possibility of recovery."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/files/{file_id}/trash".format(file_id=file_identifier),  # noqa: UP032
            method="DELETE",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_file_version_history(
    context: ToolContext,
    file_identifier: Annotated[
        str,
        "The unique ID representing a file in Box. Obtainable from the file's URL, e.g., `https://*.app.box.com/files/123` where `123` is the ID.",  # noqa: E501
    ],
    requested_fields: Annotated[
        list[str] | None,
        "A list of specific file attributes to include in the response. Only these fields, plus the mini representation, will be returned.",  # noqa: E501
    ] = None,
    max_items_per_page: Annotated[
        int | None, "Maximum number of file versions to return per page."
    ] = None,
    response_start_offset: Annotated[
        int | None,
        "The item offset to begin the response from. Must not exceed 10000; otherwise, a 400 error will be returned.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_files_id_versions'."]:
    """Retrieve a list of past versions for a file.

    This tool retrieves past versions of a specified file from Box, applicable only for premium account users. Use it to track file changes and version history."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/files/{file_id}/versions".format(file_id=file_identifier),  # noqa: UP032
            params=remove_none_values({
                "fields": requested_fields,
                "limit": max_items_per_page,
                "offset": response_start_offset,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def retrieve_file_version(
    context: ToolContext,
    unique_file_identifier: Annotated[
        str,
        "The unique identifier for a file on Box. Obtainable from the file's URL (e.g., '123' in 'https://*.app.box.com/files/123').",
    ],
    file_version_identifier: Annotated[
        str, "The unique ID representing the specific version of a file to retrieve."
    ],
    include_additional_attributes: Annotated[
        list[str] | None,
        "List of additional attributes to include in the response. Specify as an array of strings. Only fields specified will be returned, along with the mini representation.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_files_id_versions_id'."]:
    """Retrieve a specific version of a file for premium Box users.

    Use this tool to fetch details about a specific version of a file stored on Box. Only applicable for Box users with premium accounts who have version tracking enabled."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/files/{file_id}/versions/{file_version_id}".format(  # noqa: UP032
                file_id=unique_file_identifier, file_version_id=file_version_identifier
            ),
            params=remove_none_values({"fields": include_additional_attributes}),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def delete_box_file_version(
    context: ToolContext,
    file_identifier: Annotated[
        str,
        "The unique identifier for a file in Box. Obtain it from the file's URL in the web app. Example: '123' for URL 'https://*.app.box.com/files/123'.",  # noqa: E501
    ],
    file_version_id: Annotated[
        str,
        "The unique identifier of the file version to be deleted. Obtainable from the Box platform.",  # noqa: E501
    ],
    if_match_etag_value: Annotated[
        str | None,
        "Pass the item's last observed etag value to ensure it hasn't changed before deletion. Use this to prevent conflicts.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'delete_files_id_versions_id'."]:
    """Delete a specific file version from Box.

    Use this tool to move a specific version of a file to the trash on Box. Applicable only for users with premium accounts."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/files/{file_id}/versions/{file_version_id}".format(  # noqa: UP032
                file_id=file_identifier, file_version_id=file_version_id
            ),
            method="DELETE",
            headers=remove_none_values({
                "box-version": "2024.0",
                "if-match": if_match_etag_value,
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def retrieve_file_metadata(
    context: ToolContext,
    file_identifier: Annotated[
        str,
        "The unique identifier of a file, obtained from the URL in the Box web application. For example, from `https://*.app.box.com/files/123`, the `file_id` is `123`.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_files_id_metadata'."]:
    """Retrieve all metadata for a specific file.

    This tool is used to obtain comprehensive metadata information for a given file. It should be called when there is a need to access detailed metadata associated with a specific file ID in the Box service."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/files/{file_id}/metadata".format(file_id=file_identifier),  # noqa: UP032
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_file_classification_metadata(
    context: ToolContext,
    file_identifier: Annotated[
        str,
        "The unique identifier for a file, obtained from the file's URL in the Box web application. For example, in `https://*.app.box.com/files/123`, the `file_id` is `123`.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'get_files_id_metadata_enterprise_securityClassification-6VMVochwUWo'.",  # noqa: E501
]:
    """Retrieve classification metadata for a specific file.

    Fetches the applied classification metadata instance for a given file using its ID."""
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/files/{file_id}/metadata/enterprise/securityClassification-6VMVochwUWo".format(  # noqa: UP032
                file_id=file_identifier
            ),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def remove_file_classification(
    context: ToolContext,
    file_identifier: Annotated[
        str,
        "The unique identifier for the file whose classification is to be removed. Obtainable from the Box file URL.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'delete_files_id_metadata_enterprise_securityClassification-6VMVochwUWo'.",  # noqa: E501
]:
    """Remove classifications from a specified file.

    This tool is used to remove any security classifications from a file in the Box service. It should be called when there's a need to clear security classifications."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/files/{file_id}/metadata/enterprise/securityClassification-6VMVochwUWo".format(  # noqa: UP032
                file_id=file_identifier
            ),
            method="DELETE",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def retrieve_file_template_metadata(
    context: ToolContext,
    file_identifier: Annotated[
        str,
        "The unique identifier for a file, obtainable from the file URL in the Box web application.",  # noqa: E501
    ],
    metadata_scope: Annotated[
        str,
        "Defines the scope of the metadata template to be retrieved. Options are 'global' or 'enterprise'.",  # noqa: E501
    ],
    metadata_template_name: Annotated[
        str, "The name of the metadata template to retrieve for the specified file."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_files_id_metadata_id_id'."]:
    """Retrieve metadata for a specific file template.

    Use this tool to get the metadata template instance applied to a file. It should be called when metadata information about a file is needed, such as tags, classifications, or other custom data types."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/files/{file_id}/metadata/{scope}/{template_key}".format(  # noqa: UP032
                file_id=file_identifier, scope=metadata_scope, template_key=metadata_template_name
            ),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def delete_file_metadata(
    context: ToolContext,
    file_identifier: Annotated[
        str,
        "The unique identifier for a file, retrievable from the file URL, e.g., `https://*.app.box.com/files/123` where `123` is the ID.",  # noqa: E501
    ],
    metadata_scope: Annotated[
        str, "Specifies the scope of the metadata template. Choose 'global' or 'enterprise'."
    ],
    metadata_template_name: Annotated[
        str, "The name of the metadata template to be deleted from the file."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'delete_files_id_metadata_id_id'."]:
    """Deletes metadata from a specified file.

    Use this tool to delete a specific piece of metadata from a file by providing the file ID, metadata scope, and template key."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/files/{file_id}/metadata/{scope}/{template_key}".format(  # noqa: UP032
                file_id=file_identifier, scope=metadata_scope, template_key=metadata_template_name
            ),
            method="DELETE",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_box_skills_metadata(
    context: ToolContext,
    file_id: Annotated[
        str,
        "The unique identifier for the file in Box. Obtainable from the file's URL in the Box web app.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get_files_id_metadata_global_boxSkillsCards'."
]:
    """Retrieve Box Skills metadata cards for a given file.

    This tool is used to list the Box Skills metadata cards that are attached to a specific file in Box. It should be called when you need to obtain metadata information about the skills applied to a file."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/files/{file_id}/metadata/global/boxSkillsCards".format(  # noqa: UP032
                file_id=file_id
            ),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def remove_box_skills_metadata(
    context: ToolContext,
    file_identifier: Annotated[
        str,
        "The unique identifier for a file, which can be extracted from the URL in the web application. For example, in `https://*.app.box.com/files/123`, the `file_id` is `123`.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'delete_files_id_metadata_global_boxSkillsCards'.",
]:
    """Remove Box Skills cards metadata from a file.

    Use this tool to delete any Box Skills cards metadata associated with a specific file. It should be called when there is a need to clean metadata from files stored in Box."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/files/{file_id}/metadata/global/boxSkillsCards".format(  # noqa: UP032
                file_id=file_identifier
            ),
            method="DELETE",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_file_watermark(
    context: ToolContext,
    file_identifier: Annotated[
        str,
        "The unique identifier of a file. Obtainable from the URL when viewing a file on the web application.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_files_id_watermark'."]:
    """Retrieve the watermark for a file by its ID.

    Use this tool to get the watermark information of a specific file. It requires the file ID to identify which file's watermark needs to be retrieved."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/files/{file_id}/watermark".format(file_id=file_identifier),  # noqa: UP032
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def remove_file_watermark(
    context: ToolContext,
    file_identifier: Annotated[
        str,
        "The unique ID for the file, found in its Box URL. For example, from `https://*.app.box.com/files/123`, `file_id` is `123`.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'delete_files_id_watermark'."]:
    """Removes the watermark from a specified file.

    This tool is used to remove a watermark from a file in the Box service. It should be called when there's a need to delete the watermark from a specified file."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/files/{file_id}/watermark".format(file_id=file_identifier),  # noqa: UP032
            method="DELETE",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def retrieve_file_request_info(
    context: ToolContext,
    file_request_unique_id: Annotated[
        str,
        "The unique identifier for a file request, obtainable from the URL in the file request builder.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_file_requests_id'."]:
    """Retrieve information about a specific file request.

    This tool retrieves detailed information about a file request using its unique identifier. It should be called when you need to access metadata or details related to a specific file request."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/file_requests/{file_request_id}".format(  # noqa: UP032
                file_request_id=file_request_unique_id
            ),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def delete_file_request(
    context: ToolContext,
    file_request_identifier: Annotated[
        str,
        "The unique ID representing a file request, extracted from the URL in the file request builder.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'delete_file_requests_id'."]:
    """Permanently delete a specific file request.

    Use this tool to permanently delete a file request by its ID."""
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/file_requests/{file_request_id}".format(  # noqa: UP032
                file_request_id=file_request_identifier
            ),
            method="DELETE",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_folder_details(
    context: ToolContext,
    folder_unique_identifier: Annotated[
        str,
        "The unique identifier for a folder. Obtainable from the folder's URL, e.g., `123` in `https://*.app.box.com/folder/123`. The root folder's ID is `0`.",  # noqa: E501
    ],
    requested_fields: Annotated[
        list[str] | None,
        "A list of attributes to include in the response. Use for fields not normally returned in standard responses or for querying file metadata.",  # noqa: E501
    ] = None,
    secondary_sort_attribute: Annotated[
        str | None,
        "Defines the second attribute by which folder items are sorted. Options include 'id', 'name', 'date', or 'size'. Not supported for root folders.",  # noqa: E501
    ] = None,
    sort_direction: Annotated[
        str | None, "The order to sort results: 'ASC' for ascending or 'DESC' for descending."
    ] = None,
    response_offset: Annotated[
        int | None,
        "The zero-based index to start the response from. Values exceeding 10000 are rejected with a 400 error.",  # noqa: E501
    ] = None,
    max_items_per_page: Annotated[
        int | None,
        "The maximum number of items to return in a single page of results. Controls pagination by limiting the number of entries per response.",  # noqa: E501
    ] = None,
    ensure_item_has_changed: Annotated[
        str | None,
        "Supply the item's last known etag value to receive a response only if the item has changed. If unchanged, it returns a 304 status.",  # noqa: E501
    ] = None,
    shared_link_credentials: Annotated[
        str | None,
        "The URL and optional password for the shared link to access items. Format as `shared_link=[link]` or `shared_link=[link]&shared_link_password=[password]`.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_folders_id'."]:
    """Retrieve details for a folder and its first 100 entries.

    Use this tool to get information about a folder, along with the first 100 items it contains. This includes options for sorting and pagination. For accessing more items in the folder, a different endpoint should be used."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/folders/{folder_id}".format(  # noqa: UP032
                folder_id=folder_unique_identifier
            ),
            params=remove_none_values({
                "fields": requested_fields,
                "sort": secondary_sort_attribute,
                "direction": sort_direction,
                "offset": response_offset,
                "limit": max_items_per_page,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "if-none-match": ensure_item_has_changed,
                "boxapi": shared_link_credentials,
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def delete_folder(
    context: ToolContext,
    folder_identifier: Annotated[
        str,
        "The unique identifier representing a folder. Determine it by copying the ID from the folder's URL in the Box web application. The root folder ID is '0'.",  # noqa: E501
    ],
    ensure_unchanged_etag: Annotated[
        str | None,
        "Last observed `etag` value to ensure the folder hasn't changed before deletion. If changed, the operation fails with a 412 error.",  # noqa: E501
    ] = None,
    delete_recursively: Annotated[
        bool | None, "Set to true to delete a non-empty folder and all its content recursively."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'delete_folders_id'."]:
    """Delete a folder permanently or move it to the trash.

    Use this tool to remove a folder from Box, either permanently or by sending it to the trash."""
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/folders/{folder_id}".format(folder_id=folder_identifier),  # noqa: UP032
            params=remove_none_values({"recursive": delete_recursively}),
            method="DELETE",
            headers=remove_none_values({
                "box-version": "2024.0",
                "if-match": ensure_unchanged_etag,
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_folder_app_item_associations(
    context: ToolContext,
    folder_identifier: Annotated[
        str,
        "The unique identifier representing a folder. Obtainable from the folder's URL. The root folder ID is '0'.",  # noqa: E501
    ],
    max_items_per_page: Annotated[
        int | None,
        "The maximum number of items to return per page when retrieving app items associated with a folder.",  # noqa: E501
    ] = None,
    pagination_start_marker: Annotated[
        str | None,
        "Position marker to begin returning results. Used for marker-based pagination. Requires `usemarker` set to `true`.",  # noqa: E501
    ] = None,
    filter_by_application_type: Annotated[
        str | None, "Return only app items for the specified application type."
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get_folders_id_app_item_associations'."
]:
    """Retrieve app items associated with a specific folder.

    This tool returns all app items associated with a specified folder, including those linked through ancestor folders. It reveals type and IDs of the app items if the user has access to the folder, regardless of their permission on the app items themselves."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/folders/{folder_id}/app_item_associations".format(  # noqa: UP032
                folder_id=folder_identifier
            ),
            params=remove_none_values({
                "limit": max_items_per_page,
                "marker": pagination_start_marker,
                "application_type": filter_by_application_type,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def retrieve_folder_items(
    context: ToolContext,
    folder_identifier: Annotated[
        str,
        "Unique ID of a folder. Obtainable from the folder's URL. Root folder ID is always '0'.",
    ],
    included_attributes: Annotated[
        list[str] | None,
        "List of attributes to include in the response. Specify fields normally omitted in standard responses or query metadata using the format 'metadata.<scope>.<key>'.",  # noqa: E501
    ] = None,
    pagination_start_marker: Annotated[
        str | None,
        "Specifies the starting point for marker-based pagination. Requires 'usemarker' to be set to true.",  # noqa: E501
    ] = None,
    starting_item_offset: Annotated[
        int | None,
        "Specifies the starting point for the items to be returned. Must be an integer and cannot exceed 10000, or a 400 response is returned.",  # noqa: E501
    ] = None,
    max_items_per_page: Annotated[
        int | None, "The maximum number of items to return per page. Specify an integer value."
    ] = None,
    sort_attribute: Annotated[
        str | None,
        "Specifies the secondary attribute for sorting folder items. Options: 'id', 'name', 'date', or 'size'. Not supported for marker-based pagination on root folders.",  # noqa: E501
    ] = None,
    sort_direction: Annotated[
        str | None,
        "The direction to sort results: alphabetical ascending (ASC) or descending (DESC).",
    ] = None,
    shared_link_credentials: Annotated[
        str | None,
        "Provide the shared link URL and optional password to access items not explicitly shared with a user. Use 'shared_link=[link]' or 'shared_link=[link]&shared_link_password=[password]'.",  # noqa: E501
    ] = None,
    use_marker_based_pagination: Annotated[
        bool | None,
        "Set to true to enable marker-based pagination, which returns a marker for fetching the next page. Only one pagination method can be active at a time.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_folders_id_items'."]:
    """Retrieve items in a specified folder, including files and links.

    Use this tool to get a list of items such as files, folders, and web links contained within a specific folder. To obtain details about the folder itself, use a different endpoint."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/folders/{folder_id}/items".format(  # noqa: UP032
                folder_id=folder_identifier
            ),
            params=remove_none_values({
                "fields": included_attributes,
                "usemarker": use_marker_based_pagination,
                "marker": pagination_start_marker,
                "offset": starting_item_offset,
                "limit": max_items_per_page,
                "sort": sort_attribute,
                "direction": sort_direction,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "boxapi": shared_link_credentials,
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_folder_collaborations(
    context: ToolContext,
    folder_identifier: Annotated[
        str,
        "The unique identifier for a folder, obtainable from the folder's URL in the Box web application. For example, in the URL `https://*.app.box.com/folder/123`, the `folder_id` is `123`.",  # noqa: E501
    ],
    included_attributes: Annotated[
        list[str] | None,
        "List of attributes to include in the response, overriding standard fields unless specified.",  # noqa: E501
    ] = None,
    max_items_per_page: Annotated[
        int | None, "The maximum number of items to return per page."
    ] = None,
    start_position_marker: Annotated[
        str | None,
        "The position marker to begin returning results for marker-based pagination. Requires usemarker set to true.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_folders_id_collaborations'."]:
    """Retrieve pending and active collaborations for a folder.

    This tool retrieves a list of users who have access to or have been invited to a specified folder. It returns both pending and active collaborations."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/folders/{folder_id}/collaborations".format(  # noqa: UP032
                folder_id=folder_identifier
            ),
            params=remove_none_values({
                "fields": included_attributes,
                "limit": max_items_per_page,
                "marker": start_position_marker,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def retrieve_trashed_folder(
    context: ToolContext,
    folder_identifier: Annotated[
        str,
        "The unique identifier for a folder. Obtainable from the folder's URL in the web application. '0' represents the root folder.",  # noqa: E501
    ],
    include_attributes_in_response: Annotated[
        list[str] | None,
        "A list of attribute names to include in the response, specifying non-standard fields for retrieval.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_folders_id_trash'."]:
    """Retrieve a specific folder from the trash.

    This tool retrieves a folder that has been specifically moved to the trash. It can only be used if the folder itself, rather than a parent folder, is in the trash."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/folders/{folder_id}/trash".format(  # noqa: UP032
                folder_id=folder_identifier
            ),
            params=remove_none_values({"fields": include_attributes_in_response}),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def permanently_delete_folder_in_trash(
    context: ToolContext,
    folder_identifier: Annotated[
        str,
        "The unique identifier representing a folder to be permanently deleted from the trash. Obtainable from folder URL or use '0' for root folder.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'delete_folders_id_trash'."]:
    """Permanently delete a folder from the trash.

    This tool permanently deletes a folder that is in the trash, and this action cannot be undone. It should be called when there is a need to remove a folder from the trash permanently."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/folders/{folder_id}/trash".format(  # noqa: UP032
                folder_id=folder_identifier
            ),
            method="DELETE",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def retrieve_folder_metadata(
    context: ToolContext,
    folder_identifier: Annotated[
        str,
        "The unique identifier for a folder, excluding the root folder with ID `0`. Obtainable from the URL when viewing a folder in Box.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_folders_id_metadata'."]:
    """Retrieve all metadata for a specific folder.

    Use this tool to get metadata details for any folder except the root folder."""
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/folders/{folder_id}/metadata".format(  # noqa: UP032
                folder_id=folder_identifier
            ),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_folder_classification(
    context: ToolContext,
    folder_identifier: Annotated[
        str,
        "The unique identifier for a folder, retrievable from the folder's URL or as `0` for the root folder.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'get_folders_id_metadata_enterprise_securityClassification-6VMVochwUWo'.",  # noqa: E501
]:
    """Retrieve classification metadata for a specific folder.

    This tool retrieves the security classification metadata applied to a specific folder. It can be used to understand how a folder is classified within an enterprise. The tool should be called when needing to access classification details for data management or security reviews."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/folders/{folder_id}/metadata/enterprise/securityClassification-6VMVochwUWo".format(  # noqa: UP032
                folder_id=folder_identifier
            ),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def remove_folder_classifications(
    context: ToolContext,
    folder_identifier: Annotated[
        str,
        "The unique identifier representing a folder. Obtain this by visiting the folder URL (e.g., `https://*.app.box.com/folder/123`). The root folder ID is `0`.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'delete_folders_id_metadata_enterprise_securityClassification-6VMVochwUWo'.",  # noqa: E501
]:
    """Remove classifications from a specified folder.

    Use this tool to remove any security classifications applied to a specific folder. It is useful when needing to update or clear the classification status of folders in an enterprise setting."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/folders/{folder_id}/metadata/enterprise/securityClassification-6VMVochwUWo".format(  # noqa: UP032
                folder_id=folder_identifier
            ),
            method="DELETE",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_folder_metadata(
    context: ToolContext,
    folder_identifier: Annotated[
        str,
        "The unique ID representing a folder. Obtainable from the folder's URL, but not the root folder (ID `0`).",  # noqa: E501
    ],
    metadata_scope: Annotated[
        str, "The scope of the metadata template. It can be either 'global' or 'enterprise'."
    ],
    metadata_template_name: Annotated[
        str,
        "The name of the metadata template to retrieve from the folder. Excludes root folder (ID `0`).",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_folders_id_metadata_id_id'."]:
    """Retrieve metadata template instance applied to a folder.

    This tool retrieves the metadata template instance from a specified folder, excluding the root folder (ID `0`)."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/folders/{folder_id}/metadata/{scope}/{template_key}".format(  # noqa: UP032
                folder_id=folder_identifier,
                scope=metadata_scope,
                template_key=metadata_template_name,
            ),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def delete_folder_metadata(
    context: ToolContext,
    folder_identifier: Annotated[
        str,
        "The unique identifier for a folder. Obtainable from the folder URL; use '0' for the root folder.",  # noqa: E501
    ],
    metadata_template_scope: Annotated[
        str, "The scope of the metadata template. Choose either 'global' or 'enterprise'."
    ],
    metadata_template_name: Annotated[
        str, "The name of the metadata template to be deleted from the folder."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'delete_folders_id_metadata_id_id'."
]:
    """Deletes metadata from a specified folder.

    Use this tool to remove a specific piece of metadata from a folder by providing the folder ID, scope, and template key."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/folders/{folder_id}/metadata/{scope}/{template_key}".format(  # noqa: UP032
                folder_id=folder_identifier,
                scope=metadata_template_scope,
                template_key=metadata_template_name,
            ),
            method="DELETE",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def retrieve_trashed_items(
    context: ToolContext,
    include_attributes: Annotated[
        list[str] | None,
        "List of attributes to include in the response, such as non-default fields. Only these and mini representation fields will be returned.",  # noqa: E501
    ] = None,
    maximum_items_per_page: Annotated[
        int | None,
        "Specify the maximum number of items to return per page when retrieving trashed items. This value controls pagination to limit the items returned in a single request.",  # noqa: E501
    ] = None,
    pagination_offset: Annotated[
        int | None,
        "The index to start retrieving items from the trash. Must be less than or equal to 10000.",
    ] = None,
    pagination_marker: Annotated[
        str | None,
        "Defines the position marker for marker-based pagination. Requires 'use_marker_based_pagination' to be true.",  # noqa: E501
    ] = None,
    sort_direction: Annotated[
        str | None,
        "The direction to sort results: 'ASC' for ascending or 'DESC' for descending alphabetical order.",  # noqa: E501
    ] = None,
    secondary_sort_attribute: Annotated[
        str | None,
        "Defines the second attribute by which items are sorted, such as 'name', 'date', or 'size'. Unsupported with marker-based pagination.",  # noqa: E501
    ] = None,
    use_marker_based_pagination: Annotated[
        bool | None,
        "Set to true to use marker-based pagination instead of offset-based pagination, allowing retrieval of the next page with a 'marker' field.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_folders_trash_items'."]:
    """Retrieve files and folders from the trash.

    Use this tool to access files and folders that have been moved to the trash. Supports retrieval of specific attributes and pagination options."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/folders/trash/items",
            params=remove_none_values({
                "fields": include_attributes,
                "limit": maximum_items_per_page,
                "offset": pagination_offset,
                "usemarker": use_marker_based_pagination,
                "marker": pagination_marker,
                "direction": sort_direction,
                "sort": secondary_sort_attribute,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_folder_watermark(
    context: ToolContext,
    folder_identifier: Annotated[
        str,
        "The unique ID representing a folder. It can be found in the URL when viewing the folder in the web app. The root folder ID is '0'.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_folders_id_watermark'."]:
    """Retrieve the watermark for a specific folder.

    Use this tool to get the watermark information for a folder identified by its ID. Useful for checking watermark status and details."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/folders/{folder_id}/watermark".format(  # noqa: UP032
                folder_id=folder_identifier
            ),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def remove_watermark_from_folder(
    context: ToolContext,
    folder_identifier: Annotated[
        str,
        "The unique identifier for a folder. This ID can be found in the URL when visiting the folder in the Box web application. For instance, in `https://*.app.box.com/folder/123`, the `folder_id` is `123`. The root folder is always `0`.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'delete_folders_id_watermark'."]:
    """Removes the watermark from a specified folder.

    Use this tool to remove the watermark from a folder by providing the folder's ID in the request."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/folders/{folder_id}/watermark".format(  # noqa: UP032
                folder_id=folder_identifier
            ),
            method="DELETE",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def retrieve_folder_lock_details(
    context: ToolContext,
    folder_identifier: Annotated[
        str,
        "The unique identifier for a folder. Obtainable by visiting the folder URL in the Box web app. The root folder is ID '0'.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_folder_locks'."]:
    """Retrieve lock details for a specific folder.

    Use this tool to get information about locks on a folder. Authentication as the owner or co-owner is required."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/folder_locks",
            params=remove_none_values({"folder_id": folder_identifier}),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def delete_folder_lock(
    context: ToolContext,
    folder_lock_identifier: Annotated[
        str,
        "The unique ID of the folder lock to be deleted. You must be the owner or co-owner of the folder.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'delete_folder_locks_id'."]:
    """Delete a specific folder lock if you're the owner or co-owner.

    Use this tool to delete a lock on a folder you own or co-own, ensuring that only authorized modifications are permitted."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/folder_locks/{folder_lock_id}".format(  # noqa: UP032
                folder_lock_id=folder_lock_identifier
            ),
            method="DELETE",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def find_metadata_template(
    context: ToolContext,
    metadata_instance_id: Annotated[
        str, "The ID of the metadata template instance to retrieve details for."
    ],
    pagination_position_marker: Annotated[
        str | None,
        "Defines the starting position for marker-based pagination results. Requires `usemarker` to be `true`.",  # noqa: E501
    ] = None,
    items_per_page_limit: Annotated[
        int | None,
        "Specify the maximum number of items to return per page for pagination purposes.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_metadata_templates'."]:
    """Retrieve metadata template details by ID.

    Use this tool to find and retrieve details of a metadata template by searching for the ID of a template instance."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/metadata_templates",
            params=remove_none_values({
                "metadata_instance_id": metadata_instance_id,
                "marker": pagination_position_marker,
                "limit": items_per_page_limit,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_classification_metadata(
    context: ToolContext,
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'get_metadata_templates_enterprise_securityClassification-6VMVochwUWo_schema'.",  # noqa: E501
]:
    """Retrieve classification metadata template for the enterprise.

    This tool retrieves classification metadata templates and lists all classifications available to a specified enterprise. It can be used to understand the security classification options within the enterprise."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/metadata_templates/enterprise/securityClassification-6VMVochwUWo/schema",
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def retrieve_metadata_template(
    context: ToolContext,
    metadata_template_scope: Annotated[
        str,
        "Specifies the scope for the metadata template. Choose between 'global' or 'enterprise'.",
    ],
    metadata_template_name: Annotated[
        str, "The name of the metadata template to retrieve its details."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get_metadata_templates_id_id_schema'."
]:
    """Retrieve a metadata template by scope and template key.

    This tool retrieves a metadata template using its `scope` and `templateKey`. It is useful for accessing specific template details for Box. To find these values, list all templates for an enterprise or globally, or list those applied to specific files or folders."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/metadata_templates/{scope}/{template_key}/schema".format(  # noqa: UP032
                scope=metadata_template_scope, template_key=metadata_template_name
            ),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def delete_metadata_template(
    context: ToolContext,
    metadata_template_scope: Annotated[
        str,
        "Specifies the scope of the metadata template. Allowed values are 'global' or 'enterprise'.",  # noqa: E501
    ],
    metadata_template_name: Annotated[
        str, "The name of the metadata template to be permanently deleted."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'delete_metadata_templates_id_id_schema'."
]:
    """Permanently delete a metadata template and its instances.

    Use this tool to permanently delete a metadata template and all its instances. This action is irreversible and should be used with caution."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/metadata_templates/{scope}/{template_key}/schema".format(  # noqa: UP032
                scope=metadata_template_scope, template_key=metadata_template_name
            ),
            method="DELETE",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def fetch_metadata_template_by_id(
    context: ToolContext,
    template_id: Annotated[
        str,
        "The unique identifier for the metadata template to be retrieved. Provide a valid template ID.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_metadata_templates_id'."]:
    """Retrieve a metadata template using its ID.

    Use this tool to get detailed information about a specific metadata template by providing its ID."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/metadata_templates/{template_id}".format(  # noqa: UP032
                template_id=template_id
            ),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def retrieve_global_metadata_templates(
    context: ToolContext,
    pagination_start_marker: Annotated[
        str | None, "Specifies the position marker to begin returning results for paginated data."
    ] = None,
    max_items_per_page: Annotated[
        int | None,
        "The maximum number of metadata templates to return per page from the Box global templates.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_metadata_templates_global'."]:
    """Fetches global metadata templates from Box.

    Use this tool to retrieve all available global metadata templates provided by Box for enterprises."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/metadata_templates/global",
            params=remove_none_values({
                "marker": pagination_start_marker,
                "limit": max_items_per_page,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def retrieve_enterprise_metadata_templates(
    context: ToolContext,
    pagination_start_marker: Annotated[
        str | None,
        "Position marker to begin returning results, used with marker-based pagination. Requires `usemarker` to be `true`.",  # noqa: E501
    ] = None,
    maximum_items_per_page: Annotated[
        int | None,
        "The maximum number of items to return per page when retrieving metadata templates.",
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get_metadata_templates_enterprise'."
]:
    """Retrieve metadata templates for the user's enterprise.

    Used to fetch all metadata templates designated for use within the user's enterprise."""
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/metadata_templates/enterprise",
            params=remove_none_values({
                "marker": pagination_start_marker,
                "limit": maximum_items_per_page,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_metadata_cascade_policies(
    context: ToolContext,
    target_folder_id: Annotated[
        str,
        "The ID of the folder to query for metadata cascade policies. The root folder with ID '0' is not allowed.",  # noqa: E501
    ],
    owner_enterprise_id: Annotated[
        str | None,
        "The ID of the enterprise to find metadata cascade policies for. Defaults to the current enterprise if not specified.",  # noqa: E501
    ] = None,
    pagination_marker: Annotated[
        str | None, "Position marker for paginating results. Set `usemarker` to true to enable."
    ] = None,
    response_offset: Annotated[
        int | None, "The offset at which to begin the response, must not exceed 10000."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_metadata_cascade_policies'."]:
    """Retrieve metadata cascade policies for a folder.

    Use this tool to obtain a list of metadata cascade policies applied to a specific folder, excluding the root folder."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/metadata_cascade_policies",
            params=remove_none_values({
                "folder_id": target_folder_id,
                "owner_enterprise_id": owner_enterprise_id,
                "marker": pagination_marker,
                "offset": response_offset,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def retrieve_metadata_cascade_policy(
    context: ToolContext,
    metadata_cascade_policy_id: Annotated[
        str, "The unique identifier for the metadata cascade policy to retrieve."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get_metadata_cascade_policies_id'."
]:
    """Retrieve a specific metadata cascade policy for a folder.

    This tool retrieves detailed information about a specific metadata cascade policy that is assigned to a folder. Use this when you need to access the policy information by its unique ID."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/metadata_cascade_policies/{metadata_cascade_policy_id}".format(  # noqa: UP032
                metadata_cascade_policy_id=metadata_cascade_policy_id
            ),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def delete_metadata_cascade_policy(
    context: ToolContext,
    metadata_cascade_policy_id: Annotated[
        str,
        "The unique ID of the metadata cascade policy to be deleted. Ensure it is valid and exists.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'delete_metadata_cascade_policies_id'."
]:
    """Deletes a metadata cascade policy by ID.

    This tool deletes a specified metadata cascade policy using its unique ID. It should be called when you need to remove a cascade policy from your metadata handling."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/metadata_cascade_policies/{metadata_cascade_policy_id}".format(  # noqa: UP032
                metadata_cascade_policy_id=metadata_cascade_policy_id
            ),
            method="DELETE",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def fetch_comment_details(
    context: ToolContext,
    comment_id: Annotated[
        str,
        "The unique identifier for the comment whose details are being fetched. This ID is required to retrieve the comment's message, metadata, and creator information.",  # noqa: E501
    ],
    include_fields: Annotated[
        list[str] | None,
        "A list of attributes to include in the response. Only specified fields will be returned along with the mini representation.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_comments_id'."]:
    """Retrieve detailed information about a specific comment.

    This tool fetches the message, metadata, and creator information for a specified comment ID. It should be used when detailed comment insights are needed."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/comments/{comment_id}".format(comment_id=comment_id),  # noqa: UP032
            params=remove_none_values({"fields": include_fields}),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def delete_comment(
    context: ToolContext,
    comment_id: Annotated[
        str, "The unique identifier of the comment you want to permanently delete."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'delete_comments_id'."]:
    """Permanently deletes a specific comment by ID.

    Use this tool to permanently remove a comment by providing its unique ID. Call this when you need to delete a comment and ensure it's not recoverable."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/comments/{comment_id}".format(comment_id=comment_id),  # noqa: UP032
            method="DELETE",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_collaboration_details(
    context: ToolContext,
    collaboration_id: Annotated[
        str, "The unique identifier for the collaboration to retrieve details about."
    ],
    include_fields: Annotated[
        list[str] | None,
        "List of specific attributes to include in the response, which are not typically returned. Specify explicitly to retrieve these fields.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_collaborations_id'."]:
    """Retrieve details of a specific collaboration.

    Use this tool to obtain information about a specific collaboration by its ID."""
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/collaborations/{collaboration_id}".format(  # noqa: UP032
                collaboration_id=collaboration_id
            ),
            params=remove_none_values({"fields": include_fields}),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def delete_collaboration(
    context: ToolContext,
    collaboration_id_to_delete: Annotated[
        str,
        "The unique identifier of the collaboration to be deleted. Provide this ID to remove the specified collaboration.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'delete_collaborations_id'."]:
    """Deletes a specified collaboration by ID.

    This tool is used to delete a collaboration by providing the specific collaboration ID. It should be called when a collaboration needs to be removed from the system."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/collaborations/{collaboration_id}".format(  # noqa: UP032
                collaboration_id=collaboration_id_to_delete
            ),
            method="DELETE",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_pending_collaboration_invites(
    context: ToolContext,
    collaboration_status: Annotated[
        str, "Set to 'pending' to retrieve all pending collaboration invitations."
    ],
    include_attributes: Annotated[
        list[str] | None,
        "List of attribute names to include in the response. This overrides default fields, returning only specified attributes.",  # noqa: E501
    ] = None,
    starting_item_offset: Annotated[
        int | None, "Starting index for the response items. Cannot exceed 10000 to avoid errors."
    ] = None,
    maximum_items_per_page: Annotated[
        int | None, "The maximum number of collaboration invites to return per page."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_collaborations'."]:
    """Retrieve user's pending collaboration invites from Box.

    This tool fetches all pending collaboration invitations for a user from the Box service. It should be called when you need to check for any outstanding collaboration invites for a user."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/collaborations",
            params=remove_none_values({
                "status": collaboration_status,
                "fields": include_attributes,
                "offset": starting_item_offset,
                "limit": maximum_items_per_page,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def retrieve_task_information(
    context: ToolContext,
    task_id: Annotated[
        str, "The unique identifier for the specific task to retrieve information about."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_tasks_id'."]:
    """Fetch details of a specific task by ID.

    This tool retrieves information about a specific task using its ID. It should be called when you need detailed information about a particular task."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/tasks/{task_id}".format(task_id=task_id),  # noqa: UP032
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def delete_task_from_file(
    context: ToolContext,
    task_identifier: Annotated[
        str, "The unique identifier for the task to be removed from the file."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'delete_tasks_id'."]:
    """Removes a specific task from a file.

    Use this tool to delete a specific task from a file by providing the task ID. It is useful when tasks need to be removed as part of file management."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/tasks/{task_id}".format(task_id=task_identifier),  # noqa: UP032
            method="DELETE",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def list_task_assignments(
    context: ToolContext,
    task_id: Annotated[
        str,
        "The unique identifier of the task for which assignments need to be retrieved. It must be provided as a string.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_tasks_id_assignments'."]:
    """Retrieve all assignments for a specified task.

    This tool is used to list all the assignments associated with a given task by providing the task ID. Use this tool to get details on who is assigned to a specific task."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/tasks/{task_id}/assignments".format(task_id=task_id),  # noqa: UP032
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def retrieve_task_assignment_info(
    context: ToolContext,
    task_assignment_id: Annotated[
        str, "The unique identifier for the task assignment to retrieve its details."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_task_assignments_id'."]:
    """Retrieve detailed information about a task assignment.

    This tool is used to get information on a specific task assignment by its ID. It can be called when users need to understand the status, assignee, or other details related to a task assignment."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/task_assignments/{task_assignment_id}".format(  # noqa: UP032
                task_assignment_id=task_assignment_id
            ),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def delete_task_assignment(
    context: ToolContext,
    task_assignment_id: Annotated[
        str, "The unique identifier of the task assignment to be deleted."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'delete_task_assignments_id'."]:
    """Delete a specific task assignment.

    Use this tool to remove a specific task assignment by its ID. It confirms the deletion upon successful completion."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/task_assignments/{task_assignment_id}".format(  # noqa: UP032
                task_assignment_id=task_assignment_id
            ),
            method="DELETE",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def retrieve_shared_file_info(
    context: ToolContext,
    shared_link_credentials: Annotated[
        str,
        "A header string containing the shared link and optional password. Format: `shared_link=[link]&shared_link_password=[password]`.",  # noqa: E501
    ],
    include_attributes_in_response: Annotated[
        list[str] | None,
        "A list of attributes to include in the response, specifying non-standard fields and affecting returned data format.",  # noqa: E501
    ] = None,
    etag_for_change_detection: Annotated[
        str | None, "Pass the last observed etag value to return the item only if it has changed."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_shared_items'."]:
    """Retrieve file information from a shared link.

    Fetches details of a file using a shared link, which may originate within the current enterprise or externally. Useful for accessing file metadata when you only have the shared link."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/shared_items",
            params=remove_none_values({"fields": include_attributes_in_response}),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "if-none-match": etag_for_change_detection,
                "boxapi": shared_link_credentials,
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_shared_link_info(
    context: ToolContext,
    include_shared_link_fields: Annotated[
        str, "Specify if the `shared_link` fields should be explicitly returned for the file item."
    ],
    file_identifier: Annotated[
        str,
        "The unique identifier for a file, found in the URL when accessing a file in the web application (e.g., for the URL `https://*.app.box.com/files/123`, the `file_id` is `123`).",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_files_id#get_shared_link'."]:
    """Retrieve shared link details for a specific file.

    This tool is used to get information about a shared link for a specified file. It should be called when users need details about the shared link associated with a particular file in the Box service."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/files/{file_id}#get_shared_link".format(  # noqa: UP032
                file_id=file_identifier
            ),
            params=remove_none_values({"fields": include_shared_link_fields}),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_shared_folder_info(
    context: ToolContext,
    shared_link_header: Annotated[
        str,
        "A string containing the shared link and optional password formatted as 'shared_link=[link]&shared_link_password=[password]'.",  # noqa: E501
    ],
    include_fields: Annotated[
        list[str] | None,
        "A list of specific attributes to include in the response. Only these fields will be returned unless explicitly specified otherwise.",  # noqa: E501
    ] = None,
    etag_condition: Annotated[
        str | None,
        "Provide the last observed etag to receive the item only if it has changed. Useful for caching and reducing unnecessary data transfer.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_shared_items#folders'."]:
    """Retrieve folder details using a shared link.

    Fetch detailed information about a folder using a shared link. This tool is useful when only the shared link is available, regardless of the folder's origin."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/shared_items#folders",
            params=remove_none_values({"fields": include_fields}),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "if-none-match": etag_condition,
                "boxapi": shared_link_header,
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_folder_shared_link_info(
    context: ToolContext,
    include_shared_link_fields: Annotated[
        str, "Specify if the shared_link fields should be explicitly returned for this folder."
    ],
    folder_identifier: Annotated[
        str,
        "The unique ID of the folder to retrieve shared link info for. It can be found in the folder URL in Box or use '0' for the root folder.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_folders_id#get_shared_link'."]:
    """Retrieve information for a shared link on a folder.

    Use this tool to get details about a shared link for a specific folder using its ID. Useful for accessing or managing shared folder links."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/folders/{folder_id}#get_shared_link".format(  # noqa: UP032
                folder_id=folder_identifier
            ),
            params=remove_none_values({"fields": include_shared_link_fields}),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def retrieve_web_link_info(
    context: ToolContext,
    web_link_id: Annotated[
        str, "The unique identifier for the web link to retrieve information about."
    ],
    shared_link_access_details: Annotated[
        str | None,
        "The URL and optional password for accessing the shared link, formatted as `shared_link=[link]` or `shared_link=[link]&shared_link_password=[password]`. Use this to access items not explicitly shared with a user.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_web_links_id'."]:
    """Retrieve information about a specific web link.

    This tool is used to get details about a web link by its ID. Call this tool when you need information regarding a particular web link from the Box service."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/web_links/{web_link_id}".format(web_link_id=web_link_id),  # noqa: UP032
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "boxapi": shared_link_access_details,
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def delete_web_link(
    context: ToolContext,
    web_link_id: Annotated[str, "The unique identifier for the web link to be deleted."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'delete_web_links_id'."]:
    """Delete a specified web link based on its ID."""
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/web_links/{web_link_id}".format(web_link_id=web_link_id),  # noqa: UP032
            method="DELETE",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def retrieve_trashed_web_link(
    context: ToolContext,
    web_link_id: Annotated[
        str, "The unique identifier of the web link to retrieve from the trash."
    ],
    include_fields_in_response: Annotated[
        list[str] | None,
        "List of attributes to include in the response, overriding standard fields; only mini representation plus these fields will be returned.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_web_links_id_trash'."]:
    """Retrieves a web link that has been moved to the trash.

    Use this tool to get information about a specific web link that has been moved to the trash. Call this when you need to access details of a trashed web link by its ID."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/web_links/{web_link_id}/trash".format(  # noqa: UP032
                web_link_id=web_link_id
            ),
            params=remove_none_values({"fields": include_fields_in_response}),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def permanently_delete_trashed_web_link(
    context: ToolContext,
    web_link_identifier: Annotated[
        str,
        "The unique identifier of the web link to be permanently deleted from the trash. This ID is required to specify which web link should be removed.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'delete_web_links_id_trash'."]:
    """Permanently delete a trashed web link.

    Use this tool to permanently delete a web link that is currently in the trash. This action is irreversible and should be used when the web link is no longer needed."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/web_links/{web_link_id}/trash".format(  # noqa: UP032
                web_link_id=web_link_identifier
            ),
            method="DELETE",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def retrieve_shared_web_link(
    context: ToolContext,
    shared_link_header: Annotated[
        str,
        "A string containing the shared link and optional password in the format: 'shared_link=[link]&shared_link_password=[password]'.",  # noqa: E501
    ],
    include_attributes_in_response: Annotated[
        list[str] | None,
        "A list of attributes to include in the response. Only specified fields and fields for the mini representation will be returned.",  # noqa: E501
    ] = None,
    etag_if_updated_only: Annotated[
        str | None,
        "Provide the last observed etag value to only return the web link if it has been updated. This helps avoid unnecessary data transfer if no changes have occurred.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_shared_items#web_links'."]:
    """Retrieve information about a shared web link using a shared link.

    This tool is used to obtain details about a shared web link when you have a shared link, regardless of its origin."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/shared_items#web_links",
            params=remove_none_values({"fields": include_attributes_in_response}),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "if-none-match": etag_if_updated_only,
                "boxapi": shared_link_header,
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_shared_web_link_info(
    context: ToolContext,
    request_shared_link_fields: Annotated[
        str, "Specify the shared link fields to be explicitly returned for the web link."
    ],
    web_link_identifier: Annotated[
        str, "The ID of the web link for which to retrieve shared link information."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get_web_links_id#get_shared_link'."
]:
    """Retrieve shared link information for a web link.

    Use this tool to obtain detailed information about a shared link on a specific web link by providing the web link ID."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/web_links/{web_link_id}#get_shared_link".format(  # noqa: UP032
                web_link_id=web_link_identifier
            ),
            params=remove_none_values({"fields": request_shared_link_fields}),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_shared_app_item(
    context: ToolContext,
    shared_link_information: Annotated[
        str,
        "A string with the format `shared_link=[link]&shared_link_password=[password]`, containing the shared link and an optional password.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_shared_items#app_items'."]:
    """Retrieve details of an app item using a shared link.

    Use this tool to get information about an app item by providing a shared link, which may originate from any enterprise."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/shared_items#app_items",
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "boxapi": shared_link_information,
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def list_enterprise_users(
    context: ToolContext,
    search_term_for_user_filtering: Annotated[
        str | None,
        "Limits results to users whose name or login begins with the specified term. Complete match required for external users.",  # noqa: E501
    ] = None,
    user_type_filter: Annotated[
        str | None, "Specify the type of users to include: 'all', 'managed', or 'external'."
    ] = None,
    filter_by_external_app_user_id: Annotated[
        str | None,
        "Filter results to app users with the specified external app user ID. Used for retrieving users matching this ID.",  # noqa: E501
    ] = None,
    include_additional_fields: Annotated[
        list[str] | None,
        "Specify additional attributes for inclusion in the response. Only selected fields and mini representation fields will be returned.",  # noqa: E501
    ] = None,
    response_offset: Annotated[
        int | None,
        "The starting point for the response; queries exceeding 10000 will return a 400 error.",
    ] = None,
    max_items_per_page: Annotated[
        int | None, "The maximum number of user records to return per page."
    ] = None,
    pagination_start_marker: Annotated[
        str | None,
        "Defines the position marker where results begin when using marker-based pagination. Requires `usemarker` set to `true`.",  # noqa: E501
    ] = None,
    use_marker_pagination: Annotated[
        bool | None,
        "Set to true to use marker-based pagination. This enables a `marker` field in the response for pagination.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_users'."]:
    """Retrieve all users in the enterprise.

    Fetches a list of users for the enterprise, including user IDs, public names, and login information. Requires appropriate permissions to access user data across the enterprise."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/users",
            params=remove_none_values({
                "filter_term": search_term_for_user_filtering,
                "user_type": user_type_filter,
                "external_app_user_id": filter_by_external_app_user_id,
                "fields": include_additional_fields,
                "offset": response_offset,
                "limit": max_items_per_page,
                "usemarker": use_marker_pagination,
                "marker": pagination_start_marker,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_authenticated_user_info(
    context: ToolContext,
    requested_user_attributes: Annotated[
        list[str] | None,
        "List of user attributes to include in the response. Use to request non-standard fields, results in basic fields only unless specified.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_users_me'."]:
    """Retrieve details of the currently authenticated user.

    This tool retrieves information about the user who is currently authenticated via OAuth 2.0 or JWT. It can also be used with the `As-User` header to retrieve information on behalf of another user."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/users/me",
            params=remove_none_values({"fields": requested_user_attributes}),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_user_information(
    context: ToolContext,
    user_identifier: Annotated[
        str, "The unique identifier for the user whose information you want to retrieve."
    ],
    requested_user_fields: Annotated[
        list[str] | None,
        "An array of attributes to include in the response. Only specified fields are returned unless otherwise stated.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_users_id'."]:
    """Retrieve detailed user information in the enterprise.

    Use this tool to get information about a user in the enterprise. Requires permission to access user details. Returns limited info for external users with appropriate scopes."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/users/{user_id}".format(user_id=user_identifier),  # noqa: UP032
            params=remove_none_values({"fields": requested_user_fields}),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def delete_user_account(
    context: ToolContext,
    user_id: Annotated[
        str,
        "The unique identifier for the user to be deleted. Required for specifying which user account to delete.",  # noqa: E501
    ],
    send_deletion_notification: Annotated[
        bool | None,
        "Indicate whether the user should receive an email notification about the deletion. Set to true to send notification.",  # noqa: E501
    ] = None,
    force_delete_user: Annotated[
        bool | None,
        "Set to true to delete the user and their files even if they still own content.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'delete_users_id'."]:
    """Delete a user account from the system.

    Use this tool to delete a user account. Ensure the user does not own content, or use the 'force' option to remove the user along with their files."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/users/{user_id}".format(user_id=user_id),  # noqa: UP032
            params=remove_none_values({
                "notify": send_deletion_notification,
                "force": force_delete_user,
            }),
            method="DELETE",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_user_avatar(
    context: ToolContext,
    user_id: Annotated[str, "The ID of the user whose avatar you want to retrieve."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_users_id_avatar'."]:
    """Retrieve the image of a user's avatar.

    Use this tool to get the avatar image for a specific user by their user ID."""
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/users/{user_id}/avatar".format(user_id=user_id),  # noqa: UP032
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def remove_user_avatar(
    context: ToolContext,
    user_identifier: Annotated[
        str,
        "The unique identifier of the user whose avatar is to be deleted. Ensure this ID is correct, as the operation cannot be reversed.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'delete_users_id_avatar'."]:
    """Removes a user's existing avatar.

    Use this tool to permanently delete a user's avatar. This action is irreversible, so it should be called when you want to ensure a user's avatar is removed from their profile."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/users/{user_id}/avatar".format(user_id=user_identifier),  # noqa: UP032
            method="DELETE",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_user_email_aliases(
    context: ToolContext,
    user_identifier: Annotated[
        str, "The unique ID of the user to retrieve email aliases for, formatted as a string."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_users_id_email_aliases'."]:
    """Retrieve all email aliases for a specific user.

    Fetches all email aliases associated with a user, excluding their primary login email."""
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/users/{user_id}/email_aliases".format(  # noqa: UP032
                user_id=user_identifier
            ),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def remove_user_email_alias(
    context: ToolContext,
    user_identifier: Annotated[
        str, "The unique ID of the user whose email alias is to be removed."
    ],
    email_alias_id: Annotated[
        str,
        "The unique identifier of the email alias to be removed. This is required to specify which alias to delete from the user account.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'delete_users_id_email_aliases_id'."
]:
    """Removes an email alias from a user account.

    Call this tool to delete a specific email alias from a user's account using their user ID and the email alias ID."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/users/{user_id}/email_aliases/{email_alias_id}".format(  # noqa: UP032
                user_id=user_identifier, email_alias_id=email_alias_id
            ),
            method="DELETE",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_user_group_memberships(
    context: ToolContext,
    user_identifier: Annotated[str, "The ID of the user to retrieve group memberships for."],
    max_items_per_page: Annotated[
        int | None,
        "Maximum number of items to return per page. Set an integer value to limit the results displayed at once.",  # noqa: E501
    ] = None,
    response_offset: Annotated[
        int | None, "The starting point offset for the response items. Must be 10000 or less."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_users_id_memberships'."]:
    """Retrieve all groups a user belongs to.

    Fetches all the groups associated with a specific user. This is accessible only to group members or users with admin-level permissions."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/users/{user_id}/memberships".format(  # noqa: UP032
                user_id=user_identifier
            ),
            params=remove_none_values({"limit": max_items_per_page, "offset": response_offset}),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def check_user_invite_status(
    context: ToolContext,
    invite_id: Annotated[
        str,
        "The unique identifier for the user invite you want to check. This ID is necessary to retrieve the invite's status.",  # noqa: E501
    ],
    included_attributes: Annotated[
        list[str] | None,
        "A list of attributes to include in the response. Specify attributes not normally returned in a standard response. Only the mini representation fields are returned unless explicitly specified.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_invites_id'."]:
    """Retrieve the status of a specific user invite.

    This tool is used to get the current status of a user invite by its ID."""
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/invites/{invite_id}".format(invite_id=invite_id),  # noqa: UP032
            params=remove_none_values({"fields": included_attributes}),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def retrieve_enterprise_groups(
    context: ToolContext,
    group_name_starts_with: Annotated[
        str | None, "Returns groups whose names start with this search term."
    ] = None,
    included_attributes: Annotated[
        list[str] | None,
        "List of specific attributes to include in the response. Defaults to mini representation if unspecified.",  # noqa: E501
    ] = None,
    max_items_per_page: Annotated[
        int | None, "The maximum number of groups to return per page."
    ] = None,
    starting_item_offset: Annotated[
        int | None,
        "The offset of the item at which to begin the response. Ensure the value does not exceed 10000 to avoid errors.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_groups'."]:
    """Retrieve all groups for an enterprise with admin rights.

    Use this tool to get a list of all groups within a specific enterprise. Requires admin permissions."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/groups",
            params=remove_none_values({
                "filter_term": group_name_starts_with,
                "fields": included_attributes,
                "limit": max_items_per_page,
                "offset": starting_item_offset,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def retrieve_group_info(
    context: ToolContext,
    group_id: Annotated[
        str,
        "The unique identifier of the group to retrieve information for. Ensure the user has the necessary permissions.",  # noqa: E501
    ],
    include_additional_fields: Annotated[
        list[str] | None,
        "A list of attributes to include in the response. Only specified fields will be returned alongside default mini representation fields.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_groups_id'."]:
    """Retrieve detailed information about a specified group.

    This tool fetches information about a group from Box. It's intended for use by group members or users with admin-level permissions."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/groups/{group_id}".format(group_id=group_id),  # noqa: UP032
            params=remove_none_values({"fields": include_additional_fields}),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def delete_group(
    context: ToolContext,
    group_id: Annotated[
        str,
        "The unique identifier of the group to be permanently deleted. Must be used by an admin.",
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'delete_groups_id'."]:
    """Permanently delete a group with admin permissions.

    This tool is used to permanently delete a specified group. Only users with admin-level permissions are able to perform this action."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/groups/{group_id}".format(group_id=group_id),  # noqa: UP032
            method="DELETE",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def retrieve_group_memberships(
    context: ToolContext,
    group_identifier: Annotated[
        str,
        "The unique ID of the group to fetch its members. Only members or admins can access this.",
    ],
    max_items_per_page: Annotated[
        int | None, "Specify the maximum number of members to retrieve per page."
    ] = None,
    response_offset: Annotated[
        int | None,
        "The starting point for retrieving members. Must not exceed 10000 to avoid errors.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_groups_id_memberships'."]:
    """Fetch members of a specified group.

    Retrieves all the members of a specified group. This tool should be called when you need to get a list of users in a group. Note that access is restricted to members of the group or users with admin-level permissions."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/groups/{group_id}/memberships".format(  # noqa: UP032
                group_id=group_identifier
            ),
            params=remove_none_values({"limit": max_items_per_page, "offset": response_offset}),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_group_collaborations(
    context: ToolContext,
    group_id: Annotated[
        str,
        "The unique identifier of the group whose collaborations you want to retrieve. This ID is required to specify the group.",  # noqa: E501
    ],
    max_items_per_page: Annotated[
        int | None,
        "Specifies the maximum number of collaboration items to return per page. Accepts an integer value.",  # noqa: E501
    ] = None,
    response_offset: Annotated[
        int | None,
        "Starting point in the list of collaborations. Must be an integer not exceeding 10000 to avoid rejection.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_groups_id_collaborations'."]:
    """Retrieve collaborations for a specified group.

    Fetches all collaborations associated with a group, including access details for files or folders. Requires admin permissions to view enterprise groups."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/groups/{group_id}/collaborations".format(  # noqa: UP032
                group_id=group_id
            ),
            params=remove_none_values({"limit": max_items_per_page, "offset": response_offset}),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def retrieve_group_membership(
    context: ToolContext,
    group_membership_id: Annotated[
        str,
        "The unique identifier for the specific group membership to retrieve. Only admins or users with admin-level permissions can access this information.",  # noqa: E501
    ],
    include_fields_list: Annotated[
        list[str] | None,
        "List of specific attributes to include in the response, overriding standard fields.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_group_memberships_id'."]:
    """Fetch details of a specific group membership.

    This tool retrieves details for a specific group membership. It should be called by group admins or users with admin-level permissions to access membership information."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/group_memberships/{group_membership_id}".format(  # noqa: UP032
                group_membership_id=group_membership_id
            ),
            params=remove_none_values({"fields": include_fields_list}),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def delete_group_membership(
    context: ToolContext,
    group_membership_id: Annotated[
        str,
        "The unique identifier for the group membership to be deleted. Required for specifying which membership to remove.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'delete_group_memberships_id'."]:
    """Delete a specific group membership by ID.

    This tool deletes a group membership identified by its ID. It should be used by group admins or users with admin-level permissions to remove a member from a group."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/group_memberships/{group_membership_id}".format(  # noqa: UP032
                group_membership_id=group_membership_id
            ),
            method="DELETE",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def list_defined_webhooks(
    context: ToolContext,
    pagination_start_marker: Annotated[
        str | None,
        "The position marker to start returning results from. Required for marker-based pagination with `usemarker` set to `true`.",  # noqa: E501
    ] = None,
    maximum_items_per_page: Annotated[
        int | None, "The maximum number of webhooks to return per page."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_webhooks'."]:
    """Retrieve all webhooks for your application.

    Used to get all webhooks defined for files or folders owned by the authenticated user. Note: Admins can't see webhooks created by service accounts unless they have access to those folders."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/webhooks",
            params=remove_none_values({
                "marker": pagination_start_marker,
                "limit": maximum_items_per_page,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_specific_webhook(
    context: ToolContext,
    webhook_id: Annotated[str, "The unique identifier of the webhook to retrieve details for."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_webhooks_id'."]:
    """Retrieve details of a specific webhook by ID.

    Use this tool to get information about a specific webhook by providing its ID. It retrieves details such as URL, triggers, and other related metadata."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/webhooks/{webhook_id}".format(webhook_id=webhook_id),  # noqa: UP032
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def delete_webhook(
    context: ToolContext,
    webhook_id: Annotated[
        str, "The unique identifier of the webhook to be deleted. It must be a valid string."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'delete_webhooks_id'."]:
    """Delete a specified webhook.

    This tool deletes a webhook when provided with its unique identifier. Use it to manage and remove webhooks that are no longer needed."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/webhooks/{webhook_id}".format(webhook_id=webhook_id),  # noqa: UP032
            method="DELETE",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_box_events(
    context: ToolContext,
    event_stream_type: Annotated[
        str | None,
        "Specifies the category of events to retrieve. Options: 'all' for all user events, 'changes' for file updates, 'sync' for synced folders, 'admin_logs' for full enterprise events (requires admin), and 'admin_logs_streaming' for live enterprise events (requires admin).",  # noqa: E501
    ] = None,
    event_stream_start_position: Annotated[
        str | None,
        "Specifies where to start receiving events in the stream. Use 'now' for initialization or '0' to retrieve all events.",  # noqa: E501
    ] = None,
    event_limit: Annotated[
        int | None,
        "The maximum number of events to retrieve. Fewer events may be returned if already available.",  # noqa: E501
    ] = None,
    event_type_filter: Annotated[
        list[str] | None,
        "List of event types to filter by. Only applicable for 'admin_logs' or 'admin_logs_streaming' stream types.",  # noqa: E501
    ] = None,
    event_start_date: Annotated[
        str | None,
        "The start date and time for filtering events. Used only with 'admin_logs' stream type.",
    ] = None,
    event_time_upper_bound: Annotated[
        str | None,
        "The upper bound date and time for returning events, used only with 'admin_logs' stream type. Ignored for other stream types.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_events'."]:
    """Retrieve up to a year of past events for a user or enterprise.

    Fetches past events for a specific user by default, or for the entire enterprise if the stream type is set. Requires admin privileges and appropriate application scope for enterprise events."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/events",
            params=remove_none_values({
                "stream_type": event_stream_type,
                "stream_position": event_stream_start_position,
                "limit": event_limit,
                "event_type": event_type_filter,
                "created_after": event_start_date,
                "created_before": event_time_upper_bound,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def retrieve_user_collections(
    context: ToolContext,
    requested_fields: Annotated[
        list[str] | None,
        "A list of attribute names to include in the response. Only specified fields will be returned along with the mini representation.",  # noqa: E501
    ] = None,
    pagination_offset: Annotated[
        int | None,
        "Offset of the item to start the response. Must be 10000 or less to avoid rejection with a 400 error.",  # noqa: E501
    ] = None,
    maximum_items_per_page: Annotated[
        int | None,
        "The maximum number of items to return per page when retrieving user collections.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_collections'."]:
    """Retrieve collections for a user, including favorites.

    This tool retrieves all collections for a specified user, currently supporting only the 'favorites' collection."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/collections",
            params=remove_none_values({
                "fields": requested_fields,
                "offset": pagination_offset,
                "limit": maximum_items_per_page,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def retrieve_collection_contents(
    context: ToolContext,
    collection_id: Annotated[
        str, "The unique identifier for the collection whose contents are to be retrieved."
    ],
    attributes_to_include: Annotated[
        list[str] | None,
        "List of attributes to include in the response. Only the specified fields will be returned alongside the mini representation.",  # noqa: E501
    ] = None,
    response_offset: Annotated[
        int | None,
        "The starting position in the collection. Must not exceed 10000 to avoid errors.",
    ] = None,
    max_items_per_page: Annotated[
        int | None,
        "Specifies the maximum number of items to return per page when retrieving the collection contents. This controls pagination and helps manage large datasets.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_collections_id_items'."]:
    """Fetch files and folders from a specific collection.

    This tool retrieves the files and/or folders contained within a specified collection. It should be called when a user needs to access or browse the contents of a particular collection using its ID."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/collections/{collection_id}/items".format(  # noqa: UP032
                collection_id=collection_id
            ),
            params=remove_none_values({
                "fields": attributes_to_include,
                "offset": response_offset,
                "limit": max_items_per_page,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def retrieve_collection_by_id(
    context: ToolContext,
    collection_identifier: Annotated[
        str, "The unique ID of the collection to retrieve details for."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_collections_id'."]:
    """Retrieve details of a collection using its ID.

    Use this tool to get detailed information about a specific collection by providing its ID."""
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/collections/{collection_id}".format(  # noqa: UP032
                collection_id=collection_identifier
            ),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_recent_items_info(
    context: ToolContext,
    include_additional_fields: Annotated[
        list[str] | None,
        "A list of attributes to include in the response, overriding the default fields.",
    ] = None,
    max_items_per_page: Annotated[
        int | None,
        "The maximum number of items to return per page when fetching recent items accessed by a user.",  # noqa: E501
    ] = None,
    pagination_start_marker: Annotated[
        str | None,
        "A position marker to begin returning results, used for marker-based pagination. Requires `usemarker=true`.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_recent_items'."]:
    """Fetch recent items accessed by a user in Box.

    Retrieves information on the most recent items a user has accessed in Box, up to 1000 items or within the last 90 days."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/recent_items",
            params=remove_none_values({
                "fields": include_additional_fields,
                "limit": max_items_per_page,
                "marker": pagination_start_marker,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_enterprise_retention_policies(
    context: ToolContext,
    filter_by_policy_name_prefix: Annotated[
        str | None, "Filter results using a case-sensitive prefix for retention policy names."
    ] = None,
    filter_by_retention_policy_type: Annotated[
        str | None, "Filter retention policies by type: 'finite' or 'indefinite'."
    ] = None,
    filter_by_creator_user_id: Annotated[
        str | None,
        "Filters the retention policies by the ID of the user who created them. Provide the user ID for specific filtering.",  # noqa: E501
    ] = None,
    include_fields: Annotated[
        list[str] | None,
        "A list of attributes to include in the response, replacing standard fields unless specified.",  # noqa: E501
    ] = None,
    maximum_items_per_page: Annotated[
        int | None, "The maximum number of retention policies to return per page."
    ] = None,
    pagination_start_marker: Annotated[
        str | None,
        "Defines the position marker to begin returning results for marker-based pagination.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_retention_policies'."]:
    """Retrieve all retention policies for an enterprise.

    This tool retrieves all retention policies associated with an enterprise. Use it to get a comprehensive list of retention policies."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/retention_policies",
            params=remove_none_values({
                "policy_name": filter_by_policy_name_prefix,
                "policy_type": filter_by_retention_policy_type,
                "created_by_user_id": filter_by_creator_user_id,
                "fields": include_fields,
                "limit": maximum_items_per_page,
                "marker": pagination_start_marker,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_retention_policy(
    context: ToolContext,
    retention_policy_id: Annotated[
        str,
        "The ID of the retention policy to retrieve details for. This ID is essential for accessing the specific policy information.",  # noqa: E501
    ],
    include_attributes: Annotated[
        list[str] | None,
        "List of attributes to include in the response. Standard fields are omitted unless explicitly specified.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_retention_policies_id'."]:
    """Retrieve details of a specified retention policy.

    Use this tool to get details about a specific retention policy using its ID. It should be called when you need to understand or display the specifics of a particular retention policy."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/retention_policies/{retention_policy_id}".format(  # noqa: UP032
                retention_policy_id=retention_policy_id
            ),
            params=remove_none_values({"fields": include_attributes}),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def delete_retention_policy(
    context: ToolContext,
    retention_policy_id: Annotated[
        str, "The unique identifier of the retention policy to be permanently deleted."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'delete_retention_policies_id'."]:
    """Permanently deletes a specified retention policy.

    Use this tool to permanently delete a retention policy by its ID. It should be called when there is a need to remove a retention policy completely."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/retention_policies/{retention_policy_id}".format(  # noqa: UP032
                retention_policy_id=retention_policy_id
            ),
            method="DELETE",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_retention_policy_assignments(
    context: ToolContext,
    retention_policy_id: Annotated[
        str, "The unique identifier of the retention policy to retrieve assignments for."
    ],
    assignment_type: Annotated[
        str | None,
        "The type of retention policy assignment to retrieve, such as 'folder', 'enterprise', or 'metadata_template'.",  # noqa: E501
    ] = None,
    include_fields_in_response: Annotated[
        list[str] | None,
        "A list of attribute names to include in the response. These specify additional fields to return beyond the standard response.",  # noqa: E501
    ] = None,
    pagination_start_marker: Annotated[
        str | None, "The position marker to begin returning results for marker-based pagination."
    ] = None,
    max_items_per_page: Annotated[
        int | None,
        "The maximum number of items to return per page when retrieving retention policy assignments.",  # noqa: E501
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get_retention_policies_id_assignments'."
]:
    """Retrieve retention policy assignments by policy ID.

    This tool returns a list of all retention policy assignments associated with a specified retention policy ID."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/retention_policies/{retention_policy_id}/assignments".format(  # noqa: UP032
                retention_policy_id=retention_policy_id
            ),
            params=remove_none_values({
                "type": assignment_type,
                "fields": include_fields_in_response,
                "marker": pagination_start_marker,
                "limit": max_items_per_page,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def retrieve_retention_policy_assignment(
    context: ToolContext,
    retention_policy_assignment_id: Annotated[
        str, "The ID of the specific retention policy assignment to retrieve details for."
    ],
    include_fields_in_response: Annotated[
        list[str] | None,
        "A list of attributes to include in the response. If specified, standard fields are excluded unless explicitly mentioned.",  # noqa: E501
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get_retention_policy_assignments_id'."
]:
    """Fetch details of a retention policy assignment by ID.

    Use this tool to retrieve information about a specific retention policy assignment by providing the assignment ID. Useful for managing and reviewing data retention policies in Box."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/retention_policy_assignments/{retention_policy_assignment_id}".format(  # noqa: UP032
                retention_policy_assignment_id=retention_policy_assignment_id
            ),
            params=remove_none_values({"fields": include_fields_in_response}),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def remove_retention_policy_assignment(
    context: ToolContext,
    retention_policy_assignment_id: Annotated[
        str, "The unique identifier for the retention policy assignment to be removed."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'delete_retention_policy_assignments_id'."
]:
    """Removes a retention policy assignment from content.

    This tool is used to delete a specific retention policy assignment identified by its ID. It should be called when you need to remove the association of retention policies from specific content."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/retention_policy_assignments/{retention_policy_assignment_id}".format(  # noqa: UP032
                retention_policy_assignment_id=retention_policy_assignment_id
            ),
            method="DELETE",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def list_files_under_retention_policy(
    context: ToolContext,
    retention_policy_assignment_id: Annotated[
        str,
        "The ID of the retention policy assignment used to identify which retention policy's files to retrieve.",  # noqa: E501
    ],
    position_marker: Annotated[
        str | None,
        "A string to define where to start returning results for pagination using marker-based pagination. Requires `usemarker` to be `true`.",  # noqa: E501
    ] = None,
    max_items_per_page: Annotated[
        int | None,
        "The maximum number of files to retrieve per page. Determines the page size for the results.",  # noqa: E501
    ] = None,
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'get_retention_policy_assignments_id_files_under_retention'.",
]:
    """Retrieve files under a retention policy assignment.

    This tool fetches a list of files that are under retention for a given retention policy assignment ID. It should be called when you need to identify files associated with a specific retention policy."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/retention_policy_assignments/{retention_policy_assignment_id}/files_under_retention".format(  # noqa: UP032
                retention_policy_assignment_id=retention_policy_assignment_id
            ),
            params=remove_none_values({"marker": position_marker, "limit": max_items_per_page}),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_file_versions_under_retention(
    context: ToolContext,
    retention_policy_assignment_id: Annotated[
        str, "The ID of the retention policy assignment to retrieve file versions under retention."
    ],
    pagination_start_marker: Annotated[
        str | None,
        "Defines the position marker to start returning results. Requires `usemarker` to be `true` for marker-based pagination.",  # noqa: E501
    ] = None,
    max_items_per_page: Annotated[
        int | None,
        "Specifies the maximum number of file versions to return per page during retrieval.",
    ] = None,
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'get_retention_policy_assignments_id_file_versions_under_retention'.",  # noqa: E501
]:
    """Fetch file versions under a specific retention policy assignment.

    This tool retrieves a list of file versions that are currently under retention for a specified retention policy assignment. Use it to manage or review file retention statuses."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/retention_policy_assignments/{retention_policy_assignment_id}/file_versions_under_retention".format(  # noqa: UP032
                retention_policy_assignment_id=retention_policy_assignment_id
            ),
            params=remove_none_values({
                "marker": pagination_start_marker,
                "limit": max_items_per_page,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def retrieve_legal_hold_policies(
    context: ToolContext,
    policy_name_prefix: Annotated[
        str | None,
        "Limits results to policies where names start with this term. It's case-insensitive.",
    ] = None,
    response_attributes: Annotated[
        list[str] | None,
        "A list of attributes to include in the response. Only the specified fields and mini representation fields will be returned.",  # noqa: E501
    ] = None,
    pagination_marker: Annotated[
        str | None,
        "The position marker to start returning results, used for marker-based pagination. Requires `usemarker` to be `true`.",  # noqa: E501
    ] = None,
    maximum_items_per_page: Annotated[
        int | None,
        "The maximum number of items to return per page. This controls the number of legal hold policies retrieved in a single request.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_legal_hold_policies'."]:
    """Retrieve a list of enterprise legal hold policies.

    Use this tool to obtain a list of legal hold policies associated with an enterprise. Ideal for managing or reviewing legal compliance requirements."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/legal_hold_policies",
            params=remove_none_values({
                "policy_name": policy_name_prefix,
                "fields": response_attributes,
                "marker": pagination_marker,
                "limit": maximum_items_per_page,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def retrieve_legal_hold_policy(
    context: ToolContext,
    legal_hold_policy_id: Annotated[
        str, "The unique identifier for the specific legal hold policy to retrieve."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_legal_hold_policies_id'."]:
    """Retrieve information about a specific legal hold policy.

    This tool is used to fetch details of a legal hold policy based on its ID. It should be called when users need to access information about a particular legal hold policy."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/legal_hold_policies/{legal_hold_policy_id}".format(  # noqa: UP032
                legal_hold_policy_id=legal_hold_policy_id
            ),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def delete_legal_hold_policy(
    context: ToolContext,
    legal_hold_policy_id: Annotated[
        str,
        "The ID of the legal hold policy to delete. This is necessary to identify and initiate the deletion of the specified policy.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'delete_legal_hold_policies_id'."]:
    """Initiate deletion of a legal hold policy.

    Use this tool to start the process of deleting an existing legal hold policy. The deletion is asynchronous, meaning the policy won't be fully deleted when the response is received."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/legal_hold_policies/{legal_hold_policy_id}".format(  # noqa: UP032
                legal_hold_policy_id=legal_hold_policy_id
            ),
            method="DELETE",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_legal_hold_policy_assignments(
    context: ToolContext,
    legal_hold_policy_id: Annotated[
        str, "The unique identifier for the legal hold policy to retrieve assignments for."
    ],
    filter_by_assignment_type: Annotated[
        str | None,
        "Specify the type of item (e.g., file, folder, user, etc.) the policy was applied to. Choices: ['file', 'file_version', 'folder', 'user', 'ownership', 'interactions'].",  # noqa: E501
    ] = None,
    filter_by_item_id: Annotated[
        str | None, "Filters results by the ID of the item the policy was applied to."
    ] = None,
    pagination_marker: Annotated[
        str | None,
        "Specifies the position to start retrieving results using marker-based pagination. Requires `usemarker` to be set to `true`.",  # noqa: E501
    ] = None,
    maximum_items_per_page: Annotated[
        int | None,
        "Set the maximum number of items to retrieve per page for optimal pagination control.",
    ] = None,
    response_fields: Annotated[
        list[str] | None,
        "List of attributes to include in the response, overriding standard fields unless specified.",  # noqa: E501
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get_legal_hold_policy_assignments'."
]:
    """Retrieve items assigned to a legal hold policy.

    Use this tool to fetch all items that have been associated with a specific legal hold policy."""
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/legal_hold_policy_assignments",
            params=remove_none_values({
                "policy_id": legal_hold_policy_id,
                "assign_to_type": filter_by_assignment_type,
                "assign_to_id": filter_by_item_id,
                "marker": pagination_marker,
                "limit": maximum_items_per_page,
                "fields": response_fields,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def retrieve_legal_hold_policy_assignment(
    context: ToolContext,
    legal_hold_policy_assignment_id: Annotated[
        str, "The unique identifier for the legal hold policy assignment to retrieve details about."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get_legal_hold_policy_assignments_id'."
]:
    """Retrieve details of a specific legal hold policy assignment.

    Use this tool to get information about a specific legal hold policy assignment by its ID. It provides details such as the policy name, status, and related information."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/legal_hold_policy_assignments/{legal_hold_policy_assignment_id}".format(  # noqa: UP032
                legal_hold_policy_assignment_id=legal_hold_policy_assignment_id
            ),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def remove_legal_hold_from_item(
    context: ToolContext,
    legal_hold_policy_assignment_id: Annotated[
        str,
        "The unique identifier for the legal hold policy assignment you wish to remove. This value is necessary to initiate the removal process.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'delete_legal_hold_policy_assignments_id'."
]:
    """Initiate removal of a legal hold from an item.

    Use this tool to start the process of removing a legal hold from a specific item. It is an asynchronous operation, meaning the hold is not fully removed immediately upon response."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/legal_hold_policy_assignments/{legal_hold_policy_assignment_id}".format(  # noqa: UP032
                legal_hold_policy_assignment_id=legal_hold_policy_assignment_id
            ),
            method="DELETE",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_files_on_legal_hold(
    context: ToolContext,
    legal_hold_policy_assignment_id: Annotated[
        str, "The ID of the legal hold policy assignment to retrieve files currently on hold."
    ],
    pagination_marker: Annotated[
        str | None,
        "Position marker for starting the result set when using marker-based pagination. Requires the 'usemarker' parameter to be true.",  # noqa: E501
    ] = None,
    maximum_items_per_page: Annotated[
        int | None,
        "The maximum number of items to return per page. Use this to control pagination size.",
    ] = None,
    included_attributes: Annotated[
        list[str] | None,
        "A list of specific attributes to include in the response. Only these attributes will be returned unless others are explicitly specified. Use this to customize the response fields.",  # noqa: E501
    ] = None,
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'get_legal_hold_policy_assignments_id_files_on_hold'.",
]:
    """Retrieve files currently on legal hold for a specific assignment.

    This tool retrieves a list of files with their current versions that are under a legal hold for a specified assignment. It should be used when you need to know which files are currently on hold for legal purposes associated with a specific legal hold policy assignment."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/legal_hold_policy_assignments/{legal_hold_policy_assignment_id}/files_on_hold".format(  # noqa: UP032
                legal_hold_policy_assignment_id=legal_hold_policy_assignment_id
            ),
            params=remove_none_values({
                "marker": pagination_marker,
                "limit": maximum_items_per_page,
                "fields": included_attributes,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_file_version_retentions(
    context: ToolContext,
    filter_by_file_id: Annotated[
        str | None, "Filters results to include only files with this specific file ID."
    ] = None,
    filter_by_file_version_id: Annotated[
        str | None, "Filters results by file versions matching this ID."
    ] = None,
    retention_policy_id: Annotated[
        str | None, "Filter results by the specific retention policy ID."
    ] = None,
    filter_by_disposition_action: Annotated[
        str | None,
        "Filter results based on the retention policy's disposition action, such as 'permanently_delete' or 'remove_retention'.",  # noqa: E501
    ] = None,
    filter_by_disposition_before_date: Annotated[
        str | None,
        "Provide a date to filter results by files that will have their disposition come into effect before this date. Format: YYYY-MM-DD.",  # noqa: E501
    ] = None,
    disposition_effective_after_date: Annotated[
        str | None,
        "Filter results by files with disposition effective after this date. Use ISO 8601 format (e.g., '2023-10-01').",  # noqa: E501
    ] = None,
    max_items_per_page: Annotated[
        int | None, "The maximum number of items to return per page."
    ] = None,
    pagination_start_marker: Annotated[
        str | None,
        "Defines the starting point for paginated results using a position marker. Requires marker-based pagination to be enabled.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_file_version_retentions'."]:
    """Retrieve file version retentions for an enterprise.

    Retrieves all file version retentions for a specified enterprise. Note that this API is deprecated; consider using newer alternatives for files and file versions under retention."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/file_version_retentions",
            params=remove_none_values({
                "file_id": filter_by_file_id,
                "file_version_id": filter_by_file_version_id,
                "policy_id": retention_policy_id,
                "disposition_action": filter_by_disposition_action,
                "disposition_before": filter_by_disposition_before_date,
                "disposition_after": disposition_effective_after_date,
                "limit": max_items_per_page,
                "marker": pagination_start_marker,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_file_versions_on_legal_hold(
    context: ToolContext,
    legal_hold_policy_assignment_id: Annotated[
        str, "The ID of the legal hold policy assignment to retrieve previous file versions for."
    ],
    pagination_start_marker: Annotated[
        str | None,
        "Defines the position marker to start returning results for paginated data retrieval. Requires `usemarker` to be set to `true`.",  # noqa: E501
    ] = None,
    max_items_per_page: Annotated[
        int | None, "The maximum number of items to return per page when retrieving file versions."
    ] = None,
    include_additional_fields_in_response: Annotated[
        list[str] | None,
        "List of attribute names to include in the response. Only specified fields and mini representation fields will be returned.",  # noqa: E501
    ] = None,
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'get_legal_hold_policy_assignments_id_file_versions_on_hold'.",
]:
    """Retrieve previous file versions under a legal hold assignment.

    Use this tool to obtain a list of previous file versions associated with a specific legal hold policy assignment. For current versions, use a different endpoint. This tool focuses on past file versions within the ongoing system architecture. It excludes content held due to custodian collaborations on a Hub."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/legal_hold_policy_assignments/{legal_hold_policy_assignment_id}/file_versions_on_hold".format(  # noqa: UP032
                legal_hold_policy_assignment_id=legal_hold_policy_assignment_id
            ),
            params=remove_none_values({
                "marker": pagination_start_marker,
                "limit": max_items_per_page,
                "fields": include_additional_fields_in_response,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_file_version_retention_info(
    context: ToolContext,
    file_version_retention_id: Annotated[
        str,
        "The ID of the specific file version retention to retrieve information for. This is required to access retention details.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_file_version_retentions_id'."]:
    """Retrieve details of a file version retention.

    This tool provides information about a specific file version retention. Note that the file retention API is deprecated. For details on files and file versions under retention, refer to alternative endpoints."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/file_version_retentions/{file_version_retention_id}".format(  # noqa: UP032
                file_version_retention_id=file_version_retention_id
            ),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def retrieve_file_version_legal_holds(
    context: ToolContext,
    file_version_legal_hold_id: Annotated[
        str,
        "The unique identifier of the file version legal hold to retrieve specific legal hold policy details.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_file_version_legal_holds_id'."]:
    """Get details of legal holds on a specific file version.

    Use this tool to retrieve information about legal hold policies assigned to a specific file version. This is useful for compliance and legal purposes when you need to know which legal holds are applied."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/file_version_legal_holds/{file_version_legal_hold_id}".format(  # noqa: UP032
                file_version_legal_hold_id=file_version_legal_hold_id
            ),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_legacy_file_version_legal_holds(
    context: ToolContext,
    legal_hold_policy_id: Annotated[
        str,
        "The ID of the legal hold policy for which file version legal holds need to be retrieved.",
    ],
    pagination_marker: Annotated[
        str | None,
        "A string that defines the starting point for marker-based pagination. Requires `usemarker` to be true.",  # noqa: E501
    ] = None,
    max_items_per_page: Annotated[
        int | None, "Specify the maximum number of items to return per page for the request."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_file_version_legal_holds'."]:
    """Retrieve file versions on legal hold in the legacy system.

    This endpoint fetches file versions under legal hold in the legacy architecture for a specific legal hold assignment. It may not return all file versions for the policy ID. For file versions held in the new architecture, refer to the appropriate newer endpoints. This API will be deprecated after re-architecture completion."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/file_version_legal_holds",
            params=remove_none_values({
                "policy_id": legal_hold_policy_id,
                "marker": pagination_marker,
                "limit": max_items_per_page,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_shield_information_barrier(
    context: ToolContext,
    shield_information_barrier_id: Annotated[
        str, "The unique identifier for the shield information barrier to be retrieved."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get_shield_information_barriers_id'."
]:
    """Retrieve shield information barrier by ID.

    Use this tool to get details of a shield information barrier using its ID."""
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/shield_information_barriers/{shield_information_barrier_id}".format(  # noqa: UP032
                shield_information_barrier_id=shield_information_barrier_id
            ),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_shield_information_barriers(
    context: ToolContext,
    pagination_marker: Annotated[
        str | None,
        "Defines the starting point for paginated results using marker-based pagination.",
    ] = None,
    max_items_per_page: Annotated[
        int | None,
        "The maximum number of shield information barrier objects to return per page. This controls the pagination size.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_shield_information_barriers'."]:
    """Retrieve shield information barriers for the enterprise.

    This tool fetches a list of shield information barrier objects associated with the enterprise according to the JWT."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/shield_information_barriers",
            params=remove_none_values({"marker": pagination_marker, "limit": max_items_per_page}),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_shield_information_barrier_reports(
    context: ToolContext,
    shield_information_barrier_id: Annotated[
        str,
        "The unique identifier for the shield information barrier whose reports need to be fetched.",  # noqa: E501
    ],
    pagination_marker: Annotated[
        str | None,
        "Position marker to start returning results for pagination. Requires 'usemarker' set to 'true'.",  # noqa: E501
    ] = None,
    maximum_items_per_page: Annotated[
        int | None,
        "The maximum number of shield information barrier reports to return per page. This integer value controls the page size for result sets.",  # noqa: E501
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get_shield_information_barrier_reports'."
]:
    """Retrieve shield information barrier reports.

    This tool fetches a list of reports related to shield information barriers, which can be used to understand and analyze the barriers in place."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/shield_information_barrier_reports",
            params=remove_none_values({
                "shield_information_barrier_id": shield_information_barrier_id,
                "marker": pagination_marker,
                "limit": maximum_items_per_page,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def fetch_shield_barrier_report(
    context: ToolContext,
    shield_barrier_report_id: Annotated[
        str, "The unique ID of the shield information barrier report to retrieve."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get_shield_information_barrier_reports_id'."
]:
    """Retrieve details of a shield information barrier report by ID.

    Use this tool to get information about a specific shield information barrier report by providing its unique ID."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/shield_information_barrier_reports/{shield_information_barrier_report_id}".format(  # noqa: UP032
                shield_information_barrier_report_id=shield_barrier_report_id
            ),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_shield_info_barrier_segment(
    context: ToolContext,
    barrier_segment_id: Annotated[
        str, "The unique ID of the shield information barrier segment to be retrieved."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get_shield_information_barrier_segments_id'."
]:
    """Retrieve shield information barrier segment by ID.

    Use this tool to obtain details about a shield information barrier segment using its ID."""
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/shield_information_barrier_segments/{shield_information_barrier_segment_id}".format(  # noqa: UP032
                shield_information_barrier_segment_id=barrier_segment_id
            ),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def delete_shield_information_barrier_segment(
    context: ToolContext,
    shield_information_barrier_segment_id: Annotated[
        str,
        "The ID of the shield information barrier segment to delete. This should be a valid string representing the segment's unique identifier.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'delete_shield_information_barrier_segments_id'.",
]:
    """Delete a shield information barrier segment by ID.

    Use this tool to delete a specific shield information barrier segment by providing its ID."""
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/shield_information_barrier_segments/{shield_information_barrier_segment_id}".format(  # noqa: UP032
                shield_information_barrier_segment_id=shield_information_barrier_segment_id
            ),
            method="DELETE",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_shield_information_barrier_segments(
    context: ToolContext,
    shield_information_barrier_id: Annotated[
        str,
        "The unique identifier for the shield information barrier that specifies the segment objects to retrieve.",  # noqa: E501
    ],
    pagination_position_marker: Annotated[
        str | None,
        "Defines the position marker to start returning results from, used for marker-based pagination. Requires usemarker to be true.",  # noqa: E501
    ] = None,
    maximum_items_per_page: Annotated[
        int | None,
        "The maximum number of shield information barrier segment items to return in a single request. Ideal for controlling page size during pagination.",  # noqa: E501
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get_shield_information_barrier_segments'."
]:
    """Retrieve shield information barrier segment details.

    Use this tool to fetch details of shield information barrier segment objects for a specified Information Barrier ID."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/shield_information_barrier_segments",
            params=remove_none_values({
                "shield_information_barrier_id": shield_information_barrier_id,
                "marker": pagination_position_marker,
                "limit": maximum_items_per_page,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_shield_info_barrier_member(
    context: ToolContext,
    member_id: Annotated[
        str, "The ID of the shield information barrier segment member to retrieve details for."
    ],
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'get_shield_information_barrier_segment_members_id'.",
]:
    """Retrieve details of a shield information barrier segment member.

    This tool retrieves details about a specific shield information barrier segment member based on its ID."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/shield_information_barrier_segment_members/{shield_information_barrier_segment_member_id}".format(  # noqa: UP032
                shield_information_barrier_segment_member_id=member_id
            ),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def remove_shield_barrier_member(
    context: ToolContext,
    member_id_for_deletion: Annotated[
        str, "The ID of the shield information barrier segment member to be deleted."
    ],
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'delete_shield_information_barrier_segment_members_id'.",
]:
    """Delete a shield information barrier segment member by ID.

    This tool deletes a member from a shield information barrier segment using the provided member ID. Use this to manage and update segment member lists."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/shield_information_barrier_segment_members/{shield_information_barrier_segment_member_id}".format(  # noqa: UP032
                shield_information_barrier_segment_member_id=member_id_for_deletion
            ),
            method="DELETE",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def list_shield_barrier_segment_members(
    context: ToolContext,
    segment_id: Annotated[
        str, "The ID of the shield information barrier segment to retrieve members for."
    ],
    pagination_marker: Annotated[
        str | None,
        "The position marker to begin returning paginated results. Requires `usemarker` to be `true`.",  # noqa: E501
    ] = None,
    items_per_page_limit: Annotated[
        int | None,
        "The maximum number of segment members to return per page. Use this to control pagination by specifying the number of results per page.",  # noqa: E501
    ] = None,
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'get_shield_information_barrier_segment_members'.",
]:
    """Retrieve members of shield information barrier segments.

    This tool lists the members of shield information barrier segments based on provided segment IDs. It should be called when there's a need to identify or review members within these segments."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/shield_information_barrier_segment_members",
            params=remove_none_values({
                "shield_information_barrier_segment_id": segment_id,
                "marker": pagination_marker,
                "limit": items_per_page_limit,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_shield_information_barrier_segment_info(
    context: ToolContext,
    segment_restriction_id: Annotated[
        str, "The unique identifier for the shield information barrier segment restriction."
    ],
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'get_shield_information_barrier_segment_restrictions_id'.",
]:
    """Retrieve shield barrier segment restriction by ID.

    This tool retrieves details of a shield information barrier segment restriction using the specified ID."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/shield_information_barrier_segment_restrictions/{shield_information_barrier_segment_restriction_id}".format(  # noqa: UP032
                shield_information_barrier_segment_restriction_id=segment_restriction_id
            ),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def delete_shield_barrier_segment_restriction(
    context: ToolContext,
    barrier_segment_restriction_id: Annotated[
        str, "The ID of the shield information barrier segment restriction to delete."
    ],
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'delete_shield_information_barrier_segment_restrictions_id'.",
]:
    """Delete a specific shield barrier segment restriction by ID."""
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/shield_information_barrier_segment_restrictions/{shield_information_barrier_segment_restriction_id}".format(  # noqa: UP032
                shield_information_barrier_segment_restriction_id=barrier_segment_restriction_id
            ),
            method="DELETE",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_shield_information_restrictions(
    context: ToolContext,
    segment_id: Annotated[
        str,
        "The unique identifier for the shield information barrier segment to retrieve restrictions.",  # noqa: E501
    ],
    pagination_position_marker: Annotated[
        str | None,
        "Defines the position marker to begin results, used for marker-based pagination. Requires `usemarker` to be `true`.",  # noqa: E501
    ] = None,
    max_items_per_page: Annotated[
        int | None,
        "The maximum number of items to return per page when retrieving shield information barrier segment restrictions.",  # noqa: E501
    ] = None,
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'get_shield_information_barrier_segment_restrictions'.",
]:
    """Retrieve restrictions for a shield information barrier segment.

    Use this tool to list restrictions for a specific shield information barrier segment based on its ID."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/shield_information_barrier_segment_restrictions",
            params=remove_none_values({
                "shield_information_barrier_segment_id": segment_id,
                "marker": pagination_position_marker,
                "limit": max_items_per_page,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_device_pin_info(
    context: ToolContext,
    device_pin_identifier: Annotated[
        str, "The unique identifier for the device pin to retrieve information about."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_device_pinners_id'."]:
    """Retrieve details of a specific device pin.

    This tool fetches information about a specific device pin by its identifier. It should be called when detailed information about a particular device pin is needed."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/device_pinners/{device_pinner_id}".format(  # noqa: UP032
                device_pinner_id=device_pin_identifier
            ),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def delete_device_pin(
    context: ToolContext,
    device_pin_id: Annotated[str, "The unique identifier of the device pin to be deleted."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'delete_device_pinners_id'."]:
    """Delete a specific device pin from the system.

    This tool is used to delete a specified device pin by its unique identifier. It should be called when there is a need to remove a device pin."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/device_pinners/{device_pinner_id}".format(  # noqa: UP032
                device_pinner_id=device_pin_id
            ),
            method="DELETE",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_enterprise_device_pins(
    context: ToolContext,
    enterprise_id: Annotated[
        str,
        "The unique identifier for the enterprise whose device pins are to be retrieved. This is a mandatory field.",  # noqa: E501
    ],
    pagination_start_marker: Annotated[
        str | None,
        "Defines the starting position for paginated results. Requires 'usemarker' to be true.",
    ] = None,
    max_items_per_page: Annotated[
        int | None, "The maximum number of device pins to retrieve per page."
    ] = None,
    sort_direction: Annotated[
        str | None,
        "The direction to sort results: alphabetical ascending ('ASC') or descending ('DESC').",
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get_enterprises_id_device_pinners'."
]:
    """Retrieve all device pins for a specific enterprise.

    This tool should be used to retrieve all device pins within a specified enterprise. It requires admin privileges and the application needs the 'manage enterprise' scope to access the data."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/enterprises/{enterprise_id}/device_pinners".format(  # noqa: UP032
                enterprise_id=enterprise_id
            ),
            params=remove_none_values({
                "marker": pagination_start_marker,
                "limit": max_items_per_page,
                "direction": sort_direction,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_enterprise_terms_of_service(
    context: ToolContext,
    terms_of_service_type: Annotated[
        str | None,
        "Specify the type of terms of service to retrieve. Options are 'external' or 'managed'.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_terms_of_services'."]:
    """Retrieve the enterprise's terms of service.

    This tool fetches the most recent terms of service text and settings for the enterprise. Use it to obtain or verify the terms currently in effect."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/terms_of_services",
            params=remove_none_values({"tos_type": terms_of_service_type}),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_specific_terms_of_service(
    context: ToolContext,
    terms_of_service_id: Annotated[
        str, "The unique identifier for the terms of service to be fetched."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_terms_of_services_id'."]:
    """Fetches details of a specific terms of service.

    Use this tool to retrieve information about a specific terms of service using its ID."""
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/terms_of_services/{terms_of_service_id}".format(  # noqa: UP032
                terms_of_service_id=terms_of_service_id
            ),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_user_tos_status(
    context: ToolContext,
    terms_of_service_id: Annotated[
        str, "The unique identifier for the specific terms of service document."
    ],
    filter_by_user_id: Annotated[
        str | None,
        "Limits results to the specified user ID for retrieving their terms of service acceptance status.",  # noqa: E501
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get_terms_of_service_user_statuses'."
]:
    """Retrieve user acceptance status for terms of service.

    This tool retrieves information about users and their status regarding terms of service acceptance, including whether they have accepted the terms and when."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/terms_of_service_user_statuses",
            params=remove_none_values({
                "tos_id": terms_of_service_id,
                "user_id": filter_by_user_id,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_safe_collaboration_domains(
    context: ToolContext,
    pagination_start_marker: Annotated[
        str | None,
        "The position marker to begin returning results, used for marker-based pagination. Requires `usemarker` to be `true`.",  # noqa: E501
    ] = None,
    maximum_items_per_page: Annotated[
        int | None,
        "The maximum number of domains to return per page. Adjust this to control the page size of results.",  # noqa: E501
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get_collaboration_whitelist_entries'."
]:
    """Retrieve domains approved for safe collaboration.

    Use this tool to get a list of domains that are considered safe for creating collaborations within the current enterprise environment."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/collaboration_whitelist_entries",
            params=remove_none_values({
                "marker": pagination_start_marker,
                "limit": maximum_items_per_page,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def fetch_safe_collaboration_domain(
    context: ToolContext,
    collaboration_whitelist_entry_id: Annotated[
        str,
        "The ID of the trusted domain entry in the whitelist. Provide this to retrieve its details.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get_collaboration_whitelist_entries_id'."
]:
    """Retrieve a designated safe collaboration domain within an enterprise.

    This tool is used to obtain information about a domain that has been marked as safe for creating collaborations within the current enterprise. It should be called when there is a need to verify if a domain can be trusted for collaboration purposes."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/collaboration_whitelist_entries/{collaboration_whitelist_entry_id}".format(  # noqa: UP032
                collaboration_whitelist_entry_id=collaboration_whitelist_entry_id
            ),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def remove_safe_collaboration_domain(
    context: ToolContext,
    whitelist_entry_id: Annotated[
        str,
        "The unique identifier for the domain entry in the safe collaboration list to be removed.",
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'delete_collaboration_whitelist_entries_id'."
]:
    """Remove a domain from the safe collaboration list.

    Use this tool to delete a domain from the list of approved domains for collaborations in the enterprise."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/collaboration_whitelist_entries/{collaboration_whitelist_entry_id}".format(  # noqa: UP032
                collaboration_whitelist_entry_id=whitelist_entry_id
            ),
            method="DELETE",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_collaboration_whitelist_exempt_users(
    context: ToolContext,
    pagination_position_marker: Annotated[
        str | None,
        "Start position for returning results. Used for marker-based pagination. Requires `usemarker` set to `true`.",  # noqa: E501
    ] = None,
    max_items_per_page: Annotated[
        int | None, "The maximum number of users to return per page. Controls pagination size."
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get_collaboration_whitelist_exempt_targets'."
]:
    """Retrieve users exempt from collaboration restrictions.

    Use this tool to obtain a list of users who are not restricted by collaboration domain rules. It provides a quick way to identify exempt users."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/collaboration_whitelist_exempt_targets",
            params=remove_none_values({
                "marker": pagination_position_marker,
                "limit": max_items_per_page,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_collaboration_whitelist_exempt_user(
    context: ToolContext,
    exemption_target_id: Annotated[
        str,
        "The ID of the user who is exempt from collaboration domain restrictions. This ID is required to retrieve specific user details.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'get_collaboration_whitelist_exempt_targets_id'.",
]:
    """Retrieve user exempt from collaboration restrictions.

    This tool retrieves information about a user who is exempt from collaboration domain restrictions. It should be called when there is a need to identify such exempt users."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/collaboration_whitelist_exempt_targets/{collaboration_whitelist_exempt_target_id}".format(  # noqa: UP032
                collaboration_whitelist_exempt_target_id=exemption_target_id
            ),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def remove_collaboration_whitelist_exemption(
    context: ToolContext,
    exemption_id: Annotated[
        str, "The ID of the user's exemption to be removed from the collaboration whitelist."
    ],
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'delete_collaboration_whitelist_exempt_targets_id'.",
]:
    """Remove a user's exemption from domain restrictions in collaborations.

    This tool is used to revoke a specific user's exemption from the list of allowed domains for collaborative activities, ensuring that the domain restrictions apply."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/collaboration_whitelist_exempt_targets/{collaboration_whitelist_exempt_target_id}".format(  # noqa: UP032
                collaboration_whitelist_exempt_target_id=exemption_id
            ),
            method="DELETE",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def fetch_enterprise_storage_policies(
    context: ToolContext,
    include_attributes: Annotated[
        list[str] | None,
        "An array of attribute names to include in the response. Specify attributes not normally returned in a standard response. Only mini representation fields and requested attributes will be returned.",  # noqa: E501
    ] = None,
    pagination_marker: Annotated[
        str | None,
        "Defines the starting position for returning results using marker-based pagination. Requires `usemarker` to be `true`.",  # noqa: E501
    ] = None,
    max_items_per_page: Annotated[
        int | None, "Specify the maximum number of storage policy items to return per page."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_storage_policies'."]:
    """Fetches all storage policies in the enterprise.

    Use this tool to retrieve a complete list of storage policies available within an enterprise."""
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/storage_policies",
            params=remove_none_values({
                "fields": include_attributes,
                "marker": pagination_marker,
                "limit": max_items_per_page,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def fetch_storage_policy(
    context: ToolContext,
    storage_policy_identifier: Annotated[
        str, "The unique ID of the storage policy to retrieve details for."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_storage_policies_id'."]:
    """Retrieve details of a specific storage policy.

    Use this tool to fetch information about a particular storage policy using its ID. It is useful when you need to view or verify details of a storage policy by its unique identifier."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/storage_policies/{storage_policy_id}".format(  # noqa: UP032
                storage_policy_id=storage_policy_identifier
            ),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def fetch_storage_policy_assignments(
    context: ToolContext,
    target_type_for_assignments: Annotated[
        str, "Specifies whether to return storage policy assignments for a 'user' or 'enterprise'."
    ],
    target_user_or_enterprise_id: Annotated[
        str, "The ID of the user or enterprise to fetch storage policy assignments for."
    ],
    pagination_marker: Annotated[
        str | None,
        "Defines the position marker to start returning results for pagination. Requires 'usemarker' to be true.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_storage_policy_assignments'."]:
    """Retrieve storage policy assignments for enterprise or user.

    Use this tool to fetch all storage policy assignments associated with a specific enterprise or user, providing insights into storage management configurations."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/storage_policy_assignments",
            params=remove_none_values({
                "marker": pagination_marker,
                "resolved_for_type": target_type_for_assignments,
                "resolved_for_id": target_user_or_enterprise_id,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def fetch_storage_policy_assignment(
    context: ToolContext,
    storage_policy_assignment_id: Annotated[
        str, "The unique identifier of the storage policy assignment to be retrieved."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get_storage_policy_assignments_id'."
]:
    """Retrieve a storage policy assignment by ID.

    This tool is used to fetch detailed information about a specific storage policy assignment using its unique ID. Call this tool when you need to get details about a particular storage policy assignment in the Box storage system."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/storage_policy_assignments/{storage_policy_assignment_id}".format(  # noqa: UP032
                storage_policy_assignment_id=storage_policy_assignment_id
            ),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def delete_storage_policy_assignment(
    context: ToolContext,
    storage_policy_assignment_id: Annotated[
        str,
        "The ID of the storage policy assignment to delete. This is required and identifies which assignment to delete, reverting the user to the default policy.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'delete_storage_policy_assignments_id'."
]:
    """Delete a user's storage policy assignment.

    Use this tool to delete a storage policy assignment for a user. After deletion, the user will inherit the enterprise's default storage policy. Note the rate limit of two deletions per user within 24 hours."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/storage_policy_assignments/{storage_policy_assignment_id}".format(  # noqa: UP032
                storage_policy_assignment_id=storage_policy_assignment_id
            ),
            method="DELETE",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def download_zip_content(
    context: ToolContext,
    zip_archive_unique_id: Annotated[
        str,
        "The unique identifier for the zip archive to be downloaded. This ID must be obtained from the 'Create zip download' API response.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_zip_downloads_id_content'."]:
    """Download the contents of a zip archive.

    This tool retrieves the contents of a zip archive from a specified URL, which is valid for a short time. It's useful for downloading the archive to a device, but remember that once a download starts, it cannot be paused or resumed. A new request must be created for a fresh URL."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/zip_downloads/{zip_download_id}/content".format(  # noqa: UP032
                zip_download_id=zip_archive_unique_id
            ),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def check_zip_download_status(
    context: ToolContext,
    zip_archive_unique_identifier: Annotated[
        str,
        "The unique identifier representing the zip archive for which to check download status. Obtainable from the `status_url` in the Create zip download API.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_zip_downloads_id_status'."]:
    """Check the status of a zip archive download.

    Use this tool to inspect the download progress of a zip archive, including the number of skipped items. This endpoint should be accessed after the download starts and is available for 12 hours. Follow the `status_url` obtained from the Create zip download API."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/zip_downloads/{zip_download_id}/status".format(  # noqa: UP032
                zip_download_id=zip_archive_unique_identifier
            ),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def cancel_sign_request(
    context: ToolContext,
    sign_request_id: Annotated[
        str, "The unique identifier of the signature request to be cancelled."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'post_sign_requests_id_cancel'."]:
    """Cancel an existing sign request to stop further processing.

    This tool cancels a sign request based on the provided sign request ID, preventing any further action on it."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/sign_requests/{sign_request_id}/cancel".format(  # noqa: UP032
                sign_request_id=sign_request_id
            ),
            method="POST",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def resend_signature_request_email(
    context: ToolContext,
    signature_request_id: Annotated[
        str,
        "The unique identifier of the signature request to resend emails to outstanding signers.",
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'post_sign_requests_id_resend'."]:
    """Resend signature request email to outstanding signers.

    This tool is used to resend a signature request email to all signers who have not yet completed the sign request. It should be called when you need to prompt signers again to complete a signing process."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/sign_requests/{sign_request_id}/resend".format(  # noqa: UP032
                sign_request_id=signature_request_id
            ),
            method="POST",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def retrieve_sign_request_by_id(
    context: ToolContext,
    signature_request_id: Annotated[
        str, "The unique identifier for the signature request to retrieve."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_sign_requests_id'."]:
    """Retrieve details of a specific sign request by ID.

    Use this tool to obtain information about a sign request using its unique identifier."""
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/sign_requests/{sign_request_id}".format(  # noqa: UP032
                sign_request_id=signature_request_id
            ),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def fetch_signature_requests(
    context: ToolContext,
    pagination_marker: Annotated[
        str | None,
        "Defines the starting point for returning results, used for marker-based pagination. Requires use_marker to be true.",  # noqa: E501
    ] = None,
    max_items_per_page: Annotated[
        int | None, "Specify the maximum number of signature requests to return per page."
    ] = None,
    sender_email_list: Annotated[
        list[str] | None,
        "A list of sender emails to filter the signature requests by sender. `shared_requests` must be `true` if provided.",  # noqa: E501
    ] = None,
    include_shared_requests: Annotated[
        bool | None,
        "Set to true to include signature requests where the user is a collaborator but not the owner. Must be true if sender emails are provided.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_sign_requests'."]:
    """Retrieve signature requests created by a user.

    Fetches a list of signature requests that have been created by a user. Signature requests won't be listed if their associated files or parent folder are deleted."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/sign_requests",
            params=remove_none_values({
                "marker": pagination_marker,
                "limit": max_items_per_page,
                "senders": sender_email_list,
                "shared_requests": include_shared_requests,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_manual_start_workflows(
    context: ToolContext,
    folder_id: Annotated[
        str,
        "The unique identifier representing a folder. You can find this by visiting the folder in the web application and copying the ID from the URL. The root folder is always represented by ID '0'.",  # noqa: E501
    ],
    trigger_type_filter: Annotated[
        str | None,
        "Specify the trigger type to search for in workflows. Use 'WORKFLOW_MANUAL_START' for manual triggers.",  # noqa: E501
    ] = None,
    max_items_per_page: Annotated[
        int | None,
        "The maximum number of workflows to retrieve per page. Adjust based on your needs to control pagination.",  # noqa: E501
    ] = None,
    pagination_marker: Annotated[
        str | None,
        "Specifies the position marker to start returning results. Used for marker-based pagination and requires `usemarker` to be set to `true`.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_workflows'."]:
    """Retrieve workflows with manual start triggers for a folder.

    Use this tool to get workflows associated with a specific folder ID that have a manual start trigger type. Ensure your application is authorized to use the 'Manage Box Relay' application scope."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/workflows",
            params=remove_none_values({
                "folder_id": folder_id,
                "trigger_type": trigger_type_filter,
                "limit": max_items_per_page,
                "marker": pagination_marker,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_box_sign_templates(
    context: ToolContext,
    pagination_marker: Annotated[
        str | None,
        "The starting position marker for result pagination. Requires `usemarker` to be set to `true`.",  # noqa: E501
    ] = None,
    max_items_per_page: Annotated[
        int | None, "The maximum number of templates to return in a single response."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_sign_templates'."]:
    """Retrieve Box Sign templates created by a user.

    Call this tool to get a list of all Box Sign templates that have been created by a specific user."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/sign_templates",
            params=remove_none_values({"marker": pagination_marker, "limit": max_items_per_page}),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def fetch_box_sign_template_details(
    context: ToolContext,
    box_sign_template_id: Annotated[
        str, "The unique identifier for a Box Sign template to retrieve its details."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_sign_templates_id'."]:
    """Retrieve details of a specific Box Sign template.

    This tool is used to fetch information about a specific Box Sign template by its ID. It should be called when users need to access detailed information about a sign template in Box."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/sign_templates/{template_id}".format(  # noqa: UP032
                template_id=box_sign_template_id
            ),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def list_slack_integration_mappings(
    context: ToolContext,
    pagination_start_marker: Annotated[
        str | None,
        "Defines the starting position for pagination results. Requires 'usemarker' to be true.",
    ] = None,
    max_items_per_page: Annotated[
        int | None,
        "The maximum number of Slack integration mappings to return per page from the user's enterprise.",  # noqa: E501
    ] = None,
    mapped_item_type: Annotated[
        str | None,
        "The type of mapped item for which the Slack integration mapping should be returned. Only 'channel' is supported.",  # noqa: E501
    ] = None,
    mapped_item_id: Annotated[
        str | None,
        "ID of the mapped item for which the Slack integration mapping should be retrieved.",
    ] = None,
    box_item_id: Annotated[
        str | None,
        "Box item ID for which to retrieve Slack integration mappings. Must be a valid ID within the user's enterprise.",  # noqa: E501
    ] = None,
    box_item_type: Annotated[
        str | None,
        "Specify the type of Box item for which the mappings should be returned. Currently, only 'folder' is supported.",  # noqa: E501
    ] = None,
    include_manually_created_mappings: Annotated[
        bool | None, "Set to true to include mappings that have been manually created."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_integration_mappings_slack'."]:
    """Retrieve Slack integration mappings for a Box enterprise.

    This tool is used to list Slack integration mappings within a user's enterprise on Box. It requires Admin or Co-Admin privileges."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/integration_mappings/slack",
            params=remove_none_values({
                "marker": pagination_start_marker,
                "limit": max_items_per_page,
                "partner_item_type": mapped_item_type,
                "partner_item_id": mapped_item_id,
                "box_item_id": box_item_id,
                "box_item_type": box_item_type,
                "is_manually_created": include_manually_created_mappings,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def delete_slack_integration_mapping(
    context: ToolContext,
    slack_integration_mapping_id: Annotated[
        str,
        "The ID of the Slack integration mapping to be deleted. This requires Admin or Co-Admin permission.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'delete_integration_mappings_slack_id'."
]:
    """Deletes a Slack integration mapping for Box content.

    This tool deletes a specified Slack integration mapping in Box. It requires admin or co-admin permissions. Use it when a Slack integration mapping needs to be removed."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/integration_mappings/slack/{integration_mapping_id}".format(  # noqa: UP032
                integration_mapping_id=slack_integration_mapping_id
            ),
            method="DELETE",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_teams_integration_mappings(
    context: ToolContext,
    mapped_item_type: Annotated[
        str | None,
        "Specify the type of item ('channel' or 'team') for which the mapping should be returned.",
    ] = None,
    mapped_item_id: Annotated[
        str | None,
        "The ID of the mapped item for which the mapping should be returned. Required for retrieving specific integration mappings.",  # noqa: E501
    ] = None,
    box_item_id_for_mappings: Annotated[
        str | None,
        "The Box item ID to retrieve integration mappings for. Required for fetching specific mappings.",  # noqa: E501
    ] = None,
    box_item_type: Annotated[
        str | None,
        "Specify the type of Box item for which the mappings should be returned. Acceptable value is 'folder'.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_integration_mappings_teams'."]:
    """Retrieve Teams integration mappings for an enterprise.

    This tool retrieves a list of Teams integration mappings within a user's enterprise. It requires Admin or Co-Admin access to execute this call."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/integration_mappings/teams",
            params=remove_none_values({
                "partner_item_type": mapped_item_type,
                "partner_item_id": mapped_item_id,
                "box_item_id": box_item_id_for_mappings,
                "box_item_type": box_item_type,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def delete_teams_integration_mapping(
    context: ToolContext,
    integration_mapping_identifier: Annotated[
        str,
        "The ID of the Teams integration mapping to be deleted. Required for identifying the specific mapping.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'delete_integration_mappings_teams_id'."
]:
    """Deletes a Teams integration mapping in Box.

    Use this tool to delete a Teams integration mapping in Box. Admin or Co-Admin roles are required to perform this action."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/integration_mappings/teams/{integration_mapping_id}".format(  # noqa: UP032
                integration_mapping_id=integration_mapping_identifier
            ),
            method="DELETE",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_ai_agent_default_config(
    context: ToolContext,
    filter_mode: Annotated[
        str,
        "Specifies the mode to filter and return the agent configuration. Options: 'ask', 'text_gen', 'extract', 'extract_structured'.",  # noqa: E501
    ],
    agent_config_language_code: Annotated[
        str | None,
        "The ISO language code to specify the language for the AI agent configuration. Default is returned if unsupported.",  # noqa: E501
    ] = None,
    model_identifier: Annotated[
        str | None,
        "Specify the model name to retrieve the default agent configuration. Ensure it matches the supported model names.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_ai_agent_default'."]:
    """Retrieve the default configuration for the AI agent.

    Call this tool to get the default settings and configurations for the AI agent. Useful for understanding the baseline setup or preparing to customize AI agent parameters."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/ai_agent_default",
            params=remove_none_values({
                "mode": filter_mode,
                "language": agent_config_language_code,
                "model": model_identifier,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def list_ai_agents(
    context: ToolContext,
    filter_by_mode: Annotated[
        list[str] | None,
        "List of modes to filter the agent configuration. Options: `ask`, `text_gen`, `extract`.",
    ] = None,
    response_fields: Annotated[
        list[str] | None,
        "List of fields to return for each AI agent in the response. Specify as an array of strings.",  # noqa: E501
    ] = None,
    agent_state_filter: Annotated[
        list[str] | None,
        "Specify the states of agents to return. Acceptable values include: 'enabled', 'disabled', and 'enabled_for_selected_users'.",  # noqa: E501
    ] = None,
    results_start_position_marker: Annotated[
        str | None,
        "The starting point marker for returning paginated results. Use this to continue a previous query from where it left off.",  # noqa: E501
    ] = None,
    max_items_per_page: Annotated[
        int | None, "The maximum number of AI agents to return for a single page of results."
    ] = None,
    include_box_default_agents: Annotated[
        bool | None,
        "Set to true to include Box default AI agents in the response, false otherwise.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_ai_agents'."]:
    """Retrieve a list of AI agents with specified parameters.

    This tool fetches AI agents from the service based on provided filters or parameters. It should be called when information about available AI agents is needed, such as their names, types, or statuses."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/ai_agents",
            params=remove_none_values({
                "mode": filter_by_mode,
                "fields": response_fields,
                "agent_state": agent_state_filter,
                "include_box_default": include_box_default_agents,
                "marker": results_start_position_marker,
                "limit": max_items_per_page,
            }),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def get_ai_agent_details(
    context: ToolContext,
    agent_unique_identifier: Annotated[
        str, "The unique identifier of the AI agent to retrieve details for."
    ],
    fields_to_return: Annotated[
        list[str] | None,
        "List of specific fields to return in the response for the AI agent details.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_ai_agents_id'."]:
    """Retrieve details of a specific AI agent by ID.

    Call this tool to get detailed information about a specific AI agent using their unique agent ID."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/ai_agents/{agent_id}".format(  # noqa: UP032
                agent_id=agent_unique_identifier
            ),
            params=remove_none_values({"fields": fields_to_return}),
            method="GET",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="box"))
async def delete_ai_agent(
    context: ToolContext,
    agent_id: Annotated[
        str,
        "The unique identifier of the AI agent you want to delete. This ID specifies which agent will be removed.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'delete_ai_agents_id'."]:
    """Removes an AI agent by its ID.

    This tool is used to delete an AI agent by specifying the agent's ID. It should be called when an AI agent needs to be removed from the system."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.box.com/2.0/ai_agents/{agent_id}".format(agent_id=agent_id),  # noqa: UP032
            method="DELETE",
            headers=remove_none_values({
                "box-version": "2024.0",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}
