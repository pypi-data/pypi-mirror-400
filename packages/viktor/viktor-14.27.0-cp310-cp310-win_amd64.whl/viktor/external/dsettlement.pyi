from ..core import Color, File
from .external_program import ExternalProgram
from _typeshed import Incomplete
from abc import ABCMeta, abstractmethod
from enum import Enum
from io import BytesIO, StringIO
from typing import Any

__all__ = ['CalculationModel', 'ConsolidationModel', 'DSettlementAnalysis', 'DrainGrid', 'DrainType', 'DrainageSimpleMode', 'Metadata', 'Model1D', 'Model2D', 'OutputFileParser', 'VerticalDrain']

class DSettlementAnalysis(ExternalProgram):
    '''
    DSettlementAnalysis can be used to perform an analysis using DSettlement on a third-party worker. To start an
    analysis call the method :meth:`~.ExternalProgram.execute`, with an appropriate timeout (in seconds).
    To retrieve the results call the method :meth:`get_output_file`, after :meth:`~.ExternalProgram.execute`.

    Usage:

    .. code-block:: python

        input_file = File.from_data("dsettlement input file body")
        dsettlement_analysis = DSettlementAnalysis(input_file=input_file)
        dsettlement_analysis.execute(timeout=10)
        output_file = dsettlement_analysis.get_output_file()  # obtain output file in BytesIO
        sld_file = dsettlement_analysis.get_sld_file()  # obtain sld file in StringIO (to post-process)

    Exceptions which can be raised during calculation:
    - :class:`viktor.errors.ExecutionError`: generic error. Error message provides more information
    '''
    input_file: Incomplete
    def __init__(self, input_file: BytesIO | File) -> None:
        """
        :param input_file: .sli input file.
        """
    def get_output_file(self, extension: str = '.sld', *, as_file: bool = False) -> BytesIO | File | None:
        """
        Method can be used to retrieve the results generated by running an external analysis. Call method
        :meth:`~.ExternalProgram.execute` first and :meth:`get_output_file` afterwards.

        :param extension: extension of the file you want to return; one of: '.sld', '.slo', '.error.log', '.err'
        :param as_file: return as BytesIO (default) or File ::version(v13.5.0)
        """
    def get_sld_file(self, *, as_file: bool = False) -> StringIO | File:
        """
        Method to retrieve the sld (result) file.

        :param as_file: return as StringIO (default) or File ::version(v13.5.0)

        :raise ValueError: if file can not be obtained.
        """

class CalculationModel(Enum):
    NEN_KOPPEJAN: CalculationModel
    NEN_BJERRUM: CalculationModel
    ISOTACHE: CalculationModel

class ConsolidationModel(Enum):
    DARCY: ConsolidationModel
    TERZAGHI: ConsolidationModel

class DrainType(Enum):
    STRIP: DrainType
    COLUMN: DrainType
    SAND_WALL: DrainType

class DrainGrid(Enum):
    TRIANGULAR: DrainGrid
    RECTANGULAR: DrainGrid
    UNDETERMINED: DrainGrid

class DrainageSimpleMode:
    begin_time: Incomplete
    end_time: Incomplete
    underpressure: Incomplete
    dewatering_head_or_pressure: Incomplete
    def __init__(self, begin_time: float, end_time: float, underpressure: float, dewatering_head_or_pressure: float) -> None:
        """ Simple drainage schema; to be used in VerticalDrain.

        :param begin_time: [days]
        :param end_time: [days]
        :param underpressure: [kPa]
        :param dewatering_head_or_pressure: water head [m] or tube pressure (if VerticalDrain.drain_type = SAND_WALL)
         [kPa]
        """

class Metadata:
    def __init__(self, file_name: str = '-', company: str = '-', created_by: str = '-', title_1: str = '-', title_2: str = '-', title_3: str = '-', write_date: bool = False, write_time: bool = False) -> None:
        """ Data-class for defining metadata.

        :param file_name:
        :param company:
        :param created_by:
        :param title_1: max. 50 characters
        :param title_2: max. 50 characters
        :param title_3: max. 50 characters
        :param write_date: True to write the current date to the sli file; False for dummy ('01/01/1900')
        :param write_time:  True to write the current date to the sli file; False for dummy ('00:00:00')

        :raise ModelError: if `title_1`, `title_2` or `title_3` has more than 50 characters
        """

class _Material:
    gam_dry: Incomplete
    gam_wet: Incomplete
    def __init__(self, gam_dry: float, gam_wet: float, color: Color = None, **kwargs: Any) -> None: ...
    @property
    def color(self) -> Color: ...

class _Point:
    def __init__(self, x: float, y: float) -> None: ...
    @property
    def x(self) -> float: ...
    @property
    def y(self) -> float: ...
    def __eq__(self, other: Any) -> bool: ...
    def __hash__(self) -> int: ...

class _Curve:
    def __init__(self, p1: _Point, p2: _Point) -> None: ...
    @property
    def p1(self) -> _Point: ...
    @property
    def p2(self) -> _Point: ...
    def __eq__(self, other: Any) -> bool: ...
    def __hash__(self) -> int: ...

class _CurveList:
    """ Boundaries and Pl-lines are curve lists. """
    def __init__(self, curves: list[_Curve]) -> None: ...
    def __eq__(self, other: Any) -> bool: ...
    def __hash__(self) -> int: ...
    @property
    def curves(self) -> list[_Curve]: ...
    @property
    def points(self) -> list[_Point]: ...
    def area_above_horizontal(self, y: float = 0.0) -> float:
        """ Area above horizontal line defined by y-coordinate. """

class _PlLine(_CurveList):
    """ Piezometric level line. """
class _Boundary(_CurveList):
    """ Boundary. """

class _Layer:
    def __init__(self, boundary_top: _Boundary, boundary_bottom: _Boundary, material: str, pl_line_top: _PlLine | int, pl_line_bottom: _PlLine | int) -> None: ...
    @property
    def material(self) -> str: ...
    @property
    def boundary_top(self) -> _Boundary: ...
    @property
    def boundary_bottom(self) -> _Boundary: ...
    @property
    def pl_line_top(self) -> _PlLine | int: ...
    @property
    def pl_line_bottom(self) -> _PlLine | int: ...

class _Vertical:
    def __init__(self, x: float) -> None: ...
    @property
    def x(self) -> float: ...

class VerticalDrain:
    range_from: Incomplete
    range_to: Incomplete
    bottom_position: Incomplete
    center_to_center: Incomplete
    width_diameter: Incomplete
    def __init__(self, drain_type: DrainType, range_from: float, range_to: float, bottom_position: float, center_to_center: float, width_diameter: float, thickness: float = None, position_drain: float = None, grid: DrainGrid = None, start_of_drainage: float = None, phreatic_level_in_drain: float = None, schedule: DrainageSimpleMode | list[tuple[float, float, float]] = None) -> None:
        """ Data-class for setting vertical drain options.

        :param drain_type: drain type.
        :param range_from: range [m] from which drainage takes place.
        :param range_to: range [m] to which drainage takes place.
        :param bottom_position: position of bottom (depth) of drains [m].
        :param center_to_center: center-to-center distance of drains [m].
        :param width_diameter: width (or diameter for drain_type = COLUMN) of drains [m].
        :param thickness: thickness of strip [m]. Must be set for drain_type = STRIP.
        :param position_drain: drain position [m]. Must be set for drain_type = SAND_WALL (only if schedule is defined).
        :param grid: drain grid type. Must be set for drain_type = STRIP | COLUMN.
        :param start_of_drainage: start time of drainage [days]. Must be set for simple and no schedule.
        :param phreatic_level_in_drain: phreatic level in drain [m]. Must be set for simple and no schedule.
        :param schedule: DrainageSimpleMode for simple schedule; list of (time [days], underpressure [kPa],
         water head [m] (if drain_type = STRIP | COLUMN) / tube pressure [kPa] (if drain_type = SAND_WALL)) for
         detailed schedule (default: no schedule).
        """
    @property
    def position_drain(self) -> float | None: ...

class _Geometry1D:
    phreatic_level: Incomplete
    def __init__(self, bottom_level: float, layers: list[tuple[float, str]], phreatic_level: float = None) -> None: ...
    @property
    def bottom_level(self) -> float: ...
    @property
    def top_level(self) -> float: ...
    @property
    def layers(self) -> list[tuple[float, str]]: ...

class _Load(metaclass=ABCMeta): ...

class _NonUniformLoad(_Load):
    def __init__(self, name: str, points: list[tuple[float, float]], time: int = 0, end_time: int = 0, gamma_dry: float = 10.0, gamma_wet: float = 10.0, temporary: bool = False) -> None: ...
    @property
    def points(self) -> list[tuple[float, float]]: ...

class _OtherLoad(_Load, metaclass=ABCMeta): ...

class _UniformLoad(_OtherLoad):
    time: Incomplete
    unit_weight: Incomplete
    height: Incomplete
    y_application: Incomplete
    def __init__(self, time: int, unit_weight: float, height: float, y_application: float) -> None: ...

class _Model(metaclass=ABCMeta):
    @abstractmethod
    def __init__(self, calculation_model: CalculationModel, consolidation_model: ConsolidationModel, create_default_materials: bool = True, *, natural_strain: bool = False, reliability_analysis: bool = False, fit_for_settlement_plate: bool = False, horizontal_displacements: bool = False, limits: tuple[float, float] = (0.0, 100.0), water_unit_weight: float = 9.81, verticals_discretization: int = 100, verticals_z_coordinate: float = 0.0, maintain_profile: bool = False, profile_time: int = 0, profile_unit_weight_above_phreatic_level: float = 10.0, profile_unit_weight_below_phreatic_level: float = 10.0, end_of_settlement_calculation: int = 10000, stress_distribution_loads: bool = False, vertical_drain: VerticalDrain = None): ...
    @property
    def materials(self) -> dict[str, _Material]: ...
    @property
    def verticals(self) -> list[_Vertical]: ...
    def create_material(self, name: str, gam_dry: float, gam_wet: float, color: Color = None, *, initial_void_ratio: float = 0.0, cohesion: float = 0.0, phi: float = 0.0, precon_isotache_type: int = 0, precon_koppejan_type: int = 0, use_equivalent_age: int = 0, equivalent_age: float = 0.0, pc: float = 0.0, ocr: float = 1.0, pop: float = 0.0, limit_stress: float = 1.0, drained: int = 0, ap_as_approximation_by_cp_cs: int = 0, cv: float = 10.0, permeability_ver: float = 0.05, permeability_hor_factor: float = 1.0, storage_type: int = 0, permeability_strain_modulus: float = 1000000000000000.0, use_prob_defaults: int = 1, std_gam_dry: float = 0.0, std_gam_wet: float = 0.0, std_cv: float = 0.0, std_pc: float = 0.0, std_pri_comp_index: float = 0.0, std_sec_comp_index: float = 0.0, std_sec_comp_rate: float = 0.0, std_ocr: float = 0.0, std_permeability_ver: float = 0.0, std_pop: float = 0.0, std_permeability_hor_factor: float = 0.0, std_initial_void_ratio: float = 0.0, std_permeability_strain_modulus: float = 0.0, std_limit_stress: float = 0.0, std_cp: float = 0.0, std_cp1: float = 0.0, std_cs: float = 0.0, std_cs1: float = 0.0, std_ap: float = 0.0, std_asec: float = 0.0, std_car: float = 0.0, std_ca: float = 0.0, std_r_ratio: float = 0.0, std_c_ratio: float = 0.0, std_s_ratio: float = 0.0, std_cr_index: float = 0.0, std_cc_index: float = 0.0, std_csw_index: float = 0.0, dist_gam_dry: int = 2, dist_gam_wet: int = 2, dist_cv: int = 2, dist_pc: int = 2, dist_pri_comp_index: int = 2, dist_sec_comp_index: int = 2, dist_sec_comp_rate: int = 2, dist_ocr: int = 2, dist_permeability_ver: int = 2, dist_pop: int = 2, dist_permeability_hor_factor: int = 2, dist_initial_void_ratio: int = 2, dist_permeability_strain_modulus: int = 2, dist_limit_stress: int = 2, dist_cp: int = 2, dist_cp1: int = 2, dist_cs: int = 2, dist_cs1: int = 2, dist_ap: int = 2, dist_asec: int = 2, dist_car: int = 2, dist_ca: int = 2, dist_r_ratio: int = 2, dist_c_ratio: int = 2, dist_s_ratio: int = 2, dist_cr_index: int = 2, dist_cc_index: int = 2, dist_csw_index: int = 2, cor_cp_cp1: float = 0.0, cor_cs_cp1: float = 0.0, cor_cs1_cp1: float = 0.0, cor_ap_cp1: float = 0.0, cor_asec_cp1: float = 0.0, cor_cr_index_cc_index: float = 0.0, cor_r_ratio_c_ratio: float = 0.0, cor_ca_cc_index_or_c_ratio: float = 0.0, cor_pri_comp_index_sec_comp_index: float = 0.0, cor_sec_comp_rate_sec_comp_index: float = 0.0, cp: float = 1.0, cp1: float = 1.0, cs: float = 1.0, cs1: float = 1.0, ap: float = 1.0, asec: float = 1.0, car: float = 0.0, ca: float = 1.0, comp_ratio: int = 1, r_ratio: float = 1.0, c_ratio: float = 1.0, s_ratio: float = 0.0, cr_index: float = 1.0, cc_index: float = 1.0, csw_index: float = 0.0, pri_comp_index: float = 0.01, sec_comp_index: float = 0.1, sec_comp_rate: float = 0.005, horizontal_behaviour_type: int = 2, elasticity: float = 1000.0, default_elasticity: int = 1) -> None:
        """ Create a material with the given name and properties.

        :param name: name of the material to create (max. 25 characters)
        :param color: color for visualization in deltares software (None for random color)
        :param gam_dry: unit weight above phreatic level in [kN/m³]
        :param gam_wet: unit weight below phreatic level in [kN/m³]
        :param ....: etc.

        :raise ModelError:
            - if material with given name already exists in the model
            - if name is longer than 25 characters
        """
    def create_uniform_load(self, name: str, time: int, unit_weight: float, height: float, y_application: float) -> None:
        """ Create a uniform load with the given name and properties.

        :param name: name of the uniform load to create
        :param time: in [days], -1 for initial load
        :param unit_weight: in [kN/m³]
        :param height: in [m]
        :param y_application: in [m]
        """
    def set_calculation_times(self, *time: int) -> None:
        """ (Re)set calculation time(s)

        :param time: one or more calculation times at which results will be obtained  # todo: days
        :raise ModelError:
            - if time < 0 or > end time
            - if duplicates exist
        """
    def generate_input_file(self, metadata: Metadata = None, *, dissipation_calculation: _Vertical = None, as_file: bool = False) -> BytesIO | File:
        """Generate a D-Settlement input file.

        .. note:: This method needs to be mocked in (automated) unit and integration tests.

        :param metadata: Metadata which will be written to the input file. If no metadata is provided, default data
            will be used.
        :param dissipation_calculation: select vertical to add dissipation calculation; 'None' to disable.
        :param as_file: return as BytesIO (default) or File ::version(v13.5.0)
        """

class Model1D(_Model):
    '''
    Model for a 1D D-Settlement analysis.

    Example usage:

    .. code-block:: python

        # instantiate 1D model
        model = Model1D(CalculationModel.NEN_KOPPEJAN, ConsolidationModel.TERZAGHI)

        # update the geometry
        model.create_material("my_mat", 21.0, 19.0, color=Color(0, 0, 0))
        model.update_geometry(-1.0, [(1.0, "Loam"), (0.0, "my_mat")], phreatic_level=-3.0)

        # add load(s)
        model.create_uniform_load("my_load", 0, 0.001, 0.0, 0.0)

        # generate the input file
        input_file = model.generate_input_file()
    '''
    def __init__(self, calculation_model: CalculationModel, consolidation_model: ConsolidationModel, create_default_materials: bool = True, *, natural_strain: bool = False, water_unit_weight: float = 9.81, verticals_discretization: int = 100, verticals_z_coordinate: float = 0.0, maintain_profile: bool = False, profile_unit_weight_above_phreatic_level: float = 10.0, profile_unit_weight_below_phreatic_level: float = 10.0, end_of_settlement_calculation: int = 10000, vertical_drain: VerticalDrain = None) -> None:
        """
        :param calculation_model:
        :param consolidation_model:
        :param create_default_materials: start with default materials or none
        :param natural_strain: if False -> linear strain
        :param water_unit_weight: in [kN/m³]
        :param vertical_drain: parameters for vertical drains, or None (default) to disable option

        .. autoattribute:: materials
        .. automethod:: create_material
        .. automethod:: create_uniform_load
        .. automethod:: set_calculation_times
        .. automethod:: generate_input_file
        """
    @property
    def bottom_level(self) -> float: ...
    @property
    def top_level(self) -> float: ...
    @property
    def layers(self) -> list[tuple[float, str]]: ...
    @property
    def phreatic_level(self) -> float | None: ...
    def update_geometry(self, bottom_level: float, layers: list[tuple[float, str]], phreatic_level: float = None) -> None:
        ''' Overwrite the current (default if not updated before) geometry with the given data.

        :param bottom_level: bottom level of the bottom-most layer [m]
        :param layers: list of layers defined by top level [m] and material name (must be created beforehand with
            :meth:`create_material` or one of the default materials). Should be defined from top to bottom.
        :param phreatic_level: in [m]

        :raise ModelError:
            - if layers are not defined from top to bottom
            - if lowest layer top level is below given bottom level
            - if material with given name does not exist

        Example usage:

        .. code-block:: python

            model.update_geometry(-1, [(1.0, "Loam"), (0.0, "Sand")], phreatic_level=-3)
        '''

class Model2D(_Model):
    """Model for a 2D D-Settlement analysis.

    Example usage:

    .. code-block:: python

        # Initialize parameters for vertical drainage, to be used in the init of Model2D.
        vertical_drain = VerticalDrain(DrainType.SAND_WALL, 5.0, 90.0, 0.0, 2.0, 4.0,
                                       start_of_drainage=2.0, phreatic_level_in_drain=4.0)

        # Create the model (NEN - Koppejan / Terzaghi) with a starting bottom boundary, vertical drainage and
        # miscellaneous default parameters.
        model = Model2D(CalculationModel.NEN_KOPPEJAN, ConsolidationModel.TERZAGHI,
                        boundary_bottom=[(0.0, 0.0), (100.0, 0.0)], vertical_drain=vertical_drain)

        # Create points for defining boundaries and pl-lines.
        points_boundary1 = [model.create_point(x, y) for (x, y) in [(0.0, 5.0), (50.0, 5.0), (100.0, 2.5)]]
        points_boundary2 = [model.create_point(x, y) for (x, y) in [(0.0, 5.0), (50.0, 5.0), (100.0, 7.5)]]
        points_boundary3 = [model.create_point(x, y) for (x, y) in [(0.0, 10.0), (25, 10.0), (75, 10.0), (100.0, 10.0)]]
        points_plline1 = [model.create_point(x, y) for (x, y) in [(0.0, 4.0), (100.0, 4.0)]]
        points_plline2 = [model.create_point(x, y) for (x, y) in [(0.0, 6.0), (100.0, 6.0)]]

        # Create the pl-lines.
        plline1 = model.create_pl_line(points_plline1, is_phreatic=True)
        plline2 = model.create_pl_line(points_plline2)

        # Create the layers.
        model.create_layer(points_boundary1, 'Sand', pl_line_top=99, pl_line_bottom=plline2)
        model.create_layer(points_boundary2, 'Soft Clay', pl_line_top=99, pl_line_bottom=99)
        model.create_layer(points_boundary3, 'Loam', pl_line_top=plline1, pl_line_bottom=99)

        # Create verticals.
        model.create_vertical(45.0)
        model.create_vertical(50.0)
        model.create_vertical(55.0)

        # Create loads.
        model.create_non_uniform_load('load1', [(25, 10.0), (50.0, 12.0), (75, 10.0)])

        # Create calculation/residual times.
        model.set_calculation_times(1, 4, 2, 5)

        # Generate the input file for the model as if it was generated by D-Settlement.
        input_file = model.generate_input_file()
    """
    def __init__(self, calculation_model: CalculationModel, consolidation_model: ConsolidationModel, boundary_bottom: list[tuple[float, float]], create_default_materials: bool = True, *, natural_strain: bool = False, limits: tuple[float, float] = (0.0, 100.0), water_unit_weight: float = 9.81, verticals_discretization: int = 100, verticals_z_coordinate: float = 0.0, maintain_profile: bool = False, profile_time: int = 0, profile_unit_weight_above_phreatic_level: float = 10.0, profile_unit_weight_below_phreatic_level: float = 10.0, end_of_settlement_calculation: int = 10000, stress_distribution_loads: bool = False, vertical_drain: VerticalDrain = None) -> None:
        """
        :param calculation_model: Specifies which calculation model is used.
        :param consolidation_model: Specifies which consolidation model is used.
        :param boundary_bottom: The bottom boundary of the geometry.
        :param create_default_materials: start with default materials or none
        :param natural_strain: Indicates if natural strain is used. If False, linear strain is used.
        :param water_unit_weight: in [kN/m³]
        :param stress_distribution_loads: True for 'Simulate', False for 'None' (default).
        :param vertical_drain: parameters for vertical drains, or None (default) to disable option

        .. autoattribute:: materials
        .. automethod:: create_material
        .. automethod:: create_uniform_load
        .. automethod:: set_calculation_times
        .. automethod:: generate_input_file
        """
    def create_point(self, x: float, y: float) -> _Point:
        """ Create a point with given x and y coordinates.

        :param x: in [m]
        :param y: in [m]
        :return: _Point which can be used to create boundaries for layers or pl-lines.
        """
    def create_pl_line(self, points: list[_Point], is_phreatic: bool = False) -> _PlLine:
        """ Create a piezometric level line (pl-line) from the given points.

        :param points: list of points that define the pl-line
        :param is_phreatic: whether to set the current pl-line as the phreatic line (overwrites previous!)
        :return: pl-line

        :raise ModelError:
            - if 'points' contains duplicates
            - if start and end 'points' are not on the left and right boundary limit respectively
            - if 'points' are not in ascending X-direction
            - if 'is_phreatic' is True but was already set before
        """
    def create_layer(self, boundary_top: list[_Point], material: str, pl_line_top: _PlLine | int, pl_line_bottom: _PlLine | int) -> _Layer:
        """ Define layers from bottom to top.

        :param boundary_top: boundary at top of layer
        :param material: name of the material to be used (must be created beforehand)
        :param pl_line_top: pl-line at top, or 0 for no pressure, or 99 for interpolation
        :param pl_line_bottom: pl-line at bottom, or 0 for no pressure, or 99 for interpolation

        :raises ModelError:
            - if material with given name does not exist
            - if boundary_bottom is provided for layer other than first
            - if pl_line_top or pl_line_bottom are not valid
            - if 'points' contains duplicates
            - if start and end 'points' are not on the left and right boundary limit respectively
            - if 'points' are not in ascending X-direction
            - if 'is_phreatic' is True but was already set before
        """
    def create_vertical(self, x: float) -> _Vertical:
        """ Create vertical based on x-coordinate.

        :param x: [m]

        :raises ModelError: if x < left boundary limit or > right boundary limit
        """
    def create_non_uniform_load(self, name: str, points: list[tuple[float, float]], time: int = 0, end_time: int = 0, gamma_dry: float = 10.0, gamma_wet: float = 10.0, temporary: bool = False) -> _NonUniformLoad:
        """ Create a non-uniform load.

        DSettlement assumes that a non-uniform load is caused by soil self weight.
        Initial loads only affects the initial stresses and do not cause creep or consolidation.

        :param name: Name of the load.
        :param points: Points, as x-y coordinates, of the load.
          The first and last points must be located on a layer or another non-uniform load.
        :param time: The moment the load is laid down [days].
          If time is set to -1 days, the load is considered an initial load.
        :param end_time: The moment the load is removed (only in the case of temporary loads) [days].
        :param temporary: Bool which indicates if the load is a temporary load.
        :param gamma_dry: Total unit weight above phreatic level [kN/m3].
        :param gamma_wet: Total unit weight below phreatic level [kN/m3].
        """

class OutputFileParser:
    """
    Helper class to extract results from a D-Settlement output file (.sld).

    Example usage:

    .. code-block:: python

        parser = OutputFileParser(sld_file)
        vertical_results = parser.vertical_results
        residual_times = parser.residual_times
    """
    def __init__(self, sld_file: StringIO) -> None: ...
    @property
    def raw_results(self) -> str:
        """Raw result data. For convenience, specific data can also be extracted using available methods."""
    @property
    def vertical_results(self) -> dict[int, dict[str, Any]]:
        """Returns results for all verticals.

        Structure of dictionary:

        .. code-block::

            {
                vertical number: int: {

                    coordinates: {
                        x: float
                        z: float
                    },

                    time_settlement_per_load: {
                        time_step_count: int
                        load_step_count: int
                        time: List[float] [days]
                        load_1: List[float] [kPa]
                        load_2: List[float] [kPa]
                        ... (depending on model)
                    },

                    depths: List[float]
                    leakages: List[float] -> empty for some models
                    drained_layers: List[float] -> empty for some models

                    stresses: { -> empty for some models
                        initial_total_stress: List[float]
                        ... (depending on model)
                    },

                    vertical_data: {
                        time: float: {
                            settlement: List[float]
                            ... (depending on model)
                        }
                    },
                }
            }
        """
    @property
    def residual_times(self) -> dict[int, dict[str, list[float]]]:
        """Returns the residual times.

        Structure of dictionary:

        .. code-block::

            {
                vertical number: int: {

                    Time: List[float]
                    Settlement: List[float]
                    ...
                }
            }
        """
