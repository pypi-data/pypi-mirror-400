from __future__ import annotations

import os
from typing import Optional

PathLikeStr = str | os.PathLike[str]

class CommitInfo:
    id: str
    summary: Optional[str]
    author: str
    email: Optional[str]
    time: int
    offset_minutes: int

class RewriteResult:
    old_to_new: dict[str, str]
    updated_refs: dict[str, str]
    warnings: list[str]
    backup_root: str | None

class DiffStat:
    files_changed: int
    insertions: int
    deletions: int
    paths: list[str]

class RepoSummary:
    path: str
    head: str | None
    branch: str | None
    commits: int
    branches: int
    tags: int
    remotes: int
    authors: int
    files: int
    size_kb: int
    is_dirty: bool
    last_commit_time: int | None

class Repo:
    def head(self) -> Optional[CommitInfo]: ...
    def rev_parse(self, spec: str) -> str: ...
    def reword(self, commit_id: str, new_message: str) -> RewriteResult: ...
    def summary(self) -> RepoSummary: ...
    def render_refs(self, local: bool = True, remote: bool = False, tags: bool = True, max_width: int | None = None) -> str: ...
    def render_log(self, rev: str, max_commits: int = 200, decorate: bool = True, graph: bool = True, max_width: int | None = None) -> str: ...
    def diff_stat(self, a_spec: str, b_spec: str, paths: list[str] | None = None) -> DiffStat: ...
    def list_branches(self, local: bool = True, remote: bool = False) -> list[str]: ...
    def list_tags(self) -> list[str]: ...
    def current_branch(self) -> Optional[str]: ...
    def list_commits(self, max: Optional[int] = None) -> list[CommitInfo]: ...
    def create_backup_ref(self, prefix: str | None = None) -> str: ...
    def change_commit_message(self, commit_id: str, new_message: str) -> RewriteResult: ...
    def rewrite_author(self, commit_id: str, new_name: str, new_email: str, update_committer: bool = True) -> RewriteResult: ...
    def filter_commits(self, author: str | None = None, message_contains: str | None = None) -> RewriteResult: ...
    def remove_path(self, path_pattern: str) -> RewriteResult: ...
    def keep_path(self, glob_pattern: str) -> RewriteResult: ...
    def rebase_branch(self, branch: str, onto: str) -> RewriteResult: ...
    def squash_last(self, count: int, mode: str = "squash", message: str | None = None) -> RewriteResult: ...
    def merge_base(self, a_spec: str, b_spec: str) -> str | None: ...
    def is_ancestor(self, a_spec: str, b_spec: str) -> bool: ...
    def ahead_behind(self, a_spec: str, b_spec: str) -> tuple[int, int]: ...

def open_repo(path: PathLikeStr) -> Repo: ...
def create_backup_ref(repo: Repo | PathLikeStr, prefix: str | None = None) -> str: ...

def summary(repo: Repo | PathLikeStr) -> RepoSummary: ...
def refs_tui(repo: Repo | PathLikeStr, local: bool = True, remote: bool = False, tags: bool = True, max_width: int | None = None) -> str: ...
def log_tui(repo: Repo | PathLikeStr, rev: str = "HEAD", max_commits: int = 200, decorate: bool = True, graph: bool = True, max_width: int | None = None) -> str: ...
def diff_stat(repo: Repo | PathLikeStr, a_spec: str, b_spec: str, paths: list[str] | None = None) -> DiffStat: ...
def list_branches(repo: Repo | PathLikeStr, local: bool = True, remote: bool = False) -> list[str]: ...
def list_tags(repo: Repo | PathLikeStr) -> list[str]: ...
def head(repo: Repo | PathLikeStr) -> Optional[CommitInfo]: ...
def current_branch(repo: Repo | PathLikeStr) -> Optional[str]: ...
def rev_parse(repo: Repo | PathLikeStr, spec: str) -> str: ...
def list_commits(repo: Repo | PathLikeStr, max: Optional[int] = None) -> list[CommitInfo]: ...
def change_commit_message(repo: Repo | PathLikeStr, commit_id: str, new_message: str) -> RewriteResult: ...
def reword(repo: Repo | PathLikeStr, commit_id: str, new_message: str) -> RewriteResult: ...
def rewrite_author(repo: Repo | PathLikeStr, commit_id: str, new_name: str, new_email: str, update_committer: bool = True) -> RewriteResult: ...
def filter_commits(repo: Repo | PathLikeStr, author: str | None = None, message_contains: str | None = None) -> RewriteResult: ...
def remove_path(repo: Repo | PathLikeStr, path_pattern: str) -> RewriteResult: ...
def keep_path(repo: Repo | PathLikeStr, glob_pattern: str) -> RewriteResult: ...
def rebase_branch(repo: Repo | PathLikeStr, branch: str, onto: str) -> RewriteResult: ...
def squash_last(repo: Repo | PathLikeStr, count: int, mode: str = "squash", message: str | None = None) -> RewriteResult: ...
def merge_base(repo: Repo | PathLikeStr, a_spec: str, b_spec: str) -> str | None: ...
def is_ancestor(repo: Repo | PathLikeStr, a_spec: str, b_spec: str) -> bool: ...
def ahead_behind(repo: Repo | PathLikeStr, a_spec: str, b_spec: str) -> tuple[int, int]: ...

__all__ = [
    "CommitInfo",
    "DiffStat",
    "RepoSummary",
    "Repo",
    "RewriteResult",
    "open_repo",
    "head",
    "list_branches",
    "list_tags",
    "current_branch",
    "rev_parse",
    "reword",
    "list_commits",
    "change_commit_message",
    "rewrite_author",
    "filter_commits",
    "remove_path",
    "keep_path",
    "rebase_branch",
    "squash_last",
    "merge_base",
    "is_ancestor",
    "ahead_behind",
    "diff_stat",
    "refs_tui",
    "log_tui",
]
