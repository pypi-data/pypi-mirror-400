"""Arcade Starter Tools for Hubspot_Users

DO NOT EDIT THIS MODULE DIRECTLY.

THIS MODULE WAS AUTO-GENERATED BY TRANSPILING THE API STARTER TOOL JSON DEFINITIONS
IN THE ../wrapper_tools DIRECTORY INTO PYTHON CODE. ANY CHANGES TO THIS MODULE WILL
BE OVERWRITTEN BY THE TRANSPILER.
"""

import asyncio
import json
from typing import Annotated, Any

import httpx
from arcade_tdk import ToolContext, tool
from arcade_tdk.auth import Hubspot

# Retry configuration
INITIAL_RETRY_DELAY = 0.5  # seconds

HTTP_CLIENT = httpx.AsyncClient(
    timeout=httpx.Timeout(60.0, connect=10.0),
    limits=httpx.Limits(max_keepalive_connections=20, max_connections=100),
    transport=httpx.AsyncHTTPTransport(retries=3),
    http2=True,
    follow_redirects=True,
)


def remove_none_values(data: dict[str, Any]) -> dict[str, Any]:
    return {k: v for k, v in data.items() if v is not None}


async def make_request(
    url: str,
    method: str,
    params: dict[str, Any] | None = None,
    headers: dict[str, Any] | None = None,
    content: str | None = None,
    data: dict[str, Any] | None = None,
    auth: tuple[str, str] | None = None,
    max_retries: int = 3,
) -> httpx.Response:
    """Make an HTTP request with retry logic for 5xx server errors."""
    for attempt in range(max_retries):
        try:
            response = await HTTP_CLIENT.request(
                url=url,
                auth=auth,
                method=method,
                params=params,
                headers=headers,
                content=content,
            )
            response.raise_for_status()
        except httpx.HTTPStatusError as e:
            # Only retry on 5xx server errors
            if e.response.status_code >= 500 and attempt < max_retries - 1:
                # Exponential backoff: 0.5s, 1s, 2s
                await asyncio.sleep(INITIAL_RETRY_DELAY * (2**attempt))
                continue
            # Re-raise for 4xx errors or if max retries reached
            raise
        except httpx.RequestError:
            # Don't retry request errors (network issues are handled by transport)
            raise
        else:
            return response

    # This should never be reached, but satisfies type checker
    raise httpx.RequestError("Max retries exceeded")  # noqa: TRY003


@tool(requires_auth=Hubspot(scopes=["settings.users.teams.read"]))
async def view_account_teams(
    context: ToolContext,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get-/settings/v3/users/teams_getAll'."
]:
    """Retrieve all teams for the account.

    Call this tool to view all teams associated with a specific account in Hubspot. Useful for managing or reviewing team structures."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.hubapi.com/settings/v3/users/teams",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=Hubspot(scopes=["crm.objects.users.read", "settings.users.read"]))
async def get_account_roles(
    context: ToolContext,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get-/settings/v3/users/roles_getAll'."
]:
    """Retrieve all user roles from an account.

    This tool is called to fetch and list all the roles available on a specific account from Hubspot."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.hubapi.com/settings/v3/users/roles",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=Hubspot(scopes=["crm.objects.users.read", "settings.users.read"]))
async def fetch_hubspot_users_list(
    context: ToolContext,
    page_cursor_after: Annotated[
        str | None,
        "A string token used to retrieve the next page of users, if more than 100 users are available.",  # noqa: E501
    ] = None,
    user_retrieval_limit: Annotated[
        int | None, "Specify the maximum number of users to retrieve from the HubSpot account."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get-/settings/v3/users/_getPage'."]:
    """Retrieve a list of users from a HubSpot account.

    Use this tool to get a list of users associated with a specific HubSpot account. It is useful for managing or viewing user information within the account."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.hubapi.com/settings/v3/users/",
        method="GET",
        params=remove_none_values({"limit": user_retrieval_limit, "after": page_cursor_after}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=Hubspot(scopes=["crm.objects.users.write", "settings.users.write"]))
async def create_hubspot_user(
    context: ToolContext,
    user_email: Annotated[str, "The email address of the user to be created in HubSpot."],
    additional_team_ids: Annotated[
        list[str] | None, "List of IDs representing the user's additional teams."
    ] = None,
    last_name: Annotated[str | None, "The last name of the user to be created in HubSpot."] = None,
    primary_team_id: Annotated[
        str | None, "The identifier for the user's primary team in HubSpot."
    ] = None,
    send_welcome_email: Annotated[
        bool | None,
        "Set to true to send a welcome email prompting the user to set a password and log in.",
    ] = None,
    user_first_name: Annotated[
        str | None, "The first name of the user to be created in HubSpot."
    ] = None,
    user_role_id: Annotated[
        str | None, "A string representing the new user's role within HubSpot."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'post-/settings/v3/users/_create'."]:
    """Create a new user in HubSpot with basic permissions.

    This tool creates a new user in HubSpot with minimal permissions (contacts-base). The user will receive a welcome email to set a password and log in."""  # noqa: E501
    request_data: Any = {
        "firstName": user_first_name,
        "lastName": last_name,
        "primaryTeamId": primary_team_id,
        "sendWelcomeEmail": send_welcome_email,
        "roleId": user_role_id,
        "secondaryTeamIds": additional_team_ids,
        "email": user_email,
    }
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.hubapi.com/settings/v3/users/",
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=Hubspot(scopes=["crm.objects.users.read", "settings.users.read"]))
async def retrieve_hubspot_user_by_id(
    context: ToolContext,
    user_identifier: Annotated[
        str,
        "Identifier of the Hubspot user to retrieve. It can be the user ID or email based on the `id_property`.",  # noqa: E501
    ],
    user_identifier_property: Annotated[
        str | None, "Specifies the property to identify the user: `USER_ID` (default) or `EMAIL`."
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get-/settings/v3/users/{userId}_getById'."
]:
    """Retrieve Hubspot user details using user ID or email.

    Call this tool to retrieve detailed information about a Hubspot user identified by their user ID or optionally by email."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.hubapi.com/settings/v3/users/{userId}".format(userId=user_identifier),  # noqa: UP032
        method="GET",
        params=remove_none_values({"idProperty": user_identifier_property}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=Hubspot(scopes=["crm.objects.users.write", "settings.users.write"]))
async def update_hubspot_user_info(
    context: ToolContext,
    user_identifier: Annotated[
        str,
        "The unique identifier for the user. Can be the user's ID or email, based on the `id_property`.",  # noqa: E501
    ],
    additional_teams_ids: Annotated[
        list[str] | None, "An array of strings representing the IDs of the user's additional teams."
    ] = None,
    first_name: Annotated[
        str | None, "The first name of the user to update. This should be a string value."
    ] = None,
    last_name: Annotated[
        str | None,
        "The last name of the user to be modified. This is the new value of the user's last name.",
    ] = None,
    user_identifier_property: Annotated[
        str | None,
        "Specifies if the user is identified by 'USER_ID' or 'EMAIL'. Default is 'USER_ID'.",
    ] = None,
    user_primary_team_id: Annotated[
        str | None, "The unique ID for the user's primary team."
    ] = None,
    user_role_id: Annotated[
        str | None,
        "The ID representing the user's role. Used to assign the user a specific role within the system.",  # noqa: E501
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'put-/settings/v3/users/{userId}_replace'."
]:
    """Update information for a specified Hubspot user.

    This tool modifies the information of a Hubspot user identified by `userId`. It can be called when you need to update user data using their ID or email."""  # noqa: E501
    request_data: Any = {
        "firstName": first_name,
        "lastName": last_name,
        "primaryTeamId": user_primary_team_id,
        "roleId": user_role_id,
        "secondaryTeamIds": additional_teams_ids,
    }
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.hubapi.com/settings/v3/users/{userId}".format(userId=user_identifier),  # noqa: UP032
        method="PUT",
        params=remove_none_values({"idProperty": user_identifier_property}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=Hubspot(scopes=["crm.objects.users.write", "settings.users.write"]))
async def remove_user_hubspot(
    context: ToolContext,
    user_identifier: Annotated[
        str,
        "Identifier of the user to remove from HubSpot. It can be a user ID or an email address.",
    ],
    user_identifier_property: Annotated[
        str | None, "Specify whether to use `USER_ID` or `EMAIL` to identify the user."
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'delete-/settings/v3/users/{userId}_archive'."
]:
    """Remove a user from HubSpot using their ID or email.

    This tool removes a user from HubSpot, identified by either their user ID or email. It should be called when a user needs to be permanently deleted or archived from the HubSpot system."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.hubapi.com/settings/v3/users/{userId}".format(userId=user_identifier),  # noqa: UP032
        method="DELETE",
        params=remove_none_values({"idProperty": user_identifier_property}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}
