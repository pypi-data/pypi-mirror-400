"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""

import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.timestamp_pb2
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _OnAttemptsExceeded:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _OnAttemptsExceededEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_OnAttemptsExceeded.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    ON_ATTEMPTS_EXCEEDED_UNSPECIFIED: _OnAttemptsExceeded.ValueType  # 0
    ON_ATTEMPTS_EXCEEDED_DISCARD: _OnAttemptsExceeded.ValueType  # 1
    ON_ATTEMPTS_EXCEEDED_DEADLETTER: _OnAttemptsExceeded.ValueType  # 2

class OnAttemptsExceeded(_OnAttemptsExceeded, metaclass=_OnAttemptsExceededEnumTypeWrapper): ...

ON_ATTEMPTS_EXCEEDED_UNSPECIFIED: OnAttemptsExceeded.ValueType  # 0
ON_ATTEMPTS_EXCEEDED_DISCARD: OnAttemptsExceeded.ValueType  # 1
ON_ATTEMPTS_EXCEEDED_DEADLETTER: OnAttemptsExceeded.ValueType  # 2
global___OnAttemptsExceeded = OnAttemptsExceeded

class _TaskActivationStatus:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _TaskActivationStatusEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_TaskActivationStatus.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    TASK_ACTIVATION_STATUS_UNSPECIFIED: _TaskActivationStatus.ValueType  # 0
    TASK_ACTIVATION_STATUS_PENDING: _TaskActivationStatus.ValueType  # 1
    TASK_ACTIVATION_STATUS_PROCESSING: _TaskActivationStatus.ValueType  # 2
    TASK_ACTIVATION_STATUS_FAILURE: _TaskActivationStatus.ValueType  # 3
    TASK_ACTIVATION_STATUS_RETRY: _TaskActivationStatus.ValueType  # 4
    TASK_ACTIVATION_STATUS_COMPLETE: _TaskActivationStatus.ValueType  # 5

class TaskActivationStatus(_TaskActivationStatus, metaclass=_TaskActivationStatusEnumTypeWrapper): ...

TASK_ACTIVATION_STATUS_UNSPECIFIED: TaskActivationStatus.ValueType  # 0
TASK_ACTIVATION_STATUS_PENDING: TaskActivationStatus.ValueType  # 1
TASK_ACTIVATION_STATUS_PROCESSING: TaskActivationStatus.ValueType  # 2
TASK_ACTIVATION_STATUS_FAILURE: TaskActivationStatus.ValueType  # 3
TASK_ACTIVATION_STATUS_RETRY: TaskActivationStatus.ValueType  # 4
TASK_ACTIVATION_STATUS_COMPLETE: TaskActivationStatus.ValueType  # 5
global___TaskActivationStatus = TaskActivationStatus

@typing.final
class RetryState(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ATTEMPTS_FIELD_NUMBER: builtins.int
    MAX_ATTEMPTS_FIELD_NUMBER: builtins.int
    ON_ATTEMPTS_EXCEEDED_FIELD_NUMBER: builtins.int
    AT_MOST_ONCE_FIELD_NUMBER: builtins.int
    DELAY_ON_RETRY_FIELD_NUMBER: builtins.int
    attempts: builtins.int
    """Current attempt number"""
    max_attempts: builtins.int
    """After this number of attempts, the task is either discarded or deadlettered."""
    on_attempts_exceeded: global___OnAttemptsExceeded.ValueType
    """The action to take after the max_attempts is exceeded."""
    at_most_once: builtins.bool
    """Whether a task should be executed at most once."""
    delay_on_retry: builtins.int
    """Duration in seconds that a task must wait to begin execution after it is retried."""
    def __init__(
        self,
        *,
        attempts: builtins.int = ...,
        max_attempts: builtins.int = ...,
        on_attempts_exceeded: global___OnAttemptsExceeded.ValueType = ...,
        at_most_once: builtins.bool | None = ...,
        delay_on_retry: builtins.int | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["_at_most_once", b"_at_most_once", "_delay_on_retry", b"_delay_on_retry", "at_most_once", b"at_most_once", "delay_on_retry", b"delay_on_retry"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["_at_most_once", b"_at_most_once", "_delay_on_retry", b"_delay_on_retry", "at_most_once", b"at_most_once", "attempts", b"attempts", "delay_on_retry", b"delay_on_retry", "max_attempts", b"max_attempts", "on_attempts_exceeded", b"on_attempts_exceeded"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_at_most_once", b"_at_most_once"]) -> typing.Literal["at_most_once"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_delay_on_retry", b"_delay_on_retry"]) -> typing.Literal["delay_on_retry"] | None: ...

global___RetryState = RetryState

@typing.final
class TaskActivation(google.protobuf.message.Message):
    """Task message that is stored in Kafka and shared over RPC."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class HeadersEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        value: builtins.str
        def __init__(
            self,
            *,
            key: builtins.str = ...,
            value: builtins.str = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing.Literal["key", b"key", "value", b"value"]) -> None: ...

    ID_FIELD_NUMBER: builtins.int
    NAMESPACE_FIELD_NUMBER: builtins.int
    TASKNAME_FIELD_NUMBER: builtins.int
    PARAMETERS_FIELD_NUMBER: builtins.int
    HEADERS_FIELD_NUMBER: builtins.int
    RECEIVED_AT_FIELD_NUMBER: builtins.int
    RETRY_STATE_FIELD_NUMBER: builtins.int
    PROCESSING_DEADLINE_DURATION_FIELD_NUMBER: builtins.int
    EXPIRES_FIELD_NUMBER: builtins.int
    DELAY_FIELD_NUMBER: builtins.int
    APPLICATION_FIELD_NUMBER: builtins.int
    id: builtins.str
    """A GUID for the task. Used to update tasks"""
    namespace: builtins.str
    """The task namespace. Applications can contain multiple namespaces.
    While namespaces within an application must be unique, different
    applications can have overlapping namespace values.
    """
    taskname: builtins.str
    """The name of the task. This name is resolved within the worker"""
    parameters: builtins.str
    """An opaque parameter collection. Could be JSON or protobuf encoded"""
    processing_deadline_duration: builtins.int
    """The duration in seconds that a worker has to complete task execution.
    When an activation is moved from pending -> processing a result is expected
    in this many seconds.
    """
    expires: builtins.int
    """The duration in seconds that a task has to start execution.
    After received_at + expires has passed an activation is expired and will not be executed.
    """
    delay: builtins.int
    """The duration in seconds that a task must wait to begin execution after it is emitted.
    After received_at + delay has passed, the activation will become pending.
    """
    application: builtins.str
    """The client application that an activation belongs to.
    Each activation *must* belong to an application. This requirement
    is enforced during taskbroker ingestion as adding required fields to a protobuf
    is a breaking change.
    """
    @property
    def headers(self) -> google.protobuf.internal.containers.ScalarMap[builtins.str, builtins.str]:
        """A map of headers for the task."""

    @property
    def received_at(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """The timestamp a task was stored in Kafka"""

    @property
    def retry_state(self) -> global___RetryState:
        """Retry state"""

    def __init__(
        self,
        *,
        id: builtins.str = ...,
        namespace: builtins.str = ...,
        taskname: builtins.str = ...,
        parameters: builtins.str = ...,
        headers: collections.abc.Mapping[builtins.str, builtins.str] | None = ...,
        received_at: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        retry_state: global___RetryState | None = ...,
        processing_deadline_duration: builtins.int = ...,
        expires: builtins.int | None = ...,
        delay: builtins.int | None = ...,
        application: builtins.str | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["_application", b"_application", "_delay", b"_delay", "_expires", b"_expires", "application", b"application", "delay", b"delay", "expires", b"expires", "received_at", b"received_at", "retry_state", b"retry_state"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["_application", b"_application", "_delay", b"_delay", "_expires", b"_expires", "application", b"application", "delay", b"delay", "expires", b"expires", "headers", b"headers", "id", b"id", "namespace", b"namespace", "parameters", b"parameters", "processing_deadline_duration", b"processing_deadline_duration", "received_at", b"received_at", "retry_state", b"retry_state", "taskname", b"taskname"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_application", b"_application"]) -> typing.Literal["application"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_delay", b"_delay"]) -> typing.Literal["delay"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_expires", b"_expires"]) -> typing.Literal["expires"] | None: ...

global___TaskActivation = TaskActivation

@typing.final
class GetTaskRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NAMESPACE_FIELD_NUMBER: builtins.int
    APPLICATION_FIELD_NUMBER: builtins.int
    namespace: builtins.str
    """The namespace to filter activations with."""
    application: builtins.str
    """The client application to filter activations with."""
    def __init__(
        self,
        *,
        namespace: builtins.str | None = ...,
        application: builtins.str | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["_application", b"_application", "_namespace", b"_namespace", "application", b"application", "namespace", b"namespace"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["_application", b"_application", "_namespace", b"_namespace", "application", b"application", "namespace", b"namespace"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_application", b"_application"]) -> typing.Literal["application"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_namespace", b"_namespace"]) -> typing.Literal["namespace"] | None: ...

global___GetTaskRequest = GetTaskRequest

@typing.final
class GetTaskResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TASK_FIELD_NUMBER: builtins.int
    @property
    def task(self) -> global___TaskActivation:
        """If there are no tasks available, this will be empty"""

    def __init__(
        self,
        *,
        task: global___TaskActivation | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["_task", b"_task", "task", b"task"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["_task", b"_task", "task", b"task"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["_task", b"_task"]) -> typing.Literal["task"] | None: ...

global___GetTaskResponse = GetTaskResponse

@typing.final
class FetchNextTask(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NAMESPACE_FIELD_NUMBER: builtins.int
    APPLICATION_FIELD_NUMBER: builtins.int
    namespace: builtins.str
    """The namespace to filter activations by."""
    application: builtins.str
    """The client application to filter activations by."""
    def __init__(
        self,
        *,
        namespace: builtins.str | None = ...,
        application: builtins.str | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["_application", b"_application", "_namespace", b"_namespace", "application", b"application", "namespace", b"namespace"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["_application", b"_application", "_namespace", b"_namespace", "application", b"application", "namespace", b"namespace"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_application", b"_application"]) -> typing.Literal["application"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_namespace", b"_namespace"]) -> typing.Literal["namespace"] | None: ...

global___FetchNextTask = FetchNextTask

@typing.final
class SetTaskStatusRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ID_FIELD_NUMBER: builtins.int
    STATUS_FIELD_NUMBER: builtins.int
    FETCH_NEXT_TASK_FIELD_NUMBER: builtins.int
    id: builtins.str
    status: global___TaskActivationStatus.ValueType
    @property
    def fetch_next_task(self) -> global___FetchNextTask:
        """If fetch_next is provided, receive a new task in the response"""

    def __init__(
        self,
        *,
        id: builtins.str = ...,
        status: global___TaskActivationStatus.ValueType = ...,
        fetch_next_task: global___FetchNextTask | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["_fetch_next_task", b"_fetch_next_task", "fetch_next_task", b"fetch_next_task"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["_fetch_next_task", b"_fetch_next_task", "fetch_next_task", b"fetch_next_task", "id", b"id", "status", b"status"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["_fetch_next_task", b"_fetch_next_task"]) -> typing.Literal["fetch_next_task"] | None: ...

global___SetTaskStatusRequest = SetTaskStatusRequest

@typing.final
class SetTaskStatusResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TASK_FIELD_NUMBER: builtins.int
    @property
    def task(self) -> global___TaskActivation:
        """The next task the worker should execute. Requires fetch_next to be set on the request."""

    def __init__(
        self,
        *,
        task: global___TaskActivation | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["_task", b"_task", "task", b"task"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["_task", b"_task", "task", b"task"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["_task", b"_task"]) -> typing.Literal["task"] | None: ...

global___SetTaskStatusResponse = SetTaskStatusResponse
