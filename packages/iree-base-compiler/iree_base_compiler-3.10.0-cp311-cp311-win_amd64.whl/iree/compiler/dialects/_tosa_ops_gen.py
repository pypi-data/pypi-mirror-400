
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union, Optional as _Optional


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "tosa"

@_ods_cext.register_operation(_Dialect)
class AbsOp(_ods_ir.OpView):
  r"""
  Elementwise absolute value operation.
  
  Example:
  
  ```mlir
  %output = tosa.abs(%input1) : (tensor<21x3xf32>) -> tensor<21x3xf32>
  ```
  """

  OPERATION_NAME = "tosa.abs"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def abs(output, input1, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return AbsOp(output=output, input1=input1, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AddOp(_ods_ir.OpView):
  r"""
  Elementwise addition of input1 and input2. Axis of size 1 will be broadcast,
  as necessary. Rank of input tensors must match.
  
  Example:
  
  ```mlir
  // Elementwise addition.
  %out = tosa.add %input1, %input2 : tensor<12x6xf32>, tensor<12x6xf32> -> tensor<12x6xf32>
  
  // Elementwise addition with broadcasting.
  %out = tosa.add %input1, %input2 : tensor<12x6xsi32>, tensor<1x1xsi32> -> tensor<12x6xsi32>
  ```
  """

  OPERATION_NAME = "tosa.add"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    operands.append(input2)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def add(output, input1, input2, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return AddOp(output=output, input1=input1, input2=input2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AddShapeOp(_ods_ir.OpView):
  r"""
  Elementwise addition of input1 and input2. Size of shapes must match.
  """

  OPERATION_NAME = "tosa.add_shape"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    operands.append(input2)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def add_shape(output, input1, input2, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return AddShapeOp(output=output, input1=input1, input2=input2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ApplyScaleOp(_ods_ir.OpView):
  r"""
  Applies rescaling for fixed point values. This behavior is replicated in
  multiple quantized operations (mul, convolution, rescale, matmul, pooling).
  
  The commonplace implementation is to use i64 operations to avoid integer
  overflow with target specific implementations can use native operations to
  avoid wider than necessary types.
  """

  OPERATION_NAME = "tosa.apply_scale"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, value, multiplier, shift, rounding_mode, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    operands.append(multiplier)
    operands.append(shift)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["rounding_mode"] = (rounding_mode if (
    isinstance(rounding_mode, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tosa_RoundingModeAttr')) else
      _ods_ir.AttrBuilder.get('Tosa_RoundingModeAttr')(rounding_mode, context=_ods_context))
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def multiplier(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def shift(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def rounding_mode(self) -> _ods_ir.Attribute:
    return self.operation.attributes["rounding_mode"]

  @rounding_mode.setter
  def rounding_mode(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["rounding_mode"] = value

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def apply_scale(output, value, multiplier, shift, rounding_mode, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ApplyScaleOp(output=output, value=value, multiplier=multiplier, shift=shift, rounding_mode=rounding_mode, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ArgMaxOp(_ods_ir.OpView):
  r"""
  This returns the index with the largest value across the given axis of the
  input tensor. If multiple locations have equal values, returns the first
  match along the search axis.
  """

  OPERATION_NAME = "tosa.argmax"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, axis, *, nan_mode=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    isinstance(axis, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(axis, context=_ods_context))
    if nan_mode is not None: attributes["nan_mode"] = (nan_mode if (
        isinstance(nan_mode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tosa_NanPropagationModeAttr')) else
          _ods_ir.AttrBuilder.get('Tosa_NanPropagationModeAttr')(nan_mode, context=_ods_context))
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def axis(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def nan_mode(self) -> _ods_ir.Attribute:
    return self.operation.attributes["nan_mode"]

  @nan_mode.setter
  def nan_mode(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["nan_mode"] = value

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def argmax(output, input, axis, *, nan_mode=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ArgMaxOp(output=output, input=input, axis=axis, nan_mode=nan_mode, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ArithmeticRightShiftOp(_ods_ir.OpView):
  r"""
  Elementwise arithmetic right shift of input1 by the amount specified in
  input2. Axis of size 1 will be broadcast, as necessary. Rank of input tensors
  must match.
  """

  OPERATION_NAME = "tosa.arithmetic_right_shift"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, round, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    operands.append(input2)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["round"] = (round if (
    isinstance(round, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(round, context=_ods_context))
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def round(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["round"]

  @round.setter
  def round(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["round"] = value

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def arithmetic_right_shift(output, input1, input2, round, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ArithmeticRightShiftOp(output=output, input1=input1, input2=input2, round=round, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AvgPool2dOp(_ods_ir.OpView):
  r"""
  This performs an average pooling over the given input tensor. A sliding
  window of size given by <kernel size> is passed over the input tensor, with
  the mean value being placed in the output tensor. When calculating the
  average, only the number of valid input tensor values, but not padding, are
  used to calculate the divisor.
  """

  OPERATION_NAME = "tosa.avg_pool2d"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, input_zp, output_zp, kernel, stride, pad, acc_type, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(input_zp)
    operands.append(output_zp)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["kernel"] = (kernel if (
    isinstance(kernel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tosa_IntArrayAttr2')) else
      _ods_ir.AttrBuilder.get('Tosa_IntArrayAttr2')(kernel, context=_ods_context))
    attributes["stride"] = (stride if (
    isinstance(stride, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tosa_IntArrayAttr2')) else
      _ods_ir.AttrBuilder.get('Tosa_IntArrayAttr2')(stride, context=_ods_context))
    attributes["pad"] = (pad if (
    isinstance(pad, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tosa_IntArrayAttr4')) else
      _ods_ir.AttrBuilder.get('Tosa_IntArrayAttr4')(pad, context=_ods_context))
    attributes["acc_type"] = (acc_type if (
    isinstance(acc_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_693')) else
      _ods_ir.AttrBuilder.get('anonymous_693')(acc_type, context=_ods_context))
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_zp(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def output_zp(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def kernel(self) -> _ods_ir.DenseI64ArrayAttr:
    return self.operation.attributes["kernel"]

  @kernel.setter
  def kernel(self, value: _ods_ir.DenseI64ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["kernel"] = value

  @builtins.property
  def stride(self) -> _ods_ir.DenseI64ArrayAttr:
    return self.operation.attributes["stride"]

  @stride.setter
  def stride(self, value: _ods_ir.DenseI64ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["stride"] = value

  @builtins.property
  def pad(self) -> _ods_ir.DenseI64ArrayAttr:
    return self.operation.attributes["pad"]

  @pad.setter
  def pad(self, value: _ods_ir.DenseI64ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pad"] = value

  @builtins.property
  def acc_type(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["acc_type"]

  @acc_type.setter
  def acc_type(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["acc_type"] = value

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def avg_pool2d(output, input, input_zp, output_zp, kernel, stride, pad, acc_type, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return AvgPool2dOp(output=output, input=input, input_zp=input_zp, output_zp=output_zp, kernel=kernel, stride=stride, pad=pad, acc_type=acc_type, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BitwiseAndOp(_ods_ir.OpView):
  r"""
  Elementwise bitwise AND of input1 and input2. Axis of size 1
  will be broadcast as necessary. Rank of input tensors must match.
  """

  OPERATION_NAME = "tosa.bitwise_and"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    operands.append(input2)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def bitwise_and(output, input1, input2, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return BitwiseAndOp(output=output, input1=input1, input2=input2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BitwiseNotOp(_ods_ir.OpView):
  r"""
  Elementwise bitwise NOT of input tensor.
  """

  OPERATION_NAME = "tosa.bitwise_not"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def bitwise_not(output, input1, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return BitwiseNotOp(output=output, input1=input1, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BitwiseOrOp(_ods_ir.OpView):
  r"""
  Elementwise bitwise OR of input1 and input2. Axis of size 1 will be
  broadcast as necessary. Rank of input tensors must match.
  """

  OPERATION_NAME = "tosa.bitwise_or"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    operands.append(input2)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def bitwise_or(output, input1, input2, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return BitwiseOrOp(output=output, input1=input1, input2=input2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BitwiseXorOp(_ods_ir.OpView):
  r"""
  Elementwise bitwise XOR of input1 and input2. Axis of size 1 will be
  broadcast as necessary. Rank of input tensors must match.
  """

  OPERATION_NAME = "tosa.bitwise_xor"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    operands.append(input2)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def bitwise_xor(output, input1, input2, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return BitwiseXorOp(output=output, input1=input1, input2=input2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CastFromBlockScaledOp(_ods_ir.OpView):
  r"""
  Apply the scales from a scale tensor to the values in a value tensor, casting
  the result to the output type. The block dimension must be the last dimension
  of the tensor.
  """

  OPERATION_NAME = "tosa.cast_from_block_scaled"

  _ODS_REGIONS = (0, True)

  def __init__(self, output_data, input_data, input_scale, block_size, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_data)
    operands.append(input_scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["block_size"] = (block_size if (
    isinstance(block_size, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tosa_BlockSizeAttr')) else
      _ods_ir.AttrBuilder.get('Tosa_BlockSizeAttr')(block_size, context=_ods_context))
    results = []
    results.append(output_data)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_data(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_scale(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def block_size(self) -> _ods_ir.Attribute:
    return self.operation.attributes["block_size"]

  @block_size.setter
  def block_size(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["block_size"] = value

  @builtins.property
  def output_data(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cast_from_block_scaled(output_data, input_data, input_scale, block_size, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CastFromBlockScaledOp(output_data=output_data, input_data=input_data, input_scale=input_scale, block_size=block_size, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CastOp(_ods_ir.OpView):
  r"""
  Casts a tensor from one data type to another.
  * This table is showing the supported conversions from the TOSA Specification.
  * The MLIR dialect here can be used to represent other conversions.
  
  | Mode                     | Input   | Output  |
  |--------------------------|---------|---------|
  | fp16 to fp32             | float16 | float32 |
  | fp16 to int 16           | float16 | int16   |
  | fp16 to int 32           | float16 | int32   |
  | fp16 to int 8            | float16 | int8    |
  | fp32 to fp16             | float32 | float16 |
  | fp32 to int 16           | float32 | int16   |
  | fp32 to int 32           | float32 | int32   |
  | fp32 to int 8            | float32 | int8    |
  | int 16 to fp16           | int16   | float16 |
  | int 16 to fp32           | int16   | float32 |
  | int 32 to fp16           | int32   | float16 |
  | int 32 to fp32           | int32   | float32 |
  | int 8 to fp16            | int8    | float16 |
  | int 8 to fp32            | int8    | float32 |
  | bool to int 16           | Boolean | int16   |
  | bool to int 32           | Boolean | int32   |
  | bool to int 8            | Boolean | int8    |
  | int 16 to bool           | int16   | Boolean |
  | int 16 to int 32         | int16   | int32   |
  | int 16 to int 8          | int16   | int8    |
  | int 32 to bool           | int32   | Boolean |
  | int 32 to int 16         | int32   | int16   |
  | int 32 to int 8          | int32   | int8    |
  | int 8 to bool            | int8    | Boolean |
  | int 8 to int 16          | int8    | int16   |
  | int 8 to int 32          | int8    | int32   |
  | bf16 to fp32             | bf16    | float32 |
  | bf16 to int 16           | bf16    | int16   |
  | bf16 to int 32           | bf16    | int32   |
  | bf16 to int 8            | bf16    | int8    |
  | fp32 to bf16             | float32 | bf16    |
  | int 16 to bf16           | int16   | bf16    |
  | int 32 to bf16           | int32   | bf16    |
  | int 8 to bf16            | int8    | bf16    |
  | bf16 to fp8e4m3          | bf16    | fp8e4m3 |
  | fp8e4m3 to bf16          | fp8e4m3 | bf16    |
  | bf16 to fp8e5m2          | bf16    | fp8e5m2 |
  | fp8e5m2 to bf16          | fp8e5m2 | bf16    |
  | fp16 to fp8e4m3          | float16 | fp8e4m3 |
  | fp32 to fp8e4m3          | float32 | fp8e4m3 |
  | fp8e4m3 to fp16          | fp8e4m3 | float16 |
  | fp8e4m3 to fp32          | fp8e4m3 | float32 |
  | fp16 to fp8e5m2          | float16 | fp8e5m2 |
  | fp32 to fp8e5m2          | float32 | fp8e5m2 |
  | fp8e5m2 to fp16          | fp8e5m2 | float16 |
  | fp8e5m2 to fp32          | fp8e5m2 | float32 |
  """

  OPERATION_NAME = "tosa.cast"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cast(output, input, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CastOp(output=output, input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CastToBlockScaledOp(_ods_ir.OpView):
  r"""
  Calculate a scale value per block of input values and use that to calculate
  scaled data values from an input tensor. The output tensors are cast to the
  specified scale and value types. The block dimension will be the last dimension
  of the tensor.
  """

  OPERATION_NAME = "tosa.cast_to_block_scaled"

  _ODS_REGIONS = (0, True)

  def __init__(self, output_data, output_scale, input_data, block_size, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_data)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["block_size"] = (block_size if (
    isinstance(block_size, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tosa_BlockSizeAttr')) else
      _ods_ir.AttrBuilder.get('Tosa_BlockSizeAttr')(block_size, context=_ods_context))
    results = []
    results.append(output_data)
    results.append(output_scale)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_data(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def block_size(self) -> _ods_ir.Attribute:
    return self.operation.attributes["block_size"]

  @block_size.setter
  def block_size(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["block_size"] = value

  @builtins.property
  def output_data(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

  @builtins.property
  def output_scale(self) -> _ods_ir.OpResult:
    return self.operation.results[1]

def cast_to_block_scaled(output_data, output_scale, input_data, block_size, *, loc=None, ip=None) -> _ods_ir.OpResultList:
  return CastToBlockScaledOp(output_data=output_data, output_scale=output_scale, input_data=input_data, block_size=block_size, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class CeilOp(_ods_ir.OpView):
  r"""
  Elementwise ceiling operation.
  """

  OPERATION_NAME = "tosa.ceil"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def ceil(output, input1, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CeilOp(output=output, input1=input1, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ClampOp(_ods_ir.OpView):
  r"""
  Clamp to an arbitrary minimum and maximum value.
  Maximum and minimum values are specified as values in the range of the
  input type.
  No zero point subtraction is done to the values, thus to clamp to the zero
  point value, the zero point itself should be supplied as the minimum value.
  """

  OPERATION_NAME = "tosa.clamp"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, min_val, max_val, *, nan_mode=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["min_val"] = (min_val if (
    isinstance(min_val, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tosa_IntOrFloatAttr')) else
      _ods_ir.AttrBuilder.get('Tosa_IntOrFloatAttr')(min_val, context=_ods_context))
    attributes["max_val"] = (max_val if (
    isinstance(max_val, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tosa_IntOrFloatAttr')) else
      _ods_ir.AttrBuilder.get('Tosa_IntOrFloatAttr')(max_val, context=_ods_context))
    if nan_mode is not None: attributes["nan_mode"] = (nan_mode if (
        isinstance(nan_mode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tosa_NanPropagationModeAttr')) else
          _ods_ir.AttrBuilder.get('Tosa_NanPropagationModeAttr')(nan_mode, context=_ods_context))
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def min_val(self) -> _ods_ir.Attribute:
    return self.operation.attributes["min_val"]

  @min_val.setter
  def min_val(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["min_val"] = value

  @builtins.property
  def max_val(self) -> _ods_ir.Attribute:
    return self.operation.attributes["max_val"]

  @max_val.setter
  def max_val(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["max_val"] = value

  @builtins.property
  def nan_mode(self) -> _ods_ir.Attribute:
    return self.operation.attributes["nan_mode"]

  @nan_mode.setter
  def nan_mode(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["nan_mode"] = value

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def clamp(output, input, min_val, max_val, *, nan_mode=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ClampOp(output=output, input=input, min_val=min_val, max_val=max_val, nan_mode=nan_mode, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ClzOp(_ods_ir.OpView):
  r"""
  Elementwise count leading zeros operation.
  """

  OPERATION_NAME = "tosa.clz"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def clz(output, input1, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ClzOp(output=output, input1=input1, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConcatOp(_ods_ir.OpView):
  r"""
  Concatenate a list of tensors along a given axis.
  No data conversion happens during a concat operation.
  """

  OPERATION_NAME = "tosa.concat"

  _ODS_REGIONS = (0, True)

  def __init__(self, input1, axis, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(input1))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    isinstance(axis, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(axis, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def axis(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def concat(input1, axis, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ConcatOp(input1=input1, axis=axis, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConstOp(_ods_ir.OpView):
  r"""
  A node containing constant data for use as the input to an operation. May
  hold data in any of the supported data formats.
  
  Example:
  
  ```mlir
  // Generic form
  %out = "tosa.const"() {values = dense<0> : tensor<2x3xi32>} : () -> tensor<2x3xi32>
  ```
  """

  OPERATION_NAME = "tosa.const"

  _ODS_REGIONS = (0, True)

  def __init__(self, values, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["values"] = (values if (
    isinstance(values, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ElementsAttr')) else
      _ods_ir.AttrBuilder.get('ElementsAttr')(values, context=_ods_context))
    if results is None:
      _ods_result_type_source_attr = attributes["values"]
      _ods_derived_result_type = (
        _ods_ir.TypeAttr(_ods_result_type_source_attr).value
        if _ods_ir.TypeAttr.isinstance(_ods_result_type_source_attr) else
        _ods_result_type_source_attr.type)
      results = [_ods_derived_result_type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def values(self) -> _ods_ir.Attribute:
    return self.operation.attributes["values"]

  @values.setter
  def values(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["values"] = value

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def const(values, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ConstOp(values=values, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConstShapeOp(_ods_ir.OpView):
  r"""
  A node containing a constant shape.
  
  Example:
  
  ```mlir
  // Generic form
  %out = "tosa.const_shape"() {values = dense<0> : tensor<4xindex>} : () -> !tosa.shape<4>
  ```
  """

  OPERATION_NAME = "tosa.const_shape"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, values, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["values"] = (values if (
    isinstance(values, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IndexElementsAttr')) else
      _ods_ir.AttrBuilder.get('IndexElementsAttr')(values, context=_ods_context))
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def values(self) -> _ods_ir.DenseIntElementsAttr:
    return self.operation.attributes["values"]

  @values.setter
  def values(self, value: _ods_ir.DenseIntElementsAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["values"] = value

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def const_shape(output, values, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ConstShapeOp(output=output, values=values, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Conv2DOp(_ods_ir.OpView):
  r"""
  Performs a 2D convolution over the given tensor input, using the weight
  tensor. Implementations may choose to skip calculation of multiplies in
  the padding area.
  """

  OPERATION_NAME = "tosa.conv2d"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, weight, bias, input_zp, weight_zp, pad, stride, dilation, acc_type, *, local_bound=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(weight)
    operands.append(bias)
    operands.append(input_zp)
    operands.append(weight_zp)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["pad"] = (pad if (
    isinstance(pad, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tosa_IntArrayAttr4')) else
      _ods_ir.AttrBuilder.get('Tosa_IntArrayAttr4')(pad, context=_ods_context))
    attributes["stride"] = (stride if (
    isinstance(stride, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tosa_IntArrayAttr2')) else
      _ods_ir.AttrBuilder.get('Tosa_IntArrayAttr2')(stride, context=_ods_context))
    attributes["dilation"] = (dilation if (
    isinstance(dilation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tosa_IntArrayAttr2')) else
      _ods_ir.AttrBuilder.get('Tosa_IntArrayAttr2')(dilation, context=_ods_context))
    attributes["acc_type"] = (acc_type if (
    isinstance(acc_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_693')) else
      _ods_ir.AttrBuilder.get('anonymous_693')(acc_type, context=_ods_context))
    if local_bound is not None: attributes["local_bound"] = (local_bound if (
        isinstance(local_bound, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(local_bound, context=_ods_context))
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def weight(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def bias(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def input_zp(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def weight_zp(self) -> _ods_ir.Value:
    return self.operation.operands[4]

  @builtins.property
  def pad(self) -> _ods_ir.DenseI64ArrayAttr:
    return self.operation.attributes["pad"]

  @pad.setter
  def pad(self, value: _ods_ir.DenseI64ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pad"] = value

  @builtins.property
  def stride(self) -> _ods_ir.DenseI64ArrayAttr:
    return self.operation.attributes["stride"]

  @stride.setter
  def stride(self, value: _ods_ir.DenseI64ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["stride"] = value

  @builtins.property
  def dilation(self) -> _ods_ir.DenseI64ArrayAttr:
    return self.operation.attributes["dilation"]

  @dilation.setter
  def dilation(self, value: _ods_ir.DenseI64ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dilation"] = value

  @builtins.property
  def acc_type(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["acc_type"]

  @acc_type.setter
  def acc_type(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["acc_type"] = value

  @builtins.property
  def local_bound(self) -> _Optional[_ods_ir.BoolAttr]:
    if "local_bound" not in self.operation.attributes:
      return None
    return self.operation.attributes["local_bound"]

  @local_bound.setter
  def local_bound(self, value: _Optional[_ods_ir.BoolAttr]):
    if value is not None:
      self.operation.attributes["local_bound"] = value
    elif "local_bound" in self.operation.attributes:
      del self.operation.attributes["local_bound"]

  @local_bound.deleter
  def local_bound(self):
    del self.operation.attributes["local_bound"]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def conv2d(output, input, weight, bias, input_zp, weight_zp, pad, stride, dilation, acc_type, *, local_bound=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return Conv2DOp(output=output, input=input, weight=weight, bias=bias, input_zp=input_zp, weight_zp=weight_zp, pad=pad, stride=stride, dilation=dilation, acc_type=acc_type, local_bound=local_bound, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Conv3DOp(_ods_ir.OpView):
  r"""
  Performs a 3D convolution over the given input tensor. Implementations
  may choose to skip calculation of multiplies in the padding area.
  """

  OPERATION_NAME = "tosa.conv3d"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, weight, bias, input_zp, weight_zp, pad, stride, dilation, acc_type, *, local_bound=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(weight)
    operands.append(bias)
    operands.append(input_zp)
    operands.append(weight_zp)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["pad"] = (pad if (
    isinstance(pad, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tosa_IntArrayAttr6')) else
      _ods_ir.AttrBuilder.get('Tosa_IntArrayAttr6')(pad, context=_ods_context))
    attributes["stride"] = (stride if (
    isinstance(stride, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tosa_IntArrayAttr3')) else
      _ods_ir.AttrBuilder.get('Tosa_IntArrayAttr3')(stride, context=_ods_context))
    attributes["dilation"] = (dilation if (
    isinstance(dilation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tosa_IntArrayAttr3')) else
      _ods_ir.AttrBuilder.get('Tosa_IntArrayAttr3')(dilation, context=_ods_context))
    attributes["acc_type"] = (acc_type if (
    isinstance(acc_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_693')) else
      _ods_ir.AttrBuilder.get('anonymous_693')(acc_type, context=_ods_context))
    if local_bound is not None: attributes["local_bound"] = (local_bound if (
        isinstance(local_bound, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(local_bound, context=_ods_context))
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def weight(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def bias(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def input_zp(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def weight_zp(self) -> _ods_ir.Value:
    return self.operation.operands[4]

  @builtins.property
  def pad(self) -> _ods_ir.DenseI64ArrayAttr:
    return self.operation.attributes["pad"]

  @pad.setter
  def pad(self, value: _ods_ir.DenseI64ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pad"] = value

  @builtins.property
  def stride(self) -> _ods_ir.DenseI64ArrayAttr:
    return self.operation.attributes["stride"]

  @stride.setter
  def stride(self, value: _ods_ir.DenseI64ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["stride"] = value

  @builtins.property
  def dilation(self) -> _ods_ir.DenseI64ArrayAttr:
    return self.operation.attributes["dilation"]

  @dilation.setter
  def dilation(self, value: _ods_ir.DenseI64ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dilation"] = value

  @builtins.property
  def acc_type(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["acc_type"]

  @acc_type.setter
  def acc_type(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["acc_type"] = value

  @builtins.property
  def local_bound(self) -> _Optional[_ods_ir.BoolAttr]:
    if "local_bound" not in self.operation.attributes:
      return None
    return self.operation.attributes["local_bound"]

  @local_bound.setter
  def local_bound(self, value: _Optional[_ods_ir.BoolAttr]):
    if value is not None:
      self.operation.attributes["local_bound"] = value
    elif "local_bound" in self.operation.attributes:
      del self.operation.attributes["local_bound"]

  @local_bound.deleter
  def local_bound(self):
    del self.operation.attributes["local_bound"]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def conv3d(output, input, weight, bias, input_zp, weight_zp, pad, stride, dilation, acc_type, *, local_bound=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return Conv3DOp(output=output, input=input, weight=weight, bias=bias, input_zp=input_zp, weight_zp=weight_zp, pad=pad, stride=stride, dilation=dilation, acc_type=acc_type, local_bound=local_bound, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CosOp(_ods_ir.OpView):
  r"""
  Elementwise cosine operation for values given in radians.
  """

  OPERATION_NAME = "tosa.cos"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cos(output, input1, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CosOp(output=output, input1=input1, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CustomOp(_ods_ir.OpView):
  r"""
  Hardware implementing TOSA may choose to add additional custom operators
  that are not expressed in the existing TOSA operations. These operators are
  not expected to be portable across TOSA implementations. The input and
  output signatures must be expressed in the corresponding TOSA node.
  
  `operator_name` is a string that tells the backend which custom operator is
  being called.
  
  `domain_name` is a string identifier which can help avoid name collisions on
  the identifier field.
  
  `implementation_attrs` is a string which is a backend and identifier specific
  set of attributes to the custom operator.
  
  `input_list` is the set of tensor inputs to the custom operator.
  
  `output_list` is the list of tensors returned by the operator. The number of operators
  is backend specific.
  
  Example:
  
  ```mlir
  %out = tosa.custom %in {domain_name = "tosa_mlir_test", operator_name =
         "custom_test", implementation_attrs = ""}: (tensor<10xi32>) ->
         (tensor<10xi32>)
  ```
  """

  OPERATION_NAME = "tosa.custom"

  _ODS_REGIONS = (0, True)

  def __init__(self, output_list, operator_name, domain_name, implementation_attrs, input_list, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(input_list))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["operator_name"] = (operator_name if (
    isinstance(operator_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(operator_name, context=_ods_context))
    attributes["domain_name"] = (domain_name if (
    isinstance(domain_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(domain_name, context=_ods_context))
    attributes["implementation_attrs"] = (implementation_attrs if (
    isinstance(implementation_attrs, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(implementation_attrs, context=_ods_context))
    results = []
    results.extend(output_list)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_list(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def operator_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["operator_name"]

  @operator_name.setter
  def operator_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["operator_name"] = value

  @builtins.property
  def domain_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["domain_name"]

  @domain_name.setter
  def domain_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["domain_name"] = value

  @builtins.property
  def implementation_attrs(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["implementation_attrs"]

  @implementation_attrs.setter
  def implementation_attrs(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["implementation_attrs"] = value

  @builtins.property
  def output_list(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def custom(output_list, operator_name, domain_name, implementation_attrs, input_list, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, CustomOp]:
  op = CustomOp(output_list=output_list, operator_name=operator_name, domain_name=domain_name, implementation_attrs=implementation_attrs, input_list=input_list, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class DepthwiseConv2DOp(_ods_ir.OpView):
  r"""
  Performs 2D convolutions separately over each channel of the given tensor
  input, using the weight tensor. Implementations may choose to skip
  calculation of multiplies in the padding area.
  """

  OPERATION_NAME = "tosa.depthwise_conv2d"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, weight, bias, input_zp, weight_zp, pad, stride, dilation, acc_type, *, local_bound=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(weight)
    operands.append(bias)
    operands.append(input_zp)
    operands.append(weight_zp)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["pad"] = (pad if (
    isinstance(pad, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tosa_IntArrayAttr4')) else
      _ods_ir.AttrBuilder.get('Tosa_IntArrayAttr4')(pad, context=_ods_context))
    attributes["stride"] = (stride if (
    isinstance(stride, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tosa_IntArrayAttr2')) else
      _ods_ir.AttrBuilder.get('Tosa_IntArrayAttr2')(stride, context=_ods_context))
    attributes["dilation"] = (dilation if (
    isinstance(dilation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tosa_IntArrayAttr2')) else
      _ods_ir.AttrBuilder.get('Tosa_IntArrayAttr2')(dilation, context=_ods_context))
    attributes["acc_type"] = (acc_type if (
    isinstance(acc_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_693')) else
      _ods_ir.AttrBuilder.get('anonymous_693')(acc_type, context=_ods_context))
    if local_bound is not None: attributes["local_bound"] = (local_bound if (
        isinstance(local_bound, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(local_bound, context=_ods_context))
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def weight(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def bias(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def input_zp(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def weight_zp(self) -> _ods_ir.Value:
    return self.operation.operands[4]

  @builtins.property
  def pad(self) -> _ods_ir.DenseI64ArrayAttr:
    return self.operation.attributes["pad"]

  @pad.setter
  def pad(self, value: _ods_ir.DenseI64ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pad"] = value

  @builtins.property
  def stride(self) -> _ods_ir.DenseI64ArrayAttr:
    return self.operation.attributes["stride"]

  @stride.setter
  def stride(self, value: _ods_ir.DenseI64ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["stride"] = value

  @builtins.property
  def dilation(self) -> _ods_ir.DenseI64ArrayAttr:
    return self.operation.attributes["dilation"]

  @dilation.setter
  def dilation(self, value: _ods_ir.DenseI64ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dilation"] = value

  @builtins.property
  def acc_type(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["acc_type"]

  @acc_type.setter
  def acc_type(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["acc_type"] = value

  @builtins.property
  def local_bound(self) -> _Optional[_ods_ir.BoolAttr]:
    if "local_bound" not in self.operation.attributes:
      return None
    return self.operation.attributes["local_bound"]

  @local_bound.setter
  def local_bound(self, value: _Optional[_ods_ir.BoolAttr]):
    if value is not None:
      self.operation.attributes["local_bound"] = value
    elif "local_bound" in self.operation.attributes:
      del self.operation.attributes["local_bound"]

  @local_bound.deleter
  def local_bound(self):
    del self.operation.attributes["local_bound"]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def depthwise_conv2d(output, input, weight, bias, input_zp, weight_zp, pad, stride, dilation, acc_type, *, local_bound=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return DepthwiseConv2DOp(output=output, input=input, weight=weight, bias=bias, input_zp=input_zp, weight_zp=weight_zp, pad=pad, stride=stride, dilation=dilation, acc_type=acc_type, local_bound=local_bound, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DimOp(_ods_ir.OpView):
  r"""
  Returns a length 1 shape_t of the size of the input tensor for the given axis.
  """

  OPERATION_NAME = "tosa.dim"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, axis, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    isinstance(axis, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(axis, context=_ods_context))
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def axis(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def dim(output, input1, axis, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return DimOp(output=output, input1=input1, axis=axis, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DivCeilShapeOp(_ods_ir.OpView):
  r"""
  Elementwise divide of input1 by input2. The result of the divide is rounded up.
  """

  OPERATION_NAME = "tosa.div_ceil_shape"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    operands.append(input2)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def div_ceil_shape(output, input1, input2, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return DivCeilShapeOp(output=output, input1=input1, input2=input2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DivFloorShapeOp(_ods_ir.OpView):
  r"""
  Elementwise integer divide of input1 by input2. The result of the divide is rounded down.
  """

  OPERATION_NAME = "tosa.div_floor_shape"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    operands.append(input2)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def div_floor_shape(output, input1, input2, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return DivFloorShapeOp(output=output, input1=input1, input2=input2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class EqualOp(_ods_ir.OpView):
  r"""
  Elementwise comparison operation.
  """

  OPERATION_NAME = "tosa.equal"

  _ODS_REGIONS = (0, True)

  def __init__(self, input1, input2, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    operands.append(input2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def equal(input1, input2, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return EqualOp(input1=input1, input2=input2, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ErfOp(_ods_ir.OpView):
  r"""
  Gauss error function: $ erf(x) = \frac{2}{\sqrt{\pi}} \int_{0}^{x} e^{-t^2} dt $
  For quantized integer data types, the TABLE operator should be used instead
  with the following definition. The ERF table has 513 entries each of
  16-bit precision and covering the input range -4.0 to +4.0 in steps of 1/64.
  """

  OPERATION_NAME = "tosa.erf"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def erf(output, input, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ErfOp(output=output, input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ExpOp(_ods_ir.OpView):
  r"""
  Elementwise e to the x operation
  """

  OPERATION_NAME = "tosa.exp"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def exp(output, input1, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ExpOp(output=output, input1=input1, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FFT2dOp(_ods_ir.OpView):
  r"""
  Performs a batched complex 2D Fast Fourier Transform over the input. The
  complex input values are constructed from the corresponding values in the
  input_real and input_imag tensors. The resulting values in the output are
  split into the output_real and output_imag tensors. No normalization is
  applied on either the forward or inverse versions of the operation.
  
  Example:
  
  ```mlir
   %output_real, %output_imag = tosa.fft2d %input_real, %input_imag : (tensor<8x9xf32>, tensor<8x9xf32>) -> (tensor<8x9xf32>, tensor<8x9xf32>)
  ```
  """

  OPERATION_NAME = "tosa.fft2d"

  _ODS_REGIONS = (0, True)

  def __init__(self, output_real, output_imag, input_real, input_imag, inverse, *, local_bound=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_real)
    operands.append(input_imag)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["inverse"] = (inverse if (
    isinstance(inverse, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(inverse, context=_ods_context))
    if local_bound is not None: attributes["local_bound"] = (local_bound if (
        isinstance(local_bound, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(local_bound, context=_ods_context))
    results = []
    results.append(output_real)
    results.append(output_imag)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_real(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_imag(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def inverse(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["inverse"]

  @inverse.setter
  def inverse(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["inverse"] = value

  @builtins.property
  def local_bound(self) -> _Optional[_ods_ir.BoolAttr]:
    if "local_bound" not in self.operation.attributes:
      return None
    return self.operation.attributes["local_bound"]

  @local_bound.setter
  def local_bound(self, value: _Optional[_ods_ir.BoolAttr]):
    if value is not None:
      self.operation.attributes["local_bound"] = value
    elif "local_bound" in self.operation.attributes:
      del self.operation.attributes["local_bound"]

  @local_bound.deleter
  def local_bound(self):
    del self.operation.attributes["local_bound"]

  @builtins.property
  def output_real(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

  @builtins.property
  def output_imag(self) -> _ods_ir.OpResult:
    return self.operation.results[1]

def fft2d(output_real, output_imag, input_real, input_imag, inverse, *, local_bound=None, loc=None, ip=None) -> _ods_ir.OpResultList:
  return FFT2dOp(output_real=output_real, output_imag=output_imag, input_real=input_real, input_imag=input_imag, inverse=inverse, local_bound=local_bound, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class FloorOp(_ods_ir.OpView):
  r"""
  Elementwise floor operation.
  """

  OPERATION_NAME = "tosa.floor"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def floor(output, input1, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return FloorOp(output=output, input1=input1, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GatherOp(_ods_ir.OpView):
  r"""
  Generate a tensor for which each element in the output is a subtensor of the
  values tensor based on the indices. N is the number of batches, W the number
  of indices in each batch, K the range of each index and C the number data
  channels for each index.
  """

  OPERATION_NAME = "tosa.gather"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, values, indices, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(values)
    operands.append(indices)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def values(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def indices(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def gather(output, values, indices, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return GatherOp(output=output, values=values, indices=indices, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GreaterEqualOp(_ods_ir.OpView):
  r"""
  Elementwise comparison operation.
  """

  OPERATION_NAME = "tosa.greater_equal"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    operands.append(input2)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def greater_equal(output, input1, input2, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return GreaterEqualOp(output=output, input1=input1, input2=input2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GreaterOp(_ods_ir.OpView):
  r"""
  Elementwise greater than comparison operation.
  """

  OPERATION_NAME = "tosa.greater"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    operands.append(input2)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def greater(output, input1, input2, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return GreaterOp(output=output, input1=input1, input2=input2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class IdentityOp(_ods_ir.OpView):
  r"""
  Returns a tensor with the same shape, type, and contents as the input.
  """

  OPERATION_NAME = "tosa.identity"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def identity(output, input1, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return IdentityOp(output=output, input1=input1, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class IfOp(_ods_ir.OpView):
  r"""
  Evaluates a Boolean condition and then takes one of two distinct execution
  paths. This implements the semantic If-then-else structure.
  """

  OPERATION_NAME = "tosa.cond_if"

  _ODS_REGIONS = (2, True)

  def __init__(self, output_list, condition, input_list, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(condition)
    operands.extend(_get_op_results_or_values(input_list))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(output_list)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def condition(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_list(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def output_list(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def then_graph(self) -> _ods_ir.Region:
    return self.regions[0]

  @builtins.property
  def else_graph(self) -> _ods_ir.Region:
    return self.regions[1]

def cond_if(output_list, condition, input_list, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, IfOp]:
  op = IfOp(output_list=output_list, condition=condition, input_list=input_list, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class IntDivOp(_ods_ir.OpView):
  r"""
  Elementwise integer divide of input1 by input2. Axis of size 1 will be
  broadcast as necessary. Rank of input tensors must match. The result of the
  divide is truncated towards zero. Expected use is for operations on
  non-scaled integers. Floating point divide should use RECIPROCAL and MUL.
  Quantized integer divide should use TABLE (for 1/x) and MUL.
  """

  OPERATION_NAME = "tosa.intdiv"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    operands.append(input2)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def intdiv(output, input1, input2, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return IntDivOp(output=output, input1=input1, input2=input2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class LogOp(_ods_ir.OpView):
  r"""
  Elementwise natural logarithm operation
  """

  OPERATION_NAME = "tosa.log"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def log(output, input1, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return LogOp(output=output, input1=input1, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class LogicalAndOp(_ods_ir.OpView):
  r"""
  Elementwise logical AND of input1 and input2. Axis of size 1 will be
  broadcast, as necessary. Rank of input tensors must match.
  """

  OPERATION_NAME = "tosa.logical_and"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    operands.append(input2)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def logical_and(output, input1, input2, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return LogicalAndOp(output=output, input1=input1, input2=input2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class LogicalLeftShiftOp(_ods_ir.OpView):
  r"""
  Elementwise logical left-shift of input1 by the amount specified in input2.
  Axis of size 1 will be broadcast, as necessary.
  Rank of input tensors must match.
  """

  OPERATION_NAME = "tosa.logical_left_shift"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    operands.append(input2)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def logical_left_shift(output, input1, input2, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return LogicalLeftShiftOp(output=output, input1=input1, input2=input2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class LogicalNotOp(_ods_ir.OpView):
  r"""
  Elementwise logical NOT of input.
  """

  OPERATION_NAME = "tosa.logical_not"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def logical_not(output, input1, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return LogicalNotOp(output=output, input1=input1, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class LogicalOrOp(_ods_ir.OpView):
  r"""
  Elementwise logical OR of input1 and input2. Axis of size 1 will be
  broadcast as necessary. Rank of input tensors must match.
  """

  OPERATION_NAME = "tosa.logical_or"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    operands.append(input2)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def logical_or(output, input1, input2, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return LogicalOrOp(output=output, input1=input1, input2=input2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class LogicalRightShiftOp(_ods_ir.OpView):
  r"""
  Elementwise logical right shift of input1 by the amount specified in input2.
  Axis of size 1 will be broadcast, as necessary. Rank of input tensors must
  match.
  """

  OPERATION_NAME = "tosa.logical_right_shift"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    operands.append(input2)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def logical_right_shift(output, input1, input2, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return LogicalRightShiftOp(output=output, input1=input1, input2=input2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class LogicalXorOp(_ods_ir.OpView):
  r"""
  Elementwise logical XOR of input1 and input2. Axis of size 1 will be
  broadcast as necessary. Rank of input tensors must match.
  """

  OPERATION_NAME = "tosa.logical_xor"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    operands.append(input2)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def logical_xor(output, input1, input2, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return LogicalXorOp(output=output, input1=input1, input2=input2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MatMulOp(_ods_ir.OpView):
  r"""
  Performs two dimensional matrix multiplications.
  """

  OPERATION_NAME = "tosa.matmul"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, a, b, a_zp, b_zp, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    operands.append(a_zp)
    operands.append(b_zp)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def b(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def a_zp(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def b_zp(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def matmul(output, a, b, a_zp, b_zp, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return MatMulOp(output=output, a=a, b=b, a_zp=a_zp, b_zp=b_zp, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MatmulTBlockScaledOp(_ods_ir.OpView):
  r"""
  Performs two dimensional matrix multiplications using block scaled tensors. The block
  dimension is always the the last dimension of the tensor, so the result is effectively
  a matrix multiply of A by the transposed B matrix. If the N dimension of input B is of
  size 1, the B matrix will be broadcast.
  """

  OPERATION_NAME = "tosa.matmul_t_block_scaled"

  _ODS_REGIONS = (0, True)

  def __init__(self, output_data, a_data, a_scale, b_data, b_scale, block_size, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(a_data)
    operands.append(a_scale)
    operands.append(b_data)
    operands.append(b_scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["block_size"] = (block_size if (
    isinstance(block_size, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tosa_BlockSizeAttr')) else
      _ods_ir.AttrBuilder.get('Tosa_BlockSizeAttr')(block_size, context=_ods_context))
    results = []
    results.append(output_data)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a_data(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def a_scale(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def b_data(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def b_scale(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def block_size(self) -> _ods_ir.Attribute:
    return self.operation.attributes["block_size"]

  @block_size.setter
  def block_size(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["block_size"] = value

  @builtins.property
  def output_data(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def matmul_t_block_scaled(output_data, a_data, a_scale, b_data, b_scale, block_size, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return MatmulTBlockScaledOp(output_data=output_data, a_data=a_data, a_scale=a_scale, b_data=b_data, b_scale=b_scale, block_size=block_size, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MaxPool2dOp(_ods_ir.OpView):
  r"""
  This performs a max pooling over the given input tensor. A sliding window of
  size given by <kernel size> is passed over the input tensor, with the
  maximum value being placed in the
  output tensor.
  """

  OPERATION_NAME = "tosa.max_pool2d"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, kernel, stride, pad, *, nan_mode=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["kernel"] = (kernel if (
    isinstance(kernel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tosa_IntArrayAttr2')) else
      _ods_ir.AttrBuilder.get('Tosa_IntArrayAttr2')(kernel, context=_ods_context))
    attributes["stride"] = (stride if (
    isinstance(stride, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tosa_IntArrayAttr2')) else
      _ods_ir.AttrBuilder.get('Tosa_IntArrayAttr2')(stride, context=_ods_context))
    attributes["pad"] = (pad if (
    isinstance(pad, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tosa_IntArrayAttr4')) else
      _ods_ir.AttrBuilder.get('Tosa_IntArrayAttr4')(pad, context=_ods_context))
    if nan_mode is not None: attributes["nan_mode"] = (nan_mode if (
        isinstance(nan_mode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tosa_NanPropagationModeAttr')) else
          _ods_ir.AttrBuilder.get('Tosa_NanPropagationModeAttr')(nan_mode, context=_ods_context))
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def kernel(self) -> _ods_ir.DenseI64ArrayAttr:
    return self.operation.attributes["kernel"]

  @kernel.setter
  def kernel(self, value: _ods_ir.DenseI64ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["kernel"] = value

  @builtins.property
  def stride(self) -> _ods_ir.DenseI64ArrayAttr:
    return self.operation.attributes["stride"]

  @stride.setter
  def stride(self, value: _ods_ir.DenseI64ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["stride"] = value

  @builtins.property
  def pad(self) -> _ods_ir.DenseI64ArrayAttr:
    return self.operation.attributes["pad"]

  @pad.setter
  def pad(self, value: _ods_ir.DenseI64ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pad"] = value

  @builtins.property
  def nan_mode(self) -> _ods_ir.Attribute:
    return self.operation.attributes["nan_mode"]

  @nan_mode.setter
  def nan_mode(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["nan_mode"] = value

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def max_pool2d(output, input, kernel, stride, pad, *, nan_mode=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MaxPool2dOp(output=output, input=input, kernel=kernel, stride=stride, pad=pad, nan_mode=nan_mode, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MaximumOp(_ods_ir.OpView):
  r"""
  Elementwise max of input1 and input2. Axis of size 1 will be broadcast, as
  necessary. Rank of input tensors must match.
  """

  OPERATION_NAME = "tosa.maximum"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, *, nan_mode=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    operands.append(input2)
    _ods_context = _ods_get_default_loc_context(loc)
    if nan_mode is not None: attributes["nan_mode"] = (nan_mode if (
        isinstance(nan_mode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tosa_NanPropagationModeAttr')) else
          _ods_ir.AttrBuilder.get('Tosa_NanPropagationModeAttr')(nan_mode, context=_ods_context))
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def nan_mode(self) -> _ods_ir.Attribute:
    return self.operation.attributes["nan_mode"]

  @nan_mode.setter
  def nan_mode(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["nan_mode"] = value

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def maximum(output, input1, input2, *, nan_mode=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MaximumOp(output=output, input1=input1, input2=input2, nan_mode=nan_mode, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MinimumOp(_ods_ir.OpView):
  r"""
  Elementwise minimum of input1 and input2. Axis of size 1
  will be broadcast, as necessary. Rank of input tensors must match.
  """

  OPERATION_NAME = "tosa.minimum"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, *, nan_mode=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    operands.append(input2)
    _ods_context = _ods_get_default_loc_context(loc)
    if nan_mode is not None: attributes["nan_mode"] = (nan_mode if (
        isinstance(nan_mode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tosa_NanPropagationModeAttr')) else
          _ods_ir.AttrBuilder.get('Tosa_NanPropagationModeAttr')(nan_mode, context=_ods_context))
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def nan_mode(self) -> _ods_ir.Attribute:
    return self.operation.attributes["nan_mode"]

  @nan_mode.setter
  def nan_mode(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["nan_mode"] = value

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def minimum(output, input1, input2, *, nan_mode=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MinimumOp(output=output, input1=input1, input2=input2, nan_mode=nan_mode, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MulOp(_ods_ir.OpView):
  r"""
  Elementwise multiplication (Hadamard product) of input1 and input2.
  Axis of size 1 will be broadcast, as necessary. Rank of input tensors must
  match.
  """

  OPERATION_NAME = "tosa.mul"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, shift, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    operands.append(input2)
    operands.append(shift)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def shift(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mul(output, input1, input2, shift, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return MulOp(output=output, input1=input1, input2=input2, shift=shift, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MulShapeOp(_ods_ir.OpView):
  r"""
  Elementwise multiplication of input1 and input2.
  """

  OPERATION_NAME = "tosa.mul_shape"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    operands.append(input2)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mul_shape(output, input1, input2, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return MulShapeOp(output=output, input1=input1, input2=input2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class NegateOp(_ods_ir.OpView):
  r"""
  Elementwise negation operation.
  """

  OPERATION_NAME = "tosa.negate"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input1_zp, output_zp, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    operands.append(input1_zp)
    operands.append(output_zp)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input1_zp(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def output_zp(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def negate(output, input1, input1_zp, output_zp, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return NegateOp(output=output, input1=input1, input1_zp=input1_zp, output_zp=output_zp, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PadOp(_ods_ir.OpView):
  r"""
  Pads a tensor along the borders of each dimension with a supplied value.
  Returns a new tensor with the padding included. The pad_const value includes
  the zero point if the tensor uses a zero point.
  
  Example:
  
  ```mlir
  %pad_const = "tosa.const"() {values = dense<3.14> : tensor<1xf32>} : () -> tensor<1xf32>
  %padding = tosa.const_shape {values = dense<[1, 2, 3, 4]> : tensor<4xindex>} : () -> !tosa.shape<4>
  tosa.pad %arg0, %padding, %pad_const: (tensor<1x2xf32>, !tosa.shape<4>, tensor<1xf32>)  -> (tensor<4x9xf32>)
  ```
  
  Example 2:
  
  ```mlir
  %pad_const = "tosa.const"() {values = dense<3.14> : tensor<1xf32>} : () -> tensor<1xf32>
  %padding = tosa.const_shape {values = dense<[-1, 2, 3, 4]> : tensor<4xindex>} : () -> !tosa.shape<4>
  tosa.pad %arg0, %padding, %pad_const : (tensor<1x2xf32>, !tosa.shape<4>, tensor<1xf32>)  -> (tensor<?x9xf32>)
  ```
  """

  OPERATION_NAME = "tosa.pad"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, padding, pad_const, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    operands.append(padding)
    operands.append(pad_const)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def padding(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def pad_const(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def pad(output, input1, padding, pad_const, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return PadOp(output=output, input1=input1, padding=padding, pad_const=pad_const, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PowOp(_ods_ir.OpView):
  r"""
  Elementwise input1 value raised to the power of input2.
  Axis of size 1 will be broadcast, as necessary. Rank of input tensors must
  match.
  """

  OPERATION_NAME = "tosa.pow"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    operands.append(input2)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def pow(output, input1, input2, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return PowOp(output=output, input1=input1, input2=input2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RFFT2dOp(_ods_ir.OpView):
  r"""
  Performs a batched 2D real-valued Fast Fourier Transform over the input where
  the input tensor consists of real values producing complex valued output. The
  complex output values will be split into the output_real and output_imag
  tensor arguments. RFFT2D takes advantage of Hermitian symmetry to only
  calculate the first half of the final output axis. Implementations may choose
  to skip calculation of the imaginary values at (0,0), (0,W/2), (H/2,0), and
  (H/2, W/2). If the calculation is skipped, the result at that location must be
  zero.
  
  Example:
  
  ```mlir
   %ouput_real, %output_imag = tosa.rfft2d %input_real : (tensor<8x16xf32>) -> (tensor<8x9xf32>, tensor<8x9xf32>)
  ```
  """

  OPERATION_NAME = "tosa.rfft2d"

  _ODS_REGIONS = (0, True)

  def __init__(self, output_real, output_imag, input_real, *, local_bound=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_real)
    _ods_context = _ods_get_default_loc_context(loc)
    if local_bound is not None: attributes["local_bound"] = (local_bound if (
        isinstance(local_bound, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(local_bound, context=_ods_context))
    results = []
    results.append(output_real)
    results.append(output_imag)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_real(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def local_bound(self) -> _Optional[_ods_ir.BoolAttr]:
    if "local_bound" not in self.operation.attributes:
      return None
    return self.operation.attributes["local_bound"]

  @local_bound.setter
  def local_bound(self, value: _Optional[_ods_ir.BoolAttr]):
    if value is not None:
      self.operation.attributes["local_bound"] = value
    elif "local_bound" in self.operation.attributes:
      del self.operation.attributes["local_bound"]

  @local_bound.deleter
  def local_bound(self):
    del self.operation.attributes["local_bound"]

  @builtins.property
  def output_real(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

  @builtins.property
  def output_imag(self) -> _ods_ir.OpResult:
    return self.operation.results[1]

def rfft2d(output_real, output_imag, input_real, *, local_bound=None, loc=None, ip=None) -> _ods_ir.OpResultList:
  return RFFT2dOp(output_real=output_real, output_imag=output_imag, input_real=input_real, local_bound=local_bound, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class ReciprocalOp(_ods_ir.OpView):
  r"""
  Elementwise reciprocal operation. For integer operation, a TABLE should be
  used with the appropriate ranges.
  """

  OPERATION_NAME = "tosa.reciprocal"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def reciprocal(output, input1, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ReciprocalOp(output=output, input1=input1, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ReduceAllOp(_ods_ir.OpView):
  r"""
  Reduce a tensor along the given axis with a logical AND operation.
  """

  OPERATION_NAME = "tosa.reduce_all"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, axis, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    isinstance(axis, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(axis, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def axis(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def reduce_all(input, axis, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ReduceAllOp(input=input, axis=axis, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ReduceAnyOp(_ods_ir.OpView):
  r"""
  Reduce a tensor along the given axis with a logical OR operation.
  """

  OPERATION_NAME = "tosa.reduce_any"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, axis, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    isinstance(axis, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(axis, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def axis(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def reduce_any(input, axis, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ReduceAnyOp(input=input, axis=axis, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ReduceMaxOp(_ods_ir.OpView):
  r"""
  Reduce a tensor along the given axis with a maximum operation.
  """

  OPERATION_NAME = "tosa.reduce_max"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, axis, *, nan_mode=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    isinstance(axis, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(axis, context=_ods_context))
    if nan_mode is not None: attributes["nan_mode"] = (nan_mode if (
        isinstance(nan_mode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tosa_NanPropagationModeAttr')) else
          _ods_ir.AttrBuilder.get('Tosa_NanPropagationModeAttr')(nan_mode, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def axis(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def nan_mode(self) -> _ods_ir.Attribute:
    return self.operation.attributes["nan_mode"]

  @nan_mode.setter
  def nan_mode(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["nan_mode"] = value

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def reduce_max(input, axis, *, nan_mode=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ReduceMaxOp(input=input, axis=axis, nan_mode=nan_mode, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ReduceMinOp(_ods_ir.OpView):
  r"""
  Reduce a tensor along the given axis with a minimum operation.
  """

  OPERATION_NAME = "tosa.reduce_min"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, axis, *, nan_mode=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    isinstance(axis, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(axis, context=_ods_context))
    if nan_mode is not None: attributes["nan_mode"] = (nan_mode if (
        isinstance(nan_mode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tosa_NanPropagationModeAttr')) else
          _ods_ir.AttrBuilder.get('Tosa_NanPropagationModeAttr')(nan_mode, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def axis(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def nan_mode(self) -> _ods_ir.Attribute:
    return self.operation.attributes["nan_mode"]

  @nan_mode.setter
  def nan_mode(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["nan_mode"] = value

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def reduce_min(input, axis, *, nan_mode=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ReduceMinOp(input=input, axis=axis, nan_mode=nan_mode, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ReduceProductOp(_ods_ir.OpView):
  r"""
  Reduce a tensor along the given axis by computing the product of the axis.
  """

  OPERATION_NAME = "tosa.reduce_product"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, axis, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    isinstance(axis, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(axis, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def axis(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def reduce_product(input, axis, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ReduceProductOp(input=input, axis=axis, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ReduceSumOp(_ods_ir.OpView):
  r"""
  Reduce a tensor along the given axis by computing the sum of the axis.
  """

  OPERATION_NAME = "tosa.reduce_sum"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, axis, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    isinstance(axis, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(axis, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def axis(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def reduce_sum(input, axis, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ReduceSumOp(input=input, axis=axis, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RescaleOp(_ods_ir.OpView):
  r"""
  RESCALE is defined using an integer multiply, add, and shift.
  
  Rescale supports two precisions of multiplier: 16-bit and 32-bit. The 32-bit multiplier
  version supports two rounding modes to enable simpler lowering of existing frameworks
  that use two stage rounding. All arithmetic is designed so that it does not overflow a
  64-bit accumulator and that the result fits in 32 bits. In particular, a 48-bit value
  cannot be scaled with the 32-bit multiplier because the accumulator would need to have
  80 bits.
  
  The shift and value range are limited to allow a variety of implementations. The limit
  of 62 on shift allows the shift to be decomposed as two right shifts of 31.
  
  Supported rescalings:
  * This table is showing the supported conversions from the TOSA Specification.
  * The MLIR dialect here can be used to represent other conversions.
  
  | Mode                   | Input | Output | Unsigned input | Unsigned output |
  |------------------------|-------|--------|----------------|-----------------|
  | signed 16 to 16        | int16 | int16  |  false         |  false          |
  | signed 16 to 32        | int16 | int32  |  false         |  false          |
  | signed 16 to 8         | int16 | int8   |  false         |  false          |
  | signed 32 to 16        | int32 | int16  |  false         |  false          |
  | signed 32 to 32        | int32 | int32  |  false         |  false          |
  | signed 32 to 8         | int32 | int8   |  false         |  false          |
  | signed 8 to 16         | int8  | int16  |  false         |  false          |
  | signed 8 to 32         | int8  | int32  |  false         |  false          |
  | signed 8 to 8          | int8  | int8   |  false         |  false          |
  | signed 48 to 16        | int48 | int16  |  false         |  false          |
  | signed 48 to 32        | int48 | int32  |  false         |  false          |
  | signed 48 to 8         | int48 | int8   |  false         |  false          |
  | unsigned 8 to signed 8 | uint8 | int8   |  true          |  false          |
  | signed 8 to unsigned 8 | int8  | uint8  |  false         |  true           |
  """

  OPERATION_NAME = "tosa.rescale"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, multiplier, shift, input_zp, output_zp, scale32, rounding_mode, per_channel, input_unsigned, output_unsigned, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(multiplier)
    operands.append(shift)
    operands.append(input_zp)
    operands.append(output_zp)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scale32"] = (scale32 if (
    isinstance(scale32, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(scale32, context=_ods_context))
    attributes["rounding_mode"] = (rounding_mode if (
    isinstance(rounding_mode, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tosa_RoundingModeAttr')) else
      _ods_ir.AttrBuilder.get('Tosa_RoundingModeAttr')(rounding_mode, context=_ods_context))
    attributes["per_channel"] = (per_channel if (
    isinstance(per_channel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(per_channel, context=_ods_context))
    attributes["input_unsigned"] = (input_unsigned if (
    isinstance(input_unsigned, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(input_unsigned, context=_ods_context))
    attributes["output_unsigned"] = (output_unsigned if (
    isinstance(output_unsigned, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(output_unsigned, context=_ods_context))
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def multiplier(self) -> _ods_ir.Value[_ods_ir.RankedTensorType]:
    return self.operation.operands[1]

  @builtins.property
  def shift(self) -> _ods_ir.Value[_ods_ir.RankedTensorType]:
    return self.operation.operands[2]

  @builtins.property
  def input_zp(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def output_zp(self) -> _ods_ir.Value:
    return self.operation.operands[4]

  @builtins.property
  def scale32(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["scale32"]

  @scale32.setter
  def scale32(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scale32"] = value

  @builtins.property
  def rounding_mode(self) -> _ods_ir.Attribute:
    return self.operation.attributes["rounding_mode"]

  @rounding_mode.setter
  def rounding_mode(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["rounding_mode"] = value

  @builtins.property
  def per_channel(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["per_channel"]

  @per_channel.setter
  def per_channel(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["per_channel"] = value

  @builtins.property
  def input_unsigned(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["input_unsigned"]

  @input_unsigned.setter
  def input_unsigned(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["input_unsigned"] = value

  @builtins.property
  def output_unsigned(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["output_unsigned"]

  @output_unsigned.setter
  def output_unsigned(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["output_unsigned"] = value

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def rescale(output, input, multiplier, shift, input_zp, output_zp, scale32, rounding_mode, per_channel, input_unsigned, output_unsigned, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return RescaleOp(output=output, input=input, multiplier=multiplier, shift=shift, input_zp=input_zp, output_zp=output_zp, scale32=scale32, rounding_mode=rounding_mode, per_channel=per_channel, input_unsigned=input_unsigned, output_unsigned=output_unsigned, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ReshapeOp(_ods_ir.OpView):
  r"""
  Returns a tensor with the same type/values as the input, with a new shape
  specified by the shape argument. Reshape may operate on tensors of any rank.
  No data conversion happens during a reshape operation.
  """

  OPERATION_NAME = "tosa.reshape"

  _ODS_REGIONS = (0, True)

  def __init__(self, input1, shape, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    operands.append(shape)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def shape(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def reshape(input1, shape, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ReshapeOp(input1=input1, shape=shape, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ResizeOp(_ods_ir.OpView):
  r"""
  Resizes a tensor. Resize is only allowed in the H and W dimensions.
  
  The height dimension is scaled by factor (scale_y_n/scale_y_d). The width
  dimension is scaled by factor (scale_x_n/scale_x_d).
  
  The NEAREST_NEIGHBOR mode returns the value of the input tensor closest to
  the calculated sample position for both floating-point and integer data
  formats.
  
  Floating-point BILINEAR mode returns a bilinearly interpolated output value
  based on the four closest input sample positions.
  
  For integer BILINEAR interpolation mode, the output value must be scaled by
  1/(scale_y_n * scale_x_n) in a following operation to complete the
  interpolation (for example with a RESCALE operator).
  
  The output dimensions can be derived from the input dimensions by inverting
  the scale as described in the pseudocode. The [border_y, border_x] values
  adjust the output size to allow fractional sampling beyond integer input
  position (IH - 1,IW - 1).
  
  The limit MAX_SCALE is applied to each scale ratio after reduction of the
  ratio. Individual scale numerator and denominator values are allowed to be
  larger than MAX_SCALE.
  """

  OPERATION_NAME = "tosa.resize"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, scale, offset, border, mode, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(scale)
    operands.append(offset)
    operands.append(border)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["mode"] = (mode if (
    isinstance(mode, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tosa_ResizeModeAttr')) else
      _ods_ir.AttrBuilder.get('Tosa_ResizeModeAttr')(mode, context=_ods_context))
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def offset(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def border(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def mode(self) -> _ods_ir.Attribute:
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def resize(output, input, scale, offset, border, mode, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ResizeOp(output=output, input=input, scale=scale, offset=offset, border=border, mode=mode, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ReverseOp(_ods_ir.OpView):
  r"""
  Returns a tensor with the same type/values as the input, with the data
  reversed along the given axis. No data conversion happens during a reverse
  operation.
  """

  OPERATION_NAME = "tosa.reverse"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, axis, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    isinstance(axis, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(axis, context=_ods_context))
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def axis(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def reverse(output, input1, axis, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ReverseOp(output=output, input1=input1, axis=axis, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RsqrtOp(_ods_ir.OpView):
  r"""
  Elementwise reciprocal square root operation. For integer operation, a TABLE
  should be used with the appropriate ranges.
  """

  OPERATION_NAME = "tosa.rsqrt"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def rsqrt(output, input1, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return RsqrtOp(output=output, input1=input1, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ScatterOp(_ods_ir.OpView):
  r"""
  The values_out tensor is set to the values_in tensor with data modified as
  follows: data from the input tensor is inserted at the positions specified
  by the indices tensor. N is the number of batches, W the number of indices
  in each batch, K the range of each index and C the number data channels for
  each index. It is not permitted to repeat the same output index within a
  single SCATTER operation and so each output index occurs at most once. It
  follows that K >= W. In use cases that require multiple updates to the same
  output position, these must be decomposed into multiple SCATTER operations.
  """

  OPERATION_NAME = "tosa.scatter"

  _ODS_REGIONS = (0, True)

  def __init__(self, values_out, values_in, indices, input, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(values_in)
    operands.append(indices)
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(values_out)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def values_in(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def indices(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def values_out(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def scatter(values_out, values_in, indices, input, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ScatterOp(values_out=values_out, values_in=values_in, indices=indices, input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SelectOp(_ods_ir.OpView):
  r"""
  Elementwise select of the output based on a condition.
  """

  OPERATION_NAME = "tosa.select"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, input3, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    operands.append(input2)
    operands.append(input3)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def input3(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def select(output, input1, input2, input3, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return SelectOp(output=output, input1=input1, input2=input2, input3=input3, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SigmoidOp(_ods_ir.OpView):
  r"""
  Applies the sigmoid logistic function to each element of the input tensor:
  $ sigmoid(x) = \frac{1}{1 + e^{-x}} $.
  
  For quantized integer data types, the TABLE operator should be used instead.
  Each implementation may choose an appropriate TABLE given the scale and zero
  point of the input data. Eight or sixteen bit precision tables may be used
  based on the input tensor to the sigmoid function.
  """

  OPERATION_NAME = "tosa.sigmoid"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def sigmoid(output, input, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return SigmoidOp(output=output, input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SinOp(_ods_ir.OpView):
  r"""
  Elementwise sine operation for values given in radians.
  """

  OPERATION_NAME = "tosa.sin"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def sin(output, input1, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return SinOp(output=output, input1=input1, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SliceOp(_ods_ir.OpView):
  r"""
  Extracts a slice of input1, beginning at the start coordinates,
  and extending for size elements in each direction.
  No data conversion happens during a slice operation.
  """

  OPERATION_NAME = "tosa.slice"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, start, size, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    operands.append(start)
    operands.append(size)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def start(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def size(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def slice(output, input1, start, size, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return SliceOp(output=output, input1=input1, start=start, size=size, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SubOp(_ods_ir.OpView):
  r"""
  Elementwise subtraction of input1 and input2. Axis of size 1 will be
  broadcast as necessary. Rank of input tensors must match.
  """

  OPERATION_NAME = "tosa.sub"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    operands.append(input2)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def sub(output, input1, input2, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return SubOp(output=output, input1=input1, input2=input2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SubShapeOp(_ods_ir.OpView):
  r"""
  Elementwise subtraction of input1 and input2. Size of shapes must match.
  """

  OPERATION_NAME = "tosa.sub_shape"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    operands.append(input2)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def sub_shape(output, input1, input2, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return SubShapeOp(output=output, input1=input1, input2=input2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TableOp(_ods_ir.OpView):
  r"""
  Table lookup operation. For int8_t TABLE operation, perform a 256 entry
  table lookup returning an int8_t value. For int16_t tables, the int16_t
  input is treated as a fixed-point 9.7 value. The most significant 9 bits
  are used to index into the table. The fractional 7 bits are used to
  interpolate based on table[index] and table[index+1]. For int16_t inputs,
  the TABLE operator returns a 16.7 interpolated value in an int32_t. This
  value can then be input to the RESCALE operator to scale to the required
  output data type. Note that int16_t table has 513 values to handle
  table[index+1] when index=511.
  
  An int16_t to int16_t table lookup can be constructed in TOSA as follows:
  * Use the TABLE operator to produce a fixed point 16.7 interpolated result
  * Use RESCALE (in_t=int32_t, out_t=int16_t, scale=1<<14, shift=21) to
    scale the output to int16_t range (or alternate scale as required)
  """

  OPERATION_NAME = "tosa.table"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, table, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    operands.append(table)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def table(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def table(output, input1, table, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TableOp(output=output, input1=input1, table=table, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TanhOp(_ods_ir.OpView):
  r"""
  Parameterized hyperbolic tangent: $ tanh(x) = \frac{1 - e^{-2x}}{1 + e^{-2x}} $.
  
  For quantized integer data types, the TABLE operator should be used instead.
  Each implementation may choose an appropriate TABLE given the scale and zero
  point of the input data. Eight or sixteen bit precision tables may be used
  based on the input tensor to the tanh function.
  """

  OPERATION_NAME = "tosa.tanh"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def tanh(output, input, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TanhOp(output=output, input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TileOp(_ods_ir.OpView):
  r"""
  Replicates input1 multiples times along each dimension.
  """

  OPERATION_NAME = "tosa.tile"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, multiples, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    operands.append(multiples)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def multiples(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def tile(output, input1, multiples, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TileOp(output=output, input1=input1, multiples=multiples, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TransposeConv2DOp(_ods_ir.OpView):
  r"""
  Performs a 2D transposed convolution over the given tensor input, using the
  weights tensor. Implementations may choose to skip calculation of multiplies
  by zero at fractional input positions.
  """

  OPERATION_NAME = "tosa.transpose_conv2d"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, weight, bias, input_zp, weight_zp, out_pad, stride, acc_type, *, local_bound=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(weight)
    operands.append(bias)
    operands.append(input_zp)
    operands.append(weight_zp)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["out_pad"] = (out_pad if (
    isinstance(out_pad, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tosa_IntArrayAttr4')) else
      _ods_ir.AttrBuilder.get('Tosa_IntArrayAttr4')(out_pad, context=_ods_context))
    attributes["stride"] = (stride if (
    isinstance(stride, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tosa_IntArrayAttr2')) else
      _ods_ir.AttrBuilder.get('Tosa_IntArrayAttr2')(stride, context=_ods_context))
    attributes["acc_type"] = (acc_type if (
    isinstance(acc_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_693')) else
      _ods_ir.AttrBuilder.get('anonymous_693')(acc_type, context=_ods_context))
    if local_bound is not None: attributes["local_bound"] = (local_bound if (
        isinstance(local_bound, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(local_bound, context=_ods_context))
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def weight(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def bias(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def input_zp(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def weight_zp(self) -> _ods_ir.Value:
    return self.operation.operands[4]

  @builtins.property
  def out_pad(self) -> _ods_ir.DenseI64ArrayAttr:
    return self.operation.attributes["out_pad"]

  @out_pad.setter
  def out_pad(self, value: _ods_ir.DenseI64ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["out_pad"] = value

  @builtins.property
  def stride(self) -> _ods_ir.DenseI64ArrayAttr:
    return self.operation.attributes["stride"]

  @stride.setter
  def stride(self, value: _ods_ir.DenseI64ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["stride"] = value

  @builtins.property
  def acc_type(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["acc_type"]

  @acc_type.setter
  def acc_type(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["acc_type"] = value

  @builtins.property
  def local_bound(self) -> _Optional[_ods_ir.BoolAttr]:
    if "local_bound" not in self.operation.attributes:
      return None
    return self.operation.attributes["local_bound"]

  @local_bound.setter
  def local_bound(self, value: _Optional[_ods_ir.BoolAttr]):
    if value is not None:
      self.operation.attributes["local_bound"] = value
    elif "local_bound" in self.operation.attributes:
      del self.operation.attributes["local_bound"]

  @local_bound.deleter
  def local_bound(self):
    del self.operation.attributes["local_bound"]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def transpose_conv2d(output, input, weight, bias, input_zp, weight_zp, out_pad, stride, acc_type, *, local_bound=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return TransposeConv2DOp(output=output, input=input, weight=weight, bias=bias, input_zp=input_zp, weight_zp=weight_zp, out_pad=out_pad, stride=stride, acc_type=acc_type, local_bound=local_bound, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TransposeOp(_ods_ir.OpView):
  r"""
  Permutes the dimensions of the input tensor input1 based on the perms
  argument. Each value in the perms list must be a valid dimension of the
  input tensor and may not be repeated.
  """

  OPERATION_NAME = "tosa.transpose"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, perms, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["perms"] = (perms if (
    isinstance(perms, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DenseI32ArrayAttr')) else
      _ods_ir.AttrBuilder.get('DenseI32ArrayAttr')(perms, context=_ods_context))
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def perms(self) -> _ods_ir.DenseI32ArrayAttr:
    return self.operation.attributes["perms"]

  @perms.setter
  def perms(self, value: _ods_ir.DenseI32ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["perms"] = value

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def transpose(output, input1, perms, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TransposeOp(output=output, input1=input1, perms=perms, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class VariableOp(_ods_ir.OpView):
  r"""
  Defines a new TOSA variable. This is a persistent mutable value across multiple
  TOSA graph invocations. Modifications are expressed using read/write semantics.
  """

  OPERATION_NAME = "tosa.variable"

  _ODS_REGIONS = (0, True)

  def __init__(self, sym_name, var_shape, type_, *, initial_value=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["var_shape"] = (var_shape if (
    isinstance(var_shape, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IndexElementsAttr')) else
      _ods_ir.AttrBuilder.get('IndexElementsAttr')(var_shape, context=_ods_context))
    attributes["type"] = (type_ if (
    isinstance(type_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(type_, context=_ods_context))
    if initial_value is not None: attributes["initial_value"] = (initial_value if (
        isinstance(initial_value, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('AnyAttr')) else
          _ods_ir.AttrBuilder.get('AnyAttr')(initial_value, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def var_shape(self) -> _ods_ir.DenseIntElementsAttr:
    return self.operation.attributes["var_shape"]

  @var_shape.setter
  def var_shape(self, value: _ods_ir.DenseIntElementsAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["var_shape"] = value

  @builtins.property
  def type_(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["type"]

  @type_.setter
  def type_(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["type"] = value

  @builtins.property
  def initial_value(self) -> _Optional[_ods_ir.Attribute]:
    if "initial_value" not in self.operation.attributes:
      return None
    return self.operation.attributes["initial_value"]

  @initial_value.setter
  def initial_value(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["initial_value"] = value
    elif "initial_value" in self.operation.attributes:
      del self.operation.attributes["initial_value"]

  @initial_value.deleter
  def initial_value(self):
    del self.operation.attributes["initial_value"]

def variable(sym_name, var_shape, type_, *, initial_value=None, loc=None, ip=None) -> VariableOp:
  return VariableOp(sym_name=sym_name, var_shape=var_shape, type_=type_, initial_value=initial_value, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class VariableReadOp(_ods_ir.OpView):
  r"""
  Reads the value from a pseudo-buffer resource holding a persistent mutable tensor.
  """

  OPERATION_NAME = "tosa.variable_read"

  _ODS_REGIONS = (0, True)

  def __init__(self, output1, name, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["name"] = (name if (
    isinstance(name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(name, context=_ods_context))
    results = []
    results.append(output1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["name"] = value

  @builtins.property
  def output1(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def variable_read(output1, name, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return VariableReadOp(output1=output1, name=name, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class VariableWriteOp(_ods_ir.OpView):
  r"""
  Assigns a value to the pseudo-buffer resource holding a persistent mutable tensor.
  """

  OPERATION_NAME = "tosa.variable_write"

  _ODS_REGIONS = (0, True)

  def __init__(self, name, input1, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["name"] = (name if (
    isinstance(name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(name, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["name"] = value

def variable_write(name, input1, *, loc=None, ip=None) -> VariableWriteOp:
  return VariableWriteOp(name=name, input1=input1, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class WhileOp(_ods_ir.OpView):
  r"""
  Generates and evaluates a Boolean condition and either executes a loop body
  or exits the loop. This action is performed repeatedly after
  updating and re-evaluating the Boolean condition every iteration. This
  implements the semantic foreach or while iterative loop structure.
  """

  OPERATION_NAME = "tosa.while_loop"

  _ODS_REGIONS = (2, True)

  def __init__(self, output_list, input_list, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(input_list))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(output_list)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_list(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def output_list(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def cond_graph(self) -> _ods_ir.Region:
    return self.regions[0]

  @builtins.property
  def body_graph(self) -> _ods_ir.Region:
    return self.regions[1]

def while_loop(output_list, input_list, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, WhileOp]:
  op = WhileOp(output_list=output_list, input_list=input_list, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class YieldOp(_ods_ir.OpView):
  r"""
  return operation within the conditional and body of
  structured control flow. Operation takes variadic operands
  but produces no results of its own.
  """

  OPERATION_NAME = "tosa.yield"

  _ODS_REGIONS = (0, True)

  def __init__(self, inputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def yield_(inputs, *, loc=None, ip=None) -> YieldOp:
  return YieldOp(inputs=inputs, loc=loc, ip=ip)
