"""
Markdown report generator.

Generates human-readable Markdown reports that can be viewed in text editors,
converted to other formats, or committed to documentation repositories.
"""

from pathlib import Path
from typing import List, Optional

import matplotlib.pyplot as plt
import numpy as np

from siglent.report_generator.generators.base import BaseReportGenerator
from siglent.report_generator.models.plot_style import PlotStyle
from siglent.report_generator.models.report_data import MeasurementResult, TestReport, TestSection, WaveformData


class MarkdownReportGenerator(BaseReportGenerator):
    """Generator for Markdown format reports."""

    def __init__(self, include_plots: bool = True, plots_dir: str = "plots", plot_style: PlotStyle = None):
        """
        Initialize Markdown generator.

        Args:
            include_plots: Whether to generate and include waveform plots
            plots_dir: Directory name for saving plot images (relative to report)
            plot_style: Plot style configuration for matplotlib plots
        """
        self.include_plots = include_plots
        self.plots_dir = plots_dir
        self.plot_style = plot_style or PlotStyle()

    def get_file_extension(self) -> str:
        """Get file extension."""
        return ".md"

    def generate(self, report: TestReport, output_path: Path) -> bool:
        """
        Generate Markdown report.

        Args:
            report: Test report
            output_path: Path to save the report

        Returns:
            True if successful, False otherwise
        """
        if not self.validate_report(report):
            print("Report validation failed")
            return False

        try:
            # Create plots directory if needed
            output_path = Path(output_path)
            if self.include_plots:
                plots_path = output_path.parent / self.plots_dir
                plots_path.mkdir(parents=True, exist_ok=True)

            # Generate markdown content
            content = self._generate_content(report, output_path.parent)

            # Write to file
            with open(output_path, "w", encoding="utf-8") as f:
                f.write(content)

            return True

        except Exception as e:
            print(f"Failed to generate Markdown report: {e}")
            return False

    def _generate_content(self, report: TestReport, base_path: Path) -> str:
        """Generate the complete markdown content."""
        lines = []

        # Title and metadata
        lines.append(f"# {report.metadata.title}")
        lines.append("")
        lines.append(self._generate_metadata_section(report))
        lines.append("")

        # Overall result
        overall_result = report.overall_result or report.calculate_overall_result()
        result_emoji = "✅" if overall_result == "PASS" else "❌" if overall_result == "FAIL" else "ℹ️"
        lines.append(f"## Overall Result: {result_emoji} {overall_result}")
        lines.append("")

        # Executive summary (if available)
        if report.executive_summary:
            lines.append("## Executive Summary")
            lines.append("")
            lines.append(report.executive_summary)
            lines.append("")
            if report.ai_generated_summary:
                lines.append("*Summary generated by AI*")
                lines.append("")

        # Key findings
        if report.key_findings:
            lines.append("## Key Findings")
            lines.append("")
            for finding in report.key_findings:
                lines.append(f"- {finding}")
            lines.append("")

        # Sections
        for section in report.sections:
            lines.append(self._generate_section(section, base_path))
            lines.append("")

        # Recommendations
        if report.recommendations:
            lines.append("## Recommendations")
            lines.append("")
            for i, rec in enumerate(report.recommendations, 1):
                lines.append(f"{i}. {rec}")
            lines.append("")

        # Footer
        lines.append("---")
        lines.append("")
        lines.append(f"*Report generated on {report.metadata.test_date.strftime('%Y-%m-%d at %H:%M:%S')}*")
        if report.metadata.company_name:
            lines.append(f"*{report.metadata.company_name}*")
        lines.append("")

        return "\n".join(lines)

    def _generate_metadata_section(self, report: TestReport) -> str:
        """Generate metadata table."""
        lines = []
        meta = report.metadata

        lines.append("| Field | Value |")
        lines.append("|-------|-------|")
        lines.append(f"| **Technician** | {meta.technician} |")
        lines.append(f"| **Date** | {meta.test_date.strftime('%Y-%m-%d %H:%M:%S')} |")

        if meta.equipment_model:
            lines.append(f"| **Equipment** | {meta.equipment_model} |")
        if meta.equipment_id:
            lines.append(f"| **Equipment ID** | {meta.equipment_id} |")
        if meta.test_procedure:
            lines.append(f"| **Test Procedure** | {meta.test_procedure} |")
        if meta.project_name:
            lines.append(f"| **Project** | {meta.project_name} |")
        if meta.customer:
            lines.append(f"| **Customer** | {meta.customer} |")
        if meta.temperature:
            lines.append(f"| **Temperature** | {meta.temperature} |")
        if meta.humidity:
            lines.append(f"| **Humidity** | {meta.humidity} |")
        if meta.location:
            lines.append(f"| **Location** | {meta.location} |")

        return "\n".join(lines)

    def _generate_section(self, section: TestSection, base_path: Path) -> str:
        """Generate a section of the report."""
        lines = []

        lines.append(f"## {section.title}")
        lines.append("")

        if section.content:
            lines.append(section.content)
            lines.append("")

        # AI insights
        if section.ai_summary:
            lines.append("### AI Analysis")
            lines.append("")
            lines.append(section.ai_summary)
            lines.append("")

        if section.ai_insights:
            lines.append("### AI Insights")
            lines.append("")
            lines.append(section.ai_insights)
            lines.append("")

        # Waveforms
        if section.waveforms:
            lines.append("### Waveforms")
            lines.append("")
            for i, waveform in enumerate(section.waveforms):
                lines.append(self._generate_waveform_info(waveform, base_path, f"{section.title}_{i}"))
                lines.append("")

        # Measurements
        if section.measurements:
            lines.append("### Measurements")
            lines.append("")
            lines.append(self._generate_measurements_table(section.measurements))
            lines.append("")

        # FFT
        if section.include_fft and section.fft_frequency is not None:
            lines.append("### FFT Analysis")
            lines.append("")
            if self.include_plots:
                fft_plot_path = self._generate_fft_plot(section.fft_frequency, section.fft_magnitude, base_path, f"{section.title}_fft")
                lines.append(f"![FFT Analysis]({fft_plot_path})")
            lines.append("")

        # Images
        if section.images:
            lines.append("### Images")
            lines.append("")
            for img_path in section.images:
                lines.append(f"![Image]({img_path})")
                lines.append("")

        return "\n".join(lines)

    def _generate_waveform_info(self, waveform: WaveformData, base_path: Path, name: str) -> str:
        """Generate waveform information and plot."""
        lines = []

        lines.append(f"#### {waveform.label}")
        lines.append("")

        # Generate plot if requested
        if self.include_plots:
            plot_path = self._generate_waveform_plot(waveform, base_path, name)
            lines.append(f"![{waveform.label}]({plot_path})")
            lines.append("")

        # Waveform info table
        lines.append("| Parameter | Value |")
        lines.append("|-----------|-------|")
        lines.append(f"| Sample Rate | {waveform.sample_rate / 1e6:.2f} MS/s |")
        lines.append(f"| Record Length | {waveform.record_length} samples |")

        if waveform.timebase:
            lines.append(f"| Timebase | {waveform.timebase * 1e6:.2f} µs/div |")
        if waveform.voltage_scale:
            lines.append(f"| Voltage Scale | {waveform.voltage_scale} V/div |")
        if waveform.probe_ratio:
            lines.append(f"| Probe Ratio | {waveform.probe_ratio}:1 |")

        # Signal Type (if analyzed)
        if waveform.signal_type:
            confidence_str = f" ({waveform.signal_type_confidence:.1f}% confidence)" if waveform.signal_type_confidence else ""
            lines.append(f"| **Signal Type** | **{waveform.signal_type.capitalize()}**{confidence_str} |")

        # Enhanced Statistics (if available)
        if waveform.statistics:
            lines.append("")
            lines.append("**Signal Statistics:**")
            lines.append("")
            lines.append("| Measurement | Value |")
            lines.append("|-------------|-------|")

            # Amplitude measurements
            for stat in ["vmax", "vmin", "vpp", "vrms", "vmean", "dc_offset"]:
                if stat in waveform.statistics and waveform.statistics[stat] is not None:
                    formatted = waveform.format_statistic(stat)
                    stat_label = stat.upper() if len(stat) <= 4 else stat.replace("_", " ").title()
                    lines.append(f"| {stat_label} | {formatted} |")

            # Frequency and timing
            for stat in ["frequency", "period", "rise_time", "fall_time", "pulse_width", "duty_cycle"]:
                if stat in waveform.statistics and waveform.statistics[stat] is not None:
                    formatted = waveform.format_statistic(stat)
                    stat_label = stat.replace("_", " ").title()
                    lines.append(f"| {stat_label} | {formatted} |")

            # Quality metrics
            for stat in ["snr", "thd", "noise_level", "overshoot", "undershoot", "jitter"]:
                if stat in waveform.statistics and waveform.statistics[stat] is not None:
                    formatted = waveform.format_statistic(stat)
                    stat_label = stat.upper() if stat in ["snr", "thd"] else stat.replace("_", " ").title()
                    lines.append(f"| {stat_label} | {formatted} |")

            # Plateau stability metrics (if calculated)
            for stat in ["plateau_stability", "plateau_high_noise", "plateau_low_noise"]:
                if stat in waveform.statistics and waveform.statistics[stat] is not None:
                    formatted = waveform.format_statistic(stat)
                    stat_label = stat.replace("_", " ").title()
                    lines.append(f"| {stat_label} | {formatted} |")

        else:
            # Fallback to basic statistics if not analyzed
            v_min = np.min(waveform.voltage_data)
            v_max = np.max(waveform.voltage_data)
            v_pp = v_max - v_min
            lines.append(f"| Peak-to-Peak | {v_pp:.4f} V |")
            lines.append(f"| Min | {v_min:.4f} V |")
            lines.append(f"| Max | {v_max:.4f} V |")

        # Generate region subsections if present
        if waveform.regions:
            lines.append("")
            lines.append("#### Detailed Region Analysis")
            lines.append("")
            for i, region in enumerate(waveform.regions, 1):
                region_lines = self._generate_region_info(waveform, region, base_path, f"{name}_region_{i}", i)
                lines.append(region_lines)
                lines.append("")

        return "\n".join(lines)

    def _generate_region_info(self, waveform: WaveformData, region, base_path: Path, name: str, index: int) -> str:
        """
        Generate Markdown for a single region.

        Args:
            waveform: Parent waveform
            region: WaveformRegion to generate
            base_path: Base path for saving plots
            name: Unique name for this region's plot file
            index: Region index number

        Returns:
            Markdown string for this region
        """
        lines = []

        # Region title
        auto_indicator = " *(Auto-detected)*" if region.auto_detected else ""
        lines.append(f"##### Region {index}: {region.label}{auto_indicator}")
        lines.append("")

        if region.description:
            lines.append(region.description)
            lines.append("")

        # Generate zoomed plot if requested
        if self.include_plots:
            plot_path = self._generate_region_plot(waveform, region, base_path, name)
            if plot_path:
                lines.append(f"![{region.label} - Zoomed View]({plot_path})")
                lines.append("")

        # Region analysis table
        lines.append("| Analysis | Value |")
        lines.append("|----------|-------|")

        # Time range
        duration_ms = (region.end_time - region.start_time) * 1e3
        lines.append(f"| **Time Range** | {region.start_time*1e3:.3f}ms to {region.end_time*1e3:.3f}ms ({duration_ms:.3f}ms) |")

        # Region type
        if region.region_type:
            type_label = region.region_type.replace("_", " ").title()
            lines.append(f"| **Region Type** | {type_label} |")

        # Analysis metrics
        if region.slope is not None:
            lines.append(f"| Slope | {region.slope:.0f} V/s |")

        if region.flatness is not None:
            lines.append(f"| Flatness (σ) | {region.flatness*1e3:.2f} mV |")

        if region.noise_level is not None:
            lines.append(f"| Noise Level | {region.noise_level*1e3:.2f} mV RMS |")

        if region.drift is not None:
            lines.append(f"| Total Drift | {region.drift*1e3:.2f} mV |")

        if region.ideal_value is not None:
            lines.append(f"| Ideal Value | {region.ideal_value:.4f} V |")
            if region.deviation_from_ideal is not None:
                lines.append(f"| Deviation | {region.deviation_from_ideal*1e3:.2f} mV |")

        if region.passes_spec is not None:
            status = "✅ PASS" if region.passes_spec else "❌ FAIL"
            lines.append(f"| **Spec Check** | **{status}** |")

        lines.append("")

        # Calibration recommendation
        if region.calibration_recommendation:
            lines.append("**Calibration Guidance:**")
            lines.append("")
            lines.append(f"> {region.calibration_recommendation}")
            lines.append("")

        # AI insights
        if region.ai_insights:
            lines.append("**AI Analysis:**")
            lines.append("")
            lines.append(region.ai_insights)
            lines.append("")

        return "\n".join(lines)

    def _generate_region_plot(self, waveform: WaveformData, region, base_path: Path, name: str) -> Optional[str]:
        """
        Generate and save a zoomed plot for a region.

        Args:
            waveform: Parent waveform
            region: WaveformRegion to plot
            base_path: Base path for saving plots
            name: Unique filename for this plot

        Returns:
            Relative path to the plot image, or None if generation fails
        """
        try:
            import matplotlib.pyplot as plt

            plots_path = base_path / self.plots_dir
            plots_path.mkdir(parents=True, exist_ok=True)

            filename = f"{name.replace(' ', '_')}.png"
            filepath = plots_path / filename

            # Extract region data
            t, v = waveform.get_region_data(region)

            if len(t) == 0:
                return None

            # Apply matplotlib style preset
            if self.plot_style.matplotlib_style != "default":
                plt.style.use(self.plot_style.matplotlib_style)

            fig, ax = plt.subplots(figsize=(10, 4))

            # Plot the region
            ax.plot(t * 1e3, v, color=region.highlight_color or self.plot_style.waveform_color, linewidth=self.plot_style.waveform_linewidth)

            # Add reference line for ideal value
            if region.ideal_value is not None:
                ax.axhline(y=region.ideal_value, color="red", linestyle="--", linewidth=1, label=f"Ideal: {region.ideal_value:.4f}V", alpha=0.6)
                ax.legend()

            # Apply style to axes
            self.plot_style.apply_to_axes(ax)

            # Set labels with custom font sizes
            ax.set_xlabel("Time (ms)", fontsize=self.plot_style.label_fontsize)
            ax.set_ylabel("Voltage (V)", fontsize=self.plot_style.label_fontsize)
            ax.set_title(f"{region.label} - Zoomed View", fontsize=self.plot_style.title_fontsize)

            ax.grid(True, alpha=0.3)

            plt.tight_layout()
            plt.savefig(filepath, dpi=150, bbox_inches="tight")
            plt.close(fig)

            return f"{self.plots_dir}/{filename}"

        except Exception as e:
            print(f"Error generating region plot: {e}")
            return None

    def _generate_measurements_table(self, measurements: List[MeasurementResult]) -> str:
        """Generate measurements table."""
        lines = []

        lines.append("| Measurement | Value | Status | Criteria |")
        lines.append("|-------------|-------|--------|----------|")

        for meas in measurements:
            name = meas.name
            if meas.channel:
                name += f" ({meas.channel})"

            value = meas.format_value()

            status = meas.get_status_symbol()
            if meas.passed is True:
                status = "✅ PASS"
            elif meas.passed is False:
                status = "❌ FAIL"
            else:
                status = "—"

            criteria = []
            if meas.criteria_min is not None:
                criteria.append(f"min: {meas.criteria_min:.6g} {meas.unit}")
            if meas.criteria_max is not None:
                criteria.append(f"max: {meas.criteria_max:.6g} {meas.unit}")
            criteria_str = "<br>".join(criteria) if criteria else "—"

            lines.append(f"| {name} | {value} | {status} | {criteria_str} |")

        return "\n".join(lines)

    def _generate_waveform_plot(self, waveform: WaveformData, base_path: Path, name: str) -> str:
        """Generate and save waveform plot with custom style."""
        plots_path = base_path / self.plots_dir
        plots_path.mkdir(parents=True, exist_ok=True)

        filename = f"{name.replace(' ', '_')}.png"
        filepath = plots_path / filename

        # Apply matplotlib style preset
        if self.plot_style.matplotlib_style != "default":
            plt.style.use(self.plot_style.matplotlib_style)

        fig, ax = plt.subplots(figsize=(10, 4))

        # Use plot style colors and settings
        ax.plot(waveform.time_data * 1e6, waveform.voltage_data, color=waveform.color or self.plot_style.waveform_color, linewidth=self.plot_style.waveform_linewidth)

        # Apply style to axes
        self.plot_style.apply_to_axes(ax)

        # Set labels with custom font sizes
        ax.set_xlabel("Time (µs)", fontsize=self.plot_style.label_fontsize)
        ax.set_ylabel("Voltage (V)", fontsize=self.plot_style.label_fontsize)
        ax.set_title(waveform.label, fontsize=self.plot_style.title_fontsize)

        plt.tight_layout()
        plt.savefig(filepath, dpi=150, bbox_inches="tight")
        plt.close(fig)

        return f"{self.plots_dir}/{filename}"

    def _generate_fft_plot(self, frequency: np.ndarray, magnitude: np.ndarray, base_path: Path, name: str) -> str:
        """Generate and save FFT plot with custom style."""
        plots_path = base_path / self.plots_dir
        plots_path.mkdir(parents=True, exist_ok=True)

        filename = f"{name.replace(' ', '_')}_fft.png"
        filepath = plots_path / filename

        # Apply matplotlib style preset
        if self.plot_style.matplotlib_style != "default":
            plt.style.use(self.plot_style.matplotlib_style)

        fig, ax = plt.subplots(figsize=(10, 4))

        # Use plot style colors and settings
        ax.plot(frequency / 1e6, magnitude, color=self.plot_style.fft_color, linewidth=self.plot_style.waveform_linewidth)

        # Apply style to axes
        self.plot_style.apply_to_axes(ax)

        # Set labels with custom font sizes
        ax.set_xlabel("Frequency (MHz)", fontsize=self.plot_style.label_fontsize)
        ax.set_ylabel("Magnitude (dB)", fontsize=self.plot_style.label_fontsize)
        ax.set_title("FFT Analysis", fontsize=self.plot_style.title_fontsize)

        plt.tight_layout()
        plt.savefig(filepath, dpi=150, bbox_inches="tight")
        plt.close(fig)

        return f"{self.plots_dir}/{filename}"
