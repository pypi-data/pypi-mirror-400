"""The Plash CLI tool"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_cli.ipynb.

# %% auto 0
__all__ = ['PLASH_CONFIG_HOME', 'PLASH_DOMAIN', 'pat', 'log_modes', 'PlashError', 'login', 'create_tar_archive', 'deploy', 'view',
           'delete_app', 'start_app', 'stop_app', 'logs', 'download_app', 'app_list', 'plash_tool_info']

# %% ../nbs/00_cli.ipynb 3
from fastcore.all import *
from fastcore.xdg import *
import secrets, webbrowser, httpx, io, tarfile, random, string
from pathlib import Path
from uuid import uuid4
from time import time, sleep
import io, os, re, tarfile

from . import __version__

# %% ../nbs/00_cli.ipynb 6
PLASH_CONFIG_HOME = xdg_config_home() / 'plash_config.json'
PLASH_DOMAIN = os.getenv("PLASH_DOMAIN","pla.sh")  # pla.sh plash-dev.answer.ai localhost:5002

# %% ../nbs/00_cli.ipynb 7
def _get_client(cfg=PLASH_CONFIG_HOME):
    client = httpx.Client()
    if tok := os.getenv("PLASH_TOKEN"): cookies = {"session_": tok}
    elif cfg.exists(): cookies = cfg.read_json()
    else: raise FileNotFoundError("Config not found. Run plash_login and retry.")
    client.cookies.update(cookies)
    client.headers.update({'X-PLASH': 'true', 'User-Agent': f'plash_cli/{__version__}'})
    return client

# %% ../nbs/00_cli.ipynb 8
def _mk_auth_req(url:str, method:str='get', timeout=300., **kwargs):
    r = getattr(_get_client(), method)(url, timeout=timeout, **kwargs)
    if r.status_code == 200: return r
    else: print(f'Failure: {r.headers["X-Plash-Error"]}')

# %% ../nbs/00_cli.ipynb 9
def _get_app_name(path:Path):
    plash_app = Path(path) / '.plash'
    if not plash_app.exists(): raise FileNotFoundError(f"File not found: {plash_app=}")
    env = parse_env(fn=plash_app)
    if name:=env.get("PLASH_APP_NAME"): return name
    if aid :=env.get('PLASH_APP_ID'): 
            plash_app.write_text(f"export PLASH_APP_NAME={aid}")
            return aid
    raise RuntimeError(f"{plash_app=} did not have a PLASH_APP_NAME")


# %% ../nbs/00_cli.ipynb 10
def _prep(path,name): return name if name else _get_app_name(Path(path))

# %% ../nbs/00_cli.ipynb 11
def _endpoint(sub='', rt=''):
    p = "http" if "localhost" in PLASH_DOMAIN else "https"
    return f"{p}://{sub}{'.' if sub else ''}{PLASH_DOMAIN}{rt}"

# %% ../nbs/00_cli.ipynb 12
def _is_included(path):
    "Returns True if path should be included in deployment"
    if path.name.startswith('.'): return False
    if path.suffix == '.pyc': return False
    excludes = {'.git', '__pycache__', '.gitignore', '.env', 
                '.pytest_cache', '.venv', 'venv', '.ipynb_checkpoints',
                '.vscode', '.idea', '.sesskey'}
    return not any(p in excludes for p in path.parts)

# %% ../nbs/00_cli.ipynb 13
class PlashError(Exception): pass

# %% ../nbs/00_cli.ipynb 14
def _poll_cookies(paircode, interval=1, timeout=180):
    "Poll server for token until received or timeout"
    start = time()
    client = httpx.Client()
    url = _endpoint(rt=f"/cli_token?paircode={paircode}")
    while time()-start < timeout:
        resp = client.get(url).raise_for_status()
        if resp.text.strip(): return dict(client.cookies)
        sleep(interval)

# %% ../nbs/00_cli.ipynb 15
@call_parse
def login(
    token:str=None,  # Token to save directly to config
    show:bool=False  # Output the current session token
):
    "Authenticate CLI with server and save config"
    if show:
        if not PLASH_CONFIG_HOME.exists(): return print("No config found.")
        return print(PLASH_CONFIG_HOME.read_json().get("session_", ""), end='')
    if token:
        PLASH_CONFIG_HOME.write_json({"session_": token.strip()})
        return f"Token saved to {PLASH_CONFIG_HOME}"
    paircode = secrets.token_urlsafe(16)
    login_url = httpx.get(_endpoint(rt=f"/cli_login?paircode={paircode}")).text
    print(f"Opening browser for authentication:\n{login_url}\n")
    webbrowser.open(login_url)
    
    cookies = _poll_cookies(paircode)
    if cookies:
        PLASH_CONFIG_HOME.write_json(cookies)
        print(f"Authentication successful! Config saved to {PLASH_CONFIG_HOME}")
    else: print("Authentication timed out.")

# %% ../nbs/00_cli.ipynb 18
pat = r'(?m)^# /// (?P<type>[a-zA-Z0-9-]+)$\s(?P<content>(^#(| .*)$\s)+)^# ///$'

def _deps(script: bytes | str):
    'Get the dependencies from the script. From: https://peps.python.org/pep-0723/'
    name = 'script'
    if isinstance(script, bytes): script = script.decode('utf-8')
    matches = L(re.finditer(pat, script)).filter(lambda m: m.group('type') == name)
    if len(matches) > 1: raise ValueError(f'Multiple {name} blocks found')
    elif len(matches) == 1:
        import tomllib
        content = ''.join(line[2:] if line.startswith('# ') else line[1:]
                          for line in matches[0].group('content').splitlines(keepends=True))
        return '\n'.join(tomllib.loads(content)['dependencies'])
    else: return None

# %% ../nbs/00_cli.ipynb 20
def _validate_app(path):
    "Validates directory `path` is a deployable Plash app"
    if not (path / 'main.py').exists():
        raise PlashError('A Plash app requires a main.py file.')
    deps = _deps((path / 'main.py').read_text(encoding='utf-8'))
    if  deps and (path/"requirements.txt").exists(): 
        raise PlashError('A Plash app should not contain both a requirements.txt file and inline dependencies (see PEP723).')

# %% ../nbs/00_cli.ipynb 23
def create_tar_archive(path:Path, force_data:bool=False) -> tuple[io.BytesIO, int]:
    "Creates a tar archive of a directory, excluding files based on is_included"
    tarz = io.BytesIO()
    files = L(path if path.is_file() else path.iterdir()).filter(_is_included)
    if not force_data: files = files.filter(lambda f: f.name != 'data')
    with tarfile.open(fileobj=tarz, mode='w:gz') as tar:
        for f in files: tar.add(f, arcname=f.name)
        if deps:=_deps((path/'main.py').read_bytes()):
            info = tarfile.TarInfo('requirements.txt')
            info.size = len(deps)
            tar.addfile(info, io.BytesIO(deps.encode('utf-8')))
    tarz.seek(0)
    return tarz, len(files)

# %% ../nbs/00_cli.ipynb 24
def deploy(
    path:Path='.',    # Path to project
    name:str=None,          # Overrides the .plash file in project root if provided
    _force_data:bool=False): # Overwrite data/ directory during deployment
    """
    Deploys app to production. By default, this command erases all files in your app which are not in data/.
    Then uploads all files and folders, except paths starting with `.` and except the local data/ directory.
    If `force_data` is used, then it erases all files in production. Then it uploads all files and folders,
    including `data/`, except paths starting with `.`.
    """
    path = Path(path)
    if name == '': raise PlashError('App name cannot be an empty string')
    if not path.is_dir(): raise PlashError("Path should point to the project directory")
    _validate_app(path)
    
    try: 
        if not name: name = _get_app_name(path)
    except FileNotFoundError:
        plash_app = path / '.plash'
        name = friendly_name(3, 3)
        plash_app.write_text(f'export PLASH_APP_NAME={name}')
    
    tarz, _ = create_tar_archive(path, _force_data)
    r = _mk_auth_req(_endpoint(rt="/upload"), "post", files={'file': tarz},
                     data={'name': name, 'force_data': _force_data})
    if not r: raise PlashError('Unknown failure')
    return name if "." in name else _endpoint(sub=name)

# %% ../nbs/00_cli.ipynb 25
@call_parse
def _deploy(
    path:Path='.',    # Path to project
    name:str=None,          # Overrides the .plash file in project root if provided
    force_data:bool=False): # Overwrite data/ directory during deployment
    print('Initializing deployment...')
    try: res = deploy(path=path, name=name, _force_data=force_data)
    except PlashError as e: return str(e)
    print('âœ… Upload complete! Your app is currently being built.\n' +
        f'It will be live at {res}')
_deploy.__doc__ = deploy.__doc__

# %% ../nbs/00_cli.ipynb 28
@call_parse
def view(
    path:Path='.', # Path to project directory
    name:str=None,     # Overrides the .plash file in project root if provided
):
    "Open your app in the browser"
    name = _prep(path, name)
    url = name if '.' in name else _endpoint(sub=name)
    print(f"Opening browser to view app :\n{url}\n")
    webbrowser.open(url)

# %% ../nbs/00_cli.ipynb 31
def delete_app(
    path:Path='.', # Path to project
    name:str=None):      # Overrides the .plash file in project root if provided
    'Delete your deployed app'
    name = _prep(path, name)
    r = _mk_auth_req(_endpoint(rt=f"/delete?name={name}"), "delete")
    if not r: raise PlashError('Failed to delete app')
    return f"App '{name}' deleted successfully"

@call_parse
@delegates(delete_app)
def _delete(force:bool=False,  # Skip confirmation prompt
    **kwargs):
    'Delete your deployed app'
    if not force:
        confirm = input("Are you sure you want to delete the app? [y/N]: ")
        if confirm.lower() not in ['y', 'yes']: return print("Deletion cancelled.")
    try: print(delete_app(**kwargs))
    except PlashError as e:  return str(e)
_delete.__doc__ = delete_app.__doc__

# %% ../nbs/00_cli.ipynb 34
def start_app(
    path:Path='.', # Path to project
    name:str=None):      # Overrides the .plash file in project root if provided
    'Start your deployed app'
    name = _prep(path, name)
    r = _mk_auth_req(_endpoint(rt=f"/start?name={name}"))
    if not r: raise PlashError('Failed to start app')
    return f"App '{name}' started"

@call_parse
@delegates(start_app)
def _start(**kwargs):
    try: print(start_app(**kwargs))
    except PlashError as e:  return str(e)
_start.__doc__ = start_app.__doc__

# %% ../nbs/00_cli.ipynb 37
def stop_app(
    path:Path='.', # Path to project
    name:str=None):      # Overrides the .plash file in project root if provided
    'Stop your deployed app'
    name = _prep(path, name)
    r = _mk_auth_req(_endpoint(rt=f"/stop?name={name}"))
    if not r: raise PlashError('Failed to stop app')
    return f"App '{name}' stopped"

@call_parse
@delegates(stop_app)
def _stop(**kwargs):
    try: print(stop_app(**kwargs))
    except PlashError as e:  return str(e)
_stop.__doc__ = stop_app.__doc__

# %% ../nbs/00_cli.ipynb 40
log_modes = str_enum('log_modes', 'build', 'app')

# %% ../nbs/00_cli.ipynb 41
def logs(
    path:Path='.',    # Path to project
    name:str=None,          # Overrides the .plash file in project root if provided
    mode:log_modes='build'): # Choose between build or app logs
    'Get logs for your deployed app'
    name = _prep(path, name)
    r = _mk_auth_req(_endpoint(rt=f"/logs?name={name}&mode={mode}"))
    if not r: raise PlashError('Failed to retrieve logs')
    return r.text

@call_parse
@delegates(logs)
def _logs(tail:bool=False,  # Tail the logs
    **kwargs):
    try:
        if not tail: return print(logs(**kwargs))
        text = ''
        while True:
            try:
                new_text = logs(**kwargs)
                print(new_text[len(text):], end='')
                text = new_text
                if kwargs.get('mode','build') == 'build' and 'Build End Time:' in new_text: return
                sleep(1)
            except KeyboardInterrupt: print("\nExiting"); return
    except PlashError as e:  return str(e)
_logs.__doc__ = logs.__doc__

# %% ../nbs/00_cli.ipynb 44
@patch
def _is_dir_empty(self:Path): return next(self.iterdir(), None) is None

# %% ../nbs/00_cli.ipynb 48
def download_app(
    path:Path='.',  # Path to project
    name:str=None,        # Overrides the .plash file in project root if provided
    save_path:Path="./download/"): # Save path (optional)
    "Download deployed app to save_path."
    name = _prep(path, name)
    save_path = Path(save_path)
    save_path.mkdir(exist_ok=True)
    if not save_path._is_dir_empty(): raise PlashError(f'Save path ({save_path}) is not empty.')
    r = _mk_auth_req(_endpoint(rt=f'/download?name={name}'))
    if not r: raise PlashError('Download request failed')
    with tarfile.open(fileobj=io.BytesIO(r.content), mode="r:gz") as tar: 
        tar.extractall(path=save_path, filter='data')
    return save_path

@call_parse
@delegates(download_app)
def _download(**kwargs):
    try: print(f"Downloaded your app to: {download_app(**kwargs)}")
    except PlashError as e:  return str(e)
_download.__doc__ = download_app.__doc__

# %% ../nbs/00_cli.ipynb 51
def app_list():
    "List your deployed apps"
    r = _mk_auth_req(_endpoint(rt="/user_apps"))
    if not r: raise PlashError('Failed to retrieve')
    return r.json()

@call_parse
def _app_list(verbose:bool=False): # Whether to show running status as well as name: 1=running, 0=stopped
    try: res = app_list()
    except PlashError as e: return str(e)
    if not res: print("You don't have any deployed Plash apps.")
    for a in res: print(f"{a['running']} {a['name']}" if verbose else a['name'])
_app_list.__doc__ = app_list.__doc__

# %% ../nbs/00_cli.ipynb 54
def plash_tool_info():
    from dialoghelper import add_msg
    add_msg('Plash tools: &`[login, deploy, start_app, stop_app, logs, download_app, app_list]`')
