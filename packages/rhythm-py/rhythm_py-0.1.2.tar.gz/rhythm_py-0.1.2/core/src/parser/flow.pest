// Flow v2 Grammar - Top-level statements with optional front matter

program = { SOI ~ (main_function | bare_workflow | statement) ~ EOI }

// Optional syntax sugar: async function main() { ... }
// This wrapper is parsed but immediately unwrapped - used to suppress IDE errors
main_function = { "async" ~ "function" ~ "main" ~ "(" ~ ")" ~ block }

// Workflow: Optional front matter followed by top-level statements
bare_workflow = { front_matter? ~ statement+ }

// Front matter - triple backticks at start containing YAML config
front_matter = { "```" ~ front_matter_content ~ "```" }
front_matter_content = @{ (!("```") ~ ANY)* }

block = { "{" ~ statement* ~ "}" }

// Statements
statement = { return_stmt | if_stmt | while_stmt | for_loop_stmt | try_stmt | break_stmt | continue_stmt | block | declare_stmt | assign_stmt | expr_stmt }

return_stmt = { "return" ~ expression }

declare_stmt = { var_kind ~ declare_target ~ ("=" ~ expression)? }
declare_target = { destructure_pattern | identifier }
destructure_pattern = { "{" ~ destructure_props ~ "}" }
destructure_props = { identifier ~ ("," ~ identifier)* ~ ","? }
var_kind = { "let" | "const" }

assign_stmt = { identifier ~ assign_path_segment* ~ "=" ~ expression }
assign_path_segment = { "." ~ identifier | "[" ~ expression ~ "]" }

if_stmt = { "if" ~ "(" ~ expression ~ ")" ~ block ~ else_clause? }
else_clause = { "else" ~ (if_stmt | block) }

while_stmt = { "while" ~ "(" ~ expression ~ ")" ~ block }

// For loop: for (let x of arr) or for (let k in obj)
for_loop_stmt = { "for" ~ "(" ~ var_kind ~ identifier ~ for_loop_kind ~ expression ~ ")" ~ block }
for_loop_kind = { "of" | "in" }

try_stmt = { "try" ~ block ~ "catch" ~ "(" ~ identifier ~ ")" ~ block }

break_stmt = { "break" }
continue_stmt = { "continue" }

expr_stmt = { expression }

// Identifiers
identifier = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }

expression = { await_expr | ternary_expr }

// Ternary: condition ? then : else
ternary_expr = { nullish_expr ~ ("?" ~ expression ~ ":" ~ expression)? }

// Await expression: await foo(), await task
await_expr = { "await" ~ expression }

// Operator tokens (captured as named rules)
op_nullish = { "??" }
op_or = { "||" }
op_and = { "&&" }
op_eq = { "==" }
op_ne = { "!=" }
op_lte = { "<=" }
op_gte = { ">=" }
op_lt = { "<" }
op_gt = { ">" }
op_add = { "+" }
op_sub = { "-" }
op_mul = { "*" }
op_div = { "/" }
op_not = { "!" }

// Nullish coalescing: a ?? b (lower precedence than ||)
nullish_expr = { logical_or_expr ~ (op_nullish ~ logical_or_expr)* }

// Logical OR: a || b
logical_or_expr = { logical_and_expr ~ (op_or ~ logical_and_expr)* }

// Logical AND: a && b
logical_and_expr = { equality_expr ~ (op_and ~ equality_expr)* }

// Equality: a == b, a != b
equality_expr = { comparison_expr ~ ((op_eq | op_ne) ~ comparison_expr)* }

// Comparison: a < b, a <= b, a > b, a >= b
comparison_expr = { additive_expr ~ ((op_lte | op_gte | op_lt | op_gt) ~ additive_expr)* }

// Addition/Subtraction: a + b, a - b
additive_expr = { multiplicative_expr ~ ((op_add | op_sub) ~ multiplicative_expr)* }

// Multiplication/Division: a * b, a / b
multiplicative_expr = { unary_expr ~ ((op_mul | op_div) ~ unary_expr)* }

// Unary operators: !x
unary_expr = { op_not ~ unary_expr | call_expr }

// Function calls and member access: foo(), foo.bar(), foo(1, 2).concat([3])
// Supports chaining: a.concat([2]).concat([3])
call_expr = { primary ~ postfix* }

// Postfix operations that can be chained
postfix = { call_suffix | optional_access | regular_access }
call_suffix = { "(" ~ arg_list? ~ ")" }
optional_access = { "?." ~ identifier }
regular_access = { "." ~ identifier }

arg_list = { expression ~ ("," ~ expression)* }

primary = {
    "(" ~ expression ~ ")"
    | literal
    | identifier
}

literal = {
    object_lit
    | array_lit
    | boolean
    | number
    | string
    | null_lit
}

// Object literal: { key: value, key2: value2 } or { key } (shorthand)
object_lit = { "{" ~ property_list? ~ "}" }
property_list = { property ~ ("," ~ property)* ~ ","? }
property = { property_pair | property_shorthand }
property_pair = { identifier ~ ":" ~ expression }
property_shorthand = { identifier }

// Array literal: [1, 2, 3]
array_lit = { "[" ~ element_list? ~ "]" }
element_list = { expression ~ ("," ~ expression)* ~ ","? }

// Literals
number = @{ "-"? ~ ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT+)? }
boolean = { "true" | "false" }
string = { "\"" ~ string_content ~ "\"" }
string_content = @{ (!("\"") ~ ANY)* }
null_lit = { "null" }

// Whitespace and comments
WHITESPACE = _{ " " | "\t" | "\n" | "\r" }
COMMENT = _{ line_comment | block_comment }
line_comment = { "//" ~ (!"\n" ~ ANY)* }
block_comment = { "/*" ~ (!"*/" ~ ANY)* ~ "*/" }
