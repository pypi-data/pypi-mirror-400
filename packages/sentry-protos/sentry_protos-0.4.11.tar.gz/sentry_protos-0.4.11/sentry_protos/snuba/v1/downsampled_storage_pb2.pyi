"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""

import builtins
import google.protobuf.descriptor
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing.final
class DownsampledStorageConfig(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _Mode:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _ModeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[DownsampledStorageConfig._Mode.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        MODE_UNSPECIFIED: DownsampledStorageConfig._Mode.ValueType  # 0
        MODE_PREFLIGHT: DownsampledStorageConfig._Mode.ValueType  # 1
        """deprecated, treated as NORMAL mode"""
        MODE_BEST_EFFORT: DownsampledStorageConfig._Mode.ValueType  # 2
        """deprecated, treated as NORMAL mode"""
        MODE_NORMAL: DownsampledStorageConfig._Mode.ValueType  # 3
        """NORMAL queries are served faster and should not time out
        EAP will route to whatever tier it needs to in order to facilitate this
        The return payload from EAP will inform the client if there is a higher fidelity tier to scan
        """
        MODE_HIGHEST_ACCURACY: DownsampledStorageConfig._Mode.ValueType  # 4
        """HIGHEST_ACCURACY queries go straight to tier 1"""
        MODE_HIGHEST_ACCURACY_FLEXTIME: DownsampledStorageConfig._Mode.ValueType  # 5
        """queries go to tier 1 but may have their time range truncated based on data volume"""
        MODE_LOW_PRIORITY: DownsampledStorageConfig._Mode.ValueType  # 6
        """queries behave the same as NORMAL by default but are opted in
        to lose precision if the cluster is overloaded
        """

    class Mode(_Mode, metaclass=_ModeEnumTypeWrapper): ...
    MODE_UNSPECIFIED: DownsampledStorageConfig.Mode.ValueType  # 0
    MODE_PREFLIGHT: DownsampledStorageConfig.Mode.ValueType  # 1
    """deprecated, treated as NORMAL mode"""
    MODE_BEST_EFFORT: DownsampledStorageConfig.Mode.ValueType  # 2
    """deprecated, treated as NORMAL mode"""
    MODE_NORMAL: DownsampledStorageConfig.Mode.ValueType  # 3
    """NORMAL queries are served faster and should not time out
    EAP will route to whatever tier it needs to in order to facilitate this
    The return payload from EAP will inform the client if there is a higher fidelity tier to scan
    """
    MODE_HIGHEST_ACCURACY: DownsampledStorageConfig.Mode.ValueType  # 4
    """HIGHEST_ACCURACY queries go straight to tier 1"""
    MODE_HIGHEST_ACCURACY_FLEXTIME: DownsampledStorageConfig.Mode.ValueType  # 5
    """queries go to tier 1 but may have their time range truncated based on data volume"""
    MODE_LOW_PRIORITY: DownsampledStorageConfig.Mode.ValueType  # 6
    """queries behave the same as NORMAL by default but are opted in
    to lose precision if the cluster is overloaded
    """

    MODE_FIELD_NUMBER: builtins.int
    mode: global___DownsampledStorageConfig.Mode.ValueType
    def __init__(
        self,
        *,
        mode: global___DownsampledStorageConfig.Mode.ValueType = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["mode", b"mode"]) -> None: ...

global___DownsampledStorageConfig = DownsampledStorageConfig

@typing.final
class DownsampledStorageMeta(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _SelectedTier:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _SelectedTierEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[DownsampledStorageMeta._SelectedTier.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        SELECTED_TIER_UNSPECIFIED: DownsampledStorageMeta._SelectedTier.ValueType  # 0
        SELECTED_TIER_1: DownsampledStorageMeta._SelectedTier.ValueType  # 1
        SELECTED_TIER_8: DownsampledStorageMeta._SelectedTier.ValueType  # 2
        SELECTED_TIER_64: DownsampledStorageMeta._SelectedTier.ValueType  # 3
        SELECTED_TIER_512: DownsampledStorageMeta._SelectedTier.ValueType  # 4

    class SelectedTier(_SelectedTier, metaclass=_SelectedTierEnumTypeWrapper): ...
    SELECTED_TIER_UNSPECIFIED: DownsampledStorageMeta.SelectedTier.ValueType  # 0
    SELECTED_TIER_1: DownsampledStorageMeta.SelectedTier.ValueType  # 1
    SELECTED_TIER_8: DownsampledStorageMeta.SelectedTier.ValueType  # 2
    SELECTED_TIER_64: DownsampledStorageMeta.SelectedTier.ValueType  # 3
    SELECTED_TIER_512: DownsampledStorageMeta.SelectedTier.ValueType  # 4

    TIER_FIELD_NUMBER: builtins.int
    ESTIMATED_NUM_ROWS_FIELD_NUMBER: builtins.int
    CAN_GO_TO_HIGHER_ACCURACY_TIER_FIELD_NUMBER: builtins.int
    tier: global___DownsampledStorageMeta.SelectedTier.ValueType
    """deprecated, only use can_go_to_higher_accuracy_tier"""
    estimated_num_rows: builtins.int
    """how many rows did the estimator think this query would scan
    0 means the estimator was not run
    deprecated, only use can_go_to_higher_accuracy_tier
    """
    can_go_to_higher_accuracy_tier: builtins.bool
    """if there exists a higher accuracy tier that this query could route to
    note that if this query goes to a higher accuracy tier, it could potentially time out
    """
    def __init__(
        self,
        *,
        tier: global___DownsampledStorageMeta.SelectedTier.ValueType = ...,
        estimated_num_rows: builtins.int = ...,
        can_go_to_higher_accuracy_tier: builtins.bool = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["can_go_to_higher_accuracy_tier", b"can_go_to_higher_accuracy_tier", "estimated_num_rows", b"estimated_num_rows", "tier", b"tier"]) -> None: ...

global___DownsampledStorageMeta = DownsampledStorageMeta
