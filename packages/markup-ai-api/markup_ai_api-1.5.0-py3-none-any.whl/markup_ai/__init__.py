# This file was auto-generated by Fern from our API Definition.

# isort: skip_file

import typing
from importlib import import_module

if typing.TYPE_CHECKING:
    from .types import (
        AnalysisScore,
        BaseStyleGuideType,
        ClarityCategory,
        ClarityScore,
        ConfigOptions,
        ConsistencyCategory,
        ConsistencyScore,
        Dialects,
        DomainResponse,
        DomainSummary,
        ErrorResponse,
        GrammarCategory,
        GrammarScore,
        ImportSummary,
        Issue,
        IssueCategory,
        MatchedTerm,
        OriginalContent,
        PaginatedDomainsResponse,
        PaginatedTermSetsResponse,
        Position,
        QualityScore,
        RewriteContent,
        RewriteResponse,
        ScoreOutput,
        Severity,
        StyleCheckResponse,
        StyleGuide,
        StyleGuideResponse,
        StyleGuideStatus,
        StyleGuides,
        Subcategory,
        Suggestion,
        SuggestionOriginalContent,
        SuggestionResponse,
        TermCreateRequest,
        TermDetail,
        TermItem,
        TermReplaceCategory,
        TermResponse,
        TermSetResponse,
        TermSetResult,
        TermSetWithTerms,
        TermType,
        TerminologyScore,
        TerminologySearchResponse,
        ToneCategory,
        ToneScore,
        Tones,
        WebhookResponse,
        WorkflowInfo,
        WorkflowResponse,
        WorkflowStatus,
    )
    from .errors import (
        ConflictError,
        ContentTooLargeError,
        ForbiddenError,
        InternalServerError,
        NotFoundError,
        TooManyRequestsError,
        UnauthorizedError,
        UnprocessableEntityError,
    )
    from . import style_checks, style_guides, style_rewrites, style_suggestions, terminology
    from .client import AsyncMarkupAI, MarkupAI
    from .environment import MarkupAIEnvironment
    from .version import __version__
_dynamic_imports: typing.Dict[str, str] = {
    "AnalysisScore": ".types",
    "AsyncMarkupAI": ".client",
    "BaseStyleGuideType": ".types",
    "ClarityCategory": ".types",
    "ClarityScore": ".types",
    "ConfigOptions": ".types",
    "ConflictError": ".errors",
    "ConsistencyCategory": ".types",
    "ConsistencyScore": ".types",
    "ContentTooLargeError": ".errors",
    "Dialects": ".types",
    "DomainResponse": ".types",
    "DomainSummary": ".types",
    "ErrorResponse": ".types",
    "ForbiddenError": ".errors",
    "GrammarCategory": ".types",
    "GrammarScore": ".types",
    "ImportSummary": ".types",
    "InternalServerError": ".errors",
    "Issue": ".types",
    "IssueCategory": ".types",
    "MarkupAI": ".client",
    "MarkupAIEnvironment": ".environment",
    "MatchedTerm": ".types",
    "NotFoundError": ".errors",
    "OriginalContent": ".types",
    "PaginatedDomainsResponse": ".types",
    "PaginatedTermSetsResponse": ".types",
    "Position": ".types",
    "QualityScore": ".types",
    "RewriteContent": ".types",
    "RewriteResponse": ".types",
    "ScoreOutput": ".types",
    "Severity": ".types",
    "StyleCheckResponse": ".types",
    "StyleGuide": ".types",
    "StyleGuideResponse": ".types",
    "StyleGuideStatus": ".types",
    "StyleGuides": ".types",
    "Subcategory": ".types",
    "Suggestion": ".types",
    "SuggestionOriginalContent": ".types",
    "SuggestionResponse": ".types",
    "TermCreateRequest": ".types",
    "TermDetail": ".types",
    "TermItem": ".types",
    "TermReplaceCategory": ".types",
    "TermResponse": ".types",
    "TermSetResponse": ".types",
    "TermSetResult": ".types",
    "TermSetWithTerms": ".types",
    "TermType": ".types",
    "TerminologyScore": ".types",
    "TerminologySearchResponse": ".types",
    "ToneCategory": ".types",
    "ToneScore": ".types",
    "Tones": ".types",
    "TooManyRequestsError": ".errors",
    "UnauthorizedError": ".errors",
    "UnprocessableEntityError": ".errors",
    "WebhookResponse": ".types",
    "WorkflowInfo": ".types",
    "WorkflowResponse": ".types",
    "WorkflowStatus": ".types",
    "__version__": ".version",
    "style_checks": ".style_checks",
    "style_guides": ".style_guides",
    "style_rewrites": ".style_rewrites",
    "style_suggestions": ".style_suggestions",
    "terminology": ".terminology",
}


def __getattr__(attr_name: str) -> typing.Any:
    module_name = _dynamic_imports.get(attr_name)
    if module_name is None:
        raise AttributeError(f"No {attr_name} found in _dynamic_imports for module name -> {__name__}")
    try:
        module = import_module(module_name, __package__)
        if module_name == f".{attr_name}":
            return module
        else:
            return getattr(module, attr_name)
    except ImportError as e:
        raise ImportError(f"Failed to import {attr_name} from {module_name}: {e}") from e
    except AttributeError as e:
        raise AttributeError(f"Failed to get {attr_name} from {module_name}: {e}") from e


def __dir__():
    lazy_attrs = list(_dynamic_imports.keys())
    return sorted(lazy_attrs)


__all__ = [
    "AnalysisScore",
    "AsyncMarkupAI",
    "BaseStyleGuideType",
    "ClarityCategory",
    "ClarityScore",
    "ConfigOptions",
    "ConflictError",
    "ConsistencyCategory",
    "ConsistencyScore",
    "ContentTooLargeError",
    "Dialects",
    "DomainResponse",
    "DomainSummary",
    "ErrorResponse",
    "ForbiddenError",
    "GrammarCategory",
    "GrammarScore",
    "ImportSummary",
    "InternalServerError",
    "Issue",
    "IssueCategory",
    "MarkupAI",
    "MarkupAIEnvironment",
    "MatchedTerm",
    "NotFoundError",
    "OriginalContent",
    "PaginatedDomainsResponse",
    "PaginatedTermSetsResponse",
    "Position",
    "QualityScore",
    "RewriteContent",
    "RewriteResponse",
    "ScoreOutput",
    "Severity",
    "StyleCheckResponse",
    "StyleGuide",
    "StyleGuideResponse",
    "StyleGuideStatus",
    "StyleGuides",
    "Subcategory",
    "Suggestion",
    "SuggestionOriginalContent",
    "SuggestionResponse",
    "TermCreateRequest",
    "TermDetail",
    "TermItem",
    "TermReplaceCategory",
    "TermResponse",
    "TermSetResponse",
    "TermSetResult",
    "TermSetWithTerms",
    "TermType",
    "TerminologyScore",
    "TerminologySearchResponse",
    "ToneCategory",
    "ToneScore",
    "Tones",
    "TooManyRequestsError",
    "UnauthorizedError",
    "UnprocessableEntityError",
    "WebhookResponse",
    "WorkflowInfo",
    "WorkflowResponse",
    "WorkflowStatus",
    "__version__",
    "style_checks",
    "style_guides",
    "style_rewrites",
    "style_suggestions",
    "terminology",
]
