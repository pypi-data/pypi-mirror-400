import typing, clr, abc
from PalmSens import Plottable, MeasType, Method, CurrentRange, PotentialRange
from PalmSens.DataFiles import JsonBag
from System import Version, MulticastDelegate, IAsyncResult, AsyncCallback, Array_1, EventArgs, IDisposable
from PalmSens.Data import DataArray, ArrayDataAddedEventArgs, DataArrayType, EnumDirection, EnumAxes, DataSetEIS, IDataValue, CurrentReading
from System.Reflection import MethodInfo
from PalmSens.Analysis import CFALevelList, PeakList
from PalmSens.Units import Unit
from System.Threading.Tasks import Task_1, Task
from Newtonsoft.Json import JsonReader, JsonWriter
from System.Threading import CancellationToken
from System.Collections.Generic import IComparer_1, List_1, Dictionary_2
from PalmSens.Techniques import ImpedimetricMethodBase, ImpedimetricIterationMethodBase
from PalmSens.Techniques.Impedance import enumScanType, enumFrequencyType
from System.Drawing import Size

class AxisFunction(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...

    # Values:
    Normal : AxisFunction # 0
    Derivative : AxisFunction # 1
    Log : AxisFunction # 2
    Power : AxisFunction # 3
    SecondDerivative : AxisFunction # 4
    Integral : AxisFunction # 5
    Anson : AxisFunction # 6
    Cottrell : AxisFunction # 7


class Blank(abc.ABC):
    UseBlank : bool
    @classmethod
    @property
    def BlankCurve(cls) -> Curve: ...
    @classmethod
    @BlankCurve.setter
    def BlankCurve(cls, value: Curve) -> Curve: ...


class Curve(Plottable):
    @typing.overload
    def __init__(self, bag: JsonBag, coreVersion: Version) -> None: ...
    @typing.overload
    def __init__(self, curve: Curve, cloneData: bool = ...) -> None: ...
    @typing.overload
    def __init__(self, xDataArray: DataArray, yDataArray: DataArray, title: str = ..., finish: bool = ...) -> None: ...

    class EnumXAxis(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...

        # Values:
        Bottom : Curve.EnumXAxis # 0
        Top : Curve.EnumXAxis # 1


    class EnumYAxis(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...

        # Values:
        Left : Curve.EnumYAxis # 0
        Right : Curve.EnumYAxis # 1


    class NewDataAddedEventHandler(MulticastDelegate):
        def __init__(self, object: typing.Any, method: int) -> None: ...
        @property
        def Method(self) -> MethodInfo: ...
        @property
        def Target(self) -> typing.Any: ...
        def BeginInvoke(self, sender: typing.Any, e: ArrayDataAddedEventArgs, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
        def EndInvoke(self, result: IAsyncResult) -> None: ...
        def Invoke(self, sender: typing.Any, e: ArrayDataAddedEventArgs) -> None: ...

    ErrorMessage : str
    Hash : Array_1[int]
    Levels : CFALevelList
    @property
    def Appearance(self) -> VisualSettings: ...
    @Appearance.setter
    def Appearance(self, value: VisualSettings) -> VisualSettings: ...
    @property
    def CorrosionButlerVolmer(self) -> Array_1[int]: ...
    @CorrosionButlerVolmer.setter
    def CorrosionButlerVolmer(self, value: Array_1[int]) -> Array_1[int]: ...
    @property
    def CorrosionTafel(self) -> Array_1[int]: ...
    @CorrosionTafel.setter
    def CorrosionTafel(self, value: Array_1[int]) -> Array_1[int]: ...
    @property
    def Error(self) -> str: ...
    @Error.setter
    def Error(self, value: str) -> str: ...
    @property
    def HasMultipleDirections(self) -> bool: ...
    @property
    def IsFinished(self) -> bool: ...
    @property
    def IsInPlot(self) -> bool: ...
    @IsInPlot.setter
    def IsInPlot(self, value: bool) -> bool: ...
    @property
    def MaxX(self) -> float: ...
    @property
    def MaxY(self) -> float: ...
    @property
    def MeasType(self) -> MeasType: ...
    @MeasType.setter
    def MeasType(self, value: MeasType) -> MeasType: ...
    @property
    def MeasuredStepStartIndex(self) -> DataArray: ...
    @MeasuredStepStartIndex.setter
    def MeasuredStepStartIndex(self, value: DataArray) -> DataArray: ...
    @property
    def MinX(self) -> float: ...
    @property
    def MinY(self) -> float: ...
    @property
    def MuxChannel(self) -> int: ...
    @MuxChannel.setter
    def MuxChannel(self, value: int) -> int: ...
    @property
    def NPoints(self) -> int: ...
    @property
    def OCPValue(self) -> float: ...
    @property
    def Peaks(self) -> PeakList: ...
    @Peaks.setter
    def Peaks(self, value: PeakList) -> PeakList: ...
    @property
    def ReferenceElectrodeName(self) -> str: ...
    @ReferenceElectrodeName.setter
    def ReferenceElectrodeName(self, value: str) -> str: ...
    @property
    def ReferenceElectrodePotential(self) -> float: ...
    @ReferenceElectrodePotential.setter
    def ReferenceElectrodePotential(self, value: float) -> float: ...
    @property
    def SavedToFile(self) -> bool: ...
    @SavedToFile.setter
    def SavedToFile(self, value: bool) -> bool: ...
    @property
    def SavedToFilePath(self) -> str: ...
    @SavedToFilePath.setter
    def SavedToFilePath(self, value: str) -> str: ...
    @property
    def SaveToSession(self) -> bool: ...
    @SaveToSession.setter
    def SaveToSession(self, value: bool) -> bool: ...
    @property
    def SelectedPoints(self) -> Array_1[bool]: ...
    @SelectedPoints.setter
    def SelectedPoints(self, value: Array_1[bool]) -> Array_1[bool]: ...
    @property
    def SupportsPowerPlot(self) -> bool: ...
    @property
    def SuspendSavedToFileChangedEvent(self) -> bool: ...
    @SuspendSavedToFileChangedEvent.setter
    def SuspendSavedToFileChangedEvent(self, value: bool) -> bool: ...
    @property
    def Title(self) -> str: ...
    @Title.setter
    def Title(self, value: str) -> str: ...
    @property
    def ValidHash(self) -> bool: ...
    @property
    def Visible(self) -> bool: ...
    @Visible.setter
    def Visible(self, value: bool) -> bool: ...
    @property
    def XArrayType(self) -> DataArrayType: ...
    @property
    def XAxis(self) -> EnumXAxis: ...
    @XAxis.setter
    def XAxis(self, value: EnumXAxis) -> EnumXAxis: ...
    @property
    def XAxisDataArray(self) -> DataArray: ...
    @property
    def XOffset(self) -> float: ...
    @XOffset.setter
    def XOffset(self, value: float) -> float: ...
    @property
    def XUnit(self) -> Unit: ...
    @property
    def YArrayType(self) -> DataArrayType: ...
    @property
    def YAxis(self) -> EnumYAxis: ...
    @YAxis.setter
    def YAxis(self, value: EnumYAxis) -> EnumYAxis: ...
    @property
    def YAxisDataArray(self) -> DataArray: ...
    @property
    def YUnit(self) -> Unit: ...
    @property
    def ZUnit(self) -> Unit: ...
    @ZUnit.setter
    def ZUnit(self, value: Unit) -> Unit: ...
    def CalculateSlope(self, f: int, t: int) -> float: ...
    def ClearLevels(self) -> None: ...
    def ClearPeaks(self) -> None: ...
    def CorrectIndicesCV(self) -> None: ...
    @staticmethod
    def CurveFromJson(jr: JsonReader, coreVersion: Version, cancellationToken: CancellationToken) -> Task_1[Curve]: ...
    def Dispose(self) -> None: ...
    @staticmethod
    def Empty() -> Curve: ...
    def FindLevels(self, minWidth: float, minHeight: float) -> None: ...
    def FindNearestVisual(self, x: float, y: float, xMin: float, xMax: float, yMin: float, yMax: float) -> int: ...
    def FindNearestX(self, x: float) -> int: ...
    def FindNearestXCV(self, x: float, y: float, iMin: int, iMax: int) -> int: ...
    def FindPeaks(self, minPeakWidth: float, minPeakHeight: float, peakShoulders: bool = ..., mergeOverlappingPeaks: bool = ...) -> PeakList: ...
    def Finish(self, redraw: bool = ...) -> None: ...
    @staticmethod
    def FromJsonBag(bag: JsonBag, coreVersion: Version) -> Curve: ...
    def GetDirection(self, axis: EnumAxes, index: int) -> EnumDirection: ...
    def GetFormattedXValue(self, index: int) -> str: ...
    def GetFormattedYValue(self, index: int) -> str: ...
    def GetNOverloads(self) -> int: ...
    def GetNUnderloads(self) -> int: ...
    @staticmethod
    def GetOriginalDataArrayOrDefault(array: DataArray) -> DataArray: ...
    def GetOriginalXAxisDataArray(self) -> DataArray: ...
    def GetOriginalYAxisDataArray(self) -> DataArray: ...
    @staticmethod
    def GetTitleForChannel(channel: int) -> str: ...
    @staticmethod
    def GetTitleForScan(scan: int) -> str: ...
    def GetVertexIndicesForCV(self) -> Array_1[int]: ...
    def GetXDirection(self) -> EnumDirection: ...
    def GetXValue(self, index: int) -> float: ...
    def GetXValues(self) -> Array_1[float]: ...
    def GetYValue(self, index: int) -> float: ...
    def GetYValues(self, inverse: bool = ...) -> Array_1[float]: ...
    def SavitskyGolay(self, windowSize: int) -> None: ...
    def SetAxesFunction(self, axisFunction: AxisFunction) -> None: ...
    def Smooth(self, smoothLevel: int) -> bool: ...
    def SupportsAnsonPlot(self, method: Method) -> bool: ...
    def SupportsAxisFunction(self, function: AxisFunction, method: Method) -> bool: ...
    def SupportsCottrellPlot(self, method: Method) -> bool: ...
    def ToJsonBag(self) -> JsonBag: ...
    def ToJsonWriterAsync(self, jw: JsonWriter, cancellationToken: CancellationToken) -> Task: ...
    def ToString(self) -> str: ...
    # Skipped FindNearest due to it being static, abstract and generic.

    FindNearest : FindNearest_MethodGroup
    class FindNearest_MethodGroup:
        @typing.overload
        def __call__(self, x: float, y: float) -> int:...
        @typing.overload
        def __call__(self, x: float, y: float, iStart: int, iEnd: int) -> int:...

    # Skipped LLS due to it being static, abstract and generic.

    LLS : LLS_MethodGroup
    class LLS_MethodGroup:
        @typing.overload
        def __call__(self, a: clr.Reference[float], b: clr.Reference[float], corr: clr.Reference[float]) -> None:...
        @typing.overload
        def __call__(self, from_: int, to: int, offset: clr.Reference[float], slope: clr.Reference[float], CoefDet: clr.Reference[float]) -> None:...



class CurveComparer(IComparer_1[Curve]):
    def __init__(self) -> None: ...
    def Compare(self, x: Curve, y: Curve) -> int: ...


class CurveDirection(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...

    # Values:
    Ascending : CurveDirection # 1
    Descending : CurveDirection # -1


class CurveEventArgs(EventArgs):
    def __init__(self, c: Curve) -> None: ...
    def GetCurve(self) -> Curve: ...


class CurveEventHandler(MulticastDelegate):
    def __init__(self, object: typing.Any, method: int) -> None: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> typing.Any: ...
    def BeginInvoke(self, sender: typing.Any, e: CurveEventArgs, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> None: ...
    def Invoke(self, sender: typing.Any, e: CurveEventArgs) -> None: ...


class EISCurve(Curve):
    @typing.overload
    def __init__(self, bag: JsonBag, coreVersion: Version) -> None: ...
    @typing.overload
    def __init__(self, curve: Curve, cloneData: bool) -> None: ...
    @typing.overload
    def __init__(self, xDataArray: DataArray, yDataArray: DataArray, title: str, finish: bool) -> None: ...
    ErrorMessage : str
    Hash : Array_1[int]
    Levels : CFALevelList
    @property
    def Appearance(self) -> VisualSettings: ...
    @Appearance.setter
    def Appearance(self, value: VisualSettings) -> VisualSettings: ...
    @property
    def CorrosionButlerVolmer(self) -> Array_1[int]: ...
    @CorrosionButlerVolmer.setter
    def CorrosionButlerVolmer(self, value: Array_1[int]) -> Array_1[int]: ...
    @property
    def CorrosionTafel(self) -> Array_1[int]: ...
    @CorrosionTafel.setter
    def CorrosionTafel(self, value: Array_1[int]) -> Array_1[int]: ...
    @property
    def Error(self) -> str: ...
    @Error.setter
    def Error(self, value: str) -> str: ...
    @property
    def HasMultipleDirections(self) -> bool: ...
    @property
    def iFreq(self) -> int: ...
    @property
    def IsFinished(self) -> bool: ...
    @property
    def IsInPlot(self) -> bool: ...
    @IsInPlot.setter
    def IsInPlot(self, value: bool) -> bool: ...
    @property
    def MaxX(self) -> float: ...
    @property
    def MaxY(self) -> float: ...
    @property
    def MeasType(self) -> MeasType: ...
    @MeasType.setter
    def MeasType(self, value: MeasType) -> MeasType: ...
    @property
    def MeasuredStepStartIndex(self) -> DataArray: ...
    @MeasuredStepStartIndex.setter
    def MeasuredStepStartIndex(self, value: DataArray) -> DataArray: ...
    @property
    def MinX(self) -> float: ...
    @property
    def MinY(self) -> float: ...
    @property
    def MuxChannel(self) -> int: ...
    @MuxChannel.setter
    def MuxChannel(self, value: int) -> int: ...
    @property
    def NPoints(self) -> int: ...
    @property
    def OCPValue(self) -> float: ...
    @property
    def Peaks(self) -> PeakList: ...
    @Peaks.setter
    def Peaks(self, value: PeakList) -> PeakList: ...
    @property
    def ReferenceElectrodeName(self) -> str: ...
    @ReferenceElectrodeName.setter
    def ReferenceElectrodeName(self, value: str) -> str: ...
    @property
    def ReferenceElectrodePotential(self) -> float: ...
    @ReferenceElectrodePotential.setter
    def ReferenceElectrodePotential(self, value: float) -> float: ...
    @property
    def SavedToFile(self) -> bool: ...
    @SavedToFile.setter
    def SavedToFile(self, value: bool) -> bool: ...
    @property
    def SavedToFilePath(self) -> str: ...
    @SavedToFilePath.setter
    def SavedToFilePath(self, value: str) -> str: ...
    @property
    def SaveToSession(self) -> bool: ...
    @SaveToSession.setter
    def SaveToSession(self, value: bool) -> bool: ...
    @property
    def SelectedPoints(self) -> Array_1[bool]: ...
    @SelectedPoints.setter
    def SelectedPoints(self, value: Array_1[bool]) -> Array_1[bool]: ...
    @property
    def SupportsPowerPlot(self) -> bool: ...
    @property
    def SuspendSavedToFileChangedEvent(self) -> bool: ...
    @SuspendSavedToFileChangedEvent.setter
    def SuspendSavedToFileChangedEvent(self, value: bool) -> bool: ...
    @property
    def Title(self) -> str: ...
    @Title.setter
    def Title(self, value: str) -> str: ...
    @property
    def ValidHash(self) -> bool: ...
    @property
    def Visible(self) -> bool: ...
    @Visible.setter
    def Visible(self, value: bool) -> bool: ...
    @property
    def XArrayType(self) -> DataArrayType: ...
    @property
    def XAxis(self) -> Curve.EnumXAxis: ...
    @XAxis.setter
    def XAxis(self, value: Curve.EnumXAxis) -> Curve.EnumXAxis: ...
    @property
    def XAxisDataArray(self) -> DataArray: ...
    @property
    def XOffset(self) -> float: ...
    @XOffset.setter
    def XOffset(self, value: float) -> float: ...
    @property
    def XUnit(self) -> Unit: ...
    @property
    def YArrayType(self) -> DataArrayType: ...
    @property
    def YAxis(self) -> Curve.EnumYAxis: ...
    @YAxis.setter
    def YAxis(self, value: Curve.EnumYAxis) -> Curve.EnumYAxis: ...
    @property
    def YAxisDataArray(self) -> DataArray: ...
    @property
    def YUnit(self) -> Unit: ...
    @property
    def ZUnit(self) -> Unit: ...
    @ZUnit.setter
    def ZUnit(self, value: Unit) -> Unit: ...


class EISData(Plottable):
    @typing.overload
    def __init__(self, eis: EISData, cloneData: bool = ...) -> None: ...
    @typing.overload
    def __init__(self, method: ImpedimetricMethodBase, auxInputName: str, auxUnit: Unit) -> None: ...
    @typing.overload
    def __init__(self, scanType: enumScanType, freqType: enumFrequencyType, isGEIS: bool, frequencies: List_1[float] = ...) -> None: ...

    class DebugValueType(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...

        # Values:
        nPointsAC : EISData.DebugValueType # 0
        realtintac : EISData.DebugValueType # 1
        ymean : EISData.DebugValueType # 2
        debugtext : EISData.DebugValueType # 3


    class EISValueType(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...

        # Values:
        X : EISData.EISValueType # 0
        Freq : EISData.EISValueType # 1
        Logf : EISData.EISValueType # 2
        LogZ : EISData.EISValueType # 3
        Edc : EISData.EISValueType # 4
        mEdc : EISData.EISValueType # 5
        Eac : EISData.EISValueType # 6
        Time : EISData.EISValueType # 7
        Idc : EISData.EISValueType # 8
        Iac : EISData.EISValueType # 9
        miDC : EISData.EISValueType # 10
        ZRe : EISData.EISValueType # 11
        ZIm : EISData.EISValueType # 12
        Z : EISData.EISValueType # 13
        MinPhase : EISData.EISValueType # 14
        Rct : EISData.EISValueType # 15
        LogY : EISData.EISValueType # 16
        YRe : EISData.EISValueType # 17
        YIm : EISData.EISValueType # 18
        Y : EISData.EISValueType # 19
        Cs : EISData.EISValueType # 20
        CsRe : EISData.EISValueType # 21
        CsIm : EISData.EISValueType # 22
        iDCinRange : EISData.EISValueType # 23
        AuxInput : EISData.EISValueType # 24


    class NewDataEventArgs(EventArgs):
        EISData : EISData
        Index : int


    class NewDataEventHandler(MulticastDelegate):
        def __init__(self, object: typing.Any, method: int) -> None: ...
        @property
        def Method(self) -> MethodInfo: ...
        @property
        def Target(self) -> typing.Any: ...
        def BeginInvoke(self, sender: typing.Any, e: EISData.NewDataEventArgs, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
        def EndInvoke(self, result: IAsyncResult) -> None: ...
        def Invoke(self, sender: typing.Any, e: EISData.NewDataEventArgs) -> None: ...


    class NewFreqScanAddedEventHandler(MulticastDelegate):
        def __init__(self, object: typing.Any, method: int) -> None: ...
        @property
        def Method(self) -> MethodInfo: ...
        @property
        def Target(self) -> typing.Any: ...
        def BeginInvoke(self, sender: typing.Any, e: EISData.NewFreqScanEventArgs, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
        def EndInvoke(self, result: IAsyncResult) -> None: ...
        def Invoke(self, sender: typing.Any, e: EISData.NewFreqScanEventArgs) -> None: ...


    class NewFreqScanEventArgs(EventArgs):
        AddedScan : EISData

    Hash : Array_1[int]
    @property
    def Appearance(self) -> VisualSettings: ...
    @Appearance.setter
    def Appearance(self, value: VisualSettings) -> VisualSettings: ...
    @property
    def CDC(self) -> str: ...
    @CDC.setter
    def CDC(self, value: str) -> str: ...
    @property
    def CDCValues(self) -> Array_1[float]: ...
    @CDCValues.setter
    def CDCValues(self, value: Array_1[float]) -> Array_1[float]: ...
    @property
    def EISDataSet(self) -> DataSetEIS: ...
    @property
    def Error(self) -> str: ...
    @Error.setter
    def Error(self, value: str) -> str: ...
    @property
    def FreqType(self) -> enumFrequencyType: ...
    @property
    def FrequencyCurves(self) -> Dictionary_2[int, List_1[Curve]]: ...
    @property
    def HasSubScans(self) -> bool: ...
    @property
    def IsFinished(self) -> bool: ...
    @property
    def IsInPlot(self) -> bool: ...
    @IsInPlot.setter
    def IsInPlot(self, value: bool) -> bool: ...
    @property
    def MuxChannel(self) -> int: ...
    @MuxChannel.setter
    def MuxChannel(self, value: int) -> int: ...
    @property
    def NFrequencies(self) -> int: ...
    @property
    def NPoints(self) -> int: ...
    @property
    def OCPValue(self) -> float: ...
    @property
    def PlotMode(self) -> EISPlotModes: ...
    @property
    def SavedToFile(self) -> bool: ...
    @SavedToFile.setter
    def SavedToFile(self, value: bool) -> bool: ...
    @property
    def SavedToFilePath(self) -> str: ...
    @SavedToFilePath.setter
    def SavedToFilePath(self, value: str) -> str: ...
    @property
    def SaveToSession(self) -> bool: ...
    @SaveToSession.setter
    def SaveToSession(self, value: bool) -> bool: ...
    @property
    def ScanType(self) -> enumScanType: ...
    @property
    def SecondaryPlotMode(self) -> EISPlotModes: ...
    @property
    def SuspendSavedToFileChangedEvent(self) -> bool: ...
    @SuspendSavedToFileChangedEvent.setter
    def SuspendSavedToFileChangedEvent(self, value: bool) -> bool: ...
    @property
    def Title(self) -> str: ...
    @Title.setter
    def Title(self, value: str) -> str: ...
    @property
    def ValidHash(self) -> bool: ...
    @property
    def Visible(self) -> bool: ...
    @Visible.setter
    def Visible(self, value: bool) -> bool: ...
    @property
    def XUnit(self) -> Unit: ...
    @XUnit.setter
    def XUnit(self, value: Unit) -> Unit: ...
    def Dispose(self) -> None: ...
    def Finish(self) -> None: ...
    def GenerateCurves(self, plotMode: EISPlotModes, secondaryPlot: bool = ..., onlyIfExists: bool = ...) -> Array_1[Curve]: ...
    @staticmethod
    def GenerateTitle(impedimetricMethod: ImpedimetricMethodBase) -> str: ...
    def GetAllEISDatas(self) -> Array_1[EISData]: ...
    def GetCurrentRange(self, index: int) -> CurrentRange: ...
    def GetDataArrayVsX(self, freq: int) -> Dictionary_2[EISData.EISValueType, DataArray]: ...
    def GetDataValue(self, valueType: EISData.EISValueType, index: int) -> float: ...
    def GetDebugValue(self, valueType: EISData.DebugValueType, index: int) -> IDataValue: ...
    def GetFreqScanSelectedSeries(self, index: int) -> EISDataSubScan: ...
    def GetPotentialRange(self, index: int) -> PotentialRange: ...
    @staticmethod
    def GetScanTypeString(impedimetricMethod: ImpedimetricMethodBase) -> str: ...
    def GetSubScans(self) -> List_1[EISDataSubScan]: ...
    def RemovePoint(self, index: int) -> None: ...
    def ToJsonBag(self) -> JsonBag: ...
    def ToJsonWriterAsync(self, jw: JsonWriter, cancellationToken: CancellationToken) -> Task: ...
    def ToString(self) -> str: ...
    # Skipped AddRow due to it being static, abstract and generic.

    AddRow : AddRow_MethodGroup
    class AddRow_MethodGroup:
        @typing.overload
        def __call__(self, iFreq: int, seriesStartTime: float, appliedDC: IDataValue, frequency: float, idc: CurrentReading, iac: CurrentReading, zRe: float, zIm: float, phase: float, mEdc: float = ..., eac: float = ...) -> None:...
        @typing.overload
        def __call__(self, iFreq: int, seriesStartTime: float, appliedDC: IDataValue, frequency: float, idc: CurrentReading, iac: CurrentReading, zRe: float, zIm: float, phase: float, mEdc: IDataValue, eac: IDataValue) -> None:...
        @typing.overload
        def __call__(self, iFreq: int, seriesStartTime: float, appliedDC: IDataValue, frequency: float, idc: CurrentReading, iac: CurrentReading, zRe: float, zIm: float, phase: float, mEdc: float, eac: float, iterationMethod: ImpedimetricIterationMethodBase, ymean: float, auxValue: float) -> None:...
        @typing.overload
        def __call__(self, iFreq: int, seriesStartTime: float, appliedDC: IDataValue, frequency: float, idc: CurrentReading, iac: CurrentReading, zRe: float, zIm: float, phase: float, mEdc: IDataValue, eac: IDataValue, iterationMethod: ImpedimetricIterationMethodBase, ymean: float, auxValue: float) -> None:...



class EISDataEventHandler(MulticastDelegate):
    def __init__(self, object: typing.Any, method: int) -> None: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> typing.Any: ...
    def BeginInvoke(self, sender: typing.Any, eisdata: EISData, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> None: ...
    def Invoke(self, sender: typing.Any, eisdata: EISData) -> None: ...


class EISDataSubScan(EISData):
    @typing.overload
    def __init__(self, parentEISData: EISData, bag: JsonBag, coreVersion: Version, isGEIS: bool) -> None: ...
    @typing.overload
    def __init__(self, parentEISData: EISData, scanType: enumScanType, freqType: enumFrequencyType, dataSet: DataSetEIS, isGEIS: bool) -> None: ...
    @typing.overload
    def __init__(self, parentEISData: EISData, scanType: enumScanType, freqType: enumFrequencyType, isGEIS: bool) -> None: ...
    @typing.overload
    def __init__(self, parentEISData: EISData, subscan: EISData, cloneData: bool = ...) -> None: ...
    Hash : Array_1[int]
    @property
    def Appearance(self) -> VisualSettings: ...
    @Appearance.setter
    def Appearance(self, value: VisualSettings) -> VisualSettings: ...
    @property
    def CDC(self) -> str: ...
    @CDC.setter
    def CDC(self, value: str) -> str: ...
    @property
    def CDCValues(self) -> Array_1[float]: ...
    @CDCValues.setter
    def CDCValues(self, value: Array_1[float]) -> Array_1[float]: ...
    @property
    def EISDataSet(self) -> DataSetEIS: ...
    @property
    def Error(self) -> str: ...
    @Error.setter
    def Error(self, value: str) -> str: ...
    @property
    def FreqType(self) -> enumFrequencyType: ...
    @property
    def FrequencyCurves(self) -> Dictionary_2[int, List_1[Curve]]: ...
    @property
    def HasSubScans(self) -> bool: ...
    @property
    def IsFinished(self) -> bool: ...
    @property
    def IsInPlot(self) -> bool: ...
    @IsInPlot.setter
    def IsInPlot(self, value: bool) -> bool: ...
    @property
    def MuxChannel(self) -> int: ...
    @MuxChannel.setter
    def MuxChannel(self, value: int) -> int: ...
    @property
    def NFrequencies(self) -> int: ...
    @property
    def NPoints(self) -> int: ...
    @property
    def OCPValue(self) -> float: ...
    @property
    def ParentEISData(self) -> EISData: ...
    @property
    def PlotMode(self) -> EISPlotModes: ...
    @property
    def SavedToFile(self) -> bool: ...
    @SavedToFile.setter
    def SavedToFile(self, value: bool) -> bool: ...
    @property
    def SavedToFilePath(self) -> str: ...
    @SavedToFilePath.setter
    def SavedToFilePath(self, value: str) -> str: ...
    @property
    def SaveToSession(self) -> bool: ...
    @SaveToSession.setter
    def SaveToSession(self, value: bool) -> bool: ...
    @property
    def ScanType(self) -> enumScanType: ...
    @property
    def SecondaryPlotMode(self) -> EISPlotModes: ...
    @property
    def SuspendSavedToFileChangedEvent(self) -> bool: ...
    @SuspendSavedToFileChangedEvent.setter
    def SuspendSavedToFileChangedEvent(self, value: bool) -> bool: ...
    @property
    def Title(self) -> str: ...
    @Title.setter
    def Title(self, value: str) -> str: ...
    @property
    def ValidHash(self) -> bool: ...
    @property
    def Visible(self) -> bool: ...
    @Visible.setter
    def Visible(self, value: bool) -> bool: ...
    @property
    def XUnit(self) -> Unit: ...
    @XUnit.setter
    def XUnit(self, value: Unit) -> Unit: ...


class EISPlotModes(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...

    # Values:
    ZZvsX : EISPlotModes # 0
    LogZPhasevsLogF : EISPlotModes # 1
    ZPhasevsX : EISPlotModes # 2
    RctvsX : EISPlotModes # 3
    ZvsZ : EISPlotModes # 4
    LogZvsLogF : EISPlotModes # 5
    YvsY : EISPlotModes # 6
    YYvsLogF : EISPlotModes # 7
    LogYvsLogF : EISPlotModes # 8
    YYvsX : EISPlotModes # 9
    YvsX : EISPlotModes # 10
    CsImvsCsRe : EISPlotModes # 11
    CvsX : EISPlotModes # 12
    ZPhasevsLogF : EISPlotModes # 13
    CCvsX : EISPlotModes # 14
    None_ : EISPlotModes # -1


class MeasTypeChangedEventArgs(EventArgs):
    def __init__(self, previous: MeasType, current: MeasType) -> None: ...
    Current : MeasType
    Previous : MeasType


class VisualSettings(IDisposable):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, bag: JsonBag, coreVersion: Version) -> None: ...
    @typing.overload
    def __init__(self, settings: VisualSettings) -> None: ...

    class Symbol(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...

        # Values:
        Square : VisualSettings.Symbol # 0
        Diamond : VisualSettings.Symbol # 1
        Triangle : VisualSettings.Symbol # 2
        Circle : VisualSettings.Symbol # 3
        None_ : VisualSettings.Symbol # 4

    @property
    def AutoAssignColor(self) -> bool: ...
    @AutoAssignColor.setter
    def AutoAssignColor(self, value: bool) -> bool: ...
    @property
    def Color(self) -> int: ...
    @Color.setter
    def Color(self, value: int) -> int: ...
    @property
    def HideCurveLine(self) -> bool: ...
    @HideCurveLine.setter
    def HideCurveLine(self, value: bool) -> bool: ...
    @property
    def LineWidth(self) -> int: ...
    @LineWidth.setter
    def LineWidth(self, value: int) -> int: ...
    @property
    def SymbolFill(self) -> bool: ...
    @SymbolFill.setter
    def SymbolFill(self, value: bool) -> bool: ...
    @property
    def SymbolSize(self) -> Size: ...
    @SymbolSize.setter
    def SymbolSize(self, value: Size) -> Size: ...
    @property
    def SymbolType(self) -> Symbol: ...
    @SymbolType.setter
    def SymbolType(self, value: Symbol) -> Symbol: ...
    @property
    def UseDefaultSettings(self) -> bool: ...
    @UseDefaultSettings.setter
    def UseDefaultSettings(self, value: bool) -> bool: ...
    def Clone(self) -> VisualSettings: ...
    def CopyAppearance(self, newSettings: VisualSettings, includeColor: bool = ..., includeSymbolType: bool = ...) -> None: ...
    def Dispose(self) -> None: ...
    @staticmethod
    def FromJsonBag(bag: JsonBag, coreVersion: Version) -> VisualSettings: ...
    @staticmethod
    def GetVisualSettingsFastDraw() -> VisualSettings: ...
    def ToJsonBag(self) -> JsonBag: ...
    @staticmethod
    def VisualSettingsFromJson(jr: JsonReader) -> Task_1[VisualSettings]: ...
