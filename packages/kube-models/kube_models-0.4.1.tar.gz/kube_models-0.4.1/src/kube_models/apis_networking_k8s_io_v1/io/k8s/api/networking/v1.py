# generated by https://github.com/puzl-cloud/kubesdk
#   filename:  apis__networking.k8s.io__v1_openapi.json

from __future__ import annotations

from dataclasses import dataclass, field
from datetime import datetime, timezone
from typing import ClassVar, List, Set

from kube_models.const import *
from kube_models.loader import *
from kube_models.loader import Loadable
from kube_models.resource import *

from ...apimachinery.pkg.apis.meta.v1 import (
    Condition,
    LabelSelector,
    ListMeta,
    ObjectMeta,
)
from ...apimachinery.pkg.util.intstr import IntOrString
from ..core.v1 import TypedLocalObjectReference


@dataclass(slots=True, kw_only=True, frozen=True)
class IPBlock(Loadable):
    cidr: str
    except_: List[str] = field(
        metadata={'original_name': 'except'}, default_factory=list
    )


@dataclass(slots=True, kw_only=True, frozen=True)
class IngressClassParametersReference(Loadable):
    kind: str
    name: str
    apiGroup: str | None = None
    namespace: str | None = None
    scope: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class IngressClassSpec(Loadable):
    controller: str | None = None
    parameters: IngressClassParametersReference | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class IngressPortStatus(Loadable):
    port: int
    protocol: str
    error: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class IngressTLS(Loadable):
    hosts: List[str] | None = None
    secretName: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class ParentReference(Loadable):
    name: str
    resource: str
    group: str | None = None
    namespace: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class ServiceBackendPort(Loadable):
    name: str | None = None
    number: int | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class ServiceCIDRSpec(Loadable):
    cidrs: List[str] | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class IPAddressSpec(Loadable):
    parentRef: ParentReference


@dataclass(slots=True, kw_only=True, frozen=True)
class IngressLoadBalancerIngress(Loadable):
    hostname: str | None = None
    ip: str | None = None
    ports: List[IngressPortStatus] | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class IngressLoadBalancerStatus(Loadable):
    ingress: List[IngressLoadBalancerIngress] | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class IngressServiceBackend(Loadable):
    name: str
    port: ServiceBackendPort | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class IngressStatus(Loadable):
    loadBalancer: IngressLoadBalancerStatus | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class NetworkPolicyPort(Loadable):
    endPort: int | None = None
    port: IntOrString | None = None
    protocol: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class IPAddress(K8sResource):
    apiVersion: ClassVar[str] = 'networking.k8s.io/v1'
    kind: ClassVar[str] = 'IPAddress'
    metadata: ObjectMeta = field(default_factory=ObjectMeta)
    spec: IPAddressSpec | None = None
    plural_: ClassVar[str] = 'ipaddresses'
    is_namespaced_: ClassVar[bool] = False
    group_: ClassVar[Optional[str]] = 'networking.k8s.io'
    patch_strategies_: ClassVar[set[PatchRequestType]] = {
        'application/apply-patch+cbor',
        'application/apply-patch+yaml',
        'application/json-patch+json',
        'application/merge-patch+json',
        'application/strategic-merge-patch+json',
    }


@dataclass(slots=True, kw_only=True, frozen=True)
class IPAddressList(Loadable):
    items: List[IPAddress]
    apiVersion: str = 'networking.k8s.io/v1'
    kind: str = 'IPAddressList'
    metadata: ListMeta = field(default_factory=ObjectMeta)


@dataclass(slots=True, kw_only=True, frozen=True)
class IngressBackend(Loadable):
    resource: TypedLocalObjectReference | None = None
    service: IngressServiceBackend | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class IngressClass(K8sResource):
    apiVersion: ClassVar[str] = 'networking.k8s.io/v1'
    kind: ClassVar[str] = 'IngressClass'
    metadata: ObjectMeta = field(default_factory=ObjectMeta)
    spec: IngressClassSpec | None = None
    plural_: ClassVar[str] = 'ingressclasses'
    is_namespaced_: ClassVar[bool] = False
    group_: ClassVar[Optional[str]] = 'networking.k8s.io'
    patch_strategies_: ClassVar[set[PatchRequestType]] = {
        'application/apply-patch+cbor',
        'application/apply-patch+yaml',
        'application/json-patch+json',
        'application/merge-patch+json',
        'application/strategic-merge-patch+json',
    }


@dataclass(slots=True, kw_only=True, frozen=True)
class IngressClassList(Loadable):
    items: List[IngressClass]
    apiVersion: str = 'networking.k8s.io/v1'
    kind: str = 'IngressClassList'
    metadata: ListMeta = field(default_factory=ObjectMeta)


@dataclass(slots=True, kw_only=True, frozen=True)
class NetworkPolicyPeer(Loadable):
    ipBlock: IPBlock | None = None
    namespaceSelector: LabelSelector | None = None
    podSelector: LabelSelector | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class ServiceCIDRStatus(Loadable):
    conditions: List[Condition] = field(
        default_factory=list,
        metadata={
            'x-kubernetes-patch-strategy': 'merge',
            'x-kubernetes-patch-merge-key': 'type',
        },
    )


@dataclass(slots=True, kw_only=True, frozen=True)
class HTTPIngressPath(Loadable):
    backend: IngressBackend
    pathType: str
    path: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class HTTPIngressRuleValue(Loadable):
    paths: List[HTTPIngressPath]


@dataclass(slots=True, kw_only=True, frozen=True)
class IngressRule(Loadable):
    host: str | None = None
    http: HTTPIngressRuleValue | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class IngressSpec(Loadable):
    defaultBackend: IngressBackend | None = None
    ingressClassName: str | None = None
    rules: List[IngressRule] | None = None
    tls: List[IngressTLS] | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class NetworkPolicyEgressRule(Loadable):
    ports: List[NetworkPolicyPort] | None = None
    to: List[NetworkPolicyPeer] | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class NetworkPolicyIngressRule(Loadable):
    from_: List[NetworkPolicyPeer] = field(
        metadata={'original_name': 'from'}, default_factory=list
    )
    ports: List[NetworkPolicyPort] | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class NetworkPolicySpec(Loadable):
    egress: List[NetworkPolicyEgressRule] | None = None
    ingress: List[NetworkPolicyIngressRule] | None = None
    podSelector: LabelSelector | None = None
    policyTypes: List[str] | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class ServiceCIDR(K8sResource):
    apiVersion: ClassVar[str] = 'networking.k8s.io/v1'
    kind: ClassVar[str] = 'ServiceCIDR'
    metadata: ObjectMeta = field(default_factory=ObjectMeta)
    spec: ServiceCIDRSpec | None = None
    status: ServiceCIDRStatus | None = None
    plural_: ClassVar[str] = 'servicecidrs'
    is_namespaced_: ClassVar[bool] = False
    group_: ClassVar[Optional[str]] = 'networking.k8s.io'
    patch_strategies_: ClassVar[set[PatchRequestType]] = {
        'application/apply-patch+cbor',
        'application/apply-patch+yaml',
        'application/json-patch+json',
        'application/merge-patch+json',
        'application/strategic-merge-patch+json',
    }


@dataclass(slots=True, kw_only=True, frozen=True)
class ServiceCIDRList(Loadable):
    items: List[ServiceCIDR]
    apiVersion: str = 'networking.k8s.io/v1'
    kind: str = 'ServiceCIDRList'
    metadata: ListMeta = field(default_factory=ObjectMeta)


@dataclass(slots=True, kw_only=True, frozen=True)
class Ingress(K8sResource):
    apiVersion: ClassVar[str] = 'networking.k8s.io/v1'
    kind: ClassVar[str] = 'Ingress'
    metadata: ObjectMeta = field(default_factory=ObjectMeta)
    spec: IngressSpec | None = None
    status: IngressStatus | None = None
    plural_: ClassVar[str] = 'ingresses'
    is_namespaced_: ClassVar[bool] = True
    group_: ClassVar[Optional[str]] = 'networking.k8s.io'
    patch_strategies_: ClassVar[set[PatchRequestType]] = {
        'application/apply-patch+cbor',
        'application/apply-patch+yaml',
        'application/json-patch+json',
        'application/merge-patch+json',
        'application/strategic-merge-patch+json',
    }


@dataclass(slots=True, kw_only=True, frozen=True)
class IngressList(Loadable):
    items: List[Ingress]
    apiVersion: str = 'networking.k8s.io/v1'
    kind: str = 'IngressList'
    metadata: ListMeta = field(default_factory=ObjectMeta)


@dataclass(slots=True, kw_only=True, frozen=True)
class NetworkPolicy(K8sResource):
    apiVersion: ClassVar[str] = 'networking.k8s.io/v1'
    kind: ClassVar[str] = 'NetworkPolicy'
    metadata: ObjectMeta = field(default_factory=ObjectMeta)
    spec: NetworkPolicySpec | None = None
    plural_: ClassVar[str] = 'networkpolicies'
    is_namespaced_: ClassVar[bool] = True
    group_: ClassVar[Optional[str]] = 'networking.k8s.io'
    patch_strategies_: ClassVar[set[PatchRequestType]] = {
        'application/apply-patch+cbor',
        'application/apply-patch+yaml',
        'application/json-patch+json',
        'application/merge-patch+json',
        'application/strategic-merge-patch+json',
    }


@dataclass(slots=True, kw_only=True, frozen=True)
class NetworkPolicyList(Loadable):
    items: List[NetworkPolicy]
    apiVersion: str = 'networking.k8s.io/v1'
    kind: str = 'NetworkPolicyList'
    metadata: ListMeta = field(default_factory=ObjectMeta)
