-- Stored Procedure: Common Table to Vortex Repayment Migration
-- This procedure migrates repayment records from common table (fmpp_vortex_common_repayment_transfer) 
-- to Vortex architecture (t_loan_repayment_detail and t_fee_details)
-- Only processes records where is_processed_vortex = false and settlement_date IS NOT NULL

CREATE OR REPLACE PROCEDURE prc_repayments_common_table_to_vortex_migration(
    INOUT inout_response character varying DEFAULT NULL::character varying,
    IN batch_size integer DEFAULT 5000
)
LANGUAGE plpgsql
AS
$$
DECLARE
    v_current_timestamp timestamp with time zone := NOW();
    v_rows_processed int := 0;
    v_fee_records_inserted int := 0;
    v_migration_batch_id varchar(30);
    v_migration_id bigint;
    v_repayment_detail_id bigint;
    v_repayment_record RECORD;
    v_loan_id_from_ref INTEGER;
BEGIN
    -- Generate migration_batch_id (format: YYYYMMDDHHMMSS_XXXX)
    v_migration_batch_id := TO_CHAR(NOW(), 'YYYYMMDDHH24MISS') || '_' || 
                           LPAD(EXTRACT(MICROSECONDS FROM NOW())::bigint % 10000::bigint, 4, '0');
    
    -- Create migration log entry and get migration_id
    INSERT INTO t_repayment_migration_logs (
        migration_batch_id, source_system, status, rows_processed, fee_records_inserted,
        created_dtm, updated_dtm
    )
    VALUES (
        v_migration_batch_id, 'COMMON_TABLE', 'PROCESSING', 0, 0,
        v_current_timestamp, v_current_timestamp
    )
    RETURNING id INTO v_migration_id;
    
    -- Process each repayment record individually
    FOR v_repayment_record IN 
        SELECT 
            crt.id as common_table_id,
            crt.loan_id as loan_ref_id,
            crt.transaction_id,
            crt.emi_amount,
            crt.facilitation_fee,
            crt.collection_fee,
            crt.recovery_fee,
            crt.purpose,
            crt.days_past_due,
            crt.transaction_date,
            crt.settlement_date,
            crt.created_dtm as src_created_dtm
        FROM fmpp_vortex_common_repayment_transfer crt
        LEFT JOIN t_loan tl ON crt.loan_id = tl.loan_ref_id
        WHERE crt.is_processed_vortex = false
          AND crt.settlement_date IS NOT NULL
          AND crt.emi_amount > 0
          AND crt.purpose IN ('PRINCIPAL', 'INTEREST', 'DELAY_INTEREST', 'OTHER_CHARGES')
          AND tl.id IS NOT NULL  -- Only process if loan exists in Vortex
        ORDER BY crt.id
        LIMIT batch_size
    LOOP
        -- Get loan_id from t_loan using loan_ref_id
        SELECT id INTO v_loan_id_from_ref
        FROM t_loan
        WHERE loan_ref_id = v_repayment_record.loan_ref_id
        LIMIT 1;
        
        -- Skip if loan not found
        IF v_loan_id_from_ref IS NULL THEN
            CONTINUE;
        END IF;
        
        -- Insert repayment detail and get the ID
        INSERT INTO t_loan_repayment_detail(
            loan_id,
            loan_ref_id,
            purpose,
            purpose_amount,
            emi_amount,
            total_fees,
            is_processed,
            days_past_due,
            src_txn_id,
            sys_txn_id,
            migration_id,
            ammort_id,
            transaction_date,
            settlement_date,
            src_created_dtm,
            sys_created_dtm,
            updated_dtm
        )
        VALUES (
            v_loan_id_from_ref,
            v_repayment_record.loan_ref_id,
            v_repayment_record.purpose::repayment_purpose,
            COALESCE(v_repayment_record.emi_amount, 0),
            COALESCE(v_repayment_record.emi_amount, 0),
            COALESCE(v_repayment_record.facilitation_fee, 0) + 
            COALESCE(v_repayment_record.collection_fee, 0) + 
            COALESCE(v_repayment_record.recovery_fee, 0),
            false,
            COALESCE(v_repayment_record.days_past_due, 0),
            v_repayment_record.transaction_id,
            NULL,  -- sys_txn_id will be generated by trigger
            v_migration_id,
            NULL,
            v_repayment_record.transaction_date,
            v_repayment_record.settlement_date,
            v_repayment_record.src_created_dtm,
            v_current_timestamp,
            v_current_timestamp
        )
        RETURNING id INTO v_repayment_detail_id;
        
        v_rows_processed := v_rows_processed + 1;
        
        -- Insert fee details for this repayment record
        -- Facilitation Fee
        IF COALESCE(v_repayment_record.facilitation_fee, 0) > 0 THEN
            INSERT INTO t_fee_details (
                fee_source_id,
                fee_source,
                fee_type,
                fee_amount,
                fee_levy_date,
                created_dtm,
                txn_reference_id
            )
            VALUES (
                v_repayment_detail_id,
                'LOAN'::fee_source_type,
                'FF'::fee_type_enum,
                v_repayment_record.facilitation_fee,
                CURRENT_DATE,
                v_current_timestamp,
                v_migration_id
            );
            v_fee_records_inserted := v_fee_records_inserted + 1;
        END IF;
        
        -- Collection Fee
        IF COALESCE(v_repayment_record.collection_fee, 0) > 0 THEN
            INSERT INTO t_fee_details (
                fee_source_id,
                fee_source,
                fee_type,
                fee_amount,
                fee_levy_date,
                created_dtm,
                txn_reference_id
            )
            VALUES (
                v_repayment_detail_id,
                'LOAN'::fee_source_type,
                'CF'::fee_type_enum,
                v_repayment_record.collection_fee,
                CURRENT_DATE,
                v_current_timestamp,
                v_migration_id
            );
            v_fee_records_inserted := v_fee_records_inserted + 1;
        END IF;
        
        -- Recovery Fee
        IF COALESCE(v_repayment_record.recovery_fee, 0) > 0 THEN
            INSERT INTO t_fee_details (
                fee_source_id,
                fee_source,
                fee_type,
                fee_amount,
                fee_levy_date,
                created_dtm,
                txn_reference_id
            )
            VALUES (
                v_repayment_detail_id,
                'LOAN'::fee_source_type,
                'RF'::fee_type_enum,
                v_repayment_record.recovery_fee,
                CURRENT_DATE,
                v_current_timestamp,
                v_migration_id
            );
            v_fee_records_inserted := v_fee_records_inserted + 1;
        END IF;
    END LOOP;
    
    -- Mark common table records as processed (outside the loop, once per batch)
    IF v_rows_processed > 0 THEN
        UPDATE fmpp_vortex_common_repayment_transfer crt
        SET is_processed_vortex = true,
            updated_dtm = v_current_timestamp
        WHERE crt.is_processed_vortex = false
          AND crt.transaction_id IN (
            SELECT src_txn_id 
            FROM t_loan_repayment_detail 
            WHERE migration_id = v_migration_id
          );
    END IF;
    
    -- Update migration log
    UPDATE t_repayment_migration_logs
    SET status = CASE WHEN v_rows_processed > 0 THEN 'COMPLETED' ELSE 'NO_DATA' END,
        rows_processed = v_rows_processed,
        fee_records_inserted = v_fee_records_inserted,
        updated_dtm = v_current_timestamp
    WHERE id = v_migration_id;
    
    -- Return response with batch information
    inout_response := json_build_object(
        'status', CASE WHEN v_rows_processed > 0 THEN 'SUCCESS' ELSE 'NO_DATA' END,
        'migration_id', v_migration_id,
        'migration_batch_id', v_migration_batch_id,
        'rows_processed', v_rows_processed,
        'fee_records_inserted', v_fee_records_inserted,
        'message', CASE WHEN v_rows_processed > 0 THEN 'Batch processed successfully' ELSE 'No records found' END
    )::text;
    
EXCEPTION
    WHEN OTHERS THEN
        DECLARE
            my_ex_state text;
            my_ex_message text;
            my_ex_detail text;
            my_ex_hint text;
            my_ex_ctx text;
        BEGIN
            GET STACKED DIAGNOSTICS
                my_ex_state   = returned_sqlstate,
                my_ex_message = message_text,
                my_ex_detail  = pg_exception_detail,
                my_ex_hint    = pg_exception_hint,
                my_ex_ctx     = pg_exception_context;

            -- Update migration log with error
            IF v_migration_id IS NOT NULL THEN
                UPDATE t_repayment_migration_logs
                SET status = 'FAILED',
                    error_message = 'ERROR: ' || my_ex_message,
                    updated_dtm = v_current_timestamp
                WHERE id = v_migration_id;
            END IF;

            -- Log to error table if exists
            INSERT INTO t_error_log (
                sp_name, err_state, err_message, err_details, 
                err_hint, err_context, created_dtm, updated_dtm
            )
            VALUES (
                'prc_repayments_common_table_to_vortex_migration', 
                my_ex_state, my_ex_message, my_ex_detail, 
                my_ex_hint, my_ex_ctx, NOW(), NOW()
            );

            RAISE INFO 'THE FOLLOWING ERROR OCCURRED % % % % %',
                my_ex_state, my_ex_message, my_ex_detail, my_ex_hint, my_ex_ctx;

            inout_response := json_build_object(
                'status', 'ERROR',
                'migration_id', COALESCE(v_migration_id, 0),
                'migration_batch_id', COALESCE(v_migration_batch_id, 'ERROR_BATCH'),
                'rows_processed', 0,
                'fee_records_inserted', 0,
                'message', 'ERROR: ' || my_ex_message
            )::text;
        END;
END;
$$;

