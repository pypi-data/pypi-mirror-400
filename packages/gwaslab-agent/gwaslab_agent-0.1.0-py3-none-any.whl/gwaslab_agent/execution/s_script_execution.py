"""
Script execution module for GWASLab Agent.

This module handles the execution of Python scripts generated by the Planner agent,
providing a secure and controlled environment for running user-requested operations
on GWAS summary statistics data.

Key Features:
- Extracts Python code from markdown-formatted script responses
- Captures and displays figures from plotting functions automatically
- Registers new Sumstats and DataFrame objects in the RESULTS registry
- Provides user confirmation before script execution
- Handles errors gracefully with informative error messages
- Integrates with Jupyter/IPython environments for interactive execution
- Maintains a unified namespace for variable access across script executions

The module ensures that all executed scripts have access to:
- The main Sumstats object (sumstats)
- The RESULTS registry for accessing previously computed results
- Standard data science libraries (pandas, matplotlib)
- All registered objects from previous executions
"""

import re
import traceback
from typing import Optional


def extract_python_code(text: str) -> str:
    """
    Extract Python code from text, handling markdown code blocks.
    
    Parameters
    ----------
    text : str
        Text that may contain Python code in markdown blocks or plain text
        
    Returns
    -------
    str
        Extracted Python code
    """
    # Try to find Python code block
    python_block_pattern = r"```(?:python)?\s*(.*?)```"
    match = re.search(python_block_pattern, text, re.DOTALL)
    if match:
        return match.group(1).strip()
    # If no code block, return the text as-is (assuming it's already Python code)
    return text.strip()


def confirm_script_execution(script: str, log, console) -> bool:
    """
    Display the script to the user and request confirmation before execution.
    
    Parameters
    ----------
    script : str
        The Python script to be executed
    log
        Log object for writing messages
    console
        Rich console instance for printing
        
    Returns
    -------
    bool
        True if user confirms execution, False if cancelled
    """
    # Extract Python code for display
    code = extract_python_code(script)
    
    # Request confirmation
    from gwaslab_agent.core.g_print import print_status
    if console is None:
        from gwaslab_agent.core.g_console import console
    print_status(console, "Script validation passed. Ready to execute.", "info")
    
    while True:
        try:
            response = input("Execute this script? (yes/no/y/n): ").strip().lower()
            if response in ('yes', 'y'):
                print_status(console, "Execution confirmed. Running script...", "success")
                console.print()  # Add blank line
                return True
            elif response in ('no', 'n'):
                print_status(console, "Execution cancelled by user.", "error")
                console.print()  # Add blank line
                return False
            else:
                print_status(console, "Please enter 'yes' or 'no' (or 'y'/'n')", "warning")
        except (EOFError, KeyboardInterrupt):
            console.print()  # Add blank line
            print_status(console, "Execution cancelled (interrupted).", "error")
            console.print()  # Add blank line
            return False


def _find_plot_function_call(line: str, plot_functions: list) -> Optional[tuple]:
    """
    Check if a line contains a plot function call.
    
    Parameters
    ----------
    line : str
        The line of code to check
    plot_functions : list
        List of plot function names to search for
        
    Returns
    -------
    tuple or None
        If found: (indent, object_name, plot_function_name)
        If not found: None
    """
    for plot_func in plot_functions:
        # Pattern: Method call on object: something.plot_func(...)
        # Matches patterns like: sumstats.plot_manhattan(...) or my_sumstats.plot_qq(...)
        pattern = rf'(\s*)([a-zA-Z_][a-zA-Z0-9_]*)\.{re.escape(plot_func)}\s*\('
        match = re.search(pattern, line)
        if match:
            indent = match.group(1)
            obj_name = match.group(2)
            return (indent, obj_name, plot_func)
    return None


def _is_already_assigned(line: str, plot_func: str) -> bool:
    """
    Check if a plot function call is already assigned to a variable.
    
    Parameters
    ----------
    line : str
        The line of code to check
    plot_func : str
        The plot function name
        
    Returns
    -------
    bool
        True if the plot call is already assigned, False otherwise
    """
    assignment_pattern = r'^\s*([a-zA-Z_][a-zA-Z0-9_]*)\s*=\s*.*' + re.escape(plot_func)
    return bool(re.search(assignment_pattern, line))


def _collect_multiline_call(lines: list, start_index: int) -> tuple[list, int]:
    """
    Collect all lines of a multi-line function call.
    
    Parameters
    ----------
    lines : list
        All lines of code
    start_index : int
        Index of the line where the function call starts
        
    Returns
    -------
    tuple
        (list of lines in the call, index of the line after the call)
    """
    plot_lines = [lines[start_index]]
    paren_count = lines[start_index].count('(') - lines[start_index].count(')')
    current_index = start_index + 1
    
    while current_index < len(lines) and paren_count > 0:
        plot_lines.append(lines[current_index])
        paren_count += lines[current_index].count('(') - lines[current_index].count(')')
        current_index += 1
    
    return plot_lines, current_index


def _modify_multiline_plot_call(plot_lines: list, obj_name: str, plot_func: str, 
                                 var_name: str, indent: str) -> list:
    """
    Modify a multi-line plot function call to capture the return value.
    
    Parameters
    ----------
    plot_lines : list
        All lines of the multi-line function call
    obj_name : str
        The object name (e.g., 'sumstats')
    plot_func : str
        The plot function name
    var_name : str
        Variable name to assign the figure to
    indent : str
        Indentation string to preserve
        
    Returns
    -------
    list
        Modified lines with assignment and plt.show() added
    """
    # Modify the first line to add assignment: var_name = obj.plot_func(...)
    first_line = plot_lines[0]
    first_line = re.sub(
        rf'(\s*)({re.escape(obj_name)}\.{re.escape(plot_func)}\s*\()',
        rf'\1{var_name} = \2',
        first_line,
        count=1
    )
    plot_lines[0] = first_line
    
    # Add all lines of the multi-line call
    modified_lines = plot_lines.copy()
    # Add plt.show() after the last line with same indentation
    modified_lines.append(f"{indent}plt.show()")
    
    return modified_lines


def _modify_singleline_plot_call(line: str, obj_name: str, plot_func: str, 
                                  var_name: str, indent: str) -> str:
    """
    Modify a single-line plot function call to capture the return value.
    
    Parameters
    ----------
    line : str
        The line containing the plot function call
    obj_name : str
        The object name (e.g., 'sumstats')
    plot_func : str
        The plot function name
    var_name : str
        Variable name to assign the figure to
    indent : str
        Indentation string to preserve
        
    Returns
    -------
    str
        Modified line with assignment added
    """
    original_line = line
    
    # Try to match the complete function call including nested parentheses
    line = re.sub(
        rf'({re.escape(obj_name)}\.{re.escape(plot_func)}\s*\([^)]*(?:\([^)]*\)[^)]*)*\))',
        rf'{var_name} = \1',
        line,
        count=1
    )
    
    # If the pattern didn't match (complex nested parens), use simpler approach
    if line == original_line:
        # Fallback: just prepend the assignment before the method call
        line = re.sub(
            rf'(\s*)({re.escape(obj_name)}\.{re.escape(plot_func)})',
            rf'\1{var_name} = \2',
            line,
            count=1
        )
    
    return line


def modify_script_to_capture_figures(code: str, log) -> str:
    """
    Modify the script to capture plot function return values in local variables and show them.
    
    This function scans the script for calls to GWASLab plotting functions (e.g., plot_manhattan,
    plot_qq, etc.) and automatically:
    1. Captures the return value (figure object) in a local variable (_fig_0, _fig_1, etc.)
    2. Adds plt.show() calls after each plot to ensure figures are displayed
    
    Handles both single-line and multi-line function calls, including complex nested parentheses.
    Only modifies plot calls that are not already assigned to variables.
    
    Parameters
    ----------
    code : str
        The Python script code to modify
    log
        Log object for writing messages about modifications
        
    Returns
    -------
    str
        Modified script with plot return values captured and plt.show() calls added
        
    Notes
    -----
    The function identifies plotting functions from PLOTTER_SET in g_tools.py.
    It preserves the original indentation and structure of the code while adding
    the necessary variable assignments and display calls.
    """
    # Import plot functions from g_tools.py
    from gwaslab_agent.tools.g_tools import PLOTTER_SET
    
    # Get list of plotting function names
    plot_functions = list(PLOTTER_SET)
    
    # Split code into lines for line-by-line processing
    lines = code.split('\n')
    modified_lines = []
    figure_var_index = 0
    current_line_index = 0
    
    # Process each line of the script
    while current_line_index < len(lines):
        line = lines[current_line_index]
        
        # Check if this line contains a plot function call
        plot_call_info = _find_plot_function_call(line, plot_functions)
        
        if plot_call_info is None:
            # No plot function found, add line as-is
            modified_lines.append(line)
            current_line_index += 1
            continue
        
        indent, obj_name, plot_func = plot_call_info
        
        # Skip if already assigned to a variable
        if _is_already_assigned(line, plot_func):
            modified_lines.append(line)
            current_line_index += 1
            continue
        
        # Generate unique variable name for the figure
        var_name = f"_fig_{figure_var_index}"
        figure_var_index += 1
        
        # Check if this is a multi-line call by counting parentheses
        paren_count = line.count('(') - line.count(')')
        
        if paren_count > 0:
            # Multi-line call: collect all lines until parentheses are balanced
            plot_lines, next_line_index = _collect_multiline_call(lines, current_line_index)
            modified_plot_lines = _modify_multiline_plot_call(
                plot_lines, obj_name, plot_func, var_name, indent
            )
            modified_lines.extend(modified_plot_lines)
            log.write(f"Captured and will show figure from: {plot_func} (multi-line)", verbose=True)
            current_line_index = next_line_index
        else:
            # Single-line call: modify the line and add plt.show()
            modified_line = _modify_singleline_plot_call(
                line, obj_name, plot_func, var_name, indent
            )
            modified_lines.append(modified_line)
            modified_lines.append(f"{indent}plt.show()")
            log.write(f"Captured and will show figure from: {plot_func}", verbose=True)
            current_line_index += 1
    
    # Join all modified lines back into a single script string
    return '\n'.join(modified_lines)


def execute_planner_script(script: str, user_message: str, sumstats, results, log, history, archive):
    """
    Execute the validated Python script generated by Planner.
    
    This is the main execution function that:
    1. Extracts Python code from markdown-formatted script
    2. Modifies the script to capture and display figures
    3. Sets up an execution context with all necessary variables and libraries
    4. Executes the script in a controlled environment
    5. Registers newly created Sumstats and DataFrame objects
    6. Displays any captured figures
    7. Updates history and archive with execution results
    
    The execution context includes:
    - The main Sumstats object (unwrapped from SmartSumstats if needed)
    - The RESULTS registry for accessing previous results
    - All registered objects from previous executions
    - Standard libraries: pandas, matplotlib, numpy
    - User namespace variables from Jupyter/IPython (if available)
    
    Special handling:
    - Patches pandas DataFrame.query() to support @variable_name syntax
    - Configures matplotlib backend for Jupyter environments
    - Automatically registers new Sumstats and DataFrame objects
    - Provides detailed error messages for common issues
    
    Parameters
    ----------
    script : str
        The Python script code (may include markdown code blocks)
    user_message : str
        The original user message for context (currently unused but kept for future use)
    sumstats
        The Sumstats object (or SmartSumstats wrapper) to make available in execution context.
        If wrapped, the underlying gl.Sumstats object is extracted for direct method access.
    results
        The RESULTS registry object to make available in execution context.
        Used for accessing previously computed results and registering new objects.
    log
        Log object for writing execution messages and errors
    history : list
        History list to update with execution results (for current session)
    archive : list
        Archive list to update with execution results (for persistent storage)
        
    Notes
    -----
    - Execution uses only globals (no locals dict) to ensure pandas query() can access
      variables via @variable_name syntax
    - The function handles both Jupyter/IPython and standard Python environments
    - Errors are caught and logged with helpful context messages
    - New objects are automatically registered with appropriate IDs in the RESULTS registry
    """
    from gwaslab_agent.history.g_history_stages import ORCHESTRATOR_REPLY
    
    # Extract Python code from markdown-formatted script (if present)
    code = extract_python_code(script)
    
    if not code:
        log.write("ERROR: No Python code found in script", verbose=True)
        return
    
    # Modify script to capture figures from plot_* functions
    # This ensures all plot calls return values are captured and displayed
    code = modify_script_to_capture_figures(code, log)
    
    log.write("Executing Planner-generated script...", verbose=True)
    
    # Prepare execution context with unified namespace
    # Make sumstats available in the execution context
    # IMPORTANT: Extract underlying Sumstats object if sumstats is a SmartSumstats wrapper
    # Scripts need direct access to gl.Sumstats methods, not the wrapper
    # The wrapper provides convenience methods, but scripts call methods directly on gl.Sumstats
    underlying_sumstats = sumstats
    if hasattr(sumstats, 'sumstats'):
        # It's a SmartSumstats wrapper, get the underlying gl.Sumstats object
        underlying_sumstats = sumstats.sumstats
    
    # Create execution globals dictionary - this is the namespace for script execution
    # Using only globals (no locals) ensures pandas query() can access variables via @variable_name
    exec_globals = {
        'sumstats': underlying_sumstats,  # Always use underlying Sumstats object for method access
        '__builtins__': __builtins__,  # Standard Python builtins
    }
    
    # Add RESULTS registry to context for accessing previously computed results
    # Scripts can use RESULTS['result_id'] to access registered objects
    exec_globals['RESULTS'] = results
    
    # Add all registered objects directly to the namespace for easy access
    # This creates a unified namespace where all objects are accessible by their result_id
    # This means scripts can use 'result_id' directly instead of RESULTS['result_id']
    if hasattr(results, 'objects'):
        for obj_id, obj in results.objects.items():
            exec_globals[obj_id] = obj
        log.write(f"Added {len(results.objects)} registered objects to script namespace", verbose=True)
    
    # If running in Jupyter/IPython, merge user namespace to access local variables
    # This allows scripts to access variables defined in notebook cells
    try:
        from IPython import get_ipython
        ipython = get_ipython()
        if ipython is not None:
            # Get user namespace (local variables from notebook cells)
            user_ns = getattr(ipython, 'user_ns', {})
            if user_ns:
                # Merge user namespace into exec_globals
                # CRITICAL: Exclude 'sumstats' to prevent overwriting with SmartSumstats wrapper
                # exec_globals['sumstats'] must remain the underlying gl.Sumstats object
                # Also exclude IPython magic variables and builtins
                excluded_vars = {'sumstats', 'RESULTS', '__builtins__', 'In', 'Out', '_', '__', 'exit', 'quit'}
                exec_globals.update({k: v for k, v in user_ns.items() 
                                   if k not in excluded_vars and (not k.startswith('_') or k in ['__builtins__', '__name__', '__doc__'])})
                log.write(f"Loaded {len([k for k in user_ns.keys() if k not in excluded_vars and (not k.startswith('_') or k in ['__builtins__', '__name__', '__doc__'])])} variables from Jupyter notebook namespace", verbose=True)
    except Exception as e:
        # If not in Jupyter or error accessing namespace, continue without it
        # This is not a critical error - scripts can still run without notebook variables
        pass
    
    # Import pandas in the execution context
    # Scripts often use pandas for data manipulation
    import pandas as pd
    exec_globals['pd'] = pd
    
    # Patch pandas DataFrame.query to inject exec_globals for @variable_name resolution
    # This is necessary because pandas query() with engine='python' uses eval() which
    # looks in the calling frame's namespace, but our variables are in exec_globals
    # The @variable_name syntax in pandas query() needs access to these variables
    # We use a closure to capture exec_globals so it's accessible when query() is called
    original_query = pd.DataFrame.query
    
    def make_patched_query(exec_globals_dict):
        """
        Create a patched query function that has access to exec_globals via closure.
        
        This factory function creates a closure that captures exec_globals_dict,
        allowing the patched query method to access variables from the script execution
        context when evaluating @variable_name expressions.
        """
        def patched_query(self, expr, inplace=False, **kwargs):
            """
            Patched query that injects exec_globals for @variable resolution.
            
            This method ensures that when pandas query() is called with @variable_name
            syntax, it can find the variables in exec_globals. It merges exec_globals
            into the local_dict that pandas uses for variable resolution.
            """
            # Merge exec_globals into the query's local_dict
            # Get local_dict from kwargs or create new one
            local_dict = kwargs.get('local_dict', {})
            # Merge exec_globals into local_dict (exec_globals takes precedence)
            # This makes all script variables available to pandas query() expressions
            merged_dict = {**local_dict, **exec_globals_dict}
            kwargs['local_dict'] = merged_dict
            return original_query(self, expr, inplace=inplace, **kwargs)
        return patched_query
    
    # Apply the patch with exec_globals captured in closure
    # This modifies pandas DataFrame.query globally, but only for this execution
    pd.DataFrame.query = make_patched_query(exec_globals)
    
    # Import matplotlib in execution context so figures are accessible
    # Also ensure we're using a backend that works with Jupyter
    # This is important for displaying plots in notebook environments
    try:
        import matplotlib
        # Check if we're in Jupyter/IPython environment
        try:
            from IPython import get_ipython
            ipython = get_ipython()
            if ipython is not None:
                # We're in Jupyter, ensure inline backend is used for proper figure display
                try:
                    # Try matplotlib_inline first (newer Jupyter versions)
                    matplotlib.use('module://matplotlib_inline.backend_inline', force=False)
                except Exception:
                    try:
                        # Fallback to standard inline backend
                        matplotlib.use('inline', force=False)
                    except Exception:
                        # If backend setup fails, continue with default
                        pass
        except Exception:
            pass
        import matplotlib.pyplot as plt
        # Ensure interactive mode is on for Jupyter
        # This allows figures to be displayed immediately
        try:
            from IPython import get_ipython
            if get_ipython() is not None:
                plt.ion()  # Turn on interactive mode
        except Exception:
            pass
        exec_globals['plt'] = plt  # Make pyplot available as 'plt'
        exec_globals['matplotlib'] = matplotlib  # Make matplotlib module available
    except Exception:
        # If matplotlib import fails, continue without it (plots won't work but script can still run)
        pass
    
    # Track variables that might be filtered sumstats or dataframes
    # We'll register them in RESULTS if they match patterns after execution
    
    try:
        # Execute the script
        # IMPORTANT: When exec() is called with only globals (no locals dict),
        # all variables are stored in globals, which makes them accessible to
        # pandas query() when using @variable_name syntax
        # If we use both globals and locals, variables go into locals and query() can't find them
        # 
        # Also, we need to ensure that when pandas query() is called, it can access these globals.
        # The @variable_name syntax in pandas query() looks in the calling frame's globals.
        # By executing with only exec_globals, all variables are in the global namespace.
        # Compile the code first for better error messages (shows '<planner_script>' in traceback)
        exec(compile(code, '<planner_script>', 'exec'), exec_globals)
        
        # After execution, update exec_globals with any new variables that might have been created
        # This ensures pandas query() can access them via @variable_name syntax
        # (Note: exec() with only globals already puts everything in exec_globals, but this is explicit)
        
        # After execution, register any new Sumstats or DataFrame objects created in the script
        # This ensures they're available in the namespace for subsequent scripts
        # Filter out built-in and system variables to focus on user-created objects
        local_vars = {k: v for k, v in exec_globals.items() 
                     if not k.startswith('__') and k not in ['sumstats', 'RESULTS', 'pd', 'np', 'plt', 'matplotlib']}
        
        # Import libraries needed for type checking
        import gwaslab as gl
        import pandas as pd
        
        # Track which objects were already registered to avoid duplicates
        # This prevents re-registering objects that were already in the namespace
        existing_ids = set(results.objects.keys()) if hasattr(results, 'objects') else set()
        
        # Iterate through all variables created during script execution
        for var_name, var_value in local_vars.items():
            # Skip if already registered with this name
            # This prevents re-registering objects that were already in the namespace
            if var_name in existing_ids:
                continue
            
            # Register new Sumstats objects (filtered subsets, etc.)
            # These are typically created by filtering operations like sumstats.loc[...]
            if isinstance(var_value, gl.Sumstats):
                if hasattr(results, 'put'):
                    # Use put() method to get proper ID generation (preferred method)
                    # This ensures consistent ID naming and proper registration
                    obj_id = results.put(var_value)
                    # Add to exec_globals by both ID and variable name for flexible access
                    exec_globals[obj_id] = var_value
                    # Keep available by variable name if it follows standard naming patterns
                    # This allows scripts to use both the ID and the original variable name
                    if var_name.startswith(('subset_', 'filtered_', 'significant_', 'common_', 'novel_')):
                        exec_globals[var_name] = var_value
                    log.write(f"Registered new Sumstats object '{var_name}' as {obj_id} in namespace", verbose=True)
                elif hasattr(results, 'objects'):
                    # Fallback: use variable name or generate ID if put() is not available
                    # This handles cases where RESULTS doesn't have a put() method
                    if var_name.startswith('subset_'):
                        obj_id = var_name
                    else:
                        # Generate a unique ID based on existing subset count
                        obj_id = f"subset_{len([k for k in results.objects.keys() if k.startswith('subset_')])}"
                    results.objects[obj_id] = var_value
                    exec_globals[obj_id] = var_value
                    # Also keep available by variable name for convenience
                    exec_globals[var_name] = var_value
                    log.write(f"Registered new Sumstats object '{var_name}' as {obj_id} in namespace", verbose=True)
            
            # Register new DataFrames created during script execution
            # These are typically results of data processing or analysis operations
            elif isinstance(var_value, pd.DataFrame):
                if hasattr(results, 'put'):
                    # Use put() method to get proper ID generation (preferred method)
                    obj_id = results.put(var_value)
                    # Add to exec_globals by both ID and variable name for flexible access
                    exec_globals[obj_id] = var_value
                    # Keep available by variable name if it follows standard naming patterns
                    # Common patterns: df_*, leads_*, results_*
                    if var_name.startswith('df_') or var_name.startswith(('leads_', 'results_')):
                        exec_globals[var_name] = var_value
                    log.write(f"Registered new DataFrame '{var_name}' as {obj_id} in namespace. Access manually via: sumstat.RESULTS['{obj_id}'] or sumstat.RESULTS['{var_name}']", verbose=True)
                elif hasattr(results, 'objects'):
                    # Fallback: use variable name or generate ID if put() is not available
                    if var_name.startswith('df_'):
                        obj_id = var_name
                    else:
                        # Generate a unique ID based on existing DataFrame count
                        obj_id = f"df_{len([k for k in results.objects.keys() if k.startswith('df_')])}"
                    results.objects[obj_id] = var_value
                    exec_globals[obj_id] = var_value
                    # Also keep available by variable name for convenience
                    exec_globals[var_name] = var_value
                    log.write(f"Registered new DataFrame '{var_name}' as {obj_id} in namespace. Access manually via: sumstat.RESULTS['{obj_id}'] or sumstat.RESULTS['{var_name}']", verbose=True)
        
        # Check for figure objects in local_vars and display them
        # This handles figures that were captured by modify_script_to_capture_figures()
        # or created directly in the script
        try:
            from gwaslab_agent.core.g_image import _show_locally, _is_figure
            
            # Track displayed figures by their object ID to avoid duplicate displays
            displayed_figures = set()
            for var_name, var_value in local_vars.items():
                if _is_figure(var_value):
                    fig_id = id(var_value)  # Use object ID to track unique figures
                    if fig_id not in displayed_figures:
                        _show_locally(var_value)  # Display the figure
                        displayed_figures.add(fig_id)  # Mark as displayed
        except Exception as e:
            # If figure display fails, log the error but don't fail the entire execution
            log.write(f"Error displaying figures: {str(e)}", verbose=True)
        
        # Log successful execution
        log.write("Script executed successfully", verbose=True)
        
        # Update history with successful execution record
        # This allows the conversation history to track what was executed
        history.append({
            "role": "assistant",
            "gwaslab_agent": "Worker_orchestrator",
            "content": f"Executed Planner script successfully",
            "toolcalls": code,  # Store the executed code for reference
            "stage": ORCHESTRATOR_REPLY
        })
        # Also update archive for persistent storage
        archive.append({
            "role": "assistant",
            "gwaslab_agent": "Worker_orchestrator",
            "content": f"Executed Planner script successfully",
            "toolcalls": code,  # Store the executed code for reference
            "stage": ORCHESTRATOR_REPLY
        })
        
    except Exception as e:
        # Handle any errors that occur during script execution
        # Provide helpful error messages to aid debugging
        import traceback
        error_traceback = traceback.format_exc()
        error_type = type(e).__name__
        error_msg = f"Error executing script: {error_type}: {str(e)}"
        
        # Provide more helpful error messages for common issues
        # This helps users understand what went wrong and how to fix it
        if "NoneType" in error_type or "None" in str(e):
            error_msg += "\n\nThis error often occurs when a required parameter is missing or None."
            error_msg += "\nPlease check that all required parameters are provided with valid values."
        elif "AttributeError" in error_type:
            error_msg += "\n\nThis error indicates that an attribute or method doesn't exist on the object."
            error_msg += "\nPlease check the object type and available methods."
        elif "TypeError" in error_type:
            error_msg += "\n\nThis error indicates a type mismatch."
            error_msg += "\nPlease check that all parameters have the correct types."
        
        # Append full traceback for detailed debugging
        error_msg += f"\n\nFull traceback:\n{error_traceback}"
        
        log.write(error_msg, verbose=True)
        
        # Update history with error information
        # This ensures errors are tracked in the conversation history
        history.append({
            "role": "assistant",
            "gwaslab_agent": "Worker_orchestrator",
            "content": error_msg,
            "toolcalls": code,  # Store the code that caused the error
            "stage": ORCHESTRATOR_REPLY
        })
        # Also update archive for persistent storage
        archive.append({
            "role": "assistant",
            "gwaslab_agent": "Worker_orchestrator",
            "content": error_msg,
            "toolcalls": code,  # Store the code that caused the error
            "stage": ORCHESTRATOR_REPLY
        })

