# === 🏛️ PyCourt 最高法院 - 庭审全程剧本 ===

courtroom:
  supreme_court:
    summary_failed: "❌ 发现 {count} 个违宪行为:"
    summary_passed: "✅ 审查通过，未发现指定范围的违宪行为"

# === 🏛️ 各位大法官的判决模板（按法条编号） ===

judges:
  AC001:
    template: |
      🦆 鸭子类型审查官: 检测到 Any 类型滥用
      📌 变量/属性: {target_name}
      📋 违规类型: {annotation_str}
      💡 建议: 避免使用 Any，请为该值引入更具体的契约类型（如 DTO / Protocol / TypedDict）
      🔧 修复示例:
        - 为该值定义专门的数据模型，并在此处使用该类型
        - 或使用 TypedDict / Protocol 描述结构，而不是 Any

  AC002:
    template: |
      🦆 鸭子类型审查官: 检测到无契约 dict 类型
      📌 变量/属性: {target_name}
      📋 违规类型: {annotation_str}
      💡 建议: 不要直接使用裸 dict，请为 key/value 引入更明确的模型
      🔧 修复示例:
        - 为 value 定义 DTO / Schema / TypedDict / Protocol 类型，并在 dict[...] 中引用
        - 若仅为配置/数据载体，可考虑使用数据模型（如 Pydantic / dataclasses）统一承载

  AC003:
    template: |
      🦆 鸭子类型审查官: 检测到 typing.cast 滥用
      📌 表达式: {annotation_str}
      💡 建议: cast 只能作为“无奈之举”，更推荐通过类型签名和数据流本身解决问题
      🔧 修复示例:
        - 向上排查数据来源，让类型检查器自然推导出正确类型
        - 为返回值或参数引入更精确的注解或中间模型，减少在调用点 cast 的需求
        - 对于确有必要的 cast，请在附近添加注释说明理由，供团队评审

  BC001:
    template: |
      🏛️ 疆域边界审查官: 检测到边界契约违规
      📌 函数: {func}
      📋 违规参数: {name} -> {type}
      💡 建议: 为跨边界传输的数据定义专门的 DTO/Schema，而不是直接暴露内部结构或基础类型集合
      🔧 快速修复: 使用数据模型库（如 Pydantic / dataclasses）为该参数定义明确的契约类型

  DI001:
    template: |
      🏛️ 依赖倒置审查官: 检测到可疑的跨模块/组件依赖
      📋 违规导入: {imported_module}
      💡 建议: 优先依赖抽象（接口/协议）而非具体实现，必要时通过依赖注入或工厂进行装配
      🔧 快速修复: 为该依赖抽象出接口或协议类型，并在调用方仅依赖该抽象

  DS001:
    template: |
      🏛️ 文档字符串审查官: 检测到函数缺少文档
      📌 函数: {func}
      💡 建议: 为公共或复杂函数添加描述功能、主要参数和返回值的文档字符串
      🔧 快速修复: 添加简洁的 docstring，说明用途、关键参数和返回值含义

  DS002:
    template: |
      🏛️ 文档字符串审查官: 检测到类文档不足
      📌 类: {klass}
      📋 要求: 文档字符串至少 {min_len} 字符
      💡 建议: 描述该类的职责、主要协作对象和典型用法
      🔧 快速修复: 在类定义下方添加三引号文档，给出简短的使用说明

  DT001:
    template: |
      🏛️ 时间法官: 检测到 datetime.now()/utcnow() 直接调用
      💡 建议: 通过可替换的时间来源（如ClockPort时间服务接口或时钟抽象）获取当前时间，以便测试和时区控制
      🔧 快速修复: 将直接调用替换为从注入的“时钟”或配置化时间源获取

  HC001:
    template: |
      🏛️ 硬编码审查官: 检测到疑似业务含义的硬编码字符串或字面量
      📌 代码片段: {snippet}
      💡 建议: 将具有业务含义或易变的字面量迁移到集中管理的常量或配置中
      🔧 快速修复: 提取到常量模块或配置文件，并在代码中引用该常量/配置键

  HC002:
    template: |
      🏛️ 常量规范审查官: 检测到裸常量导入
      📌 常量: {name}
      💡 建议: 使用命名空间（类/模块）组织常量，避免在调用处出现过多分散的符号
      🔧 快速修复: 将常量收拢到合适的命名空间下，通过命名空间前缀引用

  HC003:
    template: |
      🏛️ 常量规范审查官: 检测到零散的裸常量定义
      📌 常量: {name}
      💡 建议: 将常量汇总到集中位置（如 constants 模块），并按领域或用途分组管理
      🔧 快速修复: 将该常量移动到集中常量定义处，并在使用方通过导入该命名空间使用

  HC004:
    template: |
      🏛️ 常量规范审查官: 检测到跨上下文直接引用业务常量
      📋 来源: {source}
      💡 建议: 在需要跨上下文共享时，引入更高层级的“系统常量”或配置项，而不是直接耦合到具体实现常量
      🔧 快速修复: 提升为更抽象层级的常量/配置，并在两侧通过该抽象访问

  HC005:
    template: |
      🏛️ 魔法数值审查官: 检测到可调业务参数以“魔法数值”形式硬编码
      📌 代码片段: {snippet}
      📋 影响: 阈值/权重/窗口大小等参数一旦写死，将难以在不同环境或版本中安全调参
      💡 建议: 将该类参数迁移到集中配置或规则系统中管理，通过注入/读取的方式使用
      🔧 快速修复:
        - 为该参数引入配置项或规则条目，而不是直接写死数值
        - 在代码中优先从配置/规则读取，仅在缺省时回退到合理的默认常量

  LL001:
    template: |
      🏛️ 过度复杂审查官: 检测到函数过长
      📌 函数: {func}
      📋 当前行数: {lines} 行（限制: {limit} 行）
      💡 建议: 拆分为更小、更专注的辅助函数，每个函数只负责一个清晰的子任务
      🔧 快速修复: 识别自然的逻辑片段，提取为私有/内部辅助函数

  LL002:
    template: |
      🏛️ 过度复杂审查官: 检测到函数圈复杂度过高
      📌 函数: {func}
      📋 圈复杂度: {complexity}（限制: {limit}）
      💡 建议: 审查分支和循环结构，简化控制流，必要时引入策略/状态等模式分解逻辑
      🔧 快速修复: 提取条件块到独立函数或对象中，避免在单个函数中聚集过多分支

  OU001:
    template: |
      🏛️ 灰色迷雾审查官: 检测到 object 类型使用
      💡 建议: 为该位置引入更具体的抽象基类、协议或具体类型，避免使用完全不具约束力的 object
      🔧 快速修复: 将注解从 object 替换为更具语义的接口/基类/联合类型

  PC001:
    template: |
      🏛️ 参数分类审查官: 检测到疑似“运营/策略参数”被写死为常量
      📌 常量: {const_name}
      💡 建议: 将易变的运营/策略参数从代码常量中抽离，由配置或规则系统统一管理
      🔧 快速修复: 为该参数增加配置或规则入口，并通过抽象的“参数提供者”在代码中获取

  PC002:
    template: |
      🏛️ 参数分类审查官: 检测到绕过参数/规则提供抽象直接访问底层资产
      📋 违规代码: {snippet}
      💡 建议: 不要直接通过文件路径或硬编码方式访问规则/配置资产，应通过统一的抽象接口加载
      🔧 快速修复: 引入规则/配置提供方抽象，通过标识（ID/Key）访问对应参数

  RE001:
    template: |
      🏛️ 门面纪律法官: 检测到 __init__.py 过长
      📋 当前行数: {code_count} 行（限制: {max_init_lines} 行）
      💡 建议: 保持门面精简，避免在其中堆积实现细节或大量导入逻辑
      🔧 快速修复: 将实现移至具体模块，仅在门面进行必要的导出说明

  RE002:
    template: |
      🏛️ 门面纪律法官: 检测到在 __init__.py 中定义业务逻辑结构
      📋 违规类型: {node_type}
      💡 建议: 将具体实现放在专门模块中，门面只暴露公共 API 或元数据
      🔧 快速修复: 将类/函数/逻辑迁移到独立模块，避免通过门面聚合导出

  RE003:
    template: |
      🏛️ 门面纪律法官: 检测到 __init__.py 中存在不推荐的结构
      📋 详情: {detail}
      💡 建议: 将复杂逻辑从门面中移除，仅保留轻量级导入/别名/说明
      🔧 快速修复: 将实现移至具体模块，避免通过门面聚合导出

  SK001:
    template: |
      🏛️ 技能使用审查官: 检测到直接硬编码的“技能/能力”标识字符串
      📌 Skill ID: {skill_id}
      💡 建议: 为这类标识引入集中定义的常量或配置，而不是在业务代码中散落字符串字面量
      🔧 快速修复: 在集中位置声明标识常量，并通过抽象的“SkillsProvider”或等价机制引用

  SK002:
    template: |
      🏛️ 技能使用审查官: 检测到直接文件访问技能/能力资产
      📋 违规代码: {snippet}
      💡 建议: 避免在业务逻辑中直接操作技能资产文件，优先通过抽象接口或服务访问
      🔧 快速修复: 引入“SkillsProvider”抽象，由该抽象负责定位和加载底层资产

  TC001:
    template: |
      🏛️ 循环依赖审查官: 检测到 TYPE_CHECKING 被用于打补丁式解决循环依赖
      💡 建议: 通过拆分模块、引入中立 DTO/接口模块等方式从根本上消除循环依赖，而不是依赖条件导入
      🔧 快速修复: 将共享类型/接口提升到更稳定的上层（如专门的 types/协议模块），从两侧共同依赖该模块

  TP001:
    template: |
      🏛️ 测试纯净度审查官: 检测到单元测试存在直接 I/O 依赖
      📌 位置: {file}:{line}
      📋 违禁导入: {import_stmt}
      💡 建议: 单元测试应尽量隔离外部系统（文件/网络/数据库等），通过端口或测试替身（fake/mock）间接使用依赖

  TP002:
    template: |
      🏛️ 测试纯净度审查官: 检测到测试代码直接依赖底层持久化或 ORM 实现
      📌 位置: {file}:{line}
      📋 导入语句: {import_stmt}
      💡 建议: 将数据库相关集成测试集中到少数专门的测试模块，其余测试通过仓储接口或领域端口访问持久化层

  TP003:
    template: |
      🏛️ 测试纯净度审查官: 检测到仅做“存在性检查”的伪覆盖测试
      📌 位置: {file}:{line}
      📋 可疑模式: importlib.import_module + hasattr（缺少行为调用）
      💡 建议: 为目标函数/方法编写至少一次真实调用，验证关键行为和边界情况，而不是仅检查符号存在

  UW001:
    template: |
      🏛️ Unit of Work 法官: 检测到与事务边界相关的可疑模式
      📋 违规方法: {method}
      💡 建议: 将事务管理集中在统一的 Unit of Work / 事务边界组件中，避免在工厂或业务对象中隐式控制事务
      🔧 快速修复: 将事务开启/提交的职责移至显式的 UoW 或服务层，由其协调各仓储操作

  UW002:
    template: |
      🏛️ Unit of Work 法官: 检测到仓储内部直接调用 commit()
      💡 建议: 仓储应专注于数据读写，事务提交应由上层 Unit of Work 或服务统一控制
      🔧 快速修复: 移除仓储中的 commit() 调用，由外层事务边界统一提交

  UW003:
    template: |
      🏛️ Unit of Work 法官: 检测到仓储内部直接调用 rollback()
      💡 建议: 仓储不应自行回滚事务，异常处理和回滚应由统一的事务边界负责
      🔧 快速修复: 移除仓储中的 rollback() 调用，由外层统一处理异常与回滚

  UW004:
    template: |
      🏛️ Unit of Work 法官: 检测到绕过统一事务边界直接操作关键资源的行为
      💡 建议: 所有关键业务操作应在同一事务上下文中完成，由显式的 UoW/服务协调各依赖
      🔧 快速修复: 将相关调用收拢到统一的事务/服务层，由该层负责协调仓储与其他外部依赖

  VT001:
    template: |
      🏛️ 向量事务法官: 检测到未支持的 asset_type
      📋 asset_type: {asset_type}
      💡 建议: 在向量/检索提供方实现中为该 asset_type 增加处理逻辑，或在配置中显式声明不支持
      🔧 快速修复: 在项目的向量 provider 或等价组件中补充对应路由或分发分支

  VT002:
    template: |
      🏛️ 向量事务法官: 检测到未支持的 capsule_kind
      📋 capsule_kind: {capsule_kind}
      💡 建议: 在向量/事件提供方实现中为该 capsule_kind 增加处理逻辑，或在配置中显式声明不支持
      🔧 快速修复: 在项目的向量/事件路由模块中补充对应处理分支

  VT003:
    template: |
      🏛️ 向量事务法官: 检测到事件缺少必填字段
      📌 事件: {event_name}
      📋 缺失字段: {field}
      💡 建议: 在事件模型或构造函数中将这些字段标记为必填，避免依赖运行时推断
      🔧 快速修复: 调整事件定义或构造逻辑，确保在创建时显式提供所有关键信息
