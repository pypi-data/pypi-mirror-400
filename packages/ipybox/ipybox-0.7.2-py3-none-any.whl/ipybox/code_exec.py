import asyncio
from contextlib import AsyncExitStack, asynccontextmanager
from dataclasses import dataclass
from pathlib import Path
from typing import AsyncIterator

from ipybox.kernel_mgr.client import ExecutionError, ExecutionResult, KernelClient
from ipybox.kernel_mgr.server import KernelGateway
from ipybox.tool_exec.approval.client import ApprovalClient, ApprovalRequest
from ipybox.tool_exec.client import reset
from ipybox.tool_exec.server import ToolServer
from ipybox.utils import find_free_port


class CodeExecutionError(Exception):
    """Raised when code execution in an IPython kernel fails."""

    pass


@dataclass
class CodeExecutionResult:
    """The result of a successful code execution.

    Attributes:
        text: Output text generated during execution, or `None` if no output.
        images: Paths to images generated during execution.
    """

    text: str | None
    images: list[Path]


@dataclass
class CodeExecutionChunk:
    """A chunk of output text generated during streaming code execution.

    Only yielded by [`CodeExecutor.stream`][ipybox.code_exec.CodeExecutor.stream]
    when `chunks=True`.

    Attributes:
        text: A chunk of output text.
    """

    text: str


class CodeExecutor:
    """Executes Python code in an IPython kernel with programmatic MCP tool call support.

    `CodeExecutor` launches an embedded
    [`KernelGateway`][ipybox.kernel_mgr.server.KernelGateway] for running Python
    code and an embedded [`ToolServer`][ipybox.tool_exec.server.ToolServer] for
    executing MCP tools. Code is executed in an IPython kernel, providing a
    stateful environment where variables and definitions persist across executions.

    MCP tools can be called from executed code using the API generated by
    [`generate_mcp_sources`][ipybox.mcp_apigen.generate_mcp_sources]. When code calls
    an MCP tool, the tool server receives the request and emits an approval request.
    The client must accept or reject the request before the tool executes.

    Example:
        Generate a Python tool API and execute code that uses it:

        ```python
        from pathlib import Path

        from ipybox import ApprovalRequest, CodeExecutionResult, CodeExecutor
        from ipybox import generate_mcp_sources

        # Generate a Python tool API for the fetch MCP server
        server_params = {"command": "uvx", "args": ["mcp-server-fetch"]}
        await generate_mcp_sources("fetch", server_params, Path("mcptools"))

        # Execute code that calls the generated API
        code = \"\"\"
        from mcptools.fetch import fetch

        result = fetch.run(fetch.Params(url="https://example.com"))
        print(result)
        \"\"\"

        async with CodeExecutor() as executor:
            async for item in executor.stream(code):
                match item:
                    case ApprovalRequest():
                        print(f"Tool call: {item}")
                        await item.accept()
                    case CodeExecutionResult():
                        print(item.text)
        ```
    """

    def __init__(
        self,
        tool_server_host: str = "localhost",
        tool_server_port: int | None = None,
        kernel_gateway_host: str = "localhost",
        kernel_gateway_port: int | None = None,
        kernel_env: dict[str, str] | None = None,
        images_dir: Path | None = None,
        approval_timeout: float | None = None,
        connect_timeout: float = 30,
        sandbox: bool = False,
        sandbox_config: Path | None = None,
        log_level: str = "WARNING",
    ):
        """Configure a code executor with optional sandboxing.

        Args:
            tool_server_host: Hostname for the
                [`ToolServer`][ipybox.tool_exec.server.ToolServer].
            tool_server_port: Port for the tool server. If `None`, a free port
                is selected automatically.
            kernel_gateway_host: Hostname for the
                [`KernelGateway`][ipybox.kernel_mgr.server.KernelGateway].
            kernel_gateway_port: Port for the kernel gateway. If `None`, a free
                port is selected automatically.
            kernel_env: Environment variables to set for the IPython kernel.
                Kernels do not inherit environment variables from the parent
                process.
            images_dir: Directory for saving images generated during code
                execution. Defaults to `images` in the current directory.
            approval_timeout: Timeout in seconds for approval requests. If an
                approval request is not accepted or rejected within this time,
                the tool call fails. If `None`, no timeout is applied.
            connect_timeout: Timeout in seconds for starting MCP servers.
            sandbox: Whether to run the kernel gateway inside Anthropic's
                [sandbox-runtime](https://github.com/anthropic-experimental/sandbox-runtime).
                When enabled, IPython kernels run in a secure sandbox with no
                network access except to the local tool server.
            sandbox_config: Path to a JSON file with sandbox configuration.
                See the Configuration section of the
                [sandbox-runtime](https://github.com/anthropic-experimental/sandbox-runtime)
                README for available options.
            log_level: Logging level (DEBUG, INFO, WARNING, ERROR, CRITICAL).
        """
        self.tool_server_host = tool_server_host
        self.tool_server_port = tool_server_port or find_free_port()

        self.kernel_gateway_host = kernel_gateway_host
        self.kernel_gateway_port = kernel_gateway_port or find_free_port()
        self.kernel_env = kernel_env or {}
        self.images_dir = images_dir

        self.approval_timeout = approval_timeout
        self.connect_timeout = connect_timeout

        self.sandbox = sandbox
        self.sandbox_config = sandbox_config
        self.log_level = log_level

        self._exit_stack = AsyncExitStack()
        self._client: KernelClient

    async def __aenter__(self):
        await self.start()
        return self

    async def __aexit__(self, exc_type, exc_value, traceback):
        await self.stop()

    async def start(self):
        """Start the executor.

        Starts the tool server, kernel gateway, and connects to the IPython kernel.
        """
        self._client = await self._exit_stack.enter_async_context(self._executor())

    async def stop(self):
        """Stop the executor.

        Stops the tool server, kernel gateway, and disconnects from the IPython
        kernel.
        """
        await self._exit_stack.aclose()

    async def reset(self):
        """Reset execution state.

        Restarts the IPython kernel and stops all started MCP servers. Kernel state
        (variables, definitions, imports) is lost. MCP servers are lazily restarted
        on their next tool call.
        """
        await reset(
            host=self.tool_server_host,
            port=self.tool_server_port,
        )
        await self._client.reset()

    async def stream(
        self, code: str, timeout: float | None = None, chunks: bool = False
    ) -> AsyncIterator[ApprovalRequest | CodeExecutionChunk | CodeExecutionResult]:
        """Execute Python code in the IPython kernel with MCP tool call approval.

        Code can call MCP tools using the API generated by
        [`generate_mcp_sources`][ipybox.mcp_apigen.generate_mcp_sources]. Each
        tool call yields an
        [`ApprovalRequest`][ipybox.tool_exec.approval.client.ApprovalRequest].
        If accepted, the tool executes on the
        [`ToolServer`][ipybox.tool_exec.server.ToolServer] and returns the
        result to the kernel. If rejected, the tool call fails with an error.

        Args:
            code: Python code to execute.
            timeout: Maximum time in seconds to wait for execution to complete.
                If `None`, no timeout is applied.
            chunks: Whether to yield
                [`CodeExecutionChunk`][ipybox.code_exec.CodeExecutionChunk] objects
                during execution. When `False`, only
                [`ApprovalRequest`][ipybox.tool_exec.approval.client.ApprovalRequest]
                and [`CodeExecutionResult`][ipybox.code_exec.CodeExecutionResult]
                are yielded.

        Yields:
            [`ApprovalRequest`][ipybox.tool_exec.approval.client.ApprovalRequest]:
                When executed code calls an MCP tool. Accept to execute the tool,
                reject to fail the tool call.
            [`CodeExecutionChunk`][ipybox.code_exec.CodeExecutionChunk]: Output text
                chunks generated during execution (emitted only if `chunks=True`).
            [`CodeExecutionResult`][ipybox.code_exec.CodeExecutionResult]: The final
                result when execution completes successfully.

        Raises:
            CodeExecutionError: If code execution raises an error (syntax errors,
                runtime errors, rejected or timed-out approval requests, MCP tool
                errors). The error message contains the stack trace from the kernel.
            asyncio.TimeoutError: If code execution exceeds the timeout.
        """
        queue: asyncio.Queue[ApprovalRequest | str | ExecutionResult | Exception] = asyncio.Queue()

        async def stream_execution():
            try:
                async for item in self._client.stream(code, timeout=timeout):
                    await queue.put(item)
            except Exception as e:
                await queue.put(e)

        async with ApprovalClient(
            callback=queue.put,
            host=self.tool_server_host,
            port=self.tool_server_port,
        ):
            task = asyncio.create_task(stream_execution())
            try:
                while True:
                    item = await queue.get()
                    match item:
                        case ApprovalRequest():
                            yield item
                        case str() if chunks:
                            yield CodeExecutionChunk(text=item)
                        case ExecutionError():
                            raise CodeExecutionError(item.args[0])
                        case Exception():
                            raise item
                        case ExecutionResult():
                            yield CodeExecutionResult(text=item.text, images=item.images)
                            break
            finally:
                await task

    async def execute(self, code: str, timeout: float | None = None) -> CodeExecutionResult:
        """Execute Python code with automatic approval of all MCP tool calls.

        Convenience method that [executes][ipybox.code_exec.CodeExecutor.stream]
        code, auto-approves any MCP tool calls, and returns the final result
        directly.

        Args:
            code: Python code to execute.
            timeout: Maximum time in seconds to wait for execution to complete.
                If `None`, no timeout is applied.

        Returns:
            The execution result containing output text and generated images.

        Raises:
            CodeExecutionError: If code execution raises an error.
            asyncio.TimeoutError: If code execution exceeds the timeout.
        """
        async for item in self.stream(code, timeout=timeout, chunks=False):
            match item:
                case ApprovalRequest():
                    await item.accept()
                case CodeExecutionResult():
                    return item

        raise RuntimeError("Code execution completed without result")

    @asynccontextmanager
    async def _executor(self) -> AsyncIterator[KernelClient]:
        async with ToolServer(
            host=self.tool_server_host,
            port=self.tool_server_port,
            approval_required=True,
            approval_timeout=self.approval_timeout,
            connect_timeout=self.connect_timeout,
            log_level=self.log_level,
        ):
            async with KernelGateway(
                host=self.kernel_gateway_host,
                port=self.kernel_gateway_port,
                sandbox=self.sandbox,
                sandbox_config=self.sandbox_config,
                log_level=self.log_level,
                env=self.kernel_env
                | {
                    "TOOL_SERVER_HOST": self.tool_server_host,
                    "TOOL_SERVER_PORT": str(self.tool_server_port),
                },
            ):
                async with KernelClient(
                    host=self.kernel_gateway_host,
                    port=self.kernel_gateway_port,
                    images_dir=self.images_dir,
                ) as client:
                    yield client
