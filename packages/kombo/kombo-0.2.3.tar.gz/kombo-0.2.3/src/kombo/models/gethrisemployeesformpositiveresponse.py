"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .schema1_union_1 import Schema1Union1, Schema1Union1TypedDict
from .schema2_union_2 import Schema2Union2, Schema2Union2TypedDict
from kombo.types import BaseModel, Nullable, OptionalNullable, UNSET, UNSET_SENTINEL
from kombo.utils import validate_const
import pydantic
from pydantic import Field, model_serializer
from pydantic.functional_validators import AfterValidator
from typing import Dict, List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


GetHrisEmployeesFormPositiveResponseUnifiedKey8 = Literal[
    "first_name",
    "last_name",
    "date_of_birth",
    "gender",
    "home_address.city",
    "home_address.country",
    "home_address.state",
    "home_address.street_1",
    "home_address.street_2",
    "home_address.zip_code",
    "job_title",
    "legal_entity_id",
    "location_id",
    "mobile_phone_number",
    "home_phone_number",
    "nationality",
    "start_date",
    "work_email",
    "private_email",
    "yearly_salary",
]


class GetHrisEmployeesFormPositiveResponseFileRestrictionsTypedDict(TypedDict):
    accepted_mime_types: List[str]
    max_file_size: NotRequired[Nullable[float]]


class GetHrisEmployeesFormPositiveResponseFileRestrictions(BaseModel):
    accepted_mime_types: List[str]

    max_file_size: OptionalNullable[float] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["max_file_size"]
        nullable_fields = ["max_file_size"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class PropertiesFileTypedDict(TypedDict):
    label: str
    required: bool
    file_restrictions: GetHrisEmployeesFormPositiveResponseFileRestrictionsTypedDict
    description: NotRequired[Nullable[str]]
    unified_key: NotRequired[Nullable[GetHrisEmployeesFormPositiveResponseUnifiedKey8]]
    type: Literal["file"]


class PropertiesFile(BaseModel):
    label: str

    required: bool

    file_restrictions: GetHrisEmployeesFormPositiveResponseFileRestrictions

    description: OptionalNullable[str] = UNSET

    unified_key: OptionalNullable[GetHrisEmployeesFormPositiveResponseUnifiedKey8] = (
        UNSET
    )

    TYPE: Annotated[
        Annotated[Literal["file"], AfterValidator(validate_const("file"))],
        pydantic.Field(alias="type"),
    ] = "file"

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["description", "unified_key"]
        nullable_fields = ["description", "unified_key"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


GetHrisEmployeesFormPositiveResponseUnifiedKey7 = Literal[
    "first_name",
    "last_name",
    "date_of_birth",
    "gender",
    "home_address.city",
    "home_address.country",
    "home_address.state",
    "home_address.street_1",
    "home_address.street_2",
    "home_address.zip_code",
    "job_title",
    "legal_entity_id",
    "location_id",
    "mobile_phone_number",
    "home_phone_number",
    "nationality",
    "start_date",
    "work_email",
    "private_email",
    "yearly_salary",
]


class PropertiesArrayTypedDict(TypedDict):
    label: str
    required: bool
    item_type: Schema2Union2TypedDict
    description: NotRequired[Nullable[str]]
    unified_key: NotRequired[Nullable[GetHrisEmployeesFormPositiveResponseUnifiedKey7]]
    type: Literal["array"]
    min_items: NotRequired[Nullable[float]]
    max_items: NotRequired[Nullable[float]]


class PropertiesArray(BaseModel):
    label: str

    required: bool

    item_type: Schema2Union2

    description: OptionalNullable[str] = UNSET

    unified_key: OptionalNullable[GetHrisEmployeesFormPositiveResponseUnifiedKey7] = (
        UNSET
    )

    TYPE: Annotated[
        Annotated[Literal["array"], AfterValidator(validate_const("array"))],
        pydantic.Field(alias="type"),
    ] = "array"

    min_items: OptionalNullable[float] = UNSET

    max_items: OptionalNullable[float] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["description", "unified_key", "min_items", "max_items"]
        nullable_fields = ["description", "unified_key", "min_items", "max_items"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


GetHrisEmployeesFormPositiveResponseUnifiedKey6 = Literal[
    "first_name",
    "last_name",
    "date_of_birth",
    "gender",
    "home_address.city",
    "home_address.country",
    "home_address.state",
    "home_address.street_1",
    "home_address.street_2",
    "home_address.zip_code",
    "job_title",
    "legal_entity_id",
    "location_id",
    "mobile_phone_number",
    "home_phone_number",
    "nationality",
    "start_date",
    "work_email",
    "private_email",
    "yearly_salary",
]


class PropertiesObjectTypedDict(TypedDict):
    label: str
    required: bool
    properties: Dict[str, Schema1Union1TypedDict]
    description: NotRequired[Nullable[str]]
    unified_key: NotRequired[Nullable[GetHrisEmployeesFormPositiveResponseUnifiedKey6]]
    type: Literal["object"]


class PropertiesObject(BaseModel):
    label: str

    required: bool

    properties: Dict[str, Schema1Union1]

    description: OptionalNullable[str] = UNSET

    unified_key: OptionalNullable[GetHrisEmployeesFormPositiveResponseUnifiedKey6] = (
        UNSET
    )

    TYPE: Annotated[
        Annotated[Literal["object"], AfterValidator(validate_const("object"))],
        pydantic.Field(alias="type"),
    ] = "object"

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["description", "unified_key"]
        nullable_fields = ["description", "unified_key"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


GetHrisEmployeesFormPositiveResponseUnifiedKey5 = Literal[
    "first_name",
    "last_name",
    "date_of_birth",
    "gender",
    "home_address.city",
    "home_address.country",
    "home_address.state",
    "home_address.street_1",
    "home_address.street_2",
    "home_address.zip_code",
    "job_title",
    "legal_entity_id",
    "location_id",
    "mobile_phone_number",
    "home_phone_number",
    "nationality",
    "start_date",
    "work_email",
    "private_email",
    "yearly_salary",
]


class PropertiesCheckboxTypedDict(TypedDict):
    label: str
    required: bool
    description: NotRequired[Nullable[str]]
    unified_key: NotRequired[Nullable[GetHrisEmployeesFormPositiveResponseUnifiedKey5]]
    type: Literal["checkbox"]


class PropertiesCheckbox(BaseModel):
    label: str

    required: bool

    description: OptionalNullable[str] = UNSET

    unified_key: OptionalNullable[GetHrisEmployeesFormPositiveResponseUnifiedKey5] = (
        UNSET
    )

    TYPE: Annotated[
        Annotated[Literal["checkbox"], AfterValidator(validate_const("checkbox"))],
        pydantic.Field(alias="type"),
    ] = "checkbox"

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["description", "unified_key"]
        nullable_fields = ["description", "unified_key"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetHrisEmployeesFormPositiveResponseOptionsReferenced2TypedDict(TypedDict):
    link: str
    type: Literal["referenced"]


class GetHrisEmployeesFormPositiveResponseOptionsReferenced2(BaseModel):
    link: str

    TYPE: Annotated[
        Annotated[Literal["referenced"], AfterValidator(validate_const("referenced"))],
        pydantic.Field(alias="type"),
    ] = "referenced"


GetHrisEmployeesFormPositiveResponseRemoteID2TypedDict = TypeAliasType(
    "GetHrisEmployeesFormPositiveResponseRemoteID2TypedDict", Union[str, float]
)


GetHrisEmployeesFormPositiveResponseRemoteID2 = TypeAliasType(
    "GetHrisEmployeesFormPositiveResponseRemoteID2", Union[str, float]
)


class GetHrisEmployeesFormPositiveResponseEntry2TypedDict(TypedDict):
    id: str
    label: str
    remote_id: GetHrisEmployeesFormPositiveResponseRemoteID2TypedDict
    unified_value: NotRequired[str]


class GetHrisEmployeesFormPositiveResponseEntry2(BaseModel):
    id: str

    label: str

    remote_id: GetHrisEmployeesFormPositiveResponseRemoteID2

    unified_value: Optional[str] = None


class GetHrisEmployeesFormPositiveResponseOptionsInline2TypedDict(TypedDict):
    entries: List[GetHrisEmployeesFormPositiveResponseEntry2TypedDict]
    type: Literal["inline"]


class GetHrisEmployeesFormPositiveResponseOptionsInline2(BaseModel):
    entries: List[GetHrisEmployeesFormPositiveResponseEntry2]

    TYPE: Annotated[
        Annotated[Literal["inline"], AfterValidator(validate_const("inline"))],
        pydantic.Field(alias="type"),
    ] = "inline"


GetHrisEmployeesFormPositiveResponseOptionsUnion2TypedDict = TypeAliasType(
    "GetHrisEmployeesFormPositiveResponseOptionsUnion2TypedDict",
    Union[
        GetHrisEmployeesFormPositiveResponseOptionsInline2TypedDict,
        GetHrisEmployeesFormPositiveResponseOptionsReferenced2TypedDict,
    ],
)


GetHrisEmployeesFormPositiveResponseOptionsUnion2 = Annotated[
    Union[
        GetHrisEmployeesFormPositiveResponseOptionsInline2,
        GetHrisEmployeesFormPositiveResponseOptionsReferenced2,
    ],
    Field(discriminator="TYPE"),
]


class PropertiesMultiSelectTypedDict(TypedDict):
    label: str
    required: bool
    options: GetHrisEmployeesFormPositiveResponseOptionsUnion2TypedDict
    description: NotRequired[Nullable[str]]
    unified_key: NotRequired[Nullable[str]]
    type: Literal["multi_select"]
    min_items: NotRequired[Nullable[float]]
    max_items: NotRequired[Nullable[float]]


class PropertiesMultiSelect(BaseModel):
    label: str

    required: bool

    options: GetHrisEmployeesFormPositiveResponseOptionsUnion2

    description: OptionalNullable[str] = UNSET

    unified_key: OptionalNullable[str] = UNSET

    TYPE: Annotated[
        Annotated[
            Literal["multi_select"], AfterValidator(validate_const("multi_select"))
        ],
        pydantic.Field(alias="type"),
    ] = "multi_select"

    min_items: OptionalNullable[float] = UNSET

    max_items: OptionalNullable[float] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["description", "unified_key", "min_items", "max_items"]
        nullable_fields = ["description", "unified_key", "min_items", "max_items"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


GetHrisEmployeesFormPositiveResponseUnifiedKey4 = Literal[
    "first_name",
    "last_name",
    "date_of_birth",
    "gender",
    "home_address.city",
    "home_address.country",
    "home_address.state",
    "home_address.street_1",
    "home_address.street_2",
    "home_address.zip_code",
    "job_title",
    "legal_entity_id",
    "location_id",
    "mobile_phone_number",
    "home_phone_number",
    "nationality",
    "start_date",
    "work_email",
    "private_email",
    "yearly_salary",
]


class GetHrisEmployeesFormPositiveResponseOptionsReferenced1TypedDict(TypedDict):
    link: str
    type: Literal["referenced"]


class GetHrisEmployeesFormPositiveResponseOptionsReferenced1(BaseModel):
    link: str

    TYPE: Annotated[
        Annotated[Literal["referenced"], AfterValidator(validate_const("referenced"))],
        pydantic.Field(alias="type"),
    ] = "referenced"


GetHrisEmployeesFormPositiveResponseRemoteID1TypedDict = TypeAliasType(
    "GetHrisEmployeesFormPositiveResponseRemoteID1TypedDict", Union[str, float]
)


GetHrisEmployeesFormPositiveResponseRemoteID1 = TypeAliasType(
    "GetHrisEmployeesFormPositiveResponseRemoteID1", Union[str, float]
)


class GetHrisEmployeesFormPositiveResponseEntry1TypedDict(TypedDict):
    id: str
    label: str
    remote_id: GetHrisEmployeesFormPositiveResponseRemoteID1TypedDict
    unified_value: NotRequired[str]


class GetHrisEmployeesFormPositiveResponseEntry1(BaseModel):
    id: str

    label: str

    remote_id: GetHrisEmployeesFormPositiveResponseRemoteID1

    unified_value: Optional[str] = None


class GetHrisEmployeesFormPositiveResponseOptionsInline1TypedDict(TypedDict):
    entries: List[GetHrisEmployeesFormPositiveResponseEntry1TypedDict]
    type: Literal["inline"]


class GetHrisEmployeesFormPositiveResponseOptionsInline1(BaseModel):
    entries: List[GetHrisEmployeesFormPositiveResponseEntry1]

    TYPE: Annotated[
        Annotated[Literal["inline"], AfterValidator(validate_const("inline"))],
        pydantic.Field(alias="type"),
    ] = "inline"


GetHrisEmployeesFormPositiveResponseOptionsUnion1TypedDict = TypeAliasType(
    "GetHrisEmployeesFormPositiveResponseOptionsUnion1TypedDict",
    Union[
        GetHrisEmployeesFormPositiveResponseOptionsInline1TypedDict,
        GetHrisEmployeesFormPositiveResponseOptionsReferenced1TypedDict,
    ],
)


GetHrisEmployeesFormPositiveResponseOptionsUnion1 = Annotated[
    Union[
        GetHrisEmployeesFormPositiveResponseOptionsInline1,
        GetHrisEmployeesFormPositiveResponseOptionsReferenced1,
    ],
    Field(discriminator="TYPE"),
]


class PropertiesSingleSelectTypedDict(TypedDict):
    label: str
    required: bool
    options: GetHrisEmployeesFormPositiveResponseOptionsUnion1TypedDict
    description: NotRequired[Nullable[str]]
    unified_key: NotRequired[Nullable[GetHrisEmployeesFormPositiveResponseUnifiedKey4]]
    type: Literal["single_select"]


class PropertiesSingleSelect(BaseModel):
    label: str

    required: bool

    options: GetHrisEmployeesFormPositiveResponseOptionsUnion1

    description: OptionalNullable[str] = UNSET

    unified_key: OptionalNullable[GetHrisEmployeesFormPositiveResponseUnifiedKey4] = (
        UNSET
    )

    TYPE: Annotated[
        Annotated[
            Literal["single_select"], AfterValidator(validate_const("single_select"))
        ],
        pydantic.Field(alias="type"),
    ] = "single_select"

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["description", "unified_key"]
        nullable_fields = ["description", "unified_key"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


GetHrisEmployeesFormPositiveResponseUnifiedKey3 = Literal[
    "first_name",
    "last_name",
    "date_of_birth",
    "gender",
    "home_address.city",
    "home_address.country",
    "home_address.state",
    "home_address.street_1",
    "home_address.street_2",
    "home_address.zip_code",
    "job_title",
    "legal_entity_id",
    "location_id",
    "mobile_phone_number",
    "home_phone_number",
    "nationality",
    "start_date",
    "work_email",
    "private_email",
    "yearly_salary",
]


class PropertiesDateTypedDict(TypedDict):
    label: str
    required: bool
    description: NotRequired[Nullable[str]]
    unified_key: NotRequired[Nullable[GetHrisEmployeesFormPositiveResponseUnifiedKey3]]
    type: Literal["date"]


class PropertiesDate(BaseModel):
    label: str

    required: bool

    description: OptionalNullable[str] = UNSET

    unified_key: OptionalNullable[GetHrisEmployeesFormPositiveResponseUnifiedKey3] = (
        UNSET
    )

    TYPE: Annotated[
        Annotated[Literal["date"], AfterValidator(validate_const("date"))],
        pydantic.Field(alias="type"),
    ] = "date"

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["description", "unified_key"]
        nullable_fields = ["description", "unified_key"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


GetHrisEmployeesFormPositiveResponseUnifiedKey2 = Literal[
    "first_name",
    "last_name",
    "date_of_birth",
    "gender",
    "home_address.city",
    "home_address.country",
    "home_address.state",
    "home_address.street_1",
    "home_address.street_2",
    "home_address.zip_code",
    "job_title",
    "legal_entity_id",
    "location_id",
    "mobile_phone_number",
    "home_phone_number",
    "nationality",
    "start_date",
    "work_email",
    "private_email",
    "yearly_salary",
]


class PropertiesNumberTypedDict(TypedDict):
    label: str
    required: bool
    description: NotRequired[Nullable[str]]
    unified_key: NotRequired[Nullable[GetHrisEmployeesFormPositiveResponseUnifiedKey2]]
    type: Literal["number"]
    min: NotRequired[Nullable[float]]
    max: NotRequired[Nullable[float]]


class PropertiesNumber(BaseModel):
    label: str

    required: bool

    description: OptionalNullable[str] = UNSET

    unified_key: OptionalNullable[GetHrisEmployeesFormPositiveResponseUnifiedKey2] = (
        UNSET
    )

    TYPE: Annotated[
        Annotated[Literal["number"], AfterValidator(validate_const("number"))],
        pydantic.Field(alias="type"),
    ] = "number"

    min: OptionalNullable[float] = UNSET

    max: OptionalNullable[float] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["description", "unified_key", "min", "max"]
        nullable_fields = ["description", "unified_key", "min", "max"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


GetHrisEmployeesFormPositiveResponseUnifiedKey1 = Literal[
    "first_name",
    "last_name",
    "date_of_birth",
    "gender",
    "home_address.city",
    "home_address.country",
    "home_address.state",
    "home_address.street_1",
    "home_address.street_2",
    "home_address.zip_code",
    "job_title",
    "legal_entity_id",
    "location_id",
    "mobile_phone_number",
    "home_phone_number",
    "nationality",
    "start_date",
    "work_email",
    "private_email",
    "yearly_salary",
]


class PropertiesTextTypedDict(TypedDict):
    label: str
    required: bool
    description: NotRequired[Nullable[str]]
    unified_key: NotRequired[Nullable[GetHrisEmployeesFormPositiveResponseUnifiedKey1]]
    type: Literal["text"]
    min_length: NotRequired[Nullable[float]]
    max_length: NotRequired[Nullable[float]]
    reg_exp: NotRequired[Nullable[str]]


class PropertiesText(BaseModel):
    label: str

    required: bool

    description: OptionalNullable[str] = UNSET

    unified_key: OptionalNullable[GetHrisEmployeesFormPositiveResponseUnifiedKey1] = (
        UNSET
    )

    TYPE: Annotated[
        Annotated[Literal["text"], AfterValidator(validate_const("text"))],
        pydantic.Field(alias="type"),
    ] = "text"

    min_length: OptionalNullable[float] = UNSET

    max_length: OptionalNullable[float] = UNSET

    reg_exp: OptionalNullable[str] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "description",
            "unified_key",
            "min_length",
            "max_length",
            "reg_exp",
        ]
        nullable_fields = [
            "description",
            "unified_key",
            "min_length",
            "max_length",
            "reg_exp",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


PropertiesTypedDict = TypeAliasType(
    "PropertiesTypedDict",
    Union[
        PropertiesDateTypedDict,
        PropertiesCheckboxTypedDict,
        PropertiesSingleSelectTypedDict,
        PropertiesObjectTypedDict,
        PropertiesFileTypedDict,
        PropertiesNumberTypedDict,
        PropertiesTextTypedDict,
        PropertiesMultiSelectTypedDict,
        PropertiesArrayTypedDict,
    ],
)


Properties = Annotated[
    Union[
        PropertiesText,
        PropertiesNumber,
        PropertiesDate,
        PropertiesSingleSelect,
        PropertiesMultiSelect,
        PropertiesCheckbox,
        PropertiesObject,
        PropertiesArray,
        PropertiesFile,
    ],
    Field(discriminator="TYPE"),
]


class GetHrisEmployeesFormPositiveResponseDataTypedDict(TypedDict):
    properties: Dict[str, PropertiesTypedDict]


class GetHrisEmployeesFormPositiveResponseData(BaseModel):
    properties: Dict[str, Properties]


class GetHrisEmployeesFormPositiveResponseWarningTypedDict(TypedDict):
    message: str


class GetHrisEmployeesFormPositiveResponseWarning(BaseModel):
    message: str


class GetHrisEmployeesFormPositiveResponseTypedDict(TypedDict):
    data: GetHrisEmployeesFormPositiveResponseDataTypedDict
    warnings: List[GetHrisEmployeesFormPositiveResponseWarningTypedDict]
    r"""These are the interaction warnings that are shown in the dashboard. They are meant to provide debug information to you. We recommend logging them to the console."""
    status: Literal["success"]


class GetHrisEmployeesFormPositiveResponse(BaseModel):
    data: GetHrisEmployeesFormPositiveResponseData

    warnings: List[GetHrisEmployeesFormPositiveResponseWarning]
    r"""These are the interaction warnings that are shown in the dashboard. They are meant to provide debug information to you. We recommend logging them to the console."""

    STATUS: Annotated[
        Annotated[Literal["success"], AfterValidator(validate_const("success"))],
        pydantic.Field(alias="status"),
    ] = "success"
