import os
import numpy as np

from .formats import naming
from .formats import vol_reader, vtm_reader


class Snapshot:
    """Used to access information generated by ELA at the snapshot :math:`n`"""

    def __init__(self, time: float, count: int, n: int, folder: str):
        self.time = time
        """Time of the snapshot, :math:`t^n`"""

        self.count = count
        """Number of blobs present, :math:`M^n`"""

        self._volume_vector_path = os.path.join(folder, naming.volume_vector_filename(n))
        r"""Filepath to the volume vector :math:`\vec{v}^{n}`"""

        self._vtm_path = os.path.join(folder, naming.vtm_filename(n))
        r"""Filepath to the volume tracking matrix :math:`\boldsymbol{Q}^{(n-1\, \rightarrow \,n)}`"""

    def get_volume_vector(self) -> vol_reader.np.ndarray:
        r"""Get the volume vector :math:`\vec{v}^{n}`"""
        return vol_reader.read_vol(self._volume_vector_path).to_numpy()

    def get_vtm(self, previous_count) -> vtm_reader.csr_matrix:
        r"""Get the volume tracking matrix :math:`\boldsymbol{Q}^{(n-1\, \rightarrow \,n)}`

        :param previous_count: Number of blobs present at the previous snapshot, :math:`M^{n-1}`
        """
        return vtm_reader.read_vtm(self._vtm_path).to_csr(previous_count)


class Interval:
    r"""Used to access tracking information over the interval :math:`[t^n, t^{n+1}]`"""

    def __init__(self, start_snapshot: Snapshot, end_snapshot: Snapshot):
        r"""
        Create an Interval

        :param start_snapshot: Snapshot at :math:`t = t^n`
        :param end_snapshot: Snapshot at :math:`t = t^{n+1}`
        """
        self.start = start_snapshot
        self.end = end_snapshot

    def start_time(self) -> float:
        r"""Get the time at the start of the interval, :math:`t^n`"""
        return self.start.time

    def end_time(self) -> float:
        r"""Get the time at the end of the interval, :math:`t^{n+1}`"""
        return self.end.time

    def get_dt(self) -> float:
        r"""Get the duration of the interval, :math:`\Delta t = t^{n+1} - t^n`"""
        return self.end_time() - self.start_time()

    def get_start_volume_vector(self) -> np.ndarray:
        r"""Get the volume vector at the start of this interval, :math:`\vec{v}^{n}`"""
        return self.start.get_volume_vector()

    def get_end_volume_vector(self) -> np.ndarray:
        r"""Get the volume vector at the end of this interval, :math:`\vec{v}^{n+1}`"""
        return self.end.get_volume_vector()

    def get_vtm(self, normalize=False):
        r"""
        Get the volume tracking matrix (VTM) covering this interval.

        - If not `normalize`, returns :math:`\boldsymbol{Q}^{(n\, \rightarrow \,n+1)}`
        - If `normalize`, returns :math:`\boldsymbol{A}^{(n\, \rightarrow \,n+1)}`
        """

        Q = self.end.get_vtm(previous_count=self.start.count)

        if normalize:
            v = self.get_start_volume_vector()
            return Q.multiply(np.reciprocal(v))

        return Q
