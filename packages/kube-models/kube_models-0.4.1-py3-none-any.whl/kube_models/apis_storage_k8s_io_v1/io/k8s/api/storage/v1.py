# generated by https://github.com/puzl-cloud/kubesdk
#   filename:  apis__storage.k8s.io__v1_openapi.json

from __future__ import annotations

from dataclasses import dataclass, field
from datetime import datetime, timezone
from typing import ClassVar, Dict, List, Set

from kube_models.const import *
from kube_models.loader import *
from kube_models.loader import Loadable
from kube_models.resource import *

from ...apimachinery.pkg.api.resource import Quantity
from ...apimachinery.pkg.apis.meta.v1 import LabelSelector, ListMeta, ObjectMeta, Time
from ..core.v1 import PersistentVolumeSpec, TopologySelectorTerm


@dataclass(slots=True, kw_only=True, frozen=True)
class TokenRequest(Loadable):
    audience: str
    expirationSeconds: int | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class VolumeNodeResources(Loadable):
    count: int | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class CSIDriverSpec(Loadable):
    attachRequired: bool | None = None
    fsGroupPolicy: str | None = None
    nodeAllocatableUpdatePeriodSeconds: int | None = None
    podInfoOnMount: bool | None = None
    requiresRepublish: bool | None = None
    seLinuxMount: bool | None = None
    serviceAccountTokenInSecrets: bool | None = None
    storageCapacity: bool | None = None
    tokenRequests: List[TokenRequest] | None = None
    volumeLifecycleModes: List[str] | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class CSINodeDriver(Loadable):
    name: str
    nodeID: str
    allocatable: VolumeNodeResources | None = None
    topologyKeys: List[str] | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class CSINodeSpec(Loadable):
    drivers: List[CSINodeDriver] = field(
        metadata={
            'x-kubernetes-patch-strategy': 'merge',
            'x-kubernetes-patch-merge-key': 'name',
        }
    )


@dataclass(slots=True, kw_only=True, frozen=True)
class VolumeError(Loadable):
    errorCode: int | None = None
    message: str | None = None
    time: Time | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class CSIDriver(K8sResource):
    spec: CSIDriverSpec
    apiVersion: ClassVar[str] = 'storage.k8s.io/v1'
    kind: ClassVar[str] = 'CSIDriver'
    metadata: ObjectMeta = field(default_factory=ObjectMeta)
    plural_: ClassVar[str] = 'csidrivers'
    is_namespaced_: ClassVar[bool] = False
    group_: ClassVar[Optional[str]] = 'storage.k8s.io'
    patch_strategies_: ClassVar[set[PatchRequestType]] = {
        'application/apply-patch+cbor',
        'application/apply-patch+yaml',
        'application/json-patch+json',
        'application/merge-patch+json',
        'application/strategic-merge-patch+json',
    }


@dataclass(slots=True, kw_only=True, frozen=True)
class CSIDriverList(Loadable):
    items: List[CSIDriver]
    apiVersion: str = 'storage.k8s.io/v1'
    kind: str = 'CSIDriverList'
    metadata: ListMeta = field(default_factory=ObjectMeta)


@dataclass(slots=True, kw_only=True, frozen=True)
class CSINode(K8sResource):
    spec: CSINodeSpec
    apiVersion: ClassVar[str] = 'storage.k8s.io/v1'
    kind: ClassVar[str] = 'CSINode'
    metadata: ObjectMeta = field(default_factory=ObjectMeta)
    plural_: ClassVar[str] = 'csinodes'
    is_namespaced_: ClassVar[bool] = False
    group_: ClassVar[Optional[str]] = 'storage.k8s.io'
    patch_strategies_: ClassVar[set[PatchRequestType]] = {
        'application/apply-patch+cbor',
        'application/apply-patch+yaml',
        'application/json-patch+json',
        'application/merge-patch+json',
        'application/strategic-merge-patch+json',
    }


@dataclass(slots=True, kw_only=True, frozen=True)
class CSINodeList(Loadable):
    items: List[CSINode]
    apiVersion: str = 'storage.k8s.io/v1'
    kind: str = 'CSINodeList'
    metadata: ListMeta = field(default_factory=ObjectMeta)


@dataclass(slots=True, kw_only=True, frozen=True)
class CSIStorageCapacity(K8sResource):
    storageClassName: str
    apiVersion: ClassVar[str] = 'storage.k8s.io/v1'
    capacity: Quantity | None = None
    kind: ClassVar[str] = 'CSIStorageCapacity'
    maximumVolumeSize: Quantity | None = None
    metadata: ObjectMeta = field(default_factory=ObjectMeta)
    nodeTopology: LabelSelector | None = None
    plural_: ClassVar[str] = 'csistoragecapacities'
    is_namespaced_: ClassVar[bool] = True
    group_: ClassVar[Optional[str]] = 'storage.k8s.io'
    patch_strategies_: ClassVar[set[PatchRequestType]] = {
        'application/apply-patch+cbor',
        'application/apply-patch+yaml',
        'application/json-patch+json',
        'application/merge-patch+json',
        'application/strategic-merge-patch+json',
    }


@dataclass(slots=True, kw_only=True, frozen=True)
class CSIStorageCapacityList(Loadable):
    items: List[CSIStorageCapacity]
    apiVersion: str = 'storage.k8s.io/v1'
    kind: str = 'CSIStorageCapacityList'
    metadata: ListMeta = field(default_factory=ObjectMeta)


@dataclass(slots=True, kw_only=True, frozen=True)
class StorageClass(K8sResource):
    provisioner: str
    allowVolumeExpansion: bool | None = None
    allowedTopologies: List[TopologySelectorTerm] | None = None
    apiVersion: ClassVar[str] = 'storage.k8s.io/v1'
    kind: ClassVar[str] = 'StorageClass'
    metadata: ObjectMeta = field(default_factory=ObjectMeta)
    mountOptions: List[str] | None = None
    parameters: Dict[str, str] | None = None
    reclaimPolicy: str | None = None
    volumeBindingMode: str | None = None
    plural_: ClassVar[str] = 'storageclasses'
    is_namespaced_: ClassVar[bool] = False
    group_: ClassVar[Optional[str]] = 'storage.k8s.io'
    patch_strategies_: ClassVar[set[PatchRequestType]] = {
        'application/apply-patch+cbor',
        'application/apply-patch+yaml',
        'application/json-patch+json',
        'application/merge-patch+json',
        'application/strategic-merge-patch+json',
    }


@dataclass(slots=True, kw_only=True, frozen=True)
class StorageClassList(Loadable):
    items: List[StorageClass]
    apiVersion: str = 'storage.k8s.io/v1'
    kind: str = 'StorageClassList'
    metadata: ListMeta = field(default_factory=ObjectMeta)


@dataclass(slots=True, kw_only=True, frozen=True)
class VolumeAttachmentSource(Loadable):
    inlineVolumeSpec: PersistentVolumeSpec | None = None
    persistentVolumeName: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class VolumeAttachmentSpec(Loadable):
    attacher: str
    nodeName: str
    source: VolumeAttachmentSource


@dataclass(slots=True, kw_only=True, frozen=True)
class VolumeAttachmentStatus(Loadable):
    attached: bool
    attachError: VolumeError | None = None
    attachmentMetadata: Dict[str, str] | None = None
    detachError: VolumeError | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class VolumeAttributesClass(K8sResource):
    driverName: str
    apiVersion: ClassVar[str] = 'storage.k8s.io/v1'
    kind: ClassVar[str] = 'VolumeAttributesClass'
    metadata: ObjectMeta = field(default_factory=ObjectMeta)
    parameters: Dict[str, str] | None = None
    plural_: ClassVar[str] = 'volumeattributesclasses'
    is_namespaced_: ClassVar[bool] = False
    group_: ClassVar[Optional[str]] = 'storage.k8s.io'
    patch_strategies_: ClassVar[set[PatchRequestType]] = {
        'application/apply-patch+cbor',
        'application/apply-patch+yaml',
        'application/json-patch+json',
        'application/merge-patch+json',
        'application/strategic-merge-patch+json',
    }


@dataclass(slots=True, kw_only=True, frozen=True)
class VolumeAttributesClassList(Loadable):
    items: List[VolumeAttributesClass]
    apiVersion: str = 'storage.k8s.io/v1'
    kind: str = 'VolumeAttributesClassList'
    metadata: ListMeta = field(default_factory=ObjectMeta)


@dataclass(slots=True, kw_only=True, frozen=True)
class VolumeAttachment(K8sResource):
    spec: VolumeAttachmentSpec
    apiVersion: ClassVar[str] = 'storage.k8s.io/v1'
    kind: ClassVar[str] = 'VolumeAttachment'
    metadata: ObjectMeta = field(default_factory=ObjectMeta)
    status: VolumeAttachmentStatus | None = None
    plural_: ClassVar[str] = 'volumeattachments'
    is_namespaced_: ClassVar[bool] = False
    group_: ClassVar[Optional[str]] = 'storage.k8s.io'
    patch_strategies_: ClassVar[set[PatchRequestType]] = {
        'application/apply-patch+cbor',
        'application/apply-patch+yaml',
        'application/json-patch+json',
        'application/merge-patch+json',
        'application/strategic-merge-patch+json',
    }


@dataclass(slots=True, kw_only=True, frozen=True)
class VolumeAttachmentList(Loadable):
    items: List[VolumeAttachment]
    apiVersion: str = 'storage.k8s.io/v1'
    kind: str = 'VolumeAttachmentList'
    metadata: ListMeta = field(default_factory=ObjectMeta)
