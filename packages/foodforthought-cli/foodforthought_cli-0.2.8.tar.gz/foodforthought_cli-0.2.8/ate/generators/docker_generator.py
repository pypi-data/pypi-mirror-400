"""
Docker Generator - Generate containerized deployment for skills.

This generator creates:
- Dockerfile: Container definition
- docker-compose.yml: Local testing configuration
- entrypoint.sh: Container entry script
- .dockerignore: Build exclusions
"""

from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Set

from ..skill_schema import SkillSpecification
from .skill_generator import to_snake_case, to_pascal_case


class DockerGenerator:
    """
    Generate Docker containerization for a skill.

    Creates all necessary files for building and running the skill
    in a Docker container, with optional ROS2 integration.
    """

    def __init__(
        self,
        spec: SkillSpecification,
        base_image: str = "ros:humble",
        include_ros2: bool = True,
    ):
        """
        Initialize the generator.

        Args:
            spec: The skill specification
            base_image: Base Docker image to use
            include_ros2: Whether to include ROS2 support
        """
        self.spec = spec
        self.base_image = base_image
        self.include_ros2 = include_ros2
        self.package_name = to_snake_case(spec.name) + "_skill"
        self.class_name = to_pascal_case(spec.name)

    def get_apt_dependencies(self) -> List[str]:
        """Get apt packages needed based on skill requirements."""
        deps = [
            "python3-pip",
            "python3-dev",
        ]

        # Add deps based on hardware requirements
        for req in self.spec.hardware_requirements:
            if req.component_type == "camera":
                deps.extend(["libopencv-dev", "python3-opencv"])
            elif req.component_type in ("arm", "gripper"):
                deps.append("libserial-dev")

        return sorted(set(deps))

    def get_pip_dependencies(self) -> List[str]:
        """Get pip packages needed based on skill requirements."""
        deps = [
            "pyyaml",
            "numpy",
        ]

        # Add deps based on hardware requirements
        for req in self.spec.hardware_requirements:
            if req.component_type == "camera":
                deps.extend(["opencv-python", "pillow"])
            elif req.component_type in ("arm", "gripper"):
                deps.append("pyserial")
            elif req.component_type == "force_sensor":
                deps.append("scipy")

        return sorted(set(deps))

    def generate_dockerfile(self) -> str:
        """Generate Dockerfile for the skill."""
        apt_deps = self.get_apt_dependencies()
        pip_deps = self.get_pip_dependencies()

        apt_deps_str = " \\\n            ".join(apt_deps)
        pip_deps_str = " ".join(pip_deps)

        if self.include_ros2:
            return self._generate_ros2_dockerfile(apt_deps_str, pip_deps_str)
        else:
            return self._generate_python_dockerfile(apt_deps_str, pip_deps_str)

    def _generate_ros2_dockerfile(self, apt_deps: str, pip_deps: str) -> str:
        """Generate Dockerfile with ROS2 support."""
        return f'''# {self.spec.name} Skill Container
# Generated by Skill Compiler v1.0.0
# Base image: {self.base_image}

FROM {self.base_image}

# Set environment variables
ENV DEBIAN_FRONTEND=noninteractive
ENV ROS_DISTRO=humble
ENV SKILL_NAME={self.package_name}

# Install system dependencies
RUN apt-get update && apt-get install -y \\
            {apt_deps} \\
    && rm -rf /var/lib/apt/lists/*

# Install Python dependencies
RUN pip3 install --no-cache-dir {pip_deps}

# Create workspace
WORKDIR /ws

# Copy skill package
COPY . /ws/src/{self.package_name}

# Build workspace
RUN . /opt/ros/${{ROS_DISTRO}}/setup.sh && \\
    colcon build --packages-select {self.package_name}

# Copy entrypoint
COPY entrypoint.sh /ws/entrypoint.sh
RUN chmod +x /ws/entrypoint.sh

# Set entrypoint
ENTRYPOINT ["/ws/entrypoint.sh"]

# Default command
CMD ["ros2", "launch", "{self.package_name}", "skill.launch.py"]

# Labels
LABEL org.opencontainers.image.title="{self.spec.name} Skill"
LABEL org.opencontainers.image.description="{self.spec.description}"
LABEL org.opencontainers.image.version="{self.spec.version}"
LABEL org.opencontainers.image.authors="{self.spec.author or 'Unknown'}"
LABEL skill.name="{self.spec.name}"
LABEL skill.version="{self.spec.version}"
'''

    def _generate_python_dockerfile(self, apt_deps: str, pip_deps: str) -> str:
        """Generate Dockerfile without ROS2 (standalone Python)."""
        return f'''# {self.spec.name} Skill Container (Standalone)
# Generated by Skill Compiler v1.0.0

FROM python:3.10-slim

# Set environment variables
ENV DEBIAN_FRONTEND=noninteractive
ENV SKILL_NAME={self.package_name}
ENV PYTHONUNBUFFERED=1

# Install system dependencies
RUN apt-get update && apt-get install -y \\
            {apt_deps} \\
    && rm -rf /var/lib/apt/lists/*

# Install Python dependencies
RUN pip3 install --no-cache-dir {pip_deps}

# Create app directory
WORKDIR /app

# Copy skill package
COPY {self.package_name}/ /app/{self.package_name}/
COPY config/ /app/config/
COPY setup.py /app/
COPY requirements.txt /app/

# Install skill package
RUN pip3 install -e .

# Copy entrypoint
COPY entrypoint.sh /app/entrypoint.sh
RUN chmod +x /app/entrypoint.sh

# Set entrypoint
ENTRYPOINT ["/app/entrypoint.sh"]

# Default command
CMD ["python3", "-m", "{self.package_name}"]

# Labels
LABEL org.opencontainers.image.title="{self.spec.name} Skill"
LABEL org.opencontainers.image.description="{self.spec.description}"
LABEL org.opencontainers.image.version="{self.spec.version}"
LABEL skill.name="{self.spec.name}"
LABEL skill.version="{self.spec.version}"
'''

    def generate_compose(self) -> str:
        """Generate docker-compose.yml for local testing."""
        hardware_volumes = []
        hardware_devices = []

        # Add device access based on hardware requirements
        for req in self.spec.hardware_requirements:
            if req.component_type in ("arm", "gripper"):
                hardware_devices.append("/dev/ttyUSB0:/dev/ttyUSB0")
                hardware_devices.append("/dev/ttyACM0:/dev/ttyACM0")
            elif req.component_type == "camera":
                hardware_devices.append("/dev/video0:/dev/video0")

        devices_str = ""
        if hardware_devices:
            devices_str = "\n    devices:\n" + "\n".join(
                f"      - {d}" for d in sorted(set(hardware_devices))
            )

        return f'''# Docker Compose for {self.spec.name} Skill
# Generated by Skill Compiler v1.0.0
#
# Usage:
#   docker-compose up                    # Run skill
#   docker-compose up -d                 # Run in background
#   docker-compose build                 # Rebuild image
#   docker-compose logs -f               # View logs
#   docker-compose down                  # Stop and remove

version: "3.8"

services:
  {self.package_name}:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: {self.package_name}
    environment:
      - ROS_DOMAIN_ID=${{ROS_DOMAIN_ID:-0}}
      - USE_SIM=${{USE_SIM:-false}}
    volumes:
      - ./config:/ws/config:ro
      - /tmp/.X11-unix:/tmp/.X11-unix:rw  # For GUI (if needed)
    network_mode: host{devices_str}
    restart: unless-stopped

  # Optional: Simulation environment
  sim:
    image: osrf/ros:humble-simulation
    container_name: {self.package_name}_sim
    environment:
      - DISPLAY=${{DISPLAY}}
      - QT_X11_NO_MITSHM=1
    volumes:
      - /tmp/.X11-unix:/tmp/.X11-unix:rw
      - ./config:/ws/config:ro
    network_mode: host
    profiles:
      - simulation

networks:
  default:
    name: {self.package_name}_network
'''

    def generate_entrypoint(self) -> str:
        """Generate entrypoint.sh script."""
        if self.include_ros2:
            return f'''#!/bin/bash
# Entrypoint for {self.spec.name} skill container
# Generated by Skill Compiler v1.0.0

set -e

# Source ROS2 environment
source /opt/ros/${{ROS_DISTRO}}/setup.bash

# Source workspace
if [ -f /ws/install/setup.bash ]; then
    source /ws/install/setup.bash
fi

# Print info
echo "========================================"
echo "  {self.spec.name} Skill Container"
echo "  Version: {self.spec.version}"
echo "  ROS Distro: ${{ROS_DISTRO}}"
echo "========================================"

# Handle signals gracefully
trap 'echo "Shutting down..."; exit 0' SIGTERM SIGINT

# Execute command
exec "$@"
'''
        else:
            return f'''#!/bin/bash
# Entrypoint for {self.spec.name} skill container (standalone)
# Generated by Skill Compiler v1.0.0

set -e

# Print info
echo "========================================"
echo "  {self.spec.name} Skill Container"
echo "  Version: {self.spec.version}"
echo "========================================"

# Handle signals gracefully
trap 'echo "Shutting down..."; exit 0' SIGTERM SIGINT

# Execute command
exec "$@"
'''

    def generate_dockerignore(self) -> str:
        """Generate .dockerignore file."""
        return '''# Docker build exclusions
# Generated by Skill Compiler v1.0.0

# Git
.git
.gitignore

# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
.pytest_cache/
.coverage
htmlcov/

# Virtual environments
venv/
ENV/
env/
.venv/

# IDE
.idea/
.vscode/
*.swp
*.swo
*~

# Build artifacts
log/
install/
build/

# Documentation
docs/
*.md
!README.md

# Tests (optional, include if needed for debugging)
# test/

# Local config
.env
*.local.yaml
secrets/
'''

    def generate_requirements_txt(self) -> str:
        """Generate requirements.txt for pip dependencies."""
        deps = self.get_pip_dependencies()
        return "\n".join(deps)

    def generate_makefile(self) -> str:
        """Generate Makefile for common Docker operations."""
        return f'''# Makefile for {self.spec.name} skill container
# Generated by Skill Compiler v1.0.0

IMAGE_NAME := {self.package_name}
VERSION := {self.spec.version}

.PHONY: build run stop logs shell clean test

# Build the Docker image
build:
	docker build -t $(IMAGE_NAME):$(VERSION) -t $(IMAGE_NAME):latest .

# Run the container
run:
	docker-compose up

# Run in background
run-detached:
	docker-compose up -d

# Stop the container
stop:
	docker-compose down

# View logs
logs:
	docker-compose logs -f

# Open shell in container
shell:
	docker exec -it {self.package_name} /bin/bash

# Clean up
clean:
	docker-compose down -v --rmi local

# Run tests in container
test:
	docker run --rm $(IMAGE_NAME):$(VERSION) python3 -m pytest

# Push to registry (customize registry URL)
push:
	docker push $(IMAGE_NAME):$(VERSION)
	docker push $(IMAGE_NAME):latest

# Run with simulation
sim:
	docker-compose --profile simulation up
'''

    def generate(self, output_dir: Path) -> Dict[str, str]:
        """
        Generate complete Docker deployment structure.

        Args:
            output_dir: Directory to write files to

        Returns:
            Dict mapping filenames to generated content
        """
        output_dir = Path(output_dir)
        output_dir.mkdir(parents=True, exist_ok=True)

        files = {
            "Dockerfile": self.generate_dockerfile(),
            "docker-compose.yml": self.generate_compose(),
            "entrypoint.sh": self.generate_entrypoint(),
            ".dockerignore": self.generate_dockerignore(),
            "requirements.txt": self.generate_requirements_txt(),
            "Makefile": self.generate_makefile(),
        }

        # Write files
        for filename, content in files.items():
            file_path = output_dir / filename
            file_path.write_text(content)
            if filename.endswith(".sh"):
                file_path.chmod(0o755)

        return files
