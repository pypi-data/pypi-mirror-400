# coding: utf-8

"""
    One-API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 2.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class SendOtp422Response(BaseModel):
    """
    SendOtp422Response
    """ # noqa: E501
    message: Optional[StrictStr] = Field(default=None, description="The given data was invalid.")
    errors: Optional[List[StrictStr]] = Field(default=None, description="It may be one of the following:  - **User channel not found**  This error can occur when the channel is specified incorrectly. Please ensure that you are using the correct channel and try again.  - **Template not found**  This error can occur when the template identifier is specified incorrectly or the specified template is not present in the system. Please ensure that you are using the correct template identifier and try again.  - **Invalid template status**  This error occurs when the provided template identifier in the request does not match the “Approved” status.  - **Insufficient funds**  Insufficient funds to send OTP. Please top up your account.  - **Exists on the stop list**  We’re unable to send message as the phone number of recipient is currently in stop list.  - **User channel inactive**  The message sending method is disabled. Please enable method in your personal account and try again.  - **This action is available for the account of your type only for your manager phone number.**  To send OTP code is not allowed in Demo account mode.   - **Authentication limit with status pending**  This error can occur when total authentication limit with status “pending” is exceeded for your account.  - **Total authentication limit**  This error can occur when total authentication limit is exceeded for your account.  - **Template is not available** This error occurs when you try to create authentication using a template that is only available in the test mode of your account. Please choose a different template. ")
    __properties: ClassVar[List[str]] = ["message", "errors"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of SendOtp422Response from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of SendOtp422Response from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "message": obj.get("message"),
            "errors": obj.get("errors")
        })
        return _obj


