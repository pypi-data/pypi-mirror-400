"""Arcade Starter Tools for Exa

DO NOT EDIT THIS MODULE DIRECTLY.

THIS MODULE WAS AUTO-GENERATED BY TRANSPILING THE API STARTER TOOL JSON DEFINITIONS
IN THE ../wrapper_tools DIRECTORY INTO PYTHON CODE. ANY CHANGES TO THIS MODULE WILL
BE OVERWRITTEN BY THE TRANSPILER.
"""

import asyncio
import json
from enum import Enum
from typing import Annotated, Any

import httpx
import jsonschema
from arcade_tdk import ToolContext, tool
from arcade_tdk.errors import RetryableToolError

from .request_body_schemas import REQUEST_BODY_SCHEMAS

# Retry configuration
INITIAL_RETRY_DELAY = 0.5  # seconds

HTTP_CLIENT = httpx.AsyncClient(
    timeout=httpx.Timeout(60.0, connect=10.0),
    limits=httpx.Limits(max_keepalive_connections=20, max_connections=100),
    transport=httpx.AsyncHTTPTransport(retries=3),
    http2=True,
    follow_redirects=True,
)


class ToolMode(str, Enum):
    """Mode for tools with complex request bodies."""

    GET_REQUEST_SCHEMA = "get_request_schema"
    EXECUTE = "execute"


def remove_none_values(data: dict[str, Any]) -> dict[str, Any]:
    return {k: v for k, v in data.items() if v is not None}


async def make_request(
    url: str,
    method: str,
    params: dict[str, Any] | None = None,
    headers: dict[str, Any] | None = None,
    content: str | None = None,
    data: dict[str, Any] | None = None,
    auth: tuple[str, str] | None = None,
    max_retries: int = 3,
) -> httpx.Response:
    """Make an HTTP request with retry logic for 5xx server errors."""
    for attempt in range(max_retries):
        try:
            response = await HTTP_CLIENT.request(
                url=url,
                auth=auth,
                method=method,
                params=params,
                headers=headers,
                content=content,
            )
            response.raise_for_status()
        except httpx.HTTPStatusError as e:
            # Only retry on 5xx server errors
            if e.response.status_code >= 500 and attempt < max_retries - 1:
                # Exponential backoff: 0.5s, 1s, 2s
                await asyncio.sleep(INITIAL_RETRY_DELAY * (2**attempt))
                continue
            # Re-raise for 4xx errors or if max retries reached
            raise
        except httpx.RequestError:
            # Don't retry request errors (network issues are handled by transport)
            raise
        else:
            return response

    # This should never be reached, but satisfies type checker
    raise httpx.RequestError("Max retries exceeded")  # noqa: TRY003


async def make_request_with_schema_validation(
    url: str,
    method: str,
    request_data: dict[str, Any],
    schema: dict[str, Any] | str,
    auth: tuple[str, str] | None = None,
    params: dict[str, Any] | None = None,
    headers: dict[str, Any] | None = None,
    max_retries: int = 3,
) -> httpx.Response:
    """Make an HTTP request with schema validation on format errors."""
    # Parse schema if it's a string, skip validation if parsing fails
    parsed_schema = None
    if isinstance(schema, str):
        try:
            parsed_schema = json.loads(schema)
        except Exception:
            # If schema parsing fails, just skip validation
            parsed_schema = None
    else:
        parsed_schema = schema

    try:
        response = await make_request(
            url=url,
            auth=auth,
            method=method,
            params=params,
            headers=headers,
            content=json.dumps(request_data),
            max_retries=max_retries,
        )
    except httpx.HTTPStatusError as e:
        # Only provide schema validation for format-related errors
        if e.response.status_code in (400, 422):
            api_error_details = f"API returned {e.response.status_code}: {e.response.text}"

            # Only run validation if we have a valid parsed schema
            if parsed_schema is not None:
                # Run validation to provide additional context
                is_valid, validation_error = validate_json_against_schema(
                    request_data, parsed_schema
                )

                if not is_valid:
                    # Schema validation found issues - additional context
                    additional_context = (
                        f"{api_error_details}\n\n"
                        f"Schema validation found the following issues:\n"
                        f"{validation_error}"
                    )
                else:
                    # Schema validation passed - just show API error
                    additional_context = api_error_details
            else:
                # No valid schema - just show API error
                additional_context = api_error_details

            raise RetryableToolError(
                message=(f"API request failed with validation error: {e.response.status_code}"),
                developer_message=api_error_details,
                additional_prompt_content=additional_context,
            ) from e
        else:
            # For non-validation errors, re-raise as-is
            raise
    else:
        return response


def validate_json_against_schema(
    json_data: dict[str, Any], schema: dict[str, Any]
) -> tuple[bool, str | None]:
    """Validate JSON data against an OpenAPI/JSON Schema.

    This provides full JSON Schema Draft 7 validation including:
    - Required fields, types, enums
    - Pattern validation (regex)
    - Format validation (email, uuid, date-time, etc.)
    - Min/max length and values
    - oneOf, anyOf, allOf
    - And all other JSON Schema features

    Args:
        json_data: The JSON data to validate
        schema: The JSON Schema to validate against

    Returns:
        Tuple of (is_valid, error_messages). If valid, error_messages is None.
        If invalid, error_messages contains all validation errors.
    """
    try:
        validator = jsonschema.Draft7Validator(
            schema, format_checker=jsonschema.Draft7Validator.FORMAT_CHECKER
        )
        # Collect ALL validation errors
        errors = list(validator.iter_errors(json_data))
        if errors:
            # Format all errors with their paths
            error_messages = []
            for error in errors:
                error_path = ".".join(str(p) for p in error.path) if error.path else "root"
                error_messages.append(f"{error.message} at {error_path}")
            # Join all errors with newlines
            return False, "\n".join(error_messages)
        else:
            return True, None
    except jsonschema.SchemaError as e:
        return False, f"Invalid schema: {e.message}"
    except Exception as e:
        return False, f"Validation error: {e!s}"


@tool(requires_secrets=["EXA_API_KEY"])
async def perform_search(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'search'."]:
    """Perform a search and retrieve relevant results.

    Use this tool to execute a search with a prompt-engineered query via Exa and obtain relevant results. Optionally, retrieve the contents of the results.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["PERFORMSEARCH"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["PERFORMSEARCH"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["PERFORMSEARCH"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.exa.ai/search",
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["PERFORMSEARCH"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_API_KEY")
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_API_KEY"])
async def find_similar_links(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'findSimilar'."]:
    """Find similar links to a given link.

    This tool finds links similar to the provided link and can optionally retrieve their contents. It should be called when a user needs to discover related web pages or resources.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["FINDSIMILARLINKS"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["FINDSIMILARLINKS"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["FINDSIMILARLINKS"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.exa.ai/findSimilar",
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["FINDSIMILARLINKS"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_API_KEY")
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_API_KEY"])
async def get_content_details(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getContents'."]:
    """Retrieve details about specific content.

    Use this tool to retrieve detailed information about specific content from the EXA service. It should be called when content details are needed for further processing or display.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["GETCONTENTDETAILS"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["GETCONTENTDETAILS"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["GETCONTENTDETAILS"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.exa.ai/contents",
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["GETCONTENTDETAILS"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_API_KEY")
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_API_KEY"])
async def generate_answer_summary(
    context: ToolContext,
    search_query: Annotated[str, "The question or query to be answered or summarized."],
    enable_streaming_response: Annotated[
        bool | None, "Return the response as a server-sent events (SSE) stream if set to true."
    ] = False,
    include_full_text: Annotated[
        bool | None, "If true, the response includes full text content in the search results."
    ] = False,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'answer'."]:
    """Retrieve direct answers or detailed summaries with citations.

    Use this tool to perform a search based on a query. It generates either a direct answer or a detailed summary with citations, depending on the nature of the query."""  # noqa: E501
    request_data: Any = {
        "query": search_query,
        "stream": enable_streaming_response,
        "text": include_full_text,
    }
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/answer",
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_API_KEY")
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_API_KEY"])
async def list_research_requests(
    context: ToolContext,
    pagination_cursor: Annotated[
        str | None,
        "A string representing the position in the paginated results to continue retrieving data from.",  # noqa: E501
    ] = None,
    results_limit: Annotated[
        float | None,
        "Specifies the number of research requests to return in the response. Helps manage pagination effectively.",  # noqa: E501
    ] = 10,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'ResearchController_listResearch'."]:
    """Retrieve a paginated list of research requests.

    Use this tool to obtain a paginated list of all research requests. Ideal for reviewing or analyzing current research queries."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/research/v1",
        method="GET",
        params=remove_none_values({"cursor": pagination_cursor, "limit": results_limit}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_API_KEY"])
async def create_research_request(
    context: ToolContext,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'ResearchController_createResearch'."
]:
    """Create a new research request through Exa API.

    This tool initiates a new research request by calling the specified endpoint of the Exa API. It should be used when there is a need to start or submit a new research inquiry."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/research/v1",
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_API_KEY"])
async def get_research_by_id(
    context: ToolContext,
    enable_streaming: Annotated[
        str, "Set to 'true' to receive real-time streaming updates of the research information."
    ],
    event_filter: Annotated[
        str,
        "Specify the events to filter for in the research retrieval. Accepts a comma-separated list of event types.",  # noqa: E501
    ],
    research_id: Annotated[
        str, "A string representing the unique identifier of the research to be retrieved."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'ResearchController_getResearch'."]:
    """Retrieve research information using a specific ID.

    Use this tool to obtain detailed research information by providing a specific research ID. Supports real-time updates with streaming."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/research/v1/{researchId}".format(researchId=research_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({"stream": enable_streaming, "events": event_filter}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_API_KEY"])
async def create_webset(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'websets-create'."]:
    """Create a new Webset with optional configurations.

    This tool allows you to create a new Webset with optional search, import, and enrichment configurations. Specify an `externalId` for easier integration. The Webset begins processing automatically upon creation."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/websets/v0/websets",
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_API_KEY"])
async def list_websets(
    context: ToolContext,
    pagination_cursor: Annotated[
        str | None, "A string used to paginate through the list of Websets."
    ] = None,
    websets_return_limit: Annotated[
        float | None, "Specify the maximum number of Websets to return in the response."
    ] = 25,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'websets-list'."]:
    """Retrieve a list of available websets.

    Use this tool to obtain a list of websets. You can paginate through results using a cursor."""
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/websets/v0/websets",
        method="GET",
        params=remove_none_values({"cursor": pagination_cursor, "limit": websets_return_limit}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_API_KEY"])
async def get_webset_details(
    context: ToolContext,
    webset_identifier: Annotated[
        str, "The unique identifier or external ID for the Webset to retrieve."
    ],
    resources_to_expand: Annotated[
        list[str] | None, "A list of resources to include in the response for additional details."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'websets-get'."]:
    """Retrieve detailed information about a specific webset.

    This tool is used to obtain the details of a specific webset using its unique identifier. Call this when you need information related to a particular webset."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/websets/v0/websets/{id}".format(id=webset_identifier),  # noqa: UP032
        method="GET",
        params=remove_none_values({"expand": resources_to_expand}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_API_KEY"])
async def update_webset_exa(
    context: ToolContext,
    webset_identifier: Annotated[
        str, "The unique identifier (id or externalId) of the Webset to update."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'websets-update'."]:
    """Update an existing webset on Exa platform.

    Use this tool to update the details of an existing webset on the Exa platform. Invoke it when modifications to a webset are needed, such as changing its properties or configurations."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/websets/v0/websets/{id}".format(id=webset_identifier),  # noqa: UP032
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_API_KEY"])
async def delete_webset(
    context: ToolContext,
    webset_identifier: Annotated[
        str, "The unique identifier or external ID of the Webset to delete."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'websets-delete'."]:
    """Deletes a Webset and its associated items.

    Use this tool to permanently delete a Webset and all its associated items. Once deleted, it cannot be recovered."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/websets/v0/websets/{id}".format(id=webset_identifier),  # noqa: UP032
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_API_KEY"])
async def cancel_webset_operations(
    context: ToolContext,
    webset_identifier: Annotated[
        str, "The ID or external ID of the Webset to cancel operations on."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'websets-cancel'."]:
    """Cancel all operations on a specified Webset.

    Use this tool to stop any ongoing enrichment or search processes on a Webset, marking it as 'idle'."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/websets/v0/websets/{id}/cancel".format(id=webset_identifier),  # noqa: UP032
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_API_KEY"])
async def preview_search_query_analysis(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'websets-preview'."]:
    """Preview how a search query will be decomposed into a webset.

    Use this tool to preview the decomposition and analysis of a search query before committing to webset creation, helping users understand the detected entity type, generated search criteria, and available enrichment options."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/websets/v0/websets/preview",
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_API_KEY"])
async def get_webset_item(
    context: ToolContext,
    webset_identifier: Annotated[
        str,
        "The ID or external ID of the Webset to identify the desired Webset from which the item is to be retrieved.",  # noqa: E501
    ],
    webset_item_id: Annotated[str, "The unique identifier of the Webset item to retrieve."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'websets-items-get'."]:
    """Retrieve a specific Webset Item by ID.

    This tool is used to retrieve information about a specific Webset Item using its ID. It should be called when you need detailed information about a particular item associated with a Webset."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/websets/v0/websets/{webset}/items/{id}".format(  # noqa: UP032
            webset=webset_identifier, id=webset_item_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_API_KEY"])
async def delete_webset_item(
    context: ToolContext,
    webset_identifier: Annotated[
        str, "The ID or external ID of the Webset from which the item will be deleted."
    ],
    webset_item_id: Annotated[
        str, "The unique identifier of the item to be deleted from the webset."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'websets-items-delete'."]:
    """Delete an item from a webset and cancel its enrichment process.

    Use this tool to remove an item from the specified webset. This will also cancel any ongoing enrichment process associated with the item."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/websets/v0/websets/{webset}/items/{id}".format(  # noqa: UP032
            webset=webset_identifier, id=webset_item_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_API_KEY"])
async def list_webset_items(
    context: ToolContext,
    webset_identifier: Annotated[
        str, "The ID or external ID of the Webset to retrieve items from."
    ],
    pagination_cursor: Annotated[
        str | None,
        "A string used to paginate through the results. Pass this to retrieve the next set of items in the webset.",  # noqa: E501
    ] = None,
    result_limit: Annotated[
        float | None,
        "Specify the number of results to return. This controls the size of the page in a paginated response.",  # noqa: E501
    ] = 20,
    source_id: Annotated[
        str | None, "The unique identifier for the source from which to retrieve items."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'websets-items-list'."]:
    """Retrieve a list of items from a specific webset.

    This tool fetches items from a designated webset, allowing pagination with the 'cursor' parameter if needed."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/websets/v0/websets/{webset}/items".format(webset=webset_identifier),  # noqa: UP032
        method="GET",
        params=remove_none_values({
            "cursor": pagination_cursor,
            "limit": result_limit,
            "sourceId": source_id,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_API_KEY"])
async def create_webset_enrichment(
    context: ToolContext,
    webset_identifier: Annotated[
        str, "The ID or external ID of the webset for which the enrichment is to be created."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'websets-enrichments-create'."]:
    """Create an enrichment for a specified webset.

    This tool is used to create an enrichment for a specified webset. It's suitable for when you need to enhance a webset with additional data."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/websets/v0/websets/{webset}/enrichments".format(  # noqa: UP032
            webset=webset_identifier
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_API_KEY"])
async def update_webset_enrichment(
    context: ToolContext,
    enrichment_configuration_id: Annotated[
        str, "The unique identifier of the enrichment configuration to be updated."
    ],
    webset_identifier: Annotated[
        str,
        "The unique identifier or name of the webset to update. This is required to target the correct webset for enrichment modification.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'websets-enrichments-update'."]:
    """Update an enrichment configuration for a webset.

    Use this tool to modify the existing enrichment configuration of a specified webset. Call this tool when you need to apply new settings or changes to an enrichment setup."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/websets/v0/websets/{webset}/enrichments/{id}".format(  # noqa: UP032
            webset=webset_identifier, id=enrichment_configuration_id
        ),
        method="PATCH",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_API_KEY"])
async def get_enrichment_details(
    context: ToolContext,
    enrichment_id: Annotated[
        str,
        "The unique identifier for the specific enrichment you want to retrieve within the webset.",
    ],
    webset_identifier: Annotated[
        str, "The ID or external ID of the webset to retrieve enrichment details for."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'websets-enrichments-get'."]:
    """Retrieve detailed information about a specific enrichment.

    Use this tool to get detailed information about a specific enrichment in a webset by providing the webset and enrichment IDs."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/websets/v0/websets/{webset}/enrichments/{id}".format(  # noqa: UP032
            webset=webset_identifier, id=enrichment_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_API_KEY"])
async def delete_enrichment(
    context: ToolContext,
    enrichment_id: Annotated[str, "The unique identifier of the enrichment to be deleted."],
    webset_id: Annotated[
        str, "The ID or external ID of the Webset to identify which enrichment to delete."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'websets-enrichments-delete'."]:
    """Delete an enrichment and cancel running processes.

    Use this tool to delete an enrichment, cancel any running processes, and remove all generated enrichment results."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/websets/v0/websets/{webset}/enrichments/{id}".format(  # noqa: UP032
            webset=webset_id, id=enrichment_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_API_KEY"])
async def cancel_enrichment_process(
    context: ToolContext,
    enrichment_id: Annotated[
        str, "The unique identifier of the enrichment process to be canceled."
    ],
    webset_id: Annotated[
        str, "The ID or external ID of the Webset to identify which enrichment process to cancel."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'websets-enrichments-cancel'."]:
    """Cancel a running enrichment process.

    Use this tool to cancel any currently running enrichment process. Once canceled, the process cannot be resumed."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/websets/v0/websets/{webset}/enrichments/{id}/cancel".format(  # noqa: UP032
            webset=webset_id, id=enrichment_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_API_KEY"])
async def create_webhook_for_notifications(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'webhooks-create'."]:
    """Create webhooks for event notifications from Exa.

    Use this tool to set up webhooks that notify you of specific events in your Websets. Choose event types and specify the URL to receive notifications. Begins receiving notifications instantly and provides a secret key for signature verification."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/websets/v0/webhooks",
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_API_KEY"])
async def get_webhooks_list(
    context: ToolContext,
    pagination_cursor: Annotated[
        str | None, "The cursor used to navigate through pages of results for webhooks."
    ] = None,
    results_per_page: Annotated[
        float | None, "The number of webhooks to return per page, up to a maximum of 200."
    ] = 25,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'webhooks-list'."]:
    """Retrieve a paginated list of all webhooks in your account.

    Use this tool to get all the webhooks associated with your account, with options to paginate through results using limit and cursor parameters."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/websets/v0/webhooks",
        method="GET",
        params=remove_none_values({"cursor": pagination_cursor, "limit": results_per_page}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_API_KEY"])
async def get_webhook_info(
    context: ToolContext,
    webhook_id: Annotated[str, "The unique identifier for the webhook you want details about."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'webhooks-get'."]:
    """Retrieve details of a webhook using its ID.

    This tool is used to get details about a specific webhook by providing its ID. It should be called when you need to access information about a particular webhook. The secret associated with the webhook is not included for security reasons."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/websets/v0/webhooks/{id}".format(id=webhook_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_API_KEY"])
async def update_webhook_settings(
    context: ToolContext,
    webhook_id: Annotated[str, "The unique identifier for the webhook to update."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'webhooks-update'."]:
    """Update webhook settings such as events, URL, or metadata.

    This tool lets you modify a webhook's configuration instantly. Use it to add or remove event notifications, update the notification URL, or change metadata. The current status of the webhook remains unchanged during updates."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/websets/v0/webhooks/{id}".format(id=webhook_id),  # noqa: UP032
        method="PATCH",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_API_KEY"])
async def remove_webhook(
    context: ToolContext,
    webhook_id: Annotated[
        str,
        "The unique identifier of the webhook to remove. This is necessary for specifying which webhook to delete.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'webhooks-delete'."]:
    """Remove a webhook from your account.

    Use this tool to delete a webhook. Once deleted, it stops receiving notifications immediately and cannot be restored. You'll need to create a new webhook if you wish to reinstate it. Use when you need to stop a webhook permanently."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/websets/v0/webhooks/{id}".format(id=webhook_id),  # noqa: UP032
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_API_KEY"])
async def list_webhook_attempts(
    context: ToolContext,
    webhook_id: Annotated[
        str, "The unique identifier for the webhook to retrieve attempt records for."
    ],
    event_type_filter: Annotated[
        str | None,
        "Filter webhook attempts by specifying the type of event, such as 'webset.created' or 'monitor.run.completed'.",  # noqa: E501
    ] = None,
    filter_by_successful_attempts: Annotated[
        bool | None,
        "Use 'true' to filter for successful webhook attempts and 'false' for unsuccessful ones.",
    ] = None,
    pagination_cursor: Annotated[
        str | None, "A string used to paginate through the webhook attempt results."
    ] = None,
    results_limit: Annotated[
        float | None, "Specify the maximum number of webhook attempt records to return."
    ] = 25,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'webhooks-attempts-list'."]:
    """Retrieve and list all webhook attempt records.

    This tool retrieves all attempts made by a specific webhook, ordered in descending order. It is useful for monitoring webhook activity and diagnosing issues."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/websets/v0/webhooks/{id}/attempts".format(id=webhook_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({
            "cursor": pagination_cursor,
            "limit": results_limit,
            "eventType": event_type_filter,
            "successful": filter_by_successful_attempts,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_API_KEY"])
async def list_system_events(
    context: ToolContext,
    created_after: Annotated[
        str | None,
        "Filter events created after or at this timestamp. Use a valid ISO 8601 datetime string in UTC.",  # noqa: E501
    ] = None,
    event_types_filter: Annotated[
        list[str] | None, "Filter events by specifying an array of event type names."
    ] = None,
    filter_created_before: Annotated[
        str | None,
        "Filter events created before or at this timestamp (inclusive). Provide a valid ISO 8601 datetime string in UTC.",  # noqa: E501
    ] = None,
    pagination_cursor: Annotated[
        str | None,
        "Cursor for paginating through event results. Use it to navigate through pages of events.",
    ] = None,
    results_limit: Annotated[
        float | None,
        "Specify the number of event results to return. This controls the size of the result set for a single request.",  # noqa: E501
    ] = 25,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'events-list'."]:
    """Retrieve a list of all system events.

    Call this tool to get a detailed list of events that have occurred within the system. Useful for auditing, monitoring, or reviewing activities. Supports pagination through a cursor parameter."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/websets/v0/events",
        method="GET",
        params=remove_none_values({
            "cursor": pagination_cursor,
            "limit": results_limit,
            "types": event_types_filter,
            "createdBefore": filter_created_before,
            "createdAfter": created_after,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_API_KEY"])
async def get_event_by_id(
    context: ToolContext,
    event_id: Annotated[str, "The unique identifier of the event to retrieve details for."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'events-get'."]:
    """Retrieve details of an event using its ID.

    Use this tool to obtain information about a specific event by providing its unique identifier."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/websets/v0/events/{id}".format(id=event_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_API_KEY"])
async def create_webset_search(
    context: ToolContext,
    webset_id: Annotated[str, "The unique identifier for the Webset to create a search within."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'websets-searches-create'."]:
    """Create a new search for a specified webset.

    This tool is used to create a new search within a specified webset, reusing previous search results and evaluating them against new criteria. Useful for updating or refining search parameters."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/websets/v0/websets/{webset}/searches".format(webset=webset_id),  # noqa: UP032
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_API_KEY"])
async def get_search_by_id(
    context: ToolContext,
    search_id: Annotated[str, "The ID of the search to retrieve details for."],
    webset_id: Annotated[str, "The ID of the Webset to retrieve the specific search."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'websets-searches-get'."]:
    """Retrieve a search by its ID.

    Use this tool to get detailed information about a specific search by providing its ID."""
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/websets/v0/websets/{webset}/searches/{id}".format(  # noqa: UP032
            webset=webset_id, id=search_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_API_KEY"])
async def cancel_running_search(
    context: ToolContext,
    search_id: Annotated[
        str,
        "The ID of the search to cancel. Provide the unique string identifier for the targeted search operation.",  # noqa: E501
    ],
    webset_id: Annotated[
        str,
        "The ID of the Webset where the search is executing. Use this to specify the Webset to be canceled.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'websets-searches-cancel'."]:
    """Cancels a currently running search operation.

    This tool cancels an ongoing search by using the specified webset and search ID. Useful when you need to stop a search that is still in progress."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/websets/v0/websets/{webset}/searches/{id}/cancel".format(  # noqa: UP032
            webset=webset_id, id=search_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_API_KEY"])
async def create_monitor_for_websets(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'monitors-create'."]:
    """Automatically create and schedule a monitor for Websets.

    This tool creates a new Monitor to keep Websets updated with fresh data. It automatically executes search and refresh operations based on defined schedules to ensure the content is current. You can configure cron expressions and timezones for precise control."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/websets/v0/monitors",
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_API_KEY"])
async def list_website_monitors(
    context: ToolContext,
    pagination_cursor: Annotated[
        str | None, "The cursor for paginating through the monitor results."
    ] = None,
    results_limit: Annotated[
        float | None,
        "Specifies the maximum number of monitor results to return. Use for pagination.",
    ] = 25,
    webset_id: Annotated[
        str | None,
        "The unique identifier for the Webset to retrieve monitors for. This is required to specify which website's monitors you want to list.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'monitors-list'."]:
    """Fetch all monitors associated with a website.

    Use this tool to retrieve a comprehensive list of all monitoring services set up for a specific website. This is helpful for maintenance, auditing, or upgrading processes."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/websets/v0/monitors",
        method="GET",
        params=remove_none_values({
            "cursor": pagination_cursor,
            "limit": results_limit,
            "websetId": webset_id,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_API_KEY"])
async def get_specific_monitor(
    context: ToolContext,
    monitor_id: Annotated[str, "The unique identifier of the monitor to retrieve details for."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'monitors-get'."]:
    """Retrieve details of a specific monitor using its ID.

    This tool is used to obtain information about a particular monitor by providing its unique ID. Call this tool when you need to get specific details about a monitor."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/websets/v0/monitors/{id}".format(id=monitor_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_API_KEY"])
async def update_monitor_configuration(
    context: ToolContext,
    monitor_id: Annotated[str, "The unique identifier for the monitor to update."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'monitors-update'."]:
    """Update a monitor configuration in Exa.

    Use this tool to update the configuration of a specified monitor in the Exa system. This is useful for modifying settings such as thresholds, alerts, and other configurations."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/websets/v0/monitors/{id}".format(id=monitor_id),  # noqa: UP032
        method="PATCH",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_API_KEY"])
async def delete_monitor(
    context: ToolContext,
    monitor_id: Annotated[str, "The unique identifier for the monitor to be deleted."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'monitors-delete'."]:
    """Deletes a specified monitor using its ID.

    Use this tool to delete a monitor by providing its ID. It should be called when you need to remove a monitor from the system."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/websets/v0/monitors/{id}".format(id=monitor_id),  # noqa: UP032
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_API_KEY"])
async def list_monitor_runs(
    context: ToolContext,
    monitor_id: Annotated[str, "The ID of the monitor to list all associated runs."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'monitors-runs-list'."]:
    """Lists all runs for a given monitor.

    Use this tool to retrieve a list of all runs associated with a specific monitor. It's helpful for tracking and analyzing past monitor activities."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/websets/v0/monitors/{monitor}/runs".format(monitor=monitor_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_API_KEY"])
async def get_specific_monitor_run(
    context: ToolContext,
    monitor_id: Annotated[str, "The unique identifier of the monitor to retrieve the run for."],
    run_id: Annotated[str, "The unique identifier of the specific run to retrieve details for."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'monitors-runs-get'."]:
    """Retrieve details of a specific monitor run.

    This tool retrieves details of a specific monitor run by using the monitor ID and run ID. It should be called when you need to access information about a particular monitor run."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/websets/v0/monitors/{monitor}/runs/{id}".format(  # noqa: UP032
            monitor=monitor_id, id=run_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_API_KEY"])
async def create_data_import(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'imports-create'."]:
    """Create a new import for data upload and enhancement.

    Use this tool to initialize a new import process to upload data into Websets. This import can then be used to enrich, search, or exclude data using Websets' features. It provides an upload URL and a deadline for uploading the data.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["CREATEDATAIMPORT"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATEDATAIMPORT"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATEDATAIMPORT"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.exa.ai/websets/v0/imports",
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["CREATEDATAIMPORT"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_API_KEY")
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_API_KEY"])
async def list_imports(
    context: ToolContext,
    pagination_cursor: Annotated[
        str | None,
        "String used for paginating through results. Pass it to retrieve the next set of results.",
    ] = None,
    results_limit: Annotated[
        float | None, "Specify the maximum number of import results to return."
    ] = 25,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'imports-list'."]:
    """Retrieve all import entries for the Webset.

    Use this tool to get a comprehensive list of all imports associated with the Webset, useful for tracking or auditing purposes."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/websets/v0/imports",
        method="GET",
        params=remove_none_values({"cursor": pagination_cursor, "limit": results_limit}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_API_KEY"])
async def get_specific_import(
    context: ToolContext,
    import_id: Annotated[
        str, "The unique identifier for the specific import to retrieve details about."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'imports-get'."]:
    """Retrieve details of a specific import.

    Use this tool to get detailed information about a particular import by providing its ID."""
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/websets/v0/imports/{id}".format(id=import_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_API_KEY"])
async def update_import_configuration(
    context: ToolContext,
    import_id: Annotated[str, "The unique ID of the import configuration to update."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'imports-update'."]:
    """Update an import configuration with specified parameters.

    Call this tool to modify the settings of an existing import configuration using its ID."""
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/websets/v0/imports/{id}".format(id=import_id),  # noqa: UP032
        method="PATCH",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_API_KEY"])
async def delete_import(
    context: ToolContext,
    import_id: Annotated[str, "The unique identifier of the import to be deleted."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'imports-delete'."]:
    """Delete an import by its ID.

    Use this tool to delete an import record when you have the import ID."""
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/websets/v0/imports/{id}".format(id=import_id),  # noqa: UP032
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}
