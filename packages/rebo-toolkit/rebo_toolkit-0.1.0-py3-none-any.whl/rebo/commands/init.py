\
from __future__ import annotations

from pathlib import Path
from datetime import datetime
import json

from ..core import ReboError, ensure_empty_or_new, ensure_dir, write_text, rel
from .. import templates


def snake_case(name: str) -> str:
    name = name.strip().replace("-", "_").replace(" ", "_")
    out = []
    for ch in name:
        if ch.isalnum() or ch == "_":
            out.append(ch.lower())
        else:
            out.append("_")
    return "".join(out)


def cmd_init(args) -> int:
    target = Path(args.path).resolve()
    project_name = args.name or target.name
    overwrite = bool(args.force)

    ensure_empty_or_new(target)

    if args.profile == "minimal":
        _init_minimal(target, project_name, overwrite=overwrite)
    elif args.profile == "py-lib":
        _init_py_lib(target, project_name, args, overwrite=overwrite)
    elif args.profile == "node-lib":
        _init_node_lib(target, project_name, args, overwrite=overwrite)
    elif args.profile == "c-lib":
        _init_c_lib(target, project_name, args, overwrite=overwrite)
    else:
        raise ReboError(f"Unknown profile: {args.profile}")

    # optional CI
    if args.with_ci:
        _add_ci(target, args.profile, overwrite=overwrite)

    print("\n[DONE] Project initialized:", target)
    print("Next:")
    print(f"  cd {target.name}")
    print("  git init")
    return 0


def _add_ci(target: Path, profile: str, overwrite: bool) -> None:
    wf = target / ".github" / "workflows" / "ci.yml"
    if profile == "py-lib":
        content = templates.gh_actions_ci_python()
    elif profile == "node-lib":
        content = templates.gh_actions_ci_node()
    elif profile == "c-lib":
        content = templates.gh_actions_ci_c()
    else:
        content = templates.gh_actions_ci_python()
    _w(wf, content, overwrite)


def _w(path: Path, content: str, overwrite: bool) -> None:
    wrote = write_text(path, content, overwrite=overwrite)
    if wrote:
        print(f"[OK]  created {rel(path)}")
    else:
        print(f"[SKIP] {rel(path)} exists")


def _init_minimal(target: Path, project_name: str, overwrite: bool) -> None:
    ensure_dir(target)
    _w(target / "README.md", templates.README_TEMPLATE.format(
        project_name=project_name,
        tagline="Minimal repo.",
        quickstart="```bash\n# add your steps here\n```\n",
    ), overwrite)
    _w(target / ".gitignore", "# Generated by rebo\n", overwrite)


def _init_py_lib(target: Path, project_name: str, args, overwrite: bool) -> None:
    ensure_dir(target)
    pkg = snake_case(project_name)

    # README
    _w(target / "README.md", templates.README_TEMPLATE.format(
        project_name=project_name,
        tagline="Python library.",
        quickstart=f"```bash\npip install {pkg}\n```",
    ), overwrite)

    # license
    _w(target / "LICENSE", templates.license_text(args.license, args.author or project_name), overwrite)

    # gitignore
    _w(target / ".gitignore", templates.PY_GITIGNORE, overwrite)

    # pyproject
    pyproject = f"""\
[build-system]
requires = ["setuptools>=68"]
build-backend = "setuptools.build_meta"

[project]
name = "{pkg}"
version = "0.1.0"
description = "TODO: short description"
readme = "README.md"
requires-python = ">=3.9"
license = {{text = "{args.license}"}}
authors = [{{name = "{args.author or "Your Name"}", email = "{args.email or "you@example.com"}"}}]
dependencies = []

[project.optional-dependencies]
dev = ["pytest>=8"]

[project.urls]
Homepage = "https://github.com/{args.github_user or "your-id"}/{target.name}"
Repository = "https://github.com/{args.github_user or "your-id"}/{target.name}"

[tool.setuptools.packages.find]
where = ["src"]
"""
    _w(target / "pyproject.toml", pyproject, overwrite)

    # src
    init_py = f'"""Top-level package for {project_name}."""\n\n__all__ = []\n'
    _w(target / "src" / pkg / "__init__.py", init_py, overwrite)

    # tests
    _w(target / "tests" / "test_placeholder.py", "def test_placeholder():\n    assert True\n", overwrite)


def _init_node_lib(target: Path, project_name: str, args, overwrite: bool) -> None:
    ensure_dir(target)
    pkg = project_name.strip().lower().replace(" ", "-")

    _w(target / "README.md", templates.README_TEMPLATE.format(
        project_name=project_name,
        tagline="Node.js library.",
        quickstart="```bash\nnpm i\nnpm test\n```",
    ), overwrite)
    _w(target / "LICENSE", templates.license_text(args.license, args.author or project_name), overwrite)
    _w(target / ".gitignore", templates.NODE_GITIGNORE, overwrite)

    package_json = {
        "name": pkg,
        "version": "0.1.0",
        "type": "module",
        "main": "src/index.js",
        "scripts": {
            "test": "node ./tests/test.js",
        },
        "license": args.license
    }
    _w(target / "package.json", json.dumps(package_json, indent=2) + "\n", overwrite)

    _w(target / "src" / "index.js", 'export function hello(){ return "hello"; }\n', overwrite)
    _w(target / "tests" / "test.js", 'import { hello } from "../src/index.js";\nif (hello() !== "hello") process.exit(1);\nconsole.log("ok");\n', overwrite)


def _init_c_lib(target: Path, project_name: str, args, overwrite: bool) -> None:
    ensure_dir(target)
    lib = snake_case(project_name)

    _w(target / "README.md", templates.README_TEMPLATE.format(
        project_name=project_name,
        tagline="C library (Makefile).",
        quickstart="```bash\nmake\n```\n",
    ), overwrite)
    _w(target / "LICENSE", templates.license_text(args.license, args.author or project_name), overwrite)
    _w(target / ".gitignore", templates.C_GITIGNORE, overwrite)

    makefile = f"""\
CC ?= gcc
CFLAGS ?= -O2 -Wall -Wextra -std=c11
AR ?= ar
ARFLAGS ?= rcs

all: lib{lib}.a

lib{lib}.a: build/{lib}.o
\t$(AR) $(ARFLAGS) $@ $^

build/{lib}.o: src/{lib}.c src/{lib}.h
\t@mkdir -p build
\t$(CC) $(CFLAGS) -c src/{lib}.c -o build/{lib}.o

clean:
\trm -rf build *.a

.PHONY: all clean
"""
    _w(target / "Makefile", makefile, overwrite)
    _w(target / "src" / f"{lib}.h", f"#pragma once\n\nint {lib}_add(int a, int b);\n", overwrite)
    _w(target / "src" / f"{lib}.c", f'#include "{lib}.h"\n\nint {lib}_add(int a, int b){{ return a + b; }}\n', overwrite)
