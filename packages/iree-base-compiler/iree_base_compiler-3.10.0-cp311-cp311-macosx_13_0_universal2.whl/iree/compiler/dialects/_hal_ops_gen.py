
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union, Optional as _Optional


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "hal"

@_ods_cext.register_operation(_Dialect)
class AllocatorAllocateOp(_ods_ir.OpView):
  r"""
  Allocates a buffer of the given size from the allocator.
  The size of the buffer returned may be larger than the requested size if the
  allocator has specific alignment requirements or minimum allocation sizes.
  """

  OPERATION_NAME = "hal.allocator.allocate"

  _ODS_REGIONS = (0, True)

  def __init__(self, allocator, queue_affinity, memory_types, buffer_usage, result_size, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(allocator)
    operands.append(queue_affinity)
    operands.append(memory_types)
    operands.append(buffer_usage)
    operands.append(result_size)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def allocator(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def queue_affinity(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def memory_types(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[2]

  @builtins.property
  def buffer_usage(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[3]

  @builtins.property
  def result_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[4]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def allocator_allocate(allocator, queue_affinity, memory_types, buffer_usage, result_size, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AllocatorAllocateOp(allocator=allocator, queue_affinity=queue_affinity, memory_types=memory_types, buffer_usage=buffer_usage, result_size=result_size, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AllocatorImportOp(_ods_ir.OpView):
  r"""
  Tries importing host memory backed by the given byte buffer into a
  device accessible `!hal.buffer`. The returned buffer may be host-only and
  not directly usable on devices. If the mapping cannot be completed (such as
  trying to map the host memory as device-local on devices with discrete
  memory) then `did_import` will indicate that the returned buffer is null.
  """

  OPERATION_NAME = "hal.allocator.import"

  _ODS_REGIONS = (0, True)

  def __init__(self, allocator, queue_affinity, memory_types, buffer_usage, source, offset, length, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(allocator)
    operands.append(queue_affinity)
    operands.append(memory_types)
    operands.append(buffer_usage)
    operands.append(source)
    operands.append(offset)
    operands.append(length)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def allocator(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def queue_affinity(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def memory_types(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[2]

  @builtins.property
  def buffer_usage(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[3]

  @builtins.property
  def source(self) -> _ods_ir.Value:
    return self.operation.operands[4]

  @builtins.property
  def offset(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[5]

  @builtins.property
  def length(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[6]

  @builtins.property
  def did_import(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[1]

def allocator_import(allocator, queue_affinity, memory_types, buffer_usage, source, offset, length, *, results=None, loc=None, ip=None) -> _ods_ir.OpResultList:
  return AllocatorImportOp(allocator=allocator, queue_affinity=queue_affinity, memory_types=memory_types, buffer_usage=buffer_usage, source=source, offset=offset, length=length, results=results, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class AllocatorResolveMemoryPropertiesOp(_ods_ir.OpView):
  r"""
  Resolves the required memory types and buffer usage for a resource with
  the given lifetime and affinity. This operation encapsulates the logic
  for deriving buffer properties based on stream resource semantics.
  
  This operation can be resolved later in compilation either by canonicalization
  for single device affinties or using the topology attribute for multiple devices.
  
  Example:
  ```mlir
  %memory_types, %buffer_usage = hal.allocator.resolve_memory_properties
      for(#hal.device.affinity<@device_a>)
      lifetime(transient) : i32, i32
  ```
  """

  OPERATION_NAME = "hal.allocator.resolve_memory_properties"

  _ODS_REGIONS = (0, True)

  def __init__(self, lifetime, *, affinity=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('AnyAttr')) else
          _ods_ir.AttrBuilder.get('AnyAttr')(affinity, context=_ods_context))
    attributes["lifetime"] = (lifetime if (
    isinstance(lifetime, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_LifetimeAttr')) else
      _ods_ir.AttrBuilder.get('HAL_LifetimeAttr')(lifetime, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def lifetime(self) -> _ods_ir.Attribute:
    return self.operation.attributes["lifetime"]

  @lifetime.setter
  def lifetime(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["lifetime"] = value

  @builtins.property
  def memory_types(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

  @builtins.property
  def buffer_usage(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[1]

def allocator_resolve_memory_properties(lifetime, *, affinity=None, results=None, loc=None, ip=None) -> _ods_ir.OpResultList:
  return AllocatorResolveMemoryPropertiesOp(lifetime=lifetime, affinity=affinity, results=results, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class AllocatorSelectOp(_ods_ir.OpView):
  r"""
  Chooses one device and queue affinity pair from the given optimal set that
  can service the requested memory type and usage for all devices in the set.
  Returns a null device if no pair is able to satisfy the conditions.
  """

  OPERATION_NAME = "hal.allocator.select"

  _ODS_REGIONS = (0, True)

  def __init__(self, devices, queue_affinities, memory_types, buffer_usage, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(devices))
    operands.extend(_get_op_results_or_values(queue_affinities))
    operands.append(memory_types)
    operands.append(buffer_usage)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def devices(self) -> _ods_ir.OpOperandList:
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 2, 2, 0, 0)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def queue_affinities(self) -> _ods_ir.OpOperandList:
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 2, 2, 0, 1)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def memory_types(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 2, 2, 0, 2)
    return self.operation.operands[start]

  @builtins.property
  def buffer_usage(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 2, 2, 1, 2)
    return self.operation.operands[start]

  @builtins.property
  def selected_device(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

  @builtins.property
  def selected_queue_affinity(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[1]

def allocator_select(devices, queue_affinities, memory_types, buffer_usage, *, results=None, loc=None, ip=None) -> _ods_ir.OpResultList:
  return AllocatorSelectOp(devices=devices, queue_affinities=queue_affinities, memory_types=memory_types, buffer_usage=buffer_usage, results=results, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class BufferAllocationDiscardOp(_ods_ir.OpView):
  r"""
  Decrementing the preserve count indicates that the owner is releasing its
  ownership. When the last owner discards their ownership it is safe to
  deallocate the buffer allocation even if there are still references
  remaining to the buffer object.
  
  Any code that _may_ receive asynchronously allocated buffers must properly
  balance their preserves and discards. Code that will never receive
  asynchronously allocated buffers - such as those using the inline HAL - can
  ignore tracking as there's no asynchronous deallocation and allocation
  lifetime is tied to buffer object lifetime. Note that unbalanced discards
  will result in either correctness issues (buffer is deallocated too early)
  or extended lifetime (buffer cannot be deallocated until all buffer object
  references have been released).
  
  Returns true if the caller was the last owner of the allocation and it can
  now be deallocated.
  """

  OPERATION_NAME = "hal.buffer.allocation.discard"

  _ODS_REGIONS = (0, True)

  def __init__(self, buffer, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(buffer)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def buffer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def buffer_allocation_discard(buffer, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BufferAllocationDiscardOp(buffer=buffer, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferAllocationIsTerminalOp(_ods_ir.OpView):
  r"""
  This can be used to reuse a buffer that has no other owners.
  
  Note that an allocated buffer may have multiple suballocations referencing
  it and this query is only for the entire allocation. When reusing a buffer
  one should ensure the allocation size matches (or is within threshold) so
  that a reuse of 16MB doesn't keep an underlying allocation of 16GB wired.
  
  Since device allocators are expected to reuse memory if in doubt prefer to
  dealloca and alloca. This method should only be used in situations where the
  buffer types are known to the application (such as fixed input and output
  buffers).
  """

  OPERATION_NAME = "hal.buffer.allocation.is_terminal"

  _ODS_REGIONS = (0, True)

  def __init__(self, buffer, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(buffer)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def buffer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def buffer_allocation_is_terminal(buffer, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BufferAllocationIsTerminalOp(buffer=buffer, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferAllocationPreserveOp(_ods_ir.OpView):
  r"""
  Preservation is a way to track lifetime of an asynchronously-allocated
  buffer on multiple device timelines. Incrementing the preserve count
  indicates that there is a new co-owner of the buffer lifetime and that owner
  must make a corresponding `hal.buffer.allocation.discard` call to release
  their ownership and possibly deallocate the buffer.
  
  Though intended for asynchronously-allocated buffers it is fine to preserve
  synchronously-allocated ones. Any code that _may_ receive asynchronously
  allocated buffers must properly balance their preserves and discards. Code
  that will never receive asynchronously allocated buffers - such as those
  using the inline HAL - can ignore tracking.
  
  This preservation roughly translates to retaining logical ownership of the
  allocation and may differ from the buffer object reference count. As an
  example if the Python GC hasn't run there may still be several references to
  the buffer object even after the application has stopped using the buffer.
  Tracking the preserve count independently allows the application to eagerly
  deallocate the buffer without relying on the lifetime of the object to do
  so.
  
  A preserved buffer will still be deallocated if there are no longer any
  references to the buffer object. Preserving the buffer only prevents any
  other owner from deallocating it while there are references outstanding.
  See `hal.buffer.allocation.discard` for more information about releasing
  ownership.
  """

  OPERATION_NAME = "hal.buffer.allocation.preserve"

  _ODS_REGIONS = (0, True)

  def __init__(self, buffer, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(buffer)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def buffer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

def buffer_allocation_preserve(buffer, *, loc=None, ip=None) -> BufferAllocationPreserveOp:
  return BufferAllocationPreserveOp(buffer=buffer, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class BufferAssertOp(_ods_ir.OpView):
  r"""
  Asserts that the buffer is compatible with the given allocator and usage.
  Program execution will abort as if `std.assert` had been used.
  
  This only checks that the buffer can be used and not that it matches the
  given parameters exactly. Buffers may be from other allocators so long as
  the allocators are compatible (devices can address each other's memory),
  the type and usage contain all the requested bits (having more bits is ok),
  and the length is at least the requested minimum (as padding may be
  ignored).
  """

  OPERATION_NAME = "hal.buffer.assert"

  _ODS_REGIONS = (0, True)

  def __init__(self, buffer, message, allocator, minimum_length, memory_types, buffer_usage, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(buffer)
    operands.append(allocator)
    operands.append(minimum_length)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["message"] = (message if (
    isinstance(message, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(message, context=_ods_context))
    attributes["memory_types"] = (memory_types if (
    isinstance(memory_types, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_MemoryTypeBitfieldAttr')) else
      _ods_ir.AttrBuilder.get('HAL_MemoryTypeBitfieldAttr')(memory_types, context=_ods_context))
    attributes["buffer_usage"] = (buffer_usage if (
    isinstance(buffer_usage, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_BufferUsageBitfieldAttr')) else
      _ods_ir.AttrBuilder.get('HAL_BufferUsageBitfieldAttr')(buffer_usage, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def buffer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def allocator(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def minimum_length(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[2]

  @builtins.property
  def message(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["message"]

  @message.setter
  def message(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["message"] = value

  @builtins.property
  def memory_types(self) -> _ods_ir.Attribute:
    return self.operation.attributes["memory_types"]

  @memory_types.setter
  def memory_types(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memory_types"] = value

  @builtins.property
  def buffer_usage(self) -> _ods_ir.Attribute:
    return self.operation.attributes["buffer_usage"]

  @buffer_usage.setter
  def buffer_usage(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["buffer_usage"] = value

def buffer_assert(buffer, message, allocator, minimum_length, memory_types, buffer_usage, *, loc=None, ip=None) -> BufferAssertOp:
  return BufferAssertOp(buffer=buffer, message=message, allocator=allocator, minimum_length=minimum_length, memory_types=memory_types, buffer_usage=buffer_usage, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class BufferLengthOp(_ods_ir.OpView):
  r"""
  Returns the allocated size of a buffer in bytes.
  May be less than the underlying buffer allocation if this is a subspan or
  view into another buffer.
  """

  OPERATION_NAME = "hal.buffer.length"

  _ODS_REGIONS = (0, True)

  def __init__(self, buffer, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(buffer)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def buffer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IndexType]:
    return self.operation.results[0]

def buffer_length(buffer, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BufferLengthOp(buffer=buffer, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferLoadOp(_ods_ir.OpView):
  r"""
  Loads a value from a buffer by mapping it.
  """

  OPERATION_NAME = "hal.buffer.load"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, source_buffer, source_offset, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(source_buffer)
    operands.append(source_offset)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source_buffer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def source_offset(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def buffer_load(result, source_buffer, source_offset, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return BufferLoadOp(result=result, source_buffer=source_buffer, source_offset=source_offset, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferStoreOp(_ods_ir.OpView):
  r"""
  Stores a value into a buffer by mapping it.
  """

  OPERATION_NAME = "hal.buffer.store"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, target_buffer, target_offset, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    operands.append(target_buffer)
    operands.append(target_offset)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def target_buffer(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def target_offset(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[2]

def buffer_store(value, target_buffer, target_offset, *, loc=None, ip=None) -> BufferStoreOp:
  return BufferStoreOp(value=value, target_buffer=target_buffer, target_offset=target_offset, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class BufferSubspanOp(_ods_ir.OpView):
  r"""
  Returns a reference to a subspan of the buffer.
  """

  OPERATION_NAME = "hal.buffer.subspan"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, source_buffer, source_offset, length, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(source_buffer)
    operands.append(source_offset)
    operands.append(length)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source_buffer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def source_offset(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def length(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[2]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def buffer_subspan(result, source_buffer, source_offset, length, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return BufferSubspanOp(result=result, source_buffer=source_buffer, source_offset=source_offset, length=length, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferUsageOp(_ods_ir.OpView):
  r"""
  Maps buffer usage bits to a runtime `iree_hal_buffer_usage_t` value.
  """

  OPERATION_NAME = "hal.buffer_usage"

  _ODS_REGIONS = (0, True)

  def __init__(self, usage, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["usage"] = (usage if (
    isinstance(usage, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_BufferUsageBitfieldAttr')) else
      _ods_ir.AttrBuilder.get('HAL_BufferUsageBitfieldAttr')(usage, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def usage(self) -> _ods_ir.Attribute:
    return self.operation.attributes["usage"]

  @usage.setter
  def usage(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["usage"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def buffer_usage(usage, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BufferUsageOp(usage=usage, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferViewAssertOp(_ods_ir.OpView):
  r"""
  Asserts that the buffer view contains a data compatible tensor with the
  given encoding. Program execution will abort as if `std.assert` had been
  used.
  """

  OPERATION_NAME = "hal.buffer_view.assert"

  _ODS_REGIONS = (0, True)

  def __init__(self, buffer_view, message, element_type, encoding_type, shape, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(buffer_view)
    operands.append(element_type)
    operands.append(encoding_type)
    operands.extend(_get_op_results_or_values(shape))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["message"] = (message if (
    isinstance(message, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(message, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def buffer_view(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def element_type(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def encoding_type(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[2]

  @builtins.property
  def shape(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 4 + 1
    return self.operation.operands[3:3 + _ods_variadic_group_length]

  @builtins.property
  def message(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["message"]

  @message.setter
  def message(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["message"] = value

def buffer_view_assert(buffer_view, message, element_type, encoding_type, shape, *, loc=None, ip=None) -> BufferViewAssertOp:
  return BufferViewAssertOp(buffer_view=buffer_view, message=message, element_type=element_type, encoding_type=encoding_type, shape=shape, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class BufferViewBufferOp(_ods_ir.OpView):
  r"""
  Returns the buffer backing this view's contents.
  """

  OPERATION_NAME = "hal.buffer_view.buffer"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, buffer_view, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(buffer_view)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def buffer_view(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def buffer_view_buffer(result, buffer_view, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return BufferViewBufferOp(result=result, buffer_view=buffer_view, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferViewCreateOp(_ods_ir.OpView):
  r"""
  Creates a reference to a buffer with a particular shape and element type.
  The buffer is not copied and both the original and view references must be
  synchronized. This makes it easier to associate commonly-carried metadata
  along with the contents.
  """

  OPERATION_NAME = "hal.buffer_view.create"

  _ODS_REGIONS = (0, True)

  def __init__(self, source_buffer, source_offset, source_length, element_type, encoding_type, shape, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(source_buffer)
    operands.append(source_offset)
    operands.append(source_length)
    operands.append(element_type)
    operands.append(encoding_type)
    operands.extend(_get_op_results_or_values(shape))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source_buffer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def source_offset(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def source_length(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[2]

  @builtins.property
  def element_type(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[3]

  @builtins.property
  def encoding_type(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[4]

  @builtins.property
  def shape(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 6 + 1
    return self.operation.operands[5:5 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def buffer_view_create(source_buffer, source_offset, source_length, element_type, encoding_type, shape, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BufferViewCreateOp(source_buffer=source_buffer, source_offset=source_offset, source_length=source_length, element_type=element_type, encoding_type=encoding_type, shape=shape, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferViewDimOp(_ods_ir.OpView):
  r"""
  Returns the value of the given dimension.
  """

  OPERATION_NAME = "hal.buffer_view.dim"

  _ODS_REGIONS = (0, True)

  def __init__(self, buffer_view, index, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(buffer_view)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["index"] = (index if (
    isinstance(index, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IndexAttr')) else
      _ods_ir.AttrBuilder.get('IndexAttr')(index, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def buffer_view(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def index(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["index"]

  @index.setter
  def index(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["index"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IndexType]:
    return self.operation.results[0]

def buffer_view_dim(buffer_view, index, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BufferViewDimOp(buffer_view=buffer_view, index=index, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferViewElementTypeOp(_ods_ir.OpView):
  r"""
  Returns the element type of the buffer view.
  """

  OPERATION_NAME = "hal.buffer_view.element_type"

  _ODS_REGIONS = (0, True)

  def __init__(self, buffer_view, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(buffer_view)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def buffer_view(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def buffer_view_element_type(buffer_view, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BufferViewElementTypeOp(buffer_view=buffer_view, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferViewEncodingTypeOp(_ods_ir.OpView):
  r"""
  Returns the encoding type of the buffer view.
  """

  OPERATION_NAME = "hal.buffer_view.encoding_type"

  _ODS_REGIONS = (0, True)

  def __init__(self, buffer_view, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(buffer_view)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def buffer_view(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def buffer_view_encoding_type(buffer_view, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BufferViewEncodingTypeOp(buffer_view=buffer_view, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferViewRankOp(_ods_ir.OpView):
  r"""
  Returns the rank of the buffer view.
  """

  OPERATION_NAME = "hal.buffer_view.rank"

  _ODS_REGIONS = (0, True)

  def __init__(self, buffer_view, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(buffer_view)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def buffer_view(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IndexType]:
    return self.operation.results[0]

def buffer_view_rank(buffer_view, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BufferViewRankOp(buffer_view=buffer_view, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferViewTraceOp(_ods_ir.OpView):
  r"""
  Traces out to a runtime trace sink (console, log file, etc) the given buffer
  views and titles them with the given key. The key is informational only and
  useful for titling/marking specific sets of buffers for easier searching.
  """

  OPERATION_NAME = "hal.buffer_view.trace"

  _ODS_REGIONS = (0, True)

  def __init__(self, key, operands_, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["key"] = (key if (
    isinstance(key, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(key, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def key(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["key"]

  @key.setter
  def key(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["key"] = value

def buffer_view_trace(key, operands_, *, loc=None, ip=None) -> BufferViewTraceOp:
  return BufferViewTraceOp(key=key, operands_=operands_, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ChannelCreateOp(_ods_ir.OpView):
  r"""
  Returns a new channel with the given rank associated with the given device
  queue. Collective operations using this channel must only be submitted on
  compatible queues.
  
  The group and ID are optional and may be null. A rank or count of -1 can be
  used to indicate a default inherited from the environment or device
  configuration.
  """

  OPERATION_NAME = "hal.channel.create"

  _ODS_REGIONS = (0, True)

  def __init__(self, device, queue_affinity, flags, id, group, rank, count, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(device)
    operands.append(queue_affinity)
    operands.append(id)
    operands.append(group)
    operands.append(rank)
    operands.append(count)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["flags"] = (flags if (
    isinstance(flags, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_ChannelFlagBitfieldAttr')) else
      _ods_ir.AttrBuilder.get('HAL_ChannelFlagBitfieldAttr')(flags, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def device(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def queue_affinity(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def id(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def group(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def rank(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[4]

  @builtins.property
  def count(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[5]

  @builtins.property
  def flags(self) -> _ods_ir.Attribute:
    return self.operation.attributes["flags"]

  @flags.setter
  def flags(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["flags"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def channel_create(device, queue_affinity, flags, id, group, rank, count, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ChannelCreateOp(device=device, queue_affinity=queue_affinity, flags=flags, id=id, group=group, rank=rank, count=count, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ChannelRankAndCountOp(_ods_ir.OpView):
  r"""
  Returns the rank the channel represents as a participant in a collective
  group in `[0, count)` and the total participant count.
  """

  OPERATION_NAME = "hal.channel.rank_and_count"

  _ODS_REGIONS = (0, True)

  def __init__(self, channel, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(channel)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def channel(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rank(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

  @builtins.property
  def count(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[1]

def channel_rank_and_count(channel, *, results=None, loc=None, ip=None) -> _ods_ir.OpResultList:
  return ChannelRankAndCountOp(channel=channel, results=results, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class ChannelSplitOp(_ods_ir.OpView):
  r"""
  Partitions the group associated with the given channel into disjoint
  subgroups for each unique value of color. Each new subgroup contains all
  participants of the same color and within each subgroup the key argument
  is used to define the rank order. When multiple participants in a group
  use the same key the tie will be broken using their rank in the parent
  group. A color of -1 indicates that the rank does not participate in any
  subgroup and will return a null channel.
  """

  OPERATION_NAME = "hal.channel.split"

  _ODS_REGIONS = (0, True)

  def __init__(self, channel, color, key, flags, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(channel)
    operands.append(color)
    operands.append(key)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["flags"] = (flags if (
    isinstance(flags, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_ChannelFlagBitfieldAttr')) else
      _ods_ir.AttrBuilder.get('HAL_ChannelFlagBitfieldAttr')(flags, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def channel(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def color(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def key(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[2]

  @builtins.property
  def flags(self) -> _ods_ir.Attribute:
    return self.operation.attributes["flags"]

  @flags.setter
  def flags(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["flags"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def channel_split(channel, color, key, flags, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ChannelSplitOp(channel=channel, color=color, key=key, flags=flags, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CommandBufferBeginDebugGroupOp(_ods_ir.OpView):
  r"""
  Pushes a new debug group with the given label.
  All commands between this and a mandatory matching call to
  `hal.command_buffer.end_debug_group` will be grouped together with the
  given label.
  """

  OPERATION_NAME = "hal.command_buffer.begin_debug_group"

  _ODS_REGIONS = (0, True)

  def __init__(self, command_buffer, label, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(command_buffer)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["label"] = (label if (
    isinstance(label, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(label, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def command_buffer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def label(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["label"]

  @label.setter
  def label(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["label"] = value

def command_buffer_begin_debug_group(command_buffer, label, *, loc=None, ip=None) -> CommandBufferBeginDebugGroupOp:
  return CommandBufferBeginDebugGroupOp(command_buffer=command_buffer, label=label, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CommandBufferCollectiveOp(_ods_ir.OpView):
  r"""
  Dispatches a collective operation defined by op using the given buffers.
  """

  OPERATION_NAME = "hal.command_buffer.collective"

  _ODS_OPERAND_SEGMENTS = [1,1,1,0,0,0,0,0,0,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, command_buffer, channel, op, element_count, *, param=None, send_buffer=None, send_offset=None, send_length=None, recv_buffer=None, recv_offset=None, recv_length=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(command_buffer)
    operands.append(channel)
    operands.append(element_count)
    operands.append(param)
    operands.append(send_buffer)
    operands.append(send_offset)
    operands.append(send_length)
    operands.append(recv_buffer)
    operands.append(recv_offset)
    operands.append(recv_length)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["op"] = (op if (
    isinstance(op, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_CollectiveAttr')) else
      _ods_ir.AttrBuilder.get('HAL_CollectiveAttr')(op, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def command_buffer(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def channel(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def element_count(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0]

  @builtins.property
  def param(self) -> _Optional[_ods_ir.Value[_ods_ir.IntegerType]]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def send_buffer(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def send_offset(self) -> _Optional[_ods_ir.Value[_ods_ir.IndexType]]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 5)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def send_length(self) -> _Optional[_ods_ir.Value[_ods_ir.IndexType]]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 6)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def recv_buffer(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 7)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def recv_offset(self) -> _Optional[_ods_ir.Value[_ods_ir.IndexType]]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 8)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def recv_length(self) -> _Optional[_ods_ir.Value[_ods_ir.IndexType]]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 9)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def op(self) -> _ods_ir.Attribute:
    return self.operation.attributes["op"]

  @op.setter
  def op(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["op"] = value

def command_buffer_collective(command_buffer, channel, op, element_count, *, param=None, send_buffer=None, send_offset=None, send_length=None, recv_buffer=None, recv_offset=None, recv_length=None, loc=None, ip=None) -> CommandBufferCollectiveOp:
  return CommandBufferCollectiveOp(command_buffer=command_buffer, channel=channel, op=op, element_count=element_count, param=param, send_buffer=send_buffer, send_offset=send_offset, send_length=send_length, recv_buffer=recv_buffer, recv_offset=recv_offset, recv_length=recv_length, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CommandBufferCopyBufferOp(_ods_ir.OpView):
  r"""
  Copies a range of one buffer to another.
  """

  OPERATION_NAME = "hal.command_buffer.copy_buffer"

  _ODS_REGIONS = (0, True)

  def __init__(self, command_buffer, source_buffer, source_offset, target_buffer, target_offset, length, flags, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(command_buffer)
    operands.append(source_buffer)
    operands.append(source_offset)
    operands.append(target_buffer)
    operands.append(target_offset)
    operands.append(length)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["flags"] = (flags if (
    isinstance(flags, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_CopyFlagBitfieldAttr')) else
      _ods_ir.AttrBuilder.get('HAL_CopyFlagBitfieldAttr')(flags, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def command_buffer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def source_buffer(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def source_offset(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[2]

  @builtins.property
  def target_buffer(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def target_offset(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[4]

  @builtins.property
  def length(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[5]

  @builtins.property
  def flags(self) -> _ods_ir.Attribute:
    return self.operation.attributes["flags"]

  @flags.setter
  def flags(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["flags"] = value

def command_buffer_copy_buffer(command_buffer, source_buffer, source_offset, target_buffer, target_offset, length, flags, *, loc=None, ip=None) -> CommandBufferCopyBufferOp:
  return CommandBufferCopyBufferOp(command_buffer=command_buffer, source_buffer=source_buffer, source_offset=source_offset, target_buffer=target_buffer, target_offset=target_offset, length=length, flags=flags, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CommandBufferCreateOp(_ods_ir.OpView):
  r"""
  Returns a command buffer from the device pool ready to begin recording.
  """

  OPERATION_NAME = "hal.command_buffer.create"

  _ODS_REGIONS = (0, True)

  def __init__(self, device, modes, command_categories, queue_affinity, *, binding_capacity=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(device)
    operands.append(queue_affinity)
    if binding_capacity is not None: operands.append(binding_capacity)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["modes"] = (modes if (
    isinstance(modes, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_CommandBufferModeBitfieldAttr')) else
      _ods_ir.AttrBuilder.get('HAL_CommandBufferModeBitfieldAttr')(modes, context=_ods_context))
    attributes["command_categories"] = (command_categories if (
    isinstance(command_categories, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_CommandCategoryBitfieldAttr')) else
      _ods_ir.AttrBuilder.get('HAL_CommandCategoryBitfieldAttr')(command_categories, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def device(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def queue_affinity(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def binding_capacity(self) -> _Optional[_ods_ir.Value[_ods_ir.IndexType]]:
    return None if len(self.operation.operands) < 3 else self.operation.operands[2]

  @builtins.property
  def modes(self) -> _ods_ir.Attribute:
    return self.operation.attributes["modes"]

  @modes.setter
  def modes(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["modes"] = value

  @builtins.property
  def command_categories(self) -> _ods_ir.Attribute:
    return self.operation.attributes["command_categories"]

  @command_categories.setter
  def command_categories(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["command_categories"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def command_buffer_create(device, modes, command_categories, queue_affinity, *, binding_capacity=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CommandBufferCreateOp(device=device, modes=modes, command_categories=command_categories, queue_affinity=queue_affinity, binding_capacity=binding_capacity, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CommandBufferDeviceOp(_ods_ir.OpView):
  r"""
  Used during conversion to access the device used to create a command buffer.
  """

  OPERATION_NAME = "hal.command_buffer.device"

  _ODS_REGIONS = (0, True)

  def __init__(self, command_buffer, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(command_buffer)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def command_buffer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def device(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def command_buffer_device(command_buffer, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CommandBufferDeviceOp(command_buffer=command_buffer, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CommandBufferDispatchIndirectOp(_ods_ir.OpView):
  r"""
  Dispatches an execution request with a deferred workgroup count.
  This is the same as iree_hal_command_buffer_dispatch but the workgroup count
  is read from the given |workgroups_ref| buffer at the specified offset as
  3 uint32_t XYZ values immediately before performing the dispatch. This
  allows prior dispatches within the command sequence to populate the
  workgroup count or the workgroup count to change across submissions of the
  same reusable command buffer.
  
  The provided constant data and binding list will be recorded into the
  command buffer and need not remain live beyond the call. Push constants are
  always 4-byte values and treated as opaque, meaning that they may be
  bit-casted floats, bit-packed booleans, etc. The provided buffers may either
  be HAL buffers or indirect references into the command buffer binding table.
  """

  OPERATION_NAME = "hal.command_buffer.dispatch.indirect"

  _ODS_OPERAND_SEGMENTS = [1,1,1,1,1,-1,-1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, command_buffer, executable, entry_point, workgroups_buffer, workgroups_offset, constants, binding_buffers, binding_offsets, binding_lengths, flags, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(command_buffer)
    operands.append(executable)
    operands.append(entry_point)
    operands.append(workgroups_buffer)
    operands.append(workgroups_offset)
    operands.append(_get_op_results_or_values(constants))
    operands.append(_get_op_results_or_values(binding_buffers))
    operands.append(_get_op_results_or_values(binding_offsets))
    operands.append(_get_op_results_or_values(binding_lengths))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["flags"] = (flags if (
    isinstance(flags, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_DispatchFlagsAttr')) else
      _ods_ir.AttrBuilder.get('HAL_DispatchFlagsAttr')(flags, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def command_buffer(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def executable(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def entry_point(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0]

  @builtins.property
  def workgroups_buffer(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range[0]

  @builtins.property
  def workgroups_offset(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range[0]

  @builtins.property
  def constants(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 5)
    return operand_range

  @builtins.property
  def binding_buffers(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 6)
    return operand_range

  @builtins.property
  def binding_offsets(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 7)
    return operand_range

  @builtins.property
  def binding_lengths(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 8)
    return operand_range

  @builtins.property
  def flags(self) -> _ods_ir.Attribute:
    return self.operation.attributes["flags"]

  @flags.setter
  def flags(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["flags"] = value

def command_buffer_dispatch_indirect(command_buffer, executable, entry_point, workgroups_buffer, workgroups_offset, constants, binding_buffers, binding_offsets, binding_lengths, flags, *, loc=None, ip=None) -> CommandBufferDispatchIndirectOp:
  return CommandBufferDispatchIndirectOp(command_buffer=command_buffer, executable=executable, entry_point=entry_point, workgroups_buffer=workgroups_buffer, workgroups_offset=workgroups_offset, constants=constants, binding_buffers=binding_buffers, binding_offsets=binding_offsets, binding_lengths=binding_lengths, flags=flags, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CommandBufferDispatchOp(_ods_ir.OpView):
  r"""
  Dispatches an execution request.
  The request may execute overlapped with any other transfer operation or
  dispatch made within the same barrier-defined sequence.
  
  The provided constant data and binding list will be recorded into the
  command buffer and need not remain live beyond the call. Push constants are
  always 4-byte values and treated as opaque, meaning that they may be
  bit-casted floats, bit-packed booleans, etc. The provided buffers may either
  be HAL buffers or indirect references into the command buffer binding table.
  """

  OPERATION_NAME = "hal.command_buffer.dispatch"

  _ODS_OPERAND_SEGMENTS = [1,1,1,1,1,1,-1,-1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, command_buffer, executable, entry_point, workgroup_x, workgroup_y, workgroup_z, constants, binding_buffers, binding_offsets, binding_lengths, flags, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(command_buffer)
    operands.append(executable)
    operands.append(entry_point)
    operands.append(workgroup_x)
    operands.append(workgroup_y)
    operands.append(workgroup_z)
    operands.append(_get_op_results_or_values(constants))
    operands.append(_get_op_results_or_values(binding_buffers))
    operands.append(_get_op_results_or_values(binding_offsets))
    operands.append(_get_op_results_or_values(binding_lengths))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["flags"] = (flags if (
    isinstance(flags, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_DispatchFlagsAttr')) else
      _ods_ir.AttrBuilder.get('HAL_DispatchFlagsAttr')(flags, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def command_buffer(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def executable(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def entry_point(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0]

  @builtins.property
  def workgroup_x(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range[0]

  @builtins.property
  def workgroup_y(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range[0]

  @builtins.property
  def workgroup_z(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 5)
    return operand_range[0]

  @builtins.property
  def constants(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 6)
    return operand_range

  @builtins.property
  def binding_buffers(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 7)
    return operand_range

  @builtins.property
  def binding_offsets(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 8)
    return operand_range

  @builtins.property
  def binding_lengths(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 9)
    return operand_range

  @builtins.property
  def flags(self) -> _ods_ir.Attribute:
    return self.operation.attributes["flags"]

  @flags.setter
  def flags(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["flags"] = value

def command_buffer_dispatch(command_buffer, executable, entry_point, workgroup_x, workgroup_y, workgroup_z, constants, binding_buffers, binding_offsets, binding_lengths, flags, *, loc=None, ip=None) -> CommandBufferDispatchOp:
  return CommandBufferDispatchOp(command_buffer=command_buffer, executable=executable, entry_point=entry_point, workgroup_x=workgroup_x, workgroup_y=workgroup_y, workgroup_z=workgroup_z, constants=constants, binding_buffers=binding_buffers, binding_offsets=binding_offsets, binding_lengths=binding_lengths, flags=flags, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CommandBufferEndDebugGroupOp(_ods_ir.OpView):
  r"""
  Pops a debug group from the stack.
  """

  OPERATION_NAME = "hal.command_buffer.end_debug_group"

  _ODS_REGIONS = (0, True)

  def __init__(self, command_buffer, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(command_buffer)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def command_buffer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

def command_buffer_end_debug_group(command_buffer, *, loc=None, ip=None) -> CommandBufferEndDebugGroupOp:
  return CommandBufferEndDebugGroupOp(command_buffer=command_buffer, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CommandBufferExecutionBarrierOp(_ods_ir.OpView):
  r"""
  Defines an execution dependency between all commands recorded before the
  barrier and all commands recorded after the barrier. Only the stages
  provided will be affected.
  """

  OPERATION_NAME = "hal.command_buffer.execution_barrier"

  _ODS_REGIONS = (0, True)

  def __init__(self, command_buffer, source_stage_mask, target_stage_mask, flags, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(command_buffer)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["source_stage_mask"] = (source_stage_mask if (
    isinstance(source_stage_mask, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_ExecutionStageBitfieldAttr')) else
      _ods_ir.AttrBuilder.get('HAL_ExecutionStageBitfieldAttr')(source_stage_mask, context=_ods_context))
    attributes["target_stage_mask"] = (target_stage_mask if (
    isinstance(target_stage_mask, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_ExecutionStageBitfieldAttr')) else
      _ods_ir.AttrBuilder.get('HAL_ExecutionStageBitfieldAttr')(target_stage_mask, context=_ods_context))
    attributes["flags"] = (flags if (
    isinstance(flags, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_ExecutionBarrierFlagBitfieldAttr')) else
      _ods_ir.AttrBuilder.get('HAL_ExecutionBarrierFlagBitfieldAttr')(flags, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def command_buffer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def source_stage_mask(self) -> _ods_ir.Attribute:
    return self.operation.attributes["source_stage_mask"]

  @source_stage_mask.setter
  def source_stage_mask(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["source_stage_mask"] = value

  @builtins.property
  def target_stage_mask(self) -> _ods_ir.Attribute:
    return self.operation.attributes["target_stage_mask"]

  @target_stage_mask.setter
  def target_stage_mask(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["target_stage_mask"] = value

  @builtins.property
  def flags(self) -> _ods_ir.Attribute:
    return self.operation.attributes["flags"]

  @flags.setter
  def flags(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["flags"] = value

def command_buffer_execution_barrier(command_buffer, source_stage_mask, target_stage_mask, flags, *, loc=None, ip=None) -> CommandBufferExecutionBarrierOp:
  return CommandBufferExecutionBarrierOp(command_buffer=command_buffer, source_stage_mask=source_stage_mask, target_stage_mask=target_stage_mask, flags=flags, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CommandBufferFillBufferOp(_ods_ir.OpView):
  r"""
  Fills the target buffer with the given repeating value.
  """

  OPERATION_NAME = "hal.command_buffer.fill_buffer"

  _ODS_REGIONS = (0, True)

  def __init__(self, command_buffer, target_buffer, target_offset, length, pattern, flags, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(command_buffer)
    operands.append(target_buffer)
    operands.append(target_offset)
    operands.append(length)
    operands.append(pattern)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["flags"] = (flags if (
    isinstance(flags, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_FillFlagBitfieldAttr')) else
      _ods_ir.AttrBuilder.get('HAL_FillFlagBitfieldAttr')(flags, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def command_buffer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def target_buffer(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def target_offset(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[2]

  @builtins.property
  def length(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[3]

  @builtins.property
  def pattern(self) -> _ods_ir.Value:
    return self.operation.operands[4]

  @builtins.property
  def flags(self) -> _ods_ir.Attribute:
    return self.operation.attributes["flags"]

  @flags.setter
  def flags(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["flags"] = value

def command_buffer_fill_buffer(command_buffer, target_buffer, target_offset, length, pattern, flags, *, loc=None, ip=None) -> CommandBufferFillBufferOp:
  return CommandBufferFillBufferOp(command_buffer=command_buffer, target_buffer=target_buffer, target_offset=target_offset, length=length, pattern=pattern, flags=flags, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CommandBufferFinalizeOp(_ods_ir.OpView):
  r"""
  Ends recording into the command buffer and prepares it for submission.
  No more commands may be recorded into the command buffer.
  """

  OPERATION_NAME = "hal.command_buffer.finalize"

  _ODS_REGIONS = (0, True)

  def __init__(self, command_buffer, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(command_buffer)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def command_buffer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

def command_buffer_finalize(command_buffer, *, loc=None, ip=None) -> CommandBufferFinalizeOp:
  return CommandBufferFinalizeOp(command_buffer=command_buffer, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CommandBufferUpdateBufferOp(_ods_ir.OpView):
  r"""
  Copies a range of a host buffer into a device buffer. The host buffer
  contents will be captured at the time of the call and embedded in the
  command buffer.
  """

  OPERATION_NAME = "hal.command_buffer.update_buffer"

  _ODS_REGIONS = (0, True)

  def __init__(self, command_buffer, source_buffer, source_size, source_offset, target_buffer, target_offset, length, flags, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(command_buffer)
    operands.append(source_buffer)
    operands.append(source_size)
    operands.append(source_offset)
    operands.append(target_buffer)
    operands.append(target_offset)
    operands.append(length)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["flags"] = (flags if (
    isinstance(flags, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_UpdateFlagBitfieldAttr')) else
      _ods_ir.AttrBuilder.get('HAL_UpdateFlagBitfieldAttr')(flags, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def command_buffer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def source_buffer(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def source_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[2]

  @builtins.property
  def source_offset(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[3]

  @builtins.property
  def target_buffer(self) -> _ods_ir.Value:
    return self.operation.operands[4]

  @builtins.property
  def target_offset(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[5]

  @builtins.property
  def length(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[6]

  @builtins.property
  def flags(self) -> _ods_ir.Attribute:
    return self.operation.attributes["flags"]

  @flags.setter
  def flags(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["flags"] = value

def command_buffer_update_buffer(command_buffer, source_buffer, source_size, source_offset, target_buffer, target_offset, length, flags, *, loc=None, ip=None) -> CommandBufferUpdateBufferOp:
  return CommandBufferUpdateBufferOp(command_buffer=command_buffer, source_buffer=source_buffer, source_size=source_size, source_offset=source_offset, target_buffer=target_buffer, target_offset=target_offset, length=length, flags=flags, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class DeviceAllocatorOp(_ods_ir.OpView):
  r"""
  Returns the allocator that can be used to allocate buffers compatible with
  the device.
  """

  OPERATION_NAME = "hal.device.allocator"

  _ODS_REGIONS = (0, True)

  def __init__(self, device, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(device)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def device(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def device_allocator(device, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return DeviceAllocatorOp(device=device, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DeviceMemoizeOp(_ods_ir.OpView):
  r"""
  Executes the nested region once per device and affinity mask and memoizes
  the results such that future references return the previously memoized
  values. The initial execution may happen on demand or be hoisted to module
  initialization time.
  
  Any uses of the device or affinity specified within the nested region will
  be substituted with the appropriate device and affinity during memoization.
  All other implicitly captured values must be either constant or global
  values available at the time the memoization occurs.
  
  It is valid for the nested region contents to be inlined in place and never
  memoized. This can be useful when diagnosing memoization issues and can be
  forced with the `--iree-hal-memoization=false` flag.
  """

  OPERATION_NAME = "hal.device.memoize"

  _ODS_REGIONS = (1, True)

  def __init__(self, results_, device, queue_affinity, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(device)
    operands.append(queue_affinity)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def device(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def queue_affinity(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def results_(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def device_memoize(results_, device, queue_affinity, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, DeviceMemoizeOp]:
  op = DeviceMemoizeOp(results_=results_, device=device, queue_affinity=queue_affinity, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class DeviceQueryOp(_ods_ir.OpView):
  r"""
  Queries a device configuration parameter with the given key.
  Returns a status indicating whether the pair was recognized/available and if
  it was the value converted to the specified type. Queries must return the
  same value for the lifetime of the module though may vary from run to run.
  
  This is roughly equivalent to the `sysconf` linux syscall
  (https://man7.org/linux/man-pages/man3/sysconf.3.html) in that the exact
  set of keys available and their interpretation is target-dependent.
  
  Users of the op must check the `ok` result before using the value as what
  set of keys is available may change over time. If in doubt: don't use this.
  Each key used adds additional versioning and testing complexity as runtime
  code path changes will explode combinatorially and should be treated with as
  much care as a binary file format change. Keys should be prefixed with `ex.`
  when experimental indicating that they are not expected to be present
  forever; all non-experimental keys should be vetted.
  
  Well-known keys:
  
  * hal.device.id :: {some id pattern}
    Returns 1 if the device identifier matches the given pattern string.
  
  * hal.executable.format :: {some format pattern}
    Returns 1 if the given format is supported by the device loader.
  
  * hal.device :: concurrency
    The maximum concurrently executable submissions, mapping roughly to the
    queue count. The actual concurrency available may be less than this based
    on dynamic runtime parameters such as power/thermal modes, quota limits,
    or user choice.
  
  * hal.dispatch :: concurrency
    The maximum concurrently executable workgroups for a particular dispatch.
    The actual concurrency available may be less depending on device state.
  """

  OPERATION_NAME = "hal.device.query"

  _ODS_REGIONS = (0, True)

  def __init__(self, ok, value, device, category, key, *, default_value=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(device)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["category"] = (category if (
    isinstance(category, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(category, context=_ods_context))
    attributes["key"] = (key if (
    isinstance(key, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(key, context=_ods_context))
    if default_value is not None: attributes["default_value"] = (default_value if (
        isinstance(default_value, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('TypedAttrInterface')) else
          _ods_ir.AttrBuilder.get('TypedAttrInterface')(default_value, context=_ods_context))
    results = []
    results.append(ok)
    results.append(value)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def device(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def category(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["category"]

  @category.setter
  def category(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["category"] = value

  @builtins.property
  def key(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["key"]

  @key.setter
  def key(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["key"] = value

  @builtins.property
  def default_value(self) -> _Optional[_ods_ir.Attribute]:
    if "default_value" not in self.operation.attributes:
      return None
    return self.operation.attributes["default_value"]

  @default_value.setter
  def default_value(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["default_value"] = value
    elif "default_value" in self.operation.attributes:
      del self.operation.attributes["default_value"]

  @default_value.deleter
  def default_value(self):
    del self.operation.attributes["default_value"]

  @builtins.property
  def ok(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

  @builtins.property
  def value(self) -> _ods_ir.OpResult:
    return self.operation.results[1]

def device_query(ok, value, device, category, key, *, default_value=None, loc=None, ip=None) -> _ods_ir.OpResultList:
  return DeviceQueryOp(ok=ok, value=value, device=device, category=category, key=key, default_value=default_value, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class DeviceQueueAllocaOp(_ods_ir.OpView):
  r"""
  Returns a queue-ordered transient buffer that will be available for use when
  the signal fence is reached. The allocation will not be made until the
  wait fence has been reached.
  
  The size of the buffer returned may be larger than the requested size if the
  allocator has specific alignment requirements or minimum allocation sizes.
  
  The buffer handle will remain live so long as there are retainers but the
  contents are undefined before the allocation signal fence has been signaled
  and after the deallocation wait fence has been reached.
  """

  OPERATION_NAME = "hal.device.queue.alloca"

  _ODS_REGIONS = (0, True)

  def __init__(self, device, queue_affinity, wait_fence, signal_fence, pool, memory_types, buffer_usage, result_size, flags, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(device)
    operands.append(queue_affinity)
    operands.append(wait_fence)
    operands.append(signal_fence)
    operands.append(pool)
    operands.append(memory_types)
    operands.append(buffer_usage)
    operands.append(result_size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["flags"] = (flags if (
    isinstance(flags, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_AllocaFlagBitfieldAttr')) else
      _ods_ir.AttrBuilder.get('HAL_AllocaFlagBitfieldAttr')(flags, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def device(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def queue_affinity(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def wait_fence(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def signal_fence(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def pool(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[4]

  @builtins.property
  def memory_types(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[5]

  @builtins.property
  def buffer_usage(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[6]

  @builtins.property
  def result_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[7]

  @builtins.property
  def flags(self) -> _ods_ir.Attribute:
    return self.operation.attributes["flags"]

  @flags.setter
  def flags(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["flags"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def device_queue_alloca(device, queue_affinity, wait_fence, signal_fence, pool, memory_types, buffer_usage, result_size, flags, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return DeviceQueueAllocaOp(device=device, queue_affinity=queue_affinity, wait_fence=wait_fence, signal_fence=signal_fence, pool=pool, memory_types=memory_types, buffer_usage=buffer_usage, result_size=result_size, flags=flags, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DeviceQueueBarrierOp(_ods_ir.OpView):
  r"""
  Signals the provided fence once the wait fence is reached.
  """

  OPERATION_NAME = "hal.device.queue.barrier"

  _ODS_REGIONS = (0, True)

  def __init__(self, device, queue_affinity, wait_fence, signal_fence, flags, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(device)
    operands.append(queue_affinity)
    operands.append(wait_fence)
    operands.append(signal_fence)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["flags"] = (flags if (
    isinstance(flags, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_ExecuteFlagBitfieldAttr')) else
      _ods_ir.AttrBuilder.get('HAL_ExecuteFlagBitfieldAttr')(flags, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def device(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def queue_affinity(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def wait_fence(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def signal_fence(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def flags(self) -> _ods_ir.Attribute:
    return self.operation.attributes["flags"]

  @flags.setter
  def flags(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["flags"] = value

def device_queue_barrier(device, queue_affinity, wait_fence, signal_fence, flags, *, loc=None, ip=None) -> DeviceQueueBarrierOp:
  return DeviceQueueBarrierOp(device=device, queue_affinity=queue_affinity, wait_fence=wait_fence, signal_fence=signal_fence, flags=flags, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class DeviceQueueCopyOp(_ods_ir.OpView):
  r"""
  The source buffer and target buffer must both be visible to the device
  queue performing the copy. In most cases the queue affinity should be set to
  where the target buffer will be consumed so that it has a chance of being
  cached. The source buffer must have transfer-source usage and the target
  buffer must have transfer-target usage.
  
  Note that individual queue transfer operations have a high overhead and they
  should be batched with other operations in command buffers.
  """

  OPERATION_NAME = "hal.device.queue.copy"

  _ODS_REGIONS = (0, True)

  def __init__(self, device, queue_affinity, wait_fence, signal_fence, source_buffer, source_offset, target_buffer, target_offset, length, flags, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(device)
    operands.append(queue_affinity)
    operands.append(wait_fence)
    operands.append(signal_fence)
    operands.append(source_buffer)
    operands.append(source_offset)
    operands.append(target_buffer)
    operands.append(target_offset)
    operands.append(length)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["flags"] = (flags if (
    isinstance(flags, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_CopyFlagBitfieldAttr')) else
      _ods_ir.AttrBuilder.get('HAL_CopyFlagBitfieldAttr')(flags, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def device(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def queue_affinity(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def wait_fence(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def signal_fence(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def source_buffer(self) -> _ods_ir.Value:
    return self.operation.operands[4]

  @builtins.property
  def source_offset(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[5]

  @builtins.property
  def target_buffer(self) -> _ods_ir.Value:
    return self.operation.operands[6]

  @builtins.property
  def target_offset(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[7]

  @builtins.property
  def length(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[8]

  @builtins.property
  def flags(self) -> _ods_ir.Attribute:
    return self.operation.attributes["flags"]

  @flags.setter
  def flags(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["flags"] = value

def device_queue_copy(device, queue_affinity, wait_fence, signal_fence, source_buffer, source_offset, target_buffer, target_offset, length, flags, *, loc=None, ip=None) -> DeviceQueueCopyOp:
  return DeviceQueueCopyOp(device=device, queue_affinity=queue_affinity, wait_fence=wait_fence, signal_fence=signal_fence, source_buffer=source_buffer, source_offset=source_offset, target_buffer=target_buffer, target_offset=target_offset, length=length, flags=flags, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class DeviceQueueDeallocaOp(_ods_ir.OpView):
  r"""
  Deallocates a queue-ordered transient buffer.
  The deallocation will not be made until the wait fence has been reached and
  once the storage is available for reuse the signal fence will be signaled.
  
  After deallocation the contents of the buffer may still be accessible but
  will have undefined contents as other operations reuse the memory.
  """

  OPERATION_NAME = "hal.device.queue.dealloca"

  _ODS_REGIONS = (0, True)

  def __init__(self, device, queue_affinity, wait_fence, signal_fence, buffer, flags, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(device)
    operands.append(queue_affinity)
    operands.append(wait_fence)
    operands.append(signal_fence)
    operands.append(buffer)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["flags"] = (flags if (
    isinstance(flags, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_DeallocaFlagBitfieldAttr')) else
      _ods_ir.AttrBuilder.get('HAL_DeallocaFlagBitfieldAttr')(flags, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def device(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def queue_affinity(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def wait_fence(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def signal_fence(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def buffer(self) -> _ods_ir.Value:
    return self.operation.operands[4]

  @builtins.property
  def flags(self) -> _ods_ir.Attribute:
    return self.operation.attributes["flags"]

  @flags.setter
  def flags(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["flags"] = value

def device_queue_dealloca(device, queue_affinity, wait_fence, signal_fence, buffer, flags, *, loc=None, ip=None) -> DeviceQueueDeallocaOp:
  return DeviceQueueDeallocaOp(device=device, queue_affinity=queue_affinity, wait_fence=wait_fence, signal_fence=signal_fence, buffer=buffer, flags=flags, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class DeviceQueueExecuteIndirectOp(_ods_ir.OpView):
  r"""
  Executes a command buffer on a device queue with the given binding table.
  No commands will execute until the wait fence has been reached and the
  signal fence will be signaled when all commands have completed.
  """

  OPERATION_NAME = "hal.device.queue.execute.indirect"

  _ODS_REGIONS = (0, True)

  def __init__(self, device, queue_affinity, wait_fence, signal_fence, command_buffer, binding_buffers, binding_offsets, binding_lengths, flags, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(device)
    operands.append(queue_affinity)
    operands.append(wait_fence)
    operands.append(signal_fence)
    operands.append(command_buffer)
    operands.extend(_get_op_results_or_values(binding_buffers))
    operands.extend(_get_op_results_or_values(binding_offsets))
    operands.extend(_get_op_results_or_values(binding_lengths))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["flags"] = (flags if (
    isinstance(flags, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_ExecuteFlagBitfieldAttr')) else
      _ods_ir.AttrBuilder.get('HAL_ExecuteFlagBitfieldAttr')(flags, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def device(self) -> _ods_ir.Value:
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 5, 3, 0, 0)
    return self.operation.operands[start]

  @builtins.property
  def queue_affinity(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 5, 3, 1, 0)
    return self.operation.operands[start]

  @builtins.property
  def wait_fence(self) -> _ods_ir.Value:
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 5, 3, 2, 0)
    return self.operation.operands[start]

  @builtins.property
  def signal_fence(self) -> _ods_ir.Value:
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 5, 3, 3, 0)
    return self.operation.operands[start]

  @builtins.property
  def command_buffer(self) -> _ods_ir.Value:
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 5, 3, 4, 0)
    return self.operation.operands[start]

  @builtins.property
  def binding_buffers(self) -> _ods_ir.OpOperandList:
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 5, 3, 5, 0)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def binding_offsets(self) -> _ods_ir.OpOperandList:
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 5, 3, 5, 1)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def binding_lengths(self) -> _ods_ir.OpOperandList:
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 5, 3, 5, 2)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def flags(self) -> _ods_ir.Attribute:
    return self.operation.attributes["flags"]

  @flags.setter
  def flags(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["flags"] = value

def device_queue_execute_indirect(device, queue_affinity, wait_fence, signal_fence, command_buffer, binding_buffers, binding_offsets, binding_lengths, flags, *, loc=None, ip=None) -> DeviceQueueExecuteIndirectOp:
  return DeviceQueueExecuteIndirectOp(device=device, queue_affinity=queue_affinity, wait_fence=wait_fence, signal_fence=signal_fence, command_buffer=command_buffer, binding_buffers=binding_buffers, binding_offsets=binding_offsets, binding_lengths=binding_lengths, flags=flags, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class DeviceQueueExecuteOp(_ods_ir.OpView):
  r"""
  Executes a command buffer on a device queue.
  No commands will execute until the wait fence has been reached and the
  signal fence will be signaled when all commands have completed.
  """

  OPERATION_NAME = "hal.device.queue.execute"

  _ODS_REGIONS = (0, True)

  def __init__(self, device, queue_affinity, wait_fence, signal_fence, command_buffer, flags, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(device)
    operands.append(queue_affinity)
    operands.append(wait_fence)
    operands.append(signal_fence)
    operands.append(command_buffer)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["flags"] = (flags if (
    isinstance(flags, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_ExecuteFlagBitfieldAttr')) else
      _ods_ir.AttrBuilder.get('HAL_ExecuteFlagBitfieldAttr')(flags, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def device(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def queue_affinity(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def wait_fence(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def signal_fence(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def command_buffer(self) -> _ods_ir.Value:
    return self.operation.operands[4]

  @builtins.property
  def flags(self) -> _ods_ir.Attribute:
    return self.operation.attributes["flags"]

  @flags.setter
  def flags(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["flags"] = value

def device_queue_execute(device, queue_affinity, wait_fence, signal_fence, command_buffer, flags, *, loc=None, ip=None) -> DeviceQueueExecuteOp:
  return DeviceQueueExecuteOp(device=device, queue_affinity=queue_affinity, wait_fence=wait_fence, signal_fence=signal_fence, command_buffer=command_buffer, flags=flags, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class DeviceQueueFillOp(_ods_ir.OpView):
  r"""
  The target buffer must be visible to the device queue performing the update.
  In most cases the queue affinity should be set to where the target buffer
  will be consumed so that it has a chance of being cached.
  
  Note that individual queue transfer operations have a high overhead and they
  should be batched with other operations in command buffers.
  """

  OPERATION_NAME = "hal.device.queue.fill"

  _ODS_REGIONS = (0, True)

  def __init__(self, device, queue_affinity, wait_fence, signal_fence, target_buffer, target_offset, length, pattern, flags, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(device)
    operands.append(queue_affinity)
    operands.append(wait_fence)
    operands.append(signal_fence)
    operands.append(target_buffer)
    operands.append(target_offset)
    operands.append(length)
    operands.append(pattern)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["flags"] = (flags if (
    isinstance(flags, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_FillFlagBitfieldAttr')) else
      _ods_ir.AttrBuilder.get('HAL_FillFlagBitfieldAttr')(flags, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def device(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def queue_affinity(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def wait_fence(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def signal_fence(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def target_buffer(self) -> _ods_ir.Value:
    return self.operation.operands[4]

  @builtins.property
  def target_offset(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[5]

  @builtins.property
  def length(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[6]

  @builtins.property
  def pattern(self) -> _ods_ir.Value:
    return self.operation.operands[7]

  @builtins.property
  def flags(self) -> _ods_ir.Attribute:
    return self.operation.attributes["flags"]

  @flags.setter
  def flags(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["flags"] = value

def device_queue_fill(device, queue_affinity, wait_fence, signal_fence, target_buffer, target_offset, length, pattern, flags, *, loc=None, ip=None) -> DeviceQueueFillOp:
  return DeviceQueueFillOp(device=device, queue_affinity=queue_affinity, wait_fence=wait_fence, signal_fence=signal_fence, target_buffer=target_buffer, target_offset=target_offset, length=length, pattern=pattern, flags=flags, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class DeviceQueueFlushOp(_ods_ir.OpView):
  r"""
  Flushes any locally-pending submissions in the queue.
  When submitting many queue operations this can be used to eagerly flush
  earlier submissions while later ones are still being constructed.
  This may be a no-op.
  """

  OPERATION_NAME = "hal.device.queue.flush"

  _ODS_REGIONS = (0, True)

  def __init__(self, device, queue_affinity, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(device)
    operands.append(queue_affinity)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def device(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def queue_affinity(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

def device_queue_flush(device, queue_affinity, *, loc=None, ip=None) -> DeviceQueueFlushOp:
  return DeviceQueueFlushOp(device=device, queue_affinity=queue_affinity, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class DeviceQueueReadOp(_ods_ir.OpView):
  r"""
  Enqueues a file read operation that streams a segment of the source file
  defined by the source offset and length into the target HAL buffer at the
  specified target offset. The queue affinity should be set to where the
  target buffer will be consumed. The source file must have read permission
  and the target buffer must have transfer-target usage. Read failure will
  result in propagated semaphore failure or device loss.
  """

  OPERATION_NAME = "hal.device.queue.read"

  _ODS_REGIONS = (0, True)

  def __init__(self, device, queue_affinity, wait_fence, signal_fence, source_file, source_offset, target_buffer, target_offset, length, flags, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(device)
    operands.append(queue_affinity)
    operands.append(wait_fence)
    operands.append(signal_fence)
    operands.append(source_file)
    operands.append(source_offset)
    operands.append(target_buffer)
    operands.append(target_offset)
    operands.append(length)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["flags"] = (flags if (
    isinstance(flags, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_ReadFlagBitfieldAttr')) else
      _ods_ir.AttrBuilder.get('HAL_ReadFlagBitfieldAttr')(flags, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def device(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def queue_affinity(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def wait_fence(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def signal_fence(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def source_file(self) -> _ods_ir.Value:
    return self.operation.operands[4]

  @builtins.property
  def source_offset(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[5]

  @builtins.property
  def target_buffer(self) -> _ods_ir.Value:
    return self.operation.operands[6]

  @builtins.property
  def target_offset(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[7]

  @builtins.property
  def length(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[8]

  @builtins.property
  def flags(self) -> _ods_ir.Attribute:
    return self.operation.attributes["flags"]

  @flags.setter
  def flags(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["flags"] = value

def device_queue_read(device, queue_affinity, wait_fence, signal_fence, source_file, source_offset, target_buffer, target_offset, length, flags, *, loc=None, ip=None) -> DeviceQueueReadOp:
  return DeviceQueueReadOp(device=device, queue_affinity=queue_affinity, wait_fence=wait_fence, signal_fence=signal_fence, source_file=source_file, source_offset=source_offset, target_buffer=target_buffer, target_offset=target_offset, length=length, flags=flags, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class DeviceQueueUpdateOp(_ods_ir.OpView):
  r"""
  The provided host source buffer will be captured and need not remain live or
  unchanged while the operation is queued. The target buffer must be visible
  to the device queue performing the update. In most cases the queue affinity
  should be set to where the target buffer will be consumed so that it has a
  chance of being cached.
  
  Some implementations may have limits on the size of the update or may
  perform poorly if the size is larger than an implementation-defined limit.
  Updates should be kept as small and infrequent as possible.
  
  Note that individual queue transfer operations have a high overhead and they
  should be batched with other operations in command buffers.
  """

  OPERATION_NAME = "hal.device.queue.update"

  _ODS_REGIONS = (0, True)

  def __init__(self, device, queue_affinity, wait_fence, signal_fence, source_buffer, source_offset, target_buffer, target_offset, length, flags, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(device)
    operands.append(queue_affinity)
    operands.append(wait_fence)
    operands.append(signal_fence)
    operands.append(source_buffer)
    operands.append(source_offset)
    operands.append(target_buffer)
    operands.append(target_offset)
    operands.append(length)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["flags"] = (flags if (
    isinstance(flags, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_UpdateFlagBitfieldAttr')) else
      _ods_ir.AttrBuilder.get('HAL_UpdateFlagBitfieldAttr')(flags, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def device(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def queue_affinity(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def wait_fence(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def signal_fence(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def source_buffer(self) -> _ods_ir.Value:
    return self.operation.operands[4]

  @builtins.property
  def source_offset(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[5]

  @builtins.property
  def target_buffer(self) -> _ods_ir.Value:
    return self.operation.operands[6]

  @builtins.property
  def target_offset(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[7]

  @builtins.property
  def length(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[8]

  @builtins.property
  def flags(self) -> _ods_ir.Attribute:
    return self.operation.attributes["flags"]

  @flags.setter
  def flags(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["flags"] = value

def device_queue_update(device, queue_affinity, wait_fence, signal_fence, source_buffer, source_offset, target_buffer, target_offset, length, flags, *, loc=None, ip=None) -> DeviceQueueUpdateOp:
  return DeviceQueueUpdateOp(device=device, queue_affinity=queue_affinity, wait_fence=wait_fence, signal_fence=signal_fence, source_buffer=source_buffer, source_offset=source_offset, target_buffer=target_buffer, target_offset=target_offset, length=length, flags=flags, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class DeviceQueueWriteOp(_ods_ir.OpView):
  r"""
  Enqueues a file write operation that streams a segment of the source HAL
  buffer defined by the source offset and length into the target file at the
  specified target offset. The queue affinity should be set to where the
  source buffer was produced. The source buffer must have transfer-source
  usage and the target file must have write permission. Write failure will
  result in propagated semaphore failure or device loss.
  """

  OPERATION_NAME = "hal.device.queue.write"

  _ODS_REGIONS = (0, True)

  def __init__(self, device, queue_affinity, wait_fence, signal_fence, source_buffer, source_offset, target_file, target_offset, length, flags, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(device)
    operands.append(queue_affinity)
    operands.append(wait_fence)
    operands.append(signal_fence)
    operands.append(source_buffer)
    operands.append(source_offset)
    operands.append(target_file)
    operands.append(target_offset)
    operands.append(length)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["flags"] = (flags if (
    isinstance(flags, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_WriteFlagBitfieldAttr')) else
      _ods_ir.AttrBuilder.get('HAL_WriteFlagBitfieldAttr')(flags, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def device(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def queue_affinity(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def wait_fence(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def signal_fence(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def source_buffer(self) -> _ods_ir.Value:
    return self.operation.operands[4]

  @builtins.property
  def source_offset(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[5]

  @builtins.property
  def target_file(self) -> _ods_ir.Value:
    return self.operation.operands[6]

  @builtins.property
  def target_offset(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[7]

  @builtins.property
  def length(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[8]

  @builtins.property
  def flags(self) -> _ods_ir.Attribute:
    return self.operation.attributes["flags"]

  @flags.setter
  def flags(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["flags"] = value

def device_queue_write(device, queue_affinity, wait_fence, signal_fence, source_buffer, source_offset, target_file, target_offset, length, flags, *, loc=None, ip=None) -> DeviceQueueWriteOp:
  return DeviceQueueWriteOp(device=device, queue_affinity=queue_affinity, wait_fence=wait_fence, signal_fence=signal_fence, source_buffer=source_buffer, source_offset=source_offset, target_file=target_file, target_offset=target_offset, length=length, flags=flags, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class DeviceResolveOp(_ods_ir.OpView):
  r"""
  Examples:
  ```
  // Returns a HAL device.
  = hal.device.resolve on(#something) : !hal.device
  // Returns a HAL device, allocator, and (optional) queue affinity.
  = hal.device.resolve on(#something) : !hal.device, !hal.allocator, i64
  // Returns a HAL allocator and (optional) queue affinity.
  = hal.device.resolve on(#something) : !hal.allocator, i64
  // Returns "any" device. Should only be used as a fallback.
  = hal.device.resolve : !hal.device
  ```
  """

  OPERATION_NAME = "hal.device.resolve"

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, *, affinity=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('HAL_DeviceAffinityAttr')) else
          _ods_ir.AttrBuilder.get('HAL_DeviceAffinityAttr')(affinity, context=_ods_context))
    results = []
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def results_(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def device_resolve(results_, *, affinity=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, DeviceResolveOp]:
  op = DeviceResolveOp(results_=results_, affinity=affinity, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class DevicesCountOp(_ods_ir.OpView):
  r"""
  Returns the total number of available devices registered at runtime.
  """

  OPERATION_NAME = "hal.devices.count"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IndexType]:
    return self.operation.results[0]

def devices_count(*, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return DevicesCountOp(results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DevicesGetOp(_ods_ir.OpView):
  r"""
  Returns the device with the given index in the [0, hal.devices.count) range.
  Devices may be lazily initialized upon first use.
  """

  OPERATION_NAME = "hal.devices.get"

  _ODS_REGIONS = (0, True)

  def __init__(self, index, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(index)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def index(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def devices_get(index, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return DevicesGetOp(index=index, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DispatchExternOp(_ods_ir.OpView):
  r"""
  Dispatches some number of workgroups across a 3-dimensional grid using a
  function defined externally in one or more referenced objects. Objects are
  declared per executable target and selected automatically during linking
  based on where the dispatch is used. Semantically this is equivalent to
  a `flow.dispatch.workgroups` but with the workgroup region invisible to the
  compiler. See `hal.executable` for more information about object linkage.
  
  Note that since this happens at tensor level the dispatch operation has
  value semantics: some tensors (and optionally other primitive types) are
  consumed and one or more new result tensors are produced. Inside each
  workgroup, however, the input and output tensors are available for arbitrary
  loads and stores. In many cases each workgroup will load some particular
  tile(s) from the input tensors and store some particular tile(s) to the
  output tensors unique to that workgroup. Though it's possible for multiple
  workgroups to load the same regions of the input tensors behavior is
  undefined if multiple workgroups store to the same regions of the output
  tensors. Codegen guarantees this behavior but when sourcing externally
  authored dispatch functions it's critical that this behavior is observed.
  
  Though the representation is similar to the GPU-style grid dispatch model
  here we still have not yet allocated buffers, determined the target device
  for execution, or even completed fully resolving shapes/types/etc. Because
  of this it's important that the workgroup body use the platform-dependent
  primitives for accessing workgroup ID, size, and count intrinsics instead
  of hardcoding them to a particular set of values. Assume that any workgroup
  dispatch may end up being specialized for several different target devices
  and even several different variants for a particular target device
  (differing workgroup sizes, etc). To aid deduplication code producing these
  external dispatches should try not to specialize early for particular shapes
  and instead emit the most generic code possible as having 500 slightly
  different `hal.dispatch.extern` ops pointing at the same object file is
  likely to require 500 copies of the object instead of 500 calls to the same
  object.
  
  Because at this point in the layering devices have not yet been selected the
  workgroup count cannot be fully evaluated. Instead workload parameters are
  captured that are then passed to a function that when later evaluated
  computes the actual workgroup count based on target information. The
  workload is not limited to the 3D XYZ grid dispatch of the workgroup count
  and can contain any number of parameters used to compute it. If workgroup
  size or distribution varies based on the target device a `!hal.device`
  argument can be used by the workgroup count calculation region to factor in
  device parameters. See `hal.device.query` for more information on how to
  query information.
  
  ```mlir
  %r = hal.dispatch.extern "some_function"[%c5, %c5](%0, %1)
      : (tensor<5x5xf32>, tensor<5xf32>) -> tensor<5x5xf32>
    ...
  ```
  
  The number of results of the operation is equal to the number of results
  in the type signature (`(tensor<5x5xf32>, tensor<5xf32>) -> tensor<5x5xf32>`).
  Each tensor argument and result in the type signature has a corresponding
  pipeline layout slot and must be declared. If multiple arguments or results
  share the same layout slot they can be aliased using the `bindings`
  attribute and otherwise each is assumed unique.
  
  There are no `arguments` operands for results, but a result can be tied an
  argument by writing the argument operand's SSA value instead of its type:
  E.g., in the above example, `-> %0` would tie the first argument to the
  result. In that case, there would be no separate block argument for the
  result.
  
  Objects for multiple targets can be specified and the ones used are selected
  based on their target and an optional condition region that returns true if
  the variant is valid for use on the provided runtime `!hal.device`. If no
  variants within an executable are valid then loading will fail at runtime.
  If multiple variants are valid the first valid one found will be loaded and
  used for execution.
  """

  OPERATION_NAME = "hal.dispatch.extern"

  _ODS_OPERAND_SEGMENTS = [-1,-1,-1,-1,]

  _ODS_REGIONS = (1, False)

  def __init__(self, results_, export_name, workload, arguments, argument_dims, result_dims, layout, targets, target_ordinals, target_objects, num_target_regions, *, workgroup_size=None, subgroup_size=None, workgroup_local_memory=None, tied_operands=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(workload))
    operands.append(_get_op_results_or_values(arguments))
    operands.append(_get_op_results_or_values(argument_dims))
    operands.append(_get_op_results_or_values(result_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["export_name"] = (export_name if (
    isinstance(export_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(export_name, context=_ods_context))
    attributes["layout"] = (layout if (
    isinstance(layout, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_PipelineLayoutAttr')) else
      _ods_ir.AttrBuilder.get('HAL_PipelineLayoutAttr')(layout, context=_ods_context))
    attributes["targets"] = (targets if (
    isinstance(targets, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(targets, context=_ods_context))
    attributes["target_ordinals"] = (target_ordinals if (
    isinstance(target_ordinals, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_OrdinalArrayAttr')) else
      _ods_ir.AttrBuilder.get('HAL_OrdinalArrayAttr')(target_ordinals, context=_ods_context))
    attributes["target_objects"] = (target_objects if (
    isinstance(target_objects, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(target_objects, context=_ods_context))
    if workgroup_size is not None: attributes["workgroup_size"] = (workgroup_size if (
        isinstance(workgroup_size, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('HAL_WorkgroupSizeAttr')) else
          _ods_ir.AttrBuilder.get('HAL_WorkgroupSizeAttr')(workgroup_size, context=_ods_context))
    if subgroup_size is not None: attributes["subgroup_size"] = (subgroup_size if (
        isinstance(subgroup_size, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('HAL_SubgroupSizeAttr')) else
          _ods_ir.AttrBuilder.get('HAL_SubgroupSizeAttr')(subgroup_size, context=_ods_context))
    if workgroup_local_memory is not None: attributes["workgroup_local_memory"] = (workgroup_local_memory if (
        isinstance(workgroup_local_memory, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('IndexAttr')) else
          _ods_ir.AttrBuilder.get('IndexAttr')(workgroup_local_memory, context=_ods_context))
    if tied_operands is not None: attributes["tied_operands"] = (tied_operands if (
        isinstance(tied_operands, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Util_TiedOpStorageAttr')) else
          _ods_ir.AttrBuilder.get('Util_TiedOpStorageAttr')(tied_operands, context=_ods_context))
    results = []
    results.extend(results_)
    _ods_successors = None
    regions = 1 + num_target_regions
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def workload(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def arguments(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def argument_dims(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def result_dims(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def export_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["export_name"]

  @export_name.setter
  def export_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["export_name"] = value

  @builtins.property
  def layout(self) -> _ods_ir.Attribute:
    return self.operation.attributes["layout"]

  @layout.setter
  def layout(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["layout"] = value

  @builtins.property
  def targets(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["targets"]

  @targets.setter
  def targets(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["targets"] = value

  @builtins.property
  def target_ordinals(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["target_ordinals"]

  @target_ordinals.setter
  def target_ordinals(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["target_ordinals"] = value

  @builtins.property
  def target_objects(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["target_objects"]

  @target_objects.setter
  def target_objects(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["target_objects"] = value

  @builtins.property
  def workgroup_size(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "workgroup_size" not in self.operation.attributes:
      return None
    return self.operation.attributes["workgroup_size"]

  @workgroup_size.setter
  def workgroup_size(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["workgroup_size"] = value
    elif "workgroup_size" in self.operation.attributes:
      del self.operation.attributes["workgroup_size"]

  @workgroup_size.deleter
  def workgroup_size(self):
    del self.operation.attributes["workgroup_size"]

  @builtins.property
  def subgroup_size(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "subgroup_size" not in self.operation.attributes:
      return None
    return self.operation.attributes["subgroup_size"]

  @subgroup_size.setter
  def subgroup_size(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["subgroup_size"] = value
    elif "subgroup_size" in self.operation.attributes:
      del self.operation.attributes["subgroup_size"]

  @subgroup_size.deleter
  def subgroup_size(self):
    del self.operation.attributes["subgroup_size"]

  @builtins.property
  def workgroup_local_memory(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "workgroup_local_memory" not in self.operation.attributes:
      return None
    return self.operation.attributes["workgroup_local_memory"]

  @workgroup_local_memory.setter
  def workgroup_local_memory(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["workgroup_local_memory"] = value
    elif "workgroup_local_memory" in self.operation.attributes:
      del self.operation.attributes["workgroup_local_memory"]

  @workgroup_local_memory.deleter
  def workgroup_local_memory(self):
    del self.operation.attributes["workgroup_local_memory"]

  @builtins.property
  def tied_operands(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tied_operands" not in self.operation.attributes:
      return None
    return self.operation.attributes["tied_operands"]

  @tied_operands.setter
  def tied_operands(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tied_operands"] = value
    elif "tied_operands" in self.operation.attributes:
      del self.operation.attributes["tied_operands"]

  @tied_operands.deleter
  def tied_operands(self):
    del self.operation.attributes["tied_operands"]

  @builtins.property
  def results_(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def workgroup_count(self) -> _ods_ir.Region:
    return self.regions[0]

  @builtins.property
  def target_regions(self) -> _ods_ir.RegionSequence:
    return self.regions[1:]

def dispatch_extern(results_, export_name, workload, arguments, argument_dims, result_dims, layout, targets, target_ordinals, target_objects, num_target_regions, *, workgroup_size=None, subgroup_size=None, workgroup_local_memory=None, tied_operands=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, DispatchExternOp]:
  op = DispatchExternOp(results_=results_, export_name=export_name, workload=workload, arguments=arguments, argument_dims=argument_dims, result_dims=result_dims, layout=layout, targets=targets, target_ordinals=target_ordinals, target_objects=target_objects, num_target_regions=num_target_regions, workgroup_size=workgroup_size, subgroup_size=subgroup_size, workgroup_local_memory=workgroup_local_memory, tied_operands=tied_operands, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class ElementTypeOp(_ods_ir.OpView):
  r"""
  Maps an MLIR type to a runtime `iree_hal_element_type_t` value for all types
  that are convertable.
  """

  OPERATION_NAME = "hal.element_type"

  _ODS_REGIONS = (0, True)

  def __init__(self, type_, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["type"] = (type_ if (
    isinstance(type_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(type_, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def type_(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["type"]

  @type_.setter
  def type_(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["type"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def element_type(type_, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ElementTypeOp(type_=type_, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class EncodingTypeOp(_ods_ir.OpView):
  r"""
  Maps an MLIR encoding to a runtime `iree_hal_encoding_type_t` value for all
  encodings that are convertable.
  """

  OPERATION_NAME = "hal.encoding_type"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, encoding=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if encoding is not None: attributes["encoding"] = (encoding if (
        isinstance(encoding, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('AnyAttr')) else
          _ods_ir.AttrBuilder.get('AnyAttr')(encoding, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def encoding(self) -> _Optional[_ods_ir.Attribute]:
    if "encoding" not in self.operation.attributes:
      return None
    return self.operation.attributes["encoding"]

  @encoding.setter
  def encoding(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["encoding"] = value
    elif "encoding" in self.operation.attributes:
      del self.operation.attributes["encoding"]

  @encoding.deleter
  def encoding(self):
    del self.operation.attributes["encoding"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def encoding_type(*, encoding=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return EncodingTypeOp(encoding=encoding, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ExFileFromMemoryOp(_ods_ir.OpView):
  r"""
  Returns a file handle that is backed by the given `buffer` contents.
  Behavior is undefined if the buffer contents change while the accesses are
  in-flight.
  
  Experimental as the exact interface for getting files from module contents
  still needs iteration. Most hardware APIs require a file descriptor or
  native platform handle but here we only have host pointers. When
  memory-mapped some systems allow for retrieval of the platform handle from
  a virtual address (GetMappedFileNameA/posix_mem_offset) but the APIs are
  sketchy and likely slow. Instead we should probably have a way to query for
  a file handle derived from the calling module by stack-walking and asking
  the VM module for its handle. Until we can figure this out this method will
  be marked epxerimental.
  """

  OPERATION_NAME = "hal.ex.file.from_memory"

  _ODS_REGIONS = (0, True)

  def __init__(self, device, queue_affinity, access, buffer, offset, length, flags, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(device)
    operands.append(queue_affinity)
    operands.append(buffer)
    operands.append(offset)
    operands.append(length)
    operands.append(flags)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["access"] = (access if (
    isinstance(access, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_MemoryAccessBitfieldAttr')) else
      _ods_ir.AttrBuilder.get('HAL_MemoryAccessBitfieldAttr')(access, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def device(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def queue_affinity(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def buffer(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def offset(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[3]

  @builtins.property
  def length(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[4]

  @builtins.property
  def flags(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[5]

  @builtins.property
  def access(self) -> _ods_ir.Attribute:
    return self.operation.attributes["access"]

  @access.setter
  def access(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["access"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def ex_file_from_memory(device, queue_affinity, access, buffer, offset, length, flags, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ExFileFromMemoryOp(device=device, queue_affinity=queue_affinity, access=access, buffer=buffer, offset=offset, length=length, flags=flags, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ExecutableBinaryOp(_ods_ir.OpView):
  r"""
  A compiled executable binary with an optional nested module containing the
  IR prior to serialization (for debugging).
  """

  OPERATION_NAME = "hal.executable.binary"

  _ODS_REGIONS = (0, True)

  def __init__(self, sym_name, format, data, *, sym_visibility=None, mime_type=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if sym_visibility is not None: attributes["sym_visibility"] = (sym_visibility if (
        isinstance(sym_visibility, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(sym_visibility, context=_ods_context))
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["format"] = (format if (
    isinstance(format, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(format, context=_ods_context))
    attributes["data"] = (data if (
    isinstance(data, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Util_AnySerializableAttr')) else
      _ods_ir.AttrBuilder.get('Util_AnySerializableAttr')(data, context=_ods_context))
    if mime_type is not None: attributes["mime_type"] = (mime_type if (
        isinstance(mime_type, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(mime_type, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_visibility(self) -> _Optional[_ods_ir.StringAttr]:
    if "sym_visibility" not in self.operation.attributes:
      return None
    return self.operation.attributes["sym_visibility"]

  @sym_visibility.setter
  def sym_visibility(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["sym_visibility"] = value
    elif "sym_visibility" in self.operation.attributes:
      del self.operation.attributes["sym_visibility"]

  @sym_visibility.deleter
  def sym_visibility(self):
    del self.operation.attributes["sym_visibility"]

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def format(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["format"]

  @format.setter
  def format(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["format"] = value

  @builtins.property
  def data(self) -> _ods_ir.Attribute:
    return self.operation.attributes["data"]

  @data.setter
  def data(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["data"] = value

  @builtins.property
  def mime_type(self) -> _Optional[_ods_ir.StringAttr]:
    if "mime_type" not in self.operation.attributes:
      return None
    return self.operation.attributes["mime_type"]

  @mime_type.setter
  def mime_type(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["mime_type"] = value
    elif "mime_type" in self.operation.attributes:
      del self.operation.attributes["mime_type"]

  @mime_type.deleter
  def mime_type(self):
    del self.operation.attributes["mime_type"]

def executable_binary(sym_name, format, data, *, sym_visibility=None, mime_type=None, loc=None, ip=None) -> ExecutableBinaryOp:
  return ExecutableBinaryOp(sym_name=sym_name, format=format, data=data, sym_visibility=sym_visibility, mime_type=mime_type, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ExecutableCalculateWorkgroupsOp(_ods_ir.OpView):
  r"""
  Calculates the workgroup count (grid XYZ) based on the given workload using
  the workgroup count calculation region of the target
  `hal.executable.export` op.
  """

  OPERATION_NAME = "hal.executable.calculate_workgroups"

  _ODS_REGIONS = (0, True)

  def __init__(self, device, entry_point, workload, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(device)
    operands.extend(_get_op_results_or_values(workload))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["entry_point"] = (entry_point if (
    isinstance(entry_point, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('SymbolRefAttr')(entry_point, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def device(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def workload(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def entry_point(self) -> _ods_ir.SymbolRefAttr:
    return self.operation.attributes["entry_point"]

  @entry_point.setter
  def entry_point(self, value: _ods_ir.SymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["entry_point"] = value

  @builtins.property
  def workgroup_x(self) -> _ods_ir.OpResult[_ods_ir.IndexType]:
    return self.operation.results[0]

  @builtins.property
  def workgroup_y(self) -> _ods_ir.OpResult[_ods_ir.IndexType]:
    return self.operation.results[1]

  @builtins.property
  def workgroup_z(self) -> _ods_ir.OpResult[_ods_ir.IndexType]:
    return self.operation.results[2]

def executable_calculate_workgroups(device, entry_point, workload, *, results=None, loc=None, ip=None) -> _ods_ir.OpResultList:
  return ExecutableCalculateWorkgroupsOp(device=device, entry_point=entry_point, workload=workload, results=results, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class ExecutableConditionOp(_ods_ir.OpView):
  r"""
  Variants are selected based on their target and this optional condition
  op that returns true if the variant is valid for use on the provided
  runtime `!hal.device`. If no variants within an executable are valid then
  loading will fail at runtime. If multiple variants are valid the first valid
  one found will be loaded and used for execution.
  """

  OPERATION_NAME = "hal.executable.condition"

  _ODS_REGIONS = (1, True)

  def __init__(self, function_type, *, arg_attrs=None, res_attrs=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["function_type"] = (function_type if (
    isinstance(function_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_960')) else
      _ods_ir.AttrBuilder.get('anonymous_960')(function_type, context=_ods_context))
    if arg_attrs is not None: attributes["arg_attrs"] = (arg_attrs if (
        isinstance(arg_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(arg_attrs, context=_ods_context))
    if res_attrs is not None: attributes["res_attrs"] = (res_attrs if (
        isinstance(res_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(res_attrs, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def function_type(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["function_type"]

  @function_type.setter
  def function_type(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["function_type"] = value

  @builtins.property
  def arg_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "arg_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["arg_attrs"]

  @arg_attrs.setter
  def arg_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["arg_attrs"] = value
    elif "arg_attrs" in self.operation.attributes:
      del self.operation.attributes["arg_attrs"]

  @arg_attrs.deleter
  def arg_attrs(self):
    del self.operation.attributes["arg_attrs"]

  @builtins.property
  def res_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "res_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["res_attrs"]

  @res_attrs.setter
  def res_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["res_attrs"] = value
    elif "res_attrs" in self.operation.attributes:
      del self.operation.attributes["res_attrs"]

  @res_attrs.deleter
  def res_attrs(self):
    del self.operation.attributes["res_attrs"]

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def executable_condition(function_type, *, arg_attrs=None, res_attrs=None, loc=None, ip=None) -> ExecutableConditionOp:
  return ExecutableConditionOp(function_type=function_type, arg_attrs=arg_attrs, res_attrs=res_attrs, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ExecutableConstantBlockOp(_ods_ir.OpView):
  r"""
  Initializes one or more constants in the executable constant block by
  returning one value per identified constant. Each constant block is
  evaluated on the host prior to instantiating the executable for a given
  device and allows for the executable to be specialized based on device
  capabilities and limits.
  
  The keys specified are unique per variant and will be deduplicated across
  multiple constant blocks when present. They are only used during lowering
  and will not survive to runtime so they need only have descriptive enough
  names to avoid collisions and represent the semantics of the value.
  
  Constant values can be loaded in the device code with the
  `hal.executable.constant.load` op:
  
  ```mlir
  hal.executable.variant public @target {
    hal.executable.constant.block(%device: !hal.device) -> (i32, i32) as ("foo", "bar") {
      %0 = hal.device.query<%device> key("some.device.prop")...
      %1 = hal.device.query<%device> key("another.device.prop")...
      hal.return %0, %1 : i32, i32
    }
    builtin.module {
      func @dispatch0() {
        %0 = hal.executable.constant.load "foo" : i32
        %1 = hal.executable.constant.load "bar" : i32
        return
      }
    }
  }
  ```
  
  Each target backend will implement the constant initialization and access in
  a way compatible with its execution model. Examples:
  - CPU: read-only buffer initialized on load and passed to each dispatch
  - CUDA: read-only buffer initialized on load and passed to each dispatch
  - SPIR-V: specialization constants
  - Metal: function constants
  - WebGPU: pipeline-overridable constants
  """

  OPERATION_NAME = "hal.executable.constant.block"

  _ODS_REGIONS = (1, True)

  def __init__(self, function_type, keys, *, arg_attrs=None, res_attrs=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["function_type"] = (function_type if (
    isinstance(function_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_960')) else
      _ods_ir.AttrBuilder.get('anonymous_960')(function_type, context=_ods_context))
    attributes["keys"] = (keys if (
    isinstance(keys, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(keys, context=_ods_context))
    if arg_attrs is not None: attributes["arg_attrs"] = (arg_attrs if (
        isinstance(arg_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(arg_attrs, context=_ods_context))
    if res_attrs is not None: attributes["res_attrs"] = (res_attrs if (
        isinstance(res_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(res_attrs, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def function_type(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["function_type"]

  @function_type.setter
  def function_type(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["function_type"] = value

  @builtins.property
  def keys(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["keys"]

  @keys.setter
  def keys(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["keys"] = value

  @builtins.property
  def arg_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "arg_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["arg_attrs"]

  @arg_attrs.setter
  def arg_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["arg_attrs"] = value
    elif "arg_attrs" in self.operation.attributes:
      del self.operation.attributes["arg_attrs"]

  @arg_attrs.deleter
  def arg_attrs(self):
    del self.operation.attributes["arg_attrs"]

  @builtins.property
  def res_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "res_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["res_attrs"]

  @res_attrs.setter
  def res_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["res_attrs"] = value
    elif "res_attrs" in self.operation.attributes:
      del self.operation.attributes["res_attrs"]

  @res_attrs.deleter
  def res_attrs(self):
    del self.operation.attributes["res_attrs"]

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def executable_constant_block(function_type, keys, *, arg_attrs=None, res_attrs=None, loc=None, ip=None) -> ExecutableConstantBlockOp:
  return ExecutableConstantBlockOp(function_type=function_type, keys=keys, arg_attrs=arg_attrs, res_attrs=res_attrs, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ExecutableConstantLoadOp(_ods_ir.OpView):
  r"""
  Loads a scalar constant value from the static executable constant block.
  The value provided by a constant block with the given key will be loaded and
  bitcast (possibly with truncation or zero-extension) to the result type.
  
  Note that backends are allowed to implement their own mechanisms for
  referencing constant block values and this is provided only as a default for
  those not needing special behavior.
  """

  OPERATION_NAME = "hal.executable.constant.load"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, key, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["key"] = (key if (
    isinstance(key, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(key, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def key(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["key"]

  @key.setter
  def key(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["key"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def executable_constant_load(result, key, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ExecutableConstantLoadOp(result=result, key=key, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ExecutableCreateOp(_ods_ir.OpView):
  r"""
  Creates a target-dependent executable cached on the provided device. Entry
  points contained within the executable can be dispatched using the resulting
  executable handle.
  
  Depending on the driver creation may take a non-trivial amount of time
  (such as when JITing/etc). As the cache is internally synchronized callers
  can issue preparation requests from multiple threads - even for the same
  executables - and calls will block until preparation completes.
  
  Optional constants provide for specialization of the executable based on
  runtime-derived parameters.
  """

  OPERATION_NAME = "hal.executable.create"

  _ODS_REGIONS = (0, True)

  def __init__(self, device, queue_affinity, executable_target, constants, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(device)
    operands.append(queue_affinity)
    operands.extend(_get_op_results_or_values(constants))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["executable_target"] = (executable_target if (
    isinstance(executable_target, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('SymbolRefAttr')(executable_target, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def device(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def queue_affinity(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def constants(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[2:2 + _ods_variadic_group_length]

  @builtins.property
  def executable_target(self) -> _ods_ir.SymbolRefAttr:
    return self.operation.attributes["executable_target"]

  @executable_target.setter
  def executable_target(self, value: _ods_ir.SymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["executable_target"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def executable_create(device, queue_affinity, executable_target, constants, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ExecutableCreateOp(device=device, queue_affinity=queue_affinity, executable_target=executable_target, constants=constants, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ExecutableEndOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.executable_end"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def executable_end(*, loc=None, ip=None) -> ExecutableEndOp:
  return ExecutableEndOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ExecutableExportOp(_ods_ir.OpView):
  r"""
  An entry point exported by the executable with statically-available
  information describing the IO interface it uses and other dispatch metadata.
  
  The `workgroup_count` region represents the computation that
  returns the number of workgroups to use in the 3D grid dispatch.
  The arguments to the region represents the workload as captured by each
  dispatch. It returns the number of workgroups along x, y, and z.
  
  The optional `condition` region provides boolean logic determining whether
  the export should be dispatched given the device and workload or if a
  specified fallback export in the same executable should be dispatched
  instead. Multiple exports can be chained together as fallbacks to allow for
  arbitrarily complex decisions trees. Fallbacks for an export must match the
  layout and workload exactly but may vary any other attribute (such as
  workgroup size or translation configuration).
  
  Workgroup count and condition regions that have dependencies on dynamic
  workload information will be executed using indirect dispatch. If the
  information is available on the host at the time a command buffer containing
  the dispatch is available the indirect dispatch _may_ have lower overhead
  by using `IREE_HAL_DISPATCH_FLAG_STATIC_INDIRECT_PARAMETERS`. If the
  information required is data-dependent on work within the same command
  buffer some backends will suffer a performance penalty. Condition regions
  consuming dynamic workloads in particular may result in long chains of
  indirect dispatches sent to the device or even host round-trips.
  """

  OPERATION_NAME = "hal.executable.export"

  _ODS_REGIONS = (2, True)

  def __init__(self, sym_name, layout, *, sym_visibility=None, ordinal=None, condition_fallback=None, workgroup_size=None, subgroup_size=None, workgroup_local_memory=None, source_locs=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if sym_visibility is not None: attributes["sym_visibility"] = (sym_visibility if (
        isinstance(sym_visibility, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(sym_visibility, context=_ods_context))
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    if ordinal is not None: attributes["ordinal"] = (ordinal if (
        isinstance(ordinal, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('HAL_OrdinalAttr')) else
          _ods_ir.AttrBuilder.get('HAL_OrdinalAttr')(ordinal, context=_ods_context))
    attributes["layout"] = (layout if (
    isinstance(layout, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_PipelineLayoutAttr')) else
      _ods_ir.AttrBuilder.get('HAL_PipelineLayoutAttr')(layout, context=_ods_context))
    if condition_fallback is not None: attributes["condition_fallback"] = (condition_fallback if (
        isinstance(condition_fallback, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
          _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(condition_fallback, context=_ods_context))
    if workgroup_size is not None: attributes["workgroup_size"] = (workgroup_size if (
        isinstance(workgroup_size, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('HAL_WorkgroupSizeAttr')) else
          _ods_ir.AttrBuilder.get('HAL_WorkgroupSizeAttr')(workgroup_size, context=_ods_context))
    if subgroup_size is not None: attributes["subgroup_size"] = (subgroup_size if (
        isinstance(subgroup_size, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('HAL_SubgroupSizeAttr')) else
          _ods_ir.AttrBuilder.get('HAL_SubgroupSizeAttr')(subgroup_size, context=_ods_context))
    if workgroup_local_memory is not None: attributes["workgroup_local_memory"] = (workgroup_local_memory if (
        isinstance(workgroup_local_memory, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('IndexAttr')) else
          _ods_ir.AttrBuilder.get('IndexAttr')(workgroup_local_memory, context=_ods_context))
    if source_locs is not None: attributes["source_locs"] = (source_locs if (
        isinstance(source_locs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictionaryAttr')) else
          _ods_ir.AttrBuilder.get('DictionaryAttr')(source_locs, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_visibility(self) -> _Optional[_ods_ir.StringAttr]:
    if "sym_visibility" not in self.operation.attributes:
      return None
    return self.operation.attributes["sym_visibility"]

  @sym_visibility.setter
  def sym_visibility(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["sym_visibility"] = value
    elif "sym_visibility" in self.operation.attributes:
      del self.operation.attributes["sym_visibility"]

  @sym_visibility.deleter
  def sym_visibility(self):
    del self.operation.attributes["sym_visibility"]

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def ordinal(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "ordinal" not in self.operation.attributes:
      return None
    return self.operation.attributes["ordinal"]

  @ordinal.setter
  def ordinal(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["ordinal"] = value
    elif "ordinal" in self.operation.attributes:
      del self.operation.attributes["ordinal"]

  @ordinal.deleter
  def ordinal(self):
    del self.operation.attributes["ordinal"]

  @builtins.property
  def layout(self) -> _ods_ir.Attribute:
    return self.operation.attributes["layout"]

  @layout.setter
  def layout(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["layout"] = value

  @builtins.property
  def condition_fallback(self) -> _Optional[_ods_ir.FlatSymbolRefAttr]:
    if "condition_fallback" not in self.operation.attributes:
      return None
    return self.operation.attributes["condition_fallback"]

  @condition_fallback.setter
  def condition_fallback(self, value: _Optional[_ods_ir.FlatSymbolRefAttr]):
    if value is not None:
      self.operation.attributes["condition_fallback"] = value
    elif "condition_fallback" in self.operation.attributes:
      del self.operation.attributes["condition_fallback"]

  @condition_fallback.deleter
  def condition_fallback(self):
    del self.operation.attributes["condition_fallback"]

  @builtins.property
  def workgroup_size(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "workgroup_size" not in self.operation.attributes:
      return None
    return self.operation.attributes["workgroup_size"]

  @workgroup_size.setter
  def workgroup_size(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["workgroup_size"] = value
    elif "workgroup_size" in self.operation.attributes:
      del self.operation.attributes["workgroup_size"]

  @workgroup_size.deleter
  def workgroup_size(self):
    del self.operation.attributes["workgroup_size"]

  @builtins.property
  def subgroup_size(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "subgroup_size" not in self.operation.attributes:
      return None
    return self.operation.attributes["subgroup_size"]

  @subgroup_size.setter
  def subgroup_size(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["subgroup_size"] = value
    elif "subgroup_size" in self.operation.attributes:
      del self.operation.attributes["subgroup_size"]

  @subgroup_size.deleter
  def subgroup_size(self):
    del self.operation.attributes["subgroup_size"]

  @builtins.property
  def workgroup_local_memory(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "workgroup_local_memory" not in self.operation.attributes:
      return None
    return self.operation.attributes["workgroup_local_memory"]

  @workgroup_local_memory.setter
  def workgroup_local_memory(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["workgroup_local_memory"] = value
    elif "workgroup_local_memory" in self.operation.attributes:
      del self.operation.attributes["workgroup_local_memory"]

  @workgroup_local_memory.deleter
  def workgroup_local_memory(self):
    del self.operation.attributes["workgroup_local_memory"]

  @builtins.property
  def source_locs(self) -> _Optional[_ods_ir.DictAttr]:
    if "source_locs" not in self.operation.attributes:
      return None
    return self.operation.attributes["source_locs"]

  @source_locs.setter
  def source_locs(self, value: _Optional[_ods_ir.DictAttr]):
    if value is not None:
      self.operation.attributes["source_locs"] = value
    elif "source_locs" in self.operation.attributes:
      del self.operation.attributes["source_locs"]

  @source_locs.deleter
  def source_locs(self):
    del self.operation.attributes["source_locs"]

  @builtins.property
  def workgroup_count(self) -> _ods_ir.Region:
    return self.regions[0]

  @builtins.property
  def condition(self) -> _ods_ir.Region:
    return self.regions[1]

def executable_export(sym_name, layout, *, sym_visibility=None, ordinal=None, condition_fallback=None, workgroup_size=None, subgroup_size=None, workgroup_local_memory=None, source_locs=None, loc=None, ip=None) -> ExecutableExportOp:
  return ExecutableExportOp(sym_name=sym_name, layout=layout, sym_visibility=sym_visibility, ordinal=ordinal, condition_fallback=condition_fallback, workgroup_size=workgroup_size, subgroup_size=subgroup_size, workgroup_local_memory=workgroup_local_memory, source_locs=source_locs, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ExecutableExportOrdinalOp(_ods_ir.OpView):
  r"""
  Resolves an executable export ordinal to a value once ordinals have been
  assigned.
  """

  OPERATION_NAME = "hal.executable.export.ordinal"

  _ODS_REGIONS = (0, True)

  def __init__(self, entry_point, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["entry_point"] = (entry_point if (
    isinstance(entry_point, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('SymbolRefAttr')(entry_point, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def entry_point(self) -> _ods_ir.SymbolRefAttr:
    return self.operation.attributes["entry_point"]

  @entry_point.setter
  def entry_point(self, value: _ods_ir.SymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["entry_point"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IndexType]:
    return self.operation.results[0]

def executable_export_ordinal(entry_point, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ExecutableExportOrdinalOp(entry_point=entry_point, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ExecutableLookupOp(_ods_ir.OpView):
  r"""
  Used during conversion to provide a placeholder for a globally cached and
  possibly lazy-initialized executable.
  """

  OPERATION_NAME = "hal.executable.lookup"

  _ODS_REGIONS = (0, True)

  def __init__(self, device, executable, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(device)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["executable"] = (executable if (
    isinstance(executable, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(executable, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def device(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def executable(self) -> _ods_ir.FlatSymbolRefAttr:
    return self.operation.attributes["executable"]

  @executable.setter
  def executable(self, value: _ods_ir.FlatSymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["executable"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def executable_lookup(device, executable, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ExecutableLookupOp(device=device, executable=executable, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ExecutableOp(_ods_ir.OpView):
  r"""
  An executable module representing a target-specific compiled
  kernel/shader/etc. Executables are treated as independent compilation units
  and may contain multiple exported entry points that are able to share code
  internally. To support multi-targeting each executable may have one or more
  target-specific variants that are lowered independently during compilation
  while still appearing as one executable at runtime (ala fat binaries).
  
  At runtime executables are loaded during module initialization and cached
  for the lifetime of the module. If the `lazy` attribute is set the
  executable _may_ have its loading deferred until first use.
  """

  OPERATION_NAME = "hal.executable"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, *, sym_visibility=None, lazy=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if sym_visibility is not None: attributes["sym_visibility"] = (sym_visibility if (
        isinstance(sym_visibility, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(sym_visibility, context=_ods_context))
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    if bool(lazy): attributes["lazy"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_visibility(self) -> _Optional[_ods_ir.StringAttr]:
    if "sym_visibility" not in self.operation.attributes:
      return None
    return self.operation.attributes["sym_visibility"]

  @sym_visibility.setter
  def sym_visibility(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["sym_visibility"] = value
    elif "sym_visibility" in self.operation.attributes:
      del self.operation.attributes["sym_visibility"]

  @sym_visibility.deleter
  def sym_visibility(self):
    del self.operation.attributes["sym_visibility"]

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def lazy(self) -> bool:
    return "lazy" in self.operation.attributes

  @lazy.setter
  def lazy(self, value):
    if bool(value):
      self.operation.attributes["lazy"] = _ods_ir.UnitAttr.get()
    elif "lazy" in self.operation.attributes:
      del self.operation.attributes["lazy"]

  @lazy.deleter
  def lazy(self):
    del self.operation.attributes["lazy"]

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def executable(sym_name, *, sym_visibility=None, lazy=None, loc=None, ip=None) -> ExecutableOp:
  return ExecutableOp(sym_name=sym_name, sym_visibility=sym_visibility, lazy=lazy, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ExecutableSourceEndOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.executable.source_end"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def executable_source_end(*, loc=None, ip=None) -> ExecutableSourceEndOp:
  return ExecutableSourceEndOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ExecutableSourceOp(_ods_ir.OpView):
  r"""
  This is an unspecialized source representation of an executable
  module without an assigned target. This is useful for hand-authoring
  executables prior to device specification.
  """

  OPERATION_NAME = "hal.executable.source"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, *, sym_visibility=None, objects=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if sym_visibility is not None: attributes["sym_visibility"] = (sym_visibility if (
        isinstance(sym_visibility, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(sym_visibility, context=_ods_context))
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    if objects is not None: attributes["objects"] = (objects if (
        isinstance(objects, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('HAL_ExecutableObjectsAttr')) else
          _ods_ir.AttrBuilder.get('HAL_ExecutableObjectsAttr')(objects, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_visibility(self) -> _Optional[_ods_ir.StringAttr]:
    if "sym_visibility" not in self.operation.attributes:
      return None
    return self.operation.attributes["sym_visibility"]

  @sym_visibility.setter
  def sym_visibility(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["sym_visibility"] = value
    elif "sym_visibility" in self.operation.attributes:
      del self.operation.attributes["sym_visibility"]

  @sym_visibility.deleter
  def sym_visibility(self):
    del self.operation.attributes["sym_visibility"]

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def objects(self) -> _Optional[_ods_ir.Attribute]:
    if "objects" not in self.operation.attributes:
      return None
    return self.operation.attributes["objects"]

  @objects.setter
  def objects(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["objects"] = value
    elif "objects" in self.operation.attributes:
      del self.operation.attributes["objects"]

  @objects.deleter
  def objects(self):
    del self.operation.attributes["objects"]

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def executable_source(sym_name, *, sym_visibility=None, objects=None, loc=None, ip=None) -> ExecutableSourceOp:
  return ExecutableSourceOp(sym_name=sym_name, sym_visibility=sym_visibility, objects=objects, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ExecutableVariantEndOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.executable.variant_end"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def executable_variant_end(*, loc=None, ip=None) -> ExecutableVariantEndOp:
  return ExecutableVariantEndOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ExecutableVariantOp(_ods_ir.OpView):
  r"""
  The target IR for the executable. This can be preserved for debugging but
  is usually removed during transformation.
  
  Variants are selected based on their target and an optional condition
  op that returns true if the variant is valid for use on the provided
  runtime `!hal.device`. If no variants within an executable are valid then
  loading will fail at runtime. If multiple variants are valid the first valid
  one found will be loaded and used for execution.
  """

  OPERATION_NAME = "hal.executable.variant"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, target, *, sym_visibility=None, objects=None, sources=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if sym_visibility is not None: attributes["sym_visibility"] = (sym_visibility if (
        isinstance(sym_visibility, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(sym_visibility, context=_ods_context))
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["target"] = (target if (
    isinstance(target, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_ExecutableTargetAttr')) else
      _ods_ir.AttrBuilder.get('HAL_ExecutableTargetAttr')(target, context=_ods_context))
    if objects is not None: attributes["objects"] = (objects if (
        isinstance(objects, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('HAL_ExecutableObjectArrayAttr')) else
          _ods_ir.AttrBuilder.get('HAL_ExecutableObjectArrayAttr')(objects, context=_ods_context))
    if sources is not None: attributes["sources"] = (sources if (
        isinstance(sources, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictionaryAttr')) else
          _ods_ir.AttrBuilder.get('DictionaryAttr')(sources, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_visibility(self) -> _Optional[_ods_ir.StringAttr]:
    if "sym_visibility" not in self.operation.attributes:
      return None
    return self.operation.attributes["sym_visibility"]

  @sym_visibility.setter
  def sym_visibility(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["sym_visibility"] = value
    elif "sym_visibility" in self.operation.attributes:
      del self.operation.attributes["sym_visibility"]

  @sym_visibility.deleter
  def sym_visibility(self):
    del self.operation.attributes["sym_visibility"]

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def target(self) -> _ods_ir.Attribute:
    return self.operation.attributes["target"]

  @target.setter
  def target(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["target"] = value

  @builtins.property
  def objects(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "objects" not in self.operation.attributes:
      return None
    return self.operation.attributes["objects"]

  @objects.setter
  def objects(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["objects"] = value
    elif "objects" in self.operation.attributes:
      del self.operation.attributes["objects"]

  @objects.deleter
  def objects(self):
    del self.operation.attributes["objects"]

  @builtins.property
  def sources(self) -> _Optional[_ods_ir.DictAttr]:
    if "sources" not in self.operation.attributes:
      return None
    return self.operation.attributes["sources"]

  @sources.setter
  def sources(self, value: _Optional[_ods_ir.DictAttr]):
    if value is not None:
      self.operation.attributes["sources"] = value
    elif "sources" in self.operation.attributes:
      del self.operation.attributes["sources"]

  @sources.deleter
  def sources(self):
    del self.operation.attributes["sources"]

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def executable_variant(sym_name, target, *, sym_visibility=None, objects=None, sources=None, loc=None, ip=None) -> ExecutableVariantOp:
  return ExecutableVariantOp(sym_name=sym_name, target=target, sym_visibility=sym_visibility, objects=objects, sources=sources, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class FenceAwaitOp(_ods_ir.OpView):
  r"""
  Yields the caller until all fences is reached. Returns the `status` of the
  fence after the wait, with a non-zero value indicating failure.
  """

  OPERATION_NAME = "hal.fence.await"

  _ODS_REGIONS = (0, True)

  def __init__(self, timeout_millis, flags, fences, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(timeout_millis)
    operands.extend(_get_op_results_or_values(fences))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["flags"] = (flags if (
    isinstance(flags, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_WaitFlagBitfieldAttr')) else
      _ods_ir.AttrBuilder.get('HAL_WaitFlagBitfieldAttr')(flags, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def timeout_millis(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def fences(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def flags(self) -> _ods_ir.Attribute:
    return self.operation.attributes["flags"]

  @flags.setter
  def flags(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["flags"] = value

  @builtins.property
  def status(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def fence_await(timeout_millis, flags, fences, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return FenceAwaitOp(timeout_millis=timeout_millis, flags=flags, fences=fences, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FenceCreateOp(_ods_ir.OpView):
  r"""
  Returns a fence that defines a point in time. By default fences will remain
  unsignaled unless they are explicitly signaled with `hal.fence.signal` or
  asynchronously signaled by the device by passing them as an operand to
  queue submission ops.
  """

  OPERATION_NAME = "hal.fence.create"

  _ODS_REGIONS = (0, True)

  def __init__(self, device, flags, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(device)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["flags"] = (flags if (
    isinstance(flags, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_FenceFlagBitfieldAttr')) else
      _ods_ir.AttrBuilder.get('HAL_FenceFlagBitfieldAttr')(flags, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def device(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def flags(self) -> _ods_ir.Attribute:
    return self.operation.attributes["flags"]

  @flags.setter
  def flags(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["flags"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def fence_create(device, flags, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return FenceCreateOp(device=device, flags=flags, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FenceFailOp(_ods_ir.OpView):
  r"""
  Signals the fence with a failure. The `status` will be returned from
  each timepoint semaphores `hal.semaphore.query` and `hal.semaphore.signal`
  for the lifetime of each semaphore.
  """

  OPERATION_NAME = "hal.fence.fail"

  _ODS_REGIONS = (0, True)

  def __init__(self, fence, status, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(fence)
    operands.append(status)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def fence(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def status(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

def fence_fail(fence, status, *, loc=None, ip=None) -> FenceFailOp:
  return FenceFailOp(fence=fence, status=status, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class FenceJoinOp(_ods_ir.OpView):
  r"""
  Returns a fence that joins the input fences as a wait-all operation.
  """

  OPERATION_NAME = "hal.fence.join"

  _ODS_REGIONS = (0, True)

  def __init__(self, flags, fences, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(fences))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["flags"] = (flags if (
    isinstance(flags, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_FenceFlagBitfieldAttr')) else
      _ods_ir.AttrBuilder.get('HAL_FenceFlagBitfieldAttr')(flags, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def fences(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def flags(self) -> _ods_ir.Attribute:
    return self.operation.attributes["flags"]

  @flags.setter
  def flags(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["flags"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def fence_join(flags, fences, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return FenceJoinOp(flags=flags, fences=fences, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FenceQueryOp(_ods_ir.OpView):
  r"""
  Queries whether the fence has been reached and its status.
  Returns OK if the fence has been signaled successfully, DEFERRED if it is
  unsignaled, and otherwise an error indicating the failure.
  """

  OPERATION_NAME = "hal.fence.query"

  _ODS_REGIONS = (0, True)

  def __init__(self, fence, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(fence)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def fence(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def status(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def fence_query(fence, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return FenceQueryOp(fence=fence, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FenceSignalOp(_ods_ir.OpView):
  r"""
  Signals the fence to indicate that the timepoints contained have been
  reached. Waiting work may begin immediately.
  """

  OPERATION_NAME = "hal.fence.signal"

  _ODS_REGIONS = (0, True)

  def __init__(self, fence, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(fence)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def fence(self) -> _ods_ir.Value:
    return self.operation.operands[0]

def fence_signal(fence, *, loc=None, ip=None) -> FenceSignalOp:
  return FenceSignalOp(fence=fence, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class InstrumentMemoryLoadOp(_ods_ir.OpView):
  r"""
  Emits a workgroup-specific memory load event indicating that a number of
  bytes from the given resolved pointer have been loaded by the workgroup.
  """

  OPERATION_NAME = "hal.instrument.memory.load"

  _ODS_REGIONS = (0, True)

  def __init__(self, buffer, workgroupKey, loadValue, base, indices, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(buffer)
    operands.append(workgroupKey)
    operands.append(loadValue)
    operands.append(base)
    operands.extend(_get_op_results_or_values(indices))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def buffer(self) -> _ods_ir.Value[_ods_ir.MemRefType]:
    return self.operation.operands[0]

  @builtins.property
  def workgroupKey(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def loadValue(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def base(self) -> _ods_ir.Value[_ods_ir.MemRefType]:
    return self.operation.operands[3]

  @builtins.property
  def indices(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 5 + 1
    return self.operation.operands[4:4 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def instrument_memory_load(buffer, workgroup_key, load_value, base, indices, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return InstrumentMemoryLoadOp(buffer=buffer, workgroupKey=workgroup_key, loadValue=load_value, base=base, indices=indices, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class InstrumentMemoryStoreOp(_ods_ir.OpView):
  r"""
  Emits a workgroup-specific memory store event indicating that a number of
  bytes have been stored to the given resolved pointer by the workgroup.
  """

  OPERATION_NAME = "hal.instrument.memory.store"

  _ODS_REGIONS = (0, True)

  def __init__(self, buffer, workgroupKey, storeValue, base, indices, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(buffer)
    operands.append(workgroupKey)
    operands.append(storeValue)
    operands.append(base)
    operands.extend(_get_op_results_or_values(indices))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def buffer(self) -> _ods_ir.Value[_ods_ir.MemRefType]:
    return self.operation.operands[0]

  @builtins.property
  def workgroupKey(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def storeValue(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def base(self) -> _ods_ir.Value[_ods_ir.MemRefType]:
    return self.operation.operands[3]

  @builtins.property
  def indices(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 5 + 1
    return self.operation.operands[4:4 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def instrument_memory_store(buffer, workgroup_key, store_value, base, indices, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return InstrumentMemoryStoreOp(buffer=buffer, workgroupKey=workgroup_key, storeValue=store_value, base=base, indices=indices, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class InstrumentPrintOp(_ods_ir.OpView):
  r"""
  Formats a string using a limited subset of printf format specifiers and the
  provided values and then emits an `iree_instrument_dispatch_print_t` event. Final
  formatted string lengths may be limited to as much as 1024 characters and
  should be kept as small as possible to avoid easily exceeding the
  instrumentation storage buffers with redundant strings.
  """

  OPERATION_NAME = "hal.instrument.print"

  _ODS_REGIONS = (0, True)

  def __init__(self, buffer, workgroupKey, format, values, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(buffer)
    operands.append(workgroupKey)
    operands.extend(_get_op_results_or_values(values))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["format"] = (format if (
    isinstance(format, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(format, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def buffer(self) -> _ods_ir.Value[_ods_ir.MemRefType]:
    return self.operation.operands[0]

  @builtins.property
  def workgroupKey(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def values(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[2:2 + _ods_variadic_group_length]

  @builtins.property
  def format(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["format"]

  @format.setter
  def format(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["format"] = value

def instrument_print(buffer, workgroup_key, format, values, *, loc=None, ip=None) -> InstrumentPrintOp:
  return InstrumentPrintOp(buffer=buffer, workgroupKey=workgroup_key, format=format, values=values, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class InstrumentValueOp(_ods_ir.OpView):
  r"""
  Emits a workgroup-specific typed value with the given workgroup-relative
  ordinal.
  
  This op will be preserved even if the output is not used as it is only for
  debugging purposes.
  """

  OPERATION_NAME = "hal.instrument.value"

  _ODS_REGIONS = (0, True)

  def __init__(self, buffer, workgroupKey, ordinal, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(buffer)
    operands.append(workgroupKey)
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["ordinal"] = (ordinal if (
    isinstance(ordinal, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AnyI8Attr')) else
      _ods_ir.AttrBuilder.get('AnyI8Attr')(ordinal, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def buffer(self) -> _ods_ir.Value[_ods_ir.MemRefType]:
    return self.operation.operands[0]

  @builtins.property
  def workgroupKey(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def ordinal(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["ordinal"]

  @ordinal.setter
  def ordinal(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ordinal"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def instrument_value(buffer, workgroup_key, ordinal, operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return InstrumentValueOp(buffer=buffer, workgroupKey=workgroup_key, ordinal=ordinal, operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class InstrumentWorkgroupOp(_ods_ir.OpView):
  r"""
  Emits an `iree_instrument_dispatch_workgroup_t` event into the
  instrumentation stream. The workgroup event identifies the unique dispatch,
  its workgroup count, and the ID of the emitting workgroup within the
  dispatch. Optionally targets that support querying the processor ID
  executing the workgroup can attach that information for tracking purposes.
  
  On targets such as CPUs where entire workgroups execute as atomic units
  only one workgroup event should be emitted. On targets such as GPUs where
  there may be multiple invocations executing as part of a single workgroup
  only the first invocation within the workgroup should emit the workgroup
  event (by checking if the LocalInvocationIndex or threadIdx == 0, etc).
  
  The resulting workgroup key is used by subsequent workgroup-specific
  instrumentation events.
  """

  OPERATION_NAME = "hal.instrument.workgroup"

  _ODS_REGIONS = (0, True)

  def __init__(self, buffer, dispatchId, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(buffer)
    operands.append(dispatchId)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def buffer(self) -> _ods_ir.Value[_ods_ir.MemRefType]:
    return self.operation.operands[0]

  @builtins.property
  def dispatchId(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def workgroupKey(self) -> _ods_ir.OpResult[_ods_ir.IndexType]:
    return self.operation.results[0]

def instrument_workgroup(buffer, dispatch_id, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return InstrumentWorkgroupOp(buffer=buffer, dispatchId=dispatch_id, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class InterfaceBindingSubspanOp(_ods_ir.OpView):
  r"""
  Returns a subspan of an interface binding storage buffer in a generic type.
  The exact shape, type, and alignment of the returned type are defined by
  the result type (tensor, memref, etc).
  
  An optional alignment indicates the byte alignment of the base binding
  resource. Note that the byte offset is added to the base and the alignment
  will be the minimum of the two.
  """

  OPERATION_NAME = "hal.interface.binding.subspan"

  _ODS_OPERAND_SEGMENTS = [0,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, result, layout, binding, dynamic_dims, *, byte_offset=None, alignment=None, descriptor_flags=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(byte_offset)
    operands.append(_get_op_results_or_values(dynamic_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["layout"] = (layout if (
    isinstance(layout, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_PipelineLayoutAttr')) else
      _ods_ir.AttrBuilder.get('HAL_PipelineLayoutAttr')(layout, context=_ods_context))
    attributes["binding"] = (binding if (
    isinstance(binding, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IndexAttr')) else
      _ods_ir.AttrBuilder.get('IndexAttr')(binding, context=_ods_context))
    if alignment is not None: attributes["alignment"] = (alignment if (
        isinstance(alignment, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('IndexAttr')) else
          _ods_ir.AttrBuilder.get('IndexAttr')(alignment, context=_ods_context))
    if descriptor_flags is not None: attributes["descriptor_flags"] = (descriptor_flags if (
        isinstance(descriptor_flags, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('HAL_DescriptorFlagsAttr')) else
          _ods_ir.AttrBuilder.get('HAL_DescriptorFlagsAttr')(descriptor_flags, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def byte_offset(self) -> _Optional[_ods_ir.Value[_ods_ir.IndexType]]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def dynamic_dims(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def layout(self) -> _ods_ir.Attribute:
    return self.operation.attributes["layout"]

  @layout.setter
  def layout(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["layout"] = value

  @builtins.property
  def binding(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["binding"]

  @binding.setter
  def binding(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["binding"] = value

  @builtins.property
  def alignment(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "alignment" not in self.operation.attributes:
      return None
    return self.operation.attributes["alignment"]

  @alignment.setter
  def alignment(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["alignment"] = value
    elif "alignment" in self.operation.attributes:
      del self.operation.attributes["alignment"]

  @alignment.deleter
  def alignment(self):
    del self.operation.attributes["alignment"]

  @builtins.property
  def descriptor_flags(self) -> _Optional[_ods_ir.Attribute]:
    if "descriptor_flags" not in self.operation.attributes:
      return None
    return self.operation.attributes["descriptor_flags"]

  @descriptor_flags.setter
  def descriptor_flags(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["descriptor_flags"] = value
    elif "descriptor_flags" in self.operation.attributes:
      del self.operation.attributes["descriptor_flags"]

  @descriptor_flags.deleter
  def descriptor_flags(self):
    del self.operation.attributes["descriptor_flags"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def interface_binding_subspan(result, layout, binding, dynamic_dims, *, byte_offset=None, alignment=None, descriptor_flags=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return InterfaceBindingSubspanOp(result=result, layout=layout, binding=binding, dynamic_dims=dynamic_dims, byte_offset=byte_offset, alignment=alignment, descriptor_flags=descriptor_flags, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class InterfaceConstantLoadOp(_ods_ir.OpView):
  r"""
  Loads a scalar constant value from an executable IO push constant block.
  The value will be loaded from the given constant offset and will be
  bitcast (possibly with truncation or zero-extension) to the result type.
  
  An optional alignment indicates the byte alignment of potential values for
  the constant when it could be determined from analysis. If omitted the value
  may be anything and its interpretation is up to the usage. This is intended
  to provide pointer alignment-like semantics to constants that are used to
  index into binding resources.
  
  An optional set of values indicates all possible values that can be passed
  to the constant from all dispatch sites in the program. If omitted the value
  may be from an unanalyzable source (outside of the program, indirect, etc)
  and must be assumed to have any value.
  """

  OPERATION_NAME = "hal.interface.constant.load"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, layout, ordinal, *, alignment=None, values=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["layout"] = (layout if (
    isinstance(layout, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_PipelineLayoutAttr')) else
      _ods_ir.AttrBuilder.get('HAL_PipelineLayoutAttr')(layout, context=_ods_context))
    attributes["ordinal"] = (ordinal if (
    isinstance(ordinal, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_HostSizeAttr')) else
      _ods_ir.AttrBuilder.get('HAL_HostSizeAttr')(ordinal, context=_ods_context))
    if alignment is not None: attributes["alignment"] = (alignment if (
        isinstance(alignment, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('IndexAttr')) else
          _ods_ir.AttrBuilder.get('IndexAttr')(alignment, context=_ods_context))
    if values is not None: attributes["values"] = (values if (
        isinstance(values, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
          _ods_ir.AttrBuilder.get('ArrayAttr')(values, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def layout(self) -> _ods_ir.Attribute:
    return self.operation.attributes["layout"]

  @layout.setter
  def layout(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["layout"] = value

  @builtins.property
  def ordinal(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["ordinal"]

  @ordinal.setter
  def ordinal(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ordinal"] = value

  @builtins.property
  def alignment(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "alignment" not in self.operation.attributes:
      return None
    return self.operation.attributes["alignment"]

  @alignment.setter
  def alignment(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["alignment"] = value
    elif "alignment" in self.operation.attributes:
      del self.operation.attributes["alignment"]

  @alignment.deleter
  def alignment(self):
    del self.operation.attributes["alignment"]

  @builtins.property
  def values(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "values" not in self.operation.attributes:
      return None
    return self.operation.attributes["values"]

  @values.setter
  def values(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["values"] = value
    elif "values" in self.operation.attributes:
      del self.operation.attributes["values"]

  @values.deleter
  def values(self):
    del self.operation.attributes["values"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def interface_constant_load(result, layout, ordinal, *, alignment=None, values=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return InterfaceConstantLoadOp(result=result, layout=layout, ordinal=ordinal, alignment=alignment, values=values, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class InterfaceWorkgroupCountOp(_ods_ir.OpView):
  r"""
  The total number of workgroups along each dimension in the dispatch grid.
  Matches what was passed to the `hal.command_buffer.dispatch` command (or
  what was indirectly specified).
  
  Corresponds to the `NumWorkgroups` SPIR-V built-in and the `gridDim` CUDA
  built-in variable.
  
  ```mlir
  %x = hal.interface.workgroup.count[0] : index
  %y = hal.interface.workgroup.count[1] : index
  %z = hal.interface.workgroup.count[2] : index
  ```
  """

  OPERATION_NAME = "hal.interface.workgroup.count"

  _ODS_REGIONS = (0, True)

  def __init__(self, dimension, *, upper_bound=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dimension"] = (dimension if (
    isinstance(dimension, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IndexAttr')) else
      _ods_ir.AttrBuilder.get('IndexAttr')(dimension, context=_ods_context))
    if upper_bound is not None: attributes["upper_bound"] = (upper_bound if (
        isinstance(upper_bound, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('IndexAttr')) else
          _ods_ir.AttrBuilder.get('IndexAttr')(upper_bound, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def dimension(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["dimension"]

  @dimension.setter
  def dimension(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dimension"] = value

  @builtins.property
  def upper_bound(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "upper_bound" not in self.operation.attributes:
      return None
    return self.operation.attributes["upper_bound"]

  @upper_bound.setter
  def upper_bound(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["upper_bound"] = value
    elif "upper_bound" in self.operation.attributes:
      del self.operation.attributes["upper_bound"]

  @upper_bound.deleter
  def upper_bound(self):
    del self.operation.attributes["upper_bound"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IndexType]:
    return self.operation.results[0]

def interface_workgroup_count(dimension, *, upper_bound=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return InterfaceWorkgroupCountOp(dimension=dimension, upper_bound=upper_bound, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class InterfaceWorkgroupIDOp(_ods_ir.OpView):
  r"""
  The global workgroup ID of the current tile in the range of
  `[0, hal.interface.workgroup.count)` along each XYZ dimension.
  
  Corresponds to the `WorkgroupId` SPIR-V built-in and the `blockIdx` CUDA
  built-in variable.
  
  ```mlir
  %x = hal.interface.workgroup.id[0] : index
  %y = hal.interface.workgroup.id[1] : index
  %z = hal.interface.workgroup.id[2] : index
  ```
  """

  OPERATION_NAME = "hal.interface.workgroup.id"

  _ODS_REGIONS = (0, True)

  def __init__(self, dimension, *, upper_bound=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dimension"] = (dimension if (
    isinstance(dimension, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IndexAttr')) else
      _ods_ir.AttrBuilder.get('IndexAttr')(dimension, context=_ods_context))
    if upper_bound is not None: attributes["upper_bound"] = (upper_bound if (
        isinstance(upper_bound, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('IndexAttr')) else
          _ods_ir.AttrBuilder.get('IndexAttr')(upper_bound, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def dimension(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["dimension"]

  @dimension.setter
  def dimension(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dimension"] = value

  @builtins.property
  def upper_bound(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "upper_bound" not in self.operation.attributes:
      return None
    return self.operation.attributes["upper_bound"]

  @upper_bound.setter
  def upper_bound(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["upper_bound"] = value
    elif "upper_bound" in self.operation.attributes:
      del self.operation.attributes["upper_bound"]

  @upper_bound.deleter
  def upper_bound(self):
    del self.operation.attributes["upper_bound"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IndexType]:
    return self.operation.results[0]

def interface_workgroup_id(dimension, *, upper_bound=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return InterfaceWorkgroupIDOp(dimension=dimension, upper_bound=upper_bound, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class InterfaceWorkgroupSizeOp(_ods_ir.OpView):
  r"""
  The number of local invocations within the current workgroup along each
  dimension. Depending on backend this may map to the SIMT thread count or
  inner loop nest parameters.
  
  Corresponds to the `WorkgroupSize` SPIR-V built-in and the `blockDim` CUDA
  built-in variable.
  
  ```mlir
  %x = hal.interface.workgroup.size[0] : index
  %y = hal.interface.workgroup.size[1] : index
  %z = hal.interface.workgroup.size[2] : index
  ```
  """

  OPERATION_NAME = "hal.interface.workgroup.size"

  _ODS_REGIONS = (0, True)

  def __init__(self, dimension, *, upper_bound=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dimension"] = (dimension if (
    isinstance(dimension, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IndexAttr')) else
      _ods_ir.AttrBuilder.get('IndexAttr')(dimension, context=_ods_context))
    if upper_bound is not None: attributes["upper_bound"] = (upper_bound if (
        isinstance(upper_bound, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('IndexAttr')) else
          _ods_ir.AttrBuilder.get('IndexAttr')(upper_bound, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def dimension(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["dimension"]

  @dimension.setter
  def dimension(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dimension"] = value

  @builtins.property
  def upper_bound(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "upper_bound" not in self.operation.attributes:
      return None
    return self.operation.attributes["upper_bound"]

  @upper_bound.setter
  def upper_bound(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["upper_bound"] = value
    elif "upper_bound" in self.operation.attributes:
      del self.operation.attributes["upper_bound"]

  @upper_bound.deleter
  def upper_bound(self):
    del self.operation.attributes["upper_bound"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IndexType]:
    return self.operation.results[0]

def interface_workgroup_size(dimension, *, upper_bound=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return InterfaceWorkgroupSizeOp(dimension=dimension, upper_bound=upper_bound, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MemoryTypeOp(_ods_ir.OpView):
  r"""
  Maps memory type bits to a runtime `iree_hal_memory_type_t` value.
  """

  OPERATION_NAME = "hal.memory_type"

  _ODS_REGIONS = (0, True)

  def __init__(self, type_, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["type"] = (type_ if (
    isinstance(type_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_MemoryTypeBitfieldAttr')) else
      _ods_ir.AttrBuilder.get('HAL_MemoryTypeBitfieldAttr')(type_, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def type_(self) -> _ods_ir.Attribute:
    return self.operation.attributes["type"]

  @type_.setter
  def type_(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["type"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def memory_type(type_, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MemoryTypeOp(type_=type_, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ReturnOp(_ods_ir.OpView):
  r"""
  Returns the given values from the region and back to the host code.
  """

  OPERATION_NAME = "hal.return"

  _ODS_REGIONS = (0, True)

  def __init__(self, operands_, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def return_(operands_, *, loc=None, ip=None) -> ReturnOp:
  return ReturnOp(operands_=operands_, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class TensorAliasOp(_ods_ir.OpView):
  r"""
  Hints that the backing storage of an entire tensor aliases the given storage
  buffer. There's no guarantee that the storage will alias and instead only
  that the tensor contents will be written to the storage as if a copy had
  occurred. This allows the compiler to avoid copies in the ideal case of a
  producer that is able to produce directly into the target storage but still
  handle cases where the producer is not able to be in-place.
  
  The storage buffer provided must have sufficient space for the tensor once
  encoded. Dynamically shaped tensors may not consume the entire provided
  storage. If a buffer view is provided the metadata is ignored and only the
  backing buffer is used.
  
  An optional wait fence can be provided in cases where the storage is not
  immediately available. Producers that may alias the storage will wait until
  the storage is available before updating the contents.
  
  Explicit aliasing side-steps any analysis that may be performed by the
  compiler and requires users to guarantee that the safety of the aliasing.
  Copy-on-write, alias analysis for overlap detection, and ordering via
  use-def chains are all ignorant of the aliased buffer memory and only ensure
  the compiler consumes or produces the aliased memory consistent with itself.
  
  Example:
  ```mlir
  %init = tensor.empty
  %value = linalg.generic ... outs(%init)
  %aliased = hal.tensor.alias %value : tensor<...> to %buffer : !hal.buffer
  ... linalg.generic ins(%aliased) ...
  ```
  """

  OPERATION_NAME = "hal.tensor.alias"

  _ODS_OPERAND_SEGMENTS = [1,-1,1,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, source, source_dims, storage, *, wait_fence=None, affinity=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(_get_op_results_or_values(source_dims))
    operands.append(storage)
    operands.append(wait_fence)
    _ods_context = _ods_get_default_loc_context(loc)
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('AnyAttr')) else
          _ods_ir.AttrBuilder.get('AnyAttr')(affinity, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def source_dims(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def storage(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0]

  @builtins.property
  def wait_fence(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def tensor_alias(source, source_dims, storage, *, wait_fence=None, affinity=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return TensorAliasOp(source=source, source_dims=source_dims, storage=storage, wait_fence=wait_fence, affinity=affinity, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorBarrierOp(_ods_ir.OpView):
  r"""
  Defines a barrier that is used to indicate availability of an entire set of
  tensors by signaling a fence. The source tensors are returned for chaining.
  """

  OPERATION_NAME = "hal.tensor.barrier"

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, sources, signal_fence, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(sources))
    operands.append(signal_fence)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sources(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def signal_fence(self) -> _ods_ir.Value:
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1 + _ods_variadic_group_length - 1]

  @builtins.property
  def results_(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def tensor_barrier(results_, sources, signal_fence, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, TensorBarrierOp]:
  op = TensorBarrierOp(results_=results_, sources=sources, signal_fence=signal_fence, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class TensorExportOp(_ods_ir.OpView):
  r"""
  Defines an export of an SSA-form tensor to an external HAL buffer view.
  
  The provided `source_encoding`, if different from the `source` type,
  indicates that the ABI-facing type may differ from the internal
  representation. The types must be bitcastable (same storage size) and
  dynamically shaped values must have the same number of dynamic dimensions.
  This allows for casting between rank-0 and rank-N types, different element
  types, etc.
  """

  OPERATION_NAME = "hal.tensor.export"

  _ODS_REGIONS = (0, True)

  def __init__(self, target, source, source_encoding, source_dims, *, name=None, affinity=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.extend(_get_op_results_or_values(source_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["source_encoding"] = (source_encoding if (
    isinstance(source_encoding, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(source_encoding, context=_ods_context))
    if name is not None: attributes["name"] = (name if (
        isinstance(name, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('AnyAttr')) else
          _ods_ir.AttrBuilder.get('AnyAttr')(affinity, context=_ods_context))
    results = []
    results.append(target)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def source_dims(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def source_encoding(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["source_encoding"]

  @source_encoding.setter
  def source_encoding(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["source_encoding"] = value

  @builtins.property
  def name(self) -> _Optional[_ods_ir.StringAttr]:
    if "name" not in self.operation.attributes:
      return None
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["name"] = value
    elif "name" in self.operation.attributes:
      del self.operation.attributes["name"]

  @name.deleter
  def name(self):
    del self.operation.attributes["name"]

  @builtins.property
  def affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def target(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def tensor_export(target, source, source_encoding, source_dims, *, name=None, affinity=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return TensorExportOp(target=target, source=source, source_encoding=source_encoding, source_dims=source_dims, name=name, affinity=affinity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorImportOp(_ods_ir.OpView):
  r"""
  Defines an import of an external HAL buffer view into a SSA-form tensor.
  An optional fence can be specified indicating when the buffer view is
  available for use. If no fence is provided it is assumed the buffer view is
  immediately available.
  
  The provided `target_encoding`, if different from the `target` type,
  indicates that the ABI-facing type may differ from the internal
  representation. The types must be bitcastable (same storage size) and
  dynamically shaped values must have the same number of dynamic dimensions.
  This allows for casting between rank-0 and rank-N types, different element
  types, etc.
  
  `consume` can be used to indicate a transfer of ownership. Though the
  imported value may still have external references when consumed a resource
  will be conceptually released from its existing owner and retained by the
  importer atomically.
  """

  OPERATION_NAME = "hal.tensor.import"

  _ODS_OPERAND_SEGMENTS = [1,-1,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, target, source, target_encoding, target_dims, *, consume=None, wait_fence=None, name=None, affinity=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(_get_op_results_or_values(target_dims))
    operands.append(wait_fence)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["target_encoding"] = (target_encoding if (
    isinstance(target_encoding, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(target_encoding, context=_ods_context))
    if bool(consume): attributes["consume"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if name is not None: attributes["name"] = (name if (
        isinstance(name, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('AnyAttr')) else
          _ods_ir.AttrBuilder.get('AnyAttr')(affinity, context=_ods_context))
    results = []
    results.append(target)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def target_dims(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def wait_fence(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def target_encoding(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["target_encoding"]

  @target_encoding.setter
  def target_encoding(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["target_encoding"] = value

  @builtins.property
  def consume(self) -> bool:
    return "consume" in self.operation.attributes

  @consume.setter
  def consume(self, value):
    if bool(value):
      self.operation.attributes["consume"] = _ods_ir.UnitAttr.get()
    elif "consume" in self.operation.attributes:
      del self.operation.attributes["consume"]

  @consume.deleter
  def consume(self):
    del self.operation.attributes["consume"]

  @builtins.property
  def name(self) -> _Optional[_ods_ir.StringAttr]:
    if "name" not in self.operation.attributes:
      return None
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["name"] = value
    elif "name" in self.operation.attributes:
      del self.operation.attributes["name"]

  @name.deleter
  def name(self):
    del self.operation.attributes["name"]

  @builtins.property
  def affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def target(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def tensor_import(target, source, target_encoding, target_dims, *, consume=None, wait_fence=None, name=None, affinity=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return TensorImportOp(target=target, source=source, target_encoding=target_encoding, target_dims=target_dims, consume=consume, wait_fence=wait_fence, name=name, affinity=affinity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorTransientsOp(_ods_ir.OpView):
  r"""
  Annotates that any transient memory used in the production of the given
  tensor should be suballocated from the provided storage buffer. This allows
  users to control transient allocations by providing their own storage,
  enabling zero-allocation execution in steady state.
  
  The storage buffer provided must have sufficient space for all transient
  allocations required to produce the tensor. Unless otherwise overridden the
  compiler will verify that all allocation sizes are computable and generate
  size query functions to allow users to query the required buffer size. If
  size checks are disabled then the user must ensure they pass in a buffer
  with sufficient capacity.
  
  The storage buffer is assumed to be immediately usable (i.e., any previous
  work using it has completed). Users must ensure proper synchronization if
  reusing storage across multiple operations. Future work may add explicit
  wait semantics to enable pipelining, but for now synchronization is the
  caller's responsibility.
  
  This operation preserves SSA use-def chains by returning the same tensor
  value it receives. It exists purely for annotation purposes and will be
  lowered away during compilation.
  
  Example:
  ```mlir
  %result = some.operation(%input) : tensor<?xf32>
  %annotated = hal.tensor.transients %result : tensor<?xf32>{%dim} from %storage : !hal.buffer
  ```
  """

  OPERATION_NAME = "hal.tensor.transients"

  _ODS_REGIONS = (0, True)

  def __init__(self, source, source_dims, storage, *, affinity=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.extend(_get_op_results_or_values(source_dims))
    operands.append(storage)
    _ods_context = _ods_get_default_loc_context(loc)
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('AnyAttr')) else
          _ods_ir.AttrBuilder.get('AnyAttr')(affinity, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def source_dims(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def storage(self) -> _ods_ir.Value:
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[2 + _ods_variadic_group_length - 1]

  @builtins.property
  def affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def tensor_transients(source, source_dims, storage, *, affinity=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return TensorTransientsOp(source=source, source_dims=source_dims, storage=storage, affinity=affinity, results=results, loc=loc, ip=ip).result
