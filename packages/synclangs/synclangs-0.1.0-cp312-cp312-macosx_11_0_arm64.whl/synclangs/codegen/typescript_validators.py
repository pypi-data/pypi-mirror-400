"""TypeScript Zod validator code generator for SyncLangs types."""

from __future__ import annotations

import posixpath

from synclangs.codegen.base import CodeGenerator
from synclangs.parser.ast import (
    ConstDef,
    EnumDef,
    ListTypeExpr,
    MapTypeExpr,
    Module,
    NullableTypeExpr,
    PrimitiveType,
    PrimitiveTypeExpr,
    TypeDef,
    TypeExpr,
    TypeRef,
)


class ZodGenerator(CodeGenerator):
    """Generate Zod schemas from SyncLangs AST."""

    def __init__(self, file_extension: str = ".validators.ts") -> None:
        self._file_extension = file_extension

    def generate(self, module: Module) -> str:
        """Generate TypeScript Zod source code for a module."""
        lines: list[str] = [
            "// Auto-generated by SyncLangs - DO NOT EDIT",
            "",
            "import { z } from 'zod';",
            "",
        ]

        # Add module imports for type references from other files
        if module.imports:
            for import_stmt in module.imports:
                import_path = self._ts_import_path(
                    module.path, import_stmt.path
                )
                # Import schemas instead of types
                schema_names = [f"{name}Schema" for name in import_stmt.names]
                names = ", ".join(schema_names)
                lines.append(f"import {{ {names} }} from '{import_path}';")
            lines.append("")

        # Generate constants first
        for const_def in module.constants:
            lines.extend(self._generate_constant(const_def))
        if module.constants:
            lines.append("")

        # Generate enums as Zod enums
        for enum_def in module.enums:
            lines.extend(self._generate_enum(enum_def))
            lines.append("")

        # Generate Zod schemas (types)
        for type_def in module.types:
            lines.extend(self._generate_type(type_def))
            lines.append("")

        return "\n".join(lines).rstrip() + "\n"

    def _generate_constant(self, const_def: ConstDef) -> list[str]:
        """Generate a TypeScript constant definition."""
        lines: list[str] = []
        if const_def.doc_comment:
            lines.extend(self._format_jsdoc(const_def.doc_comment, ""))
        ts_type = self._type_to_ts(const_def.type_expr)
        value = self._const_value_to_ts(const_def.value)
        lines.append(f"export const {const_def.name}: {ts_type} = {value};")
        return lines

    def _generate_enum(self, enum_def: EnumDef) -> list[str]:
        """Generate a Zod enum schema."""
        lines: list[str] = []
        if enum_def.doc_comment:
            lines.extend(self._format_jsdoc(enum_def.doc_comment, ""))

        # Generate Zod enum
        variant_names = [f"'{v.name}'" for v in enum_def.variants]
        variants_str = ", ".join(variant_names)
        lines.append(f"export const {enum_def.name}Schema = z.enum([{variants_str}]);")
        lines.append(f"export type {enum_def.name} = z.infer<typeof {enum_def.name}Schema>;")

        return lines

    def _generate_type(self, type_def: TypeDef) -> list[str]:
        """Generate a Zod object schema."""
        lines: list[str] = []

        # JSDoc comment
        if type_def.doc_comment:
            lines.extend(self._format_jsdoc(type_def.doc_comment, ""))

        # Open schema definition
        lines.append(f"export const {type_def.name}Schema = z.object({{")

        # Fields
        for field in type_def.fields:
            if field.doc_comment:
                lines.extend(self._format_jsdoc(field.doc_comment, "  "))
            zod_type = self._field_to_zod(field.type_expr)
            lines.append(f"  {field.name}: {zod_type},")

        # Close schema definition
        lines.append("});")

        # Export inferred type
        lines.append(
            f"export type {type_def.name} = z.infer<typeof {type_def.name}Schema>;"
        )

        return lines

    def _field_to_zod(self, type_expr: TypeExpr) -> str:
        """Convert a type expression to a Zod validator."""
        if isinstance(type_expr, NullableTypeExpr):
            inner = self._type_to_zod(type_expr.inner_type)
            return f"{inner}.optional()"
        return self._type_to_zod(type_expr)

    def _type_to_zod(self, type_expr: TypeExpr) -> str:
        """Convert a type expression to a Zod validator (without optional)."""
        if isinstance(type_expr, PrimitiveTypeExpr):
            return self._primitive_to_zod(type_expr.primitive)
        if isinstance(type_expr, ListTypeExpr):
            inner = self._type_to_zod(type_expr.element_type)
            return f"z.array({inner})"
        if isinstance(type_expr, MapTypeExpr):
            key = self._type_to_zod(type_expr.key_type)
            value = self._type_to_zod(type_expr.value_type)
            return f"z.record({key}, {value})"
        if isinstance(type_expr, NullableTypeExpr):
            inner = self._type_to_zod(type_expr.inner_type)
            return f"{inner}.optional()"
        if isinstance(type_expr, TypeRef):
            # Reference to another type - use its schema
            return f"{type_expr.name}Schema"
        raise TypeError(f"Unsupported type expression: {type_expr}")

    def _primitive_to_zod(self, primitive: PrimitiveType) -> str:
        """Map primitive SyncLangs types to Zod validators."""
        mapping = {
            PrimitiveType.STRING: "z.string()",
            PrimitiveType.INT: "z.number()",
            PrimitiveType.FLOAT: "z.number()",
            PrimitiveType.BOOL: "z.boolean()",
            PrimitiveType.ANY: "z.any()",
        }
        return mapping[primitive]

    def _type_to_ts(self, type_expr: TypeExpr) -> str:
        """Convert a type expression to a TypeScript type (for constants)."""
        if isinstance(type_expr, PrimitiveTypeExpr):
            return self._primitive_to_ts(type_expr.primitive)
        raise TypeError(f"Unsupported constant type: {type_expr}")

    def _primitive_to_ts(self, primitive: PrimitiveType) -> str:
        """Map primitive SyncLangs types to TypeScript types."""
        mapping = {
            PrimitiveType.STRING: "string",
            PrimitiveType.INT: "number",
            PrimitiveType.FLOAT: "number",
            PrimitiveType.BOOL: "boolean",
            PrimitiveType.ANY: "any",
        }
        return mapping[primitive]

    def _const_value_to_ts(self, value: "ConstDef.value") -> str:
        """Convert a constant value to TypeScript literal."""
        from synclangs.parser.ast import ConstValue

        if not isinstance(value, ConstValue):
            return str(value)
        if isinstance(value.value, str):
            return f'"{value.value}"'
        if isinstance(value.value, bool):
            return "true" if value.value else "false"
        return str(value.value)

    def _ts_import_path(self, module_path: str, import_path: str) -> str:
        """Resolve an import path to a TypeScript module specifier."""
        current_dir = posixpath.dirname(module_path)
        target_path = posixpath.normpath(posixpath.join(current_dir, import_path))
        base = current_dir if current_dir else "."
        rel_path = posixpath.relpath(target_path, base)
        if rel_path.endswith(".syln"):
            rel_path = rel_path[: -len(".syln")] + self._file_extension
        if rel_path.endswith(".ts"):
            rel_path = rel_path[: -len(".ts")]
        if not rel_path.startswith("."):
            rel_path = f"./{rel_path}"
        return rel_path

    def _format_jsdoc(self, text: str, indent: str) -> list[str]:
        """Format a JSDoc comment with the provided indentation."""
        lines = text.splitlines()
        if len(lines) == 1:
            return [f"{indent}/** {lines[0]} */"]
        formatted = [f"{indent}/**"]
        formatted.extend(f"{indent} * {line}" for line in lines)
        formatted.append(f"{indent} */")
        return formatted
