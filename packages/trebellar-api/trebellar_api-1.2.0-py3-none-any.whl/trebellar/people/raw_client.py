# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.pydantic_utilities import parse_obj_as
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..errors.bad_request_error import BadRequestError
from ..errors.internal_server_error import InternalServerError
from ..errors.not_found_error import NotFoundError
from ..types.add_people_group_members_batch_response import AddPeopleGroupMembersBatchResponse
from ..types.asset_id import AssetId
from ..types.delete_people_asset_batch_response import DeletePeopleAssetBatchResponse
from ..types.delete_people_batch_response import DeletePeopleBatchResponse
from ..types.error_schema import ErrorSchema
from ..types.list_people_response import ListPeopleResponse
from ..types.people_input import PeopleInput
from ..types.remove_people_group_members_batch_response import RemovePeopleGroupMembersBatchResponse
from ..types.upsert_people_asset_batch_response import UpsertPeopleAssetBatchResponse
from ..types.upsert_people_batch_response import UpsertPeopleBatchResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawPeopleClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list_people(
        self, *, for_asset_ids: typing.Optional[str] = None, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[ListPeopleResponse]:
        """
        Retrieve a list of people with optional filtering by asset assignments. Use the forAssetIds parameter to filter people who are assigned to specific assets (desks, spaces, etc.). Returns complete employee profiles including contact information, employment status, group memberships, and current asset assignments.

        Parameters
        ----------
        for_asset_ids : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ListPeopleResponse]
            People list retrieved successfully with complete profiles and asset assignments
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v2/people",
            method="GET",
            params={
                "forAssetIds": for_asset_ids,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListPeopleResponse,
                    parse_obj_as(
                        type_=ListPeopleResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorSchema,
                        parse_obj_as(
                            type_=ErrorSchema,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def upsert_people_batch(
        self, *, people: typing.Sequence[PeopleInput], request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[UpsertPeopleBatchResponse]:
        """
        Create new people or update existing employee records in a single batch operation. Use this for HR system integrations, bulk imports, or synchronized employee data updates. Each person record can include employment details, contact information, and initial group assignments. Existing people are matched by ID and updated; new records without IDs are created.

        Parameters
        ----------
        people : typing.Sequence[PeopleInput]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[UpsertPeopleBatchResponse]
            All people records processed successfully - existing employees updated and new employees created
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v2/people/batch/upsert",
            method="POST",
            json={
                "people": convert_and_respect_annotation_metadata(
                    object_=people, annotation=typing.Sequence[PeopleInput], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    UpsertPeopleBatchResponse,
                    parse_obj_as(
                        type_=UpsertPeopleBatchResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorSchema,
                        parse_obj_as(
                            type_=ErrorSchema,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorSchema,
                        parse_obj_as(
                            type_=ErrorSchema,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete_people_batch(
        self, *, people_ids: typing.Sequence[str], request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[DeletePeopleBatchResponse]:
        """
        Permanently remove multiple employee records by their IDs. This operation also removes all associated asset assignments and group memberships. Use with caution as this action cannot be undone. Consider updating employment status to inactive instead of deletion for audit trail purposes.

        Parameters
        ----------
        people_ids : typing.Sequence[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DeletePeopleBatchResponse]
            All specified people records deleted successfully along with their assignments
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v2/people/batch/delete",
            method="DELETE",
            json={
                "peopleIds": people_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeletePeopleBatchResponse,
                    parse_obj_as(
                        type_=DeletePeopleBatchResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorSchema,
                        parse_obj_as(
                            type_=ErrorSchema,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorSchema,
                        parse_obj_as(
                            type_=ErrorSchema,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorSchema,
                        parse_obj_as(
                            type_=ErrorSchema,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def upsert_people_asset_batch(
        self,
        *,
        people_ids: typing.Sequence[str],
        asset_ids: typing.Sequence[AssetId],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[UpsertPeopleAssetBatchResponse]:
        """
        Create or update assignments between employees and workspace assets (desks, spaces, etc.). This is typically used for desk assignments, office allocations, or space reservations. Each person can be assigned to multiple assets, and assets can have multiple people assigned (depending on capacity).

        Parameters
        ----------
        people_ids : typing.Sequence[str]

        asset_ids : typing.Sequence[AssetId]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[UpsertPeopleAssetBatchResponse]
            All people successfully assigned to the specified assets
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v2/people/batch/assets/upsert",
            method="PATCH",
            json={
                "peopleIds": people_ids,
                "assetIds": asset_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    UpsertPeopleAssetBatchResponse,
                    parse_obj_as(
                        type_=UpsertPeopleAssetBatchResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorSchema,
                        parse_obj_as(
                            type_=ErrorSchema,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorSchema,
                        parse_obj_as(
                            type_=ErrorSchema,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete_people_asset_batch(
        self,
        *,
        people_ids: typing.Sequence[str],
        asset_ids: typing.Sequence[AssetId],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[DeletePeopleAssetBatchResponse]:
        """
        Remove associations between people and assets

        Parameters
        ----------
        people_ids : typing.Sequence[str]

        asset_ids : typing.Sequence[AssetId]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DeletePeopleAssetBatchResponse]
            People-asset associations deleted successfully
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v2/people/batch/assets/delete",
            method="DELETE",
            json={
                "peopleIds": people_ids,
                "assetIds": asset_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeletePeopleAssetBatchResponse,
                    parse_obj_as(
                        type_=DeletePeopleAssetBatchResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorSchema,
                        parse_obj_as(
                            type_=ErrorSchema,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorSchema,
                        parse_obj_as(
                            type_=ErrorSchema,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorSchema,
                        parse_obj_as(
                            type_=ErrorSchema,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def add_people_group_members_batch(
        self,
        *,
        people_ids: typing.Sequence[str],
        group_ids: typing.Sequence[str],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[AddPeopleGroupMembersBatchResponse]:
        """
        Add people as members to multiple groups

        Parameters
        ----------
        people_ids : typing.Sequence[str]

        group_ids : typing.Sequence[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[AddPeopleGroupMembersBatchResponse]
            People added to groups successfully
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v2/people/batch/groups/add",
            method="PATCH",
            json={
                "peopleIds": people_ids,
                "groupIds": group_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AddPeopleGroupMembersBatchResponse,
                    parse_obj_as(
                        type_=AddPeopleGroupMembersBatchResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorSchema,
                        parse_obj_as(
                            type_=ErrorSchema,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorSchema,
                        parse_obj_as(
                            type_=ErrorSchema,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def remove_people_group_members_batch(
        self,
        *,
        people_ids: typing.Sequence[str],
        group_ids: typing.Sequence[str],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[RemovePeopleGroupMembersBatchResponse]:
        """
        Remove people as members from multiple groups

        Parameters
        ----------
        people_ids : typing.Sequence[str]

        group_ids : typing.Sequence[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[RemovePeopleGroupMembersBatchResponse]
            People removed from groups successfully
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v2/people/group/batch/members/remove",
            method="PATCH",
            json={
                "peopleIds": people_ids,
                "groupIds": group_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    RemovePeopleGroupMembersBatchResponse,
                    parse_obj_as(
                        type_=RemovePeopleGroupMembersBatchResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorSchema,
                        parse_obj_as(
                            type_=ErrorSchema,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorSchema,
                        parse_obj_as(
                            type_=ErrorSchema,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorSchema,
                        parse_obj_as(
                            type_=ErrorSchema,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawPeopleClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list_people(
        self, *, for_asset_ids: typing.Optional[str] = None, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[ListPeopleResponse]:
        """
        Retrieve a list of people with optional filtering by asset assignments. Use the forAssetIds parameter to filter people who are assigned to specific assets (desks, spaces, etc.). Returns complete employee profiles including contact information, employment status, group memberships, and current asset assignments.

        Parameters
        ----------
        for_asset_ids : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ListPeopleResponse]
            People list retrieved successfully with complete profiles and asset assignments
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v2/people",
            method="GET",
            params={
                "forAssetIds": for_asset_ids,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListPeopleResponse,
                    parse_obj_as(
                        type_=ListPeopleResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorSchema,
                        parse_obj_as(
                            type_=ErrorSchema,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def upsert_people_batch(
        self, *, people: typing.Sequence[PeopleInput], request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[UpsertPeopleBatchResponse]:
        """
        Create new people or update existing employee records in a single batch operation. Use this for HR system integrations, bulk imports, or synchronized employee data updates. Each person record can include employment details, contact information, and initial group assignments. Existing people are matched by ID and updated; new records without IDs are created.

        Parameters
        ----------
        people : typing.Sequence[PeopleInput]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[UpsertPeopleBatchResponse]
            All people records processed successfully - existing employees updated and new employees created
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v2/people/batch/upsert",
            method="POST",
            json={
                "people": convert_and_respect_annotation_metadata(
                    object_=people, annotation=typing.Sequence[PeopleInput], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    UpsertPeopleBatchResponse,
                    parse_obj_as(
                        type_=UpsertPeopleBatchResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorSchema,
                        parse_obj_as(
                            type_=ErrorSchema,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorSchema,
                        parse_obj_as(
                            type_=ErrorSchema,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete_people_batch(
        self, *, people_ids: typing.Sequence[str], request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[DeletePeopleBatchResponse]:
        """
        Permanently remove multiple employee records by their IDs. This operation also removes all associated asset assignments and group memberships. Use with caution as this action cannot be undone. Consider updating employment status to inactive instead of deletion for audit trail purposes.

        Parameters
        ----------
        people_ids : typing.Sequence[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DeletePeopleBatchResponse]
            All specified people records deleted successfully along with their assignments
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v2/people/batch/delete",
            method="DELETE",
            json={
                "peopleIds": people_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeletePeopleBatchResponse,
                    parse_obj_as(
                        type_=DeletePeopleBatchResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorSchema,
                        parse_obj_as(
                            type_=ErrorSchema,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorSchema,
                        parse_obj_as(
                            type_=ErrorSchema,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorSchema,
                        parse_obj_as(
                            type_=ErrorSchema,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def upsert_people_asset_batch(
        self,
        *,
        people_ids: typing.Sequence[str],
        asset_ids: typing.Sequence[AssetId],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[UpsertPeopleAssetBatchResponse]:
        """
        Create or update assignments between employees and workspace assets (desks, spaces, etc.). This is typically used for desk assignments, office allocations, or space reservations. Each person can be assigned to multiple assets, and assets can have multiple people assigned (depending on capacity).

        Parameters
        ----------
        people_ids : typing.Sequence[str]

        asset_ids : typing.Sequence[AssetId]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[UpsertPeopleAssetBatchResponse]
            All people successfully assigned to the specified assets
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v2/people/batch/assets/upsert",
            method="PATCH",
            json={
                "peopleIds": people_ids,
                "assetIds": asset_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    UpsertPeopleAssetBatchResponse,
                    parse_obj_as(
                        type_=UpsertPeopleAssetBatchResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorSchema,
                        parse_obj_as(
                            type_=ErrorSchema,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorSchema,
                        parse_obj_as(
                            type_=ErrorSchema,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete_people_asset_batch(
        self,
        *,
        people_ids: typing.Sequence[str],
        asset_ids: typing.Sequence[AssetId],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[DeletePeopleAssetBatchResponse]:
        """
        Remove associations between people and assets

        Parameters
        ----------
        people_ids : typing.Sequence[str]

        asset_ids : typing.Sequence[AssetId]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DeletePeopleAssetBatchResponse]
            People-asset associations deleted successfully
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v2/people/batch/assets/delete",
            method="DELETE",
            json={
                "peopleIds": people_ids,
                "assetIds": asset_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeletePeopleAssetBatchResponse,
                    parse_obj_as(
                        type_=DeletePeopleAssetBatchResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorSchema,
                        parse_obj_as(
                            type_=ErrorSchema,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorSchema,
                        parse_obj_as(
                            type_=ErrorSchema,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorSchema,
                        parse_obj_as(
                            type_=ErrorSchema,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def add_people_group_members_batch(
        self,
        *,
        people_ids: typing.Sequence[str],
        group_ids: typing.Sequence[str],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[AddPeopleGroupMembersBatchResponse]:
        """
        Add people as members to multiple groups

        Parameters
        ----------
        people_ids : typing.Sequence[str]

        group_ids : typing.Sequence[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[AddPeopleGroupMembersBatchResponse]
            People added to groups successfully
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v2/people/batch/groups/add",
            method="PATCH",
            json={
                "peopleIds": people_ids,
                "groupIds": group_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AddPeopleGroupMembersBatchResponse,
                    parse_obj_as(
                        type_=AddPeopleGroupMembersBatchResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorSchema,
                        parse_obj_as(
                            type_=ErrorSchema,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorSchema,
                        parse_obj_as(
                            type_=ErrorSchema,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def remove_people_group_members_batch(
        self,
        *,
        people_ids: typing.Sequence[str],
        group_ids: typing.Sequence[str],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[RemovePeopleGroupMembersBatchResponse]:
        """
        Remove people as members from multiple groups

        Parameters
        ----------
        people_ids : typing.Sequence[str]

        group_ids : typing.Sequence[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[RemovePeopleGroupMembersBatchResponse]
            People removed from groups successfully
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v2/people/group/batch/members/remove",
            method="PATCH",
            json={
                "peopleIds": people_ids,
                "groupIds": group_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    RemovePeopleGroupMembersBatchResponse,
                    parse_obj_as(
                        type_=RemovePeopleGroupMembersBatchResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorSchema,
                        parse_obj_as(
                            type_=ErrorSchema,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorSchema,
                        parse_obj_as(
                            type_=ErrorSchema,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorSchema,
                        parse_obj_as(
                            type_=ErrorSchema,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
