"""Python Pydantic validator code generator for SyncLangs types."""

from __future__ import annotations

import posixpath

from synclangs.codegen.base import CodeGenerator
from synclangs.parser.ast import (
    ConstDef,
    EnumDef,
    Field,
    ListTypeExpr,
    MapTypeExpr,
    Module,
    NullableTypeExpr,
    PrimitiveType,
    PrimitiveTypeExpr,
    TypeDef,
    TypeExpr,
    TypeRef,
)


class PydanticGenerator(CodeGenerator):
    """Generate Pydantic BaseModel classes from SyncLangs AST."""

    def __init__(self, file_extension: str = "_validators.py") -> None:
        self._file_extension = file_extension

    def generate(self, module: Module) -> str:
        """Generate Python Pydantic source code for a module."""
        lines: list[str] = [
            "# Auto-generated by SyncLangs - DO NOT EDIT",
            "from __future__ import annotations",
            "",
        ]

        # Collect imports needed
        stdlib_imports: list[str] = []
        pydantic_imports: list[str] = []

        if module.enums:
            stdlib_imports.append("from enum import Enum")

        if module.types:
            pydantic_imports.append("BaseModel")
            pydantic_imports.append("ConfigDict")

        typing_imports = self._collect_typing_imports(module)

        # Add stdlib imports
        lines.extend(stdlib_imports)

        # Add typing imports
        if typing_imports:
            imports = ", ".join(sorted(typing_imports))
            lines.append(f"from typing import {imports}")

        # Add pydantic imports
        if pydantic_imports:
            imports = ", ".join(sorted(pydantic_imports))
            lines.append(f"from pydantic import {imports}")

        lines.append("")

        # Add module imports
        if module.imports:
            for import_stmt in module.imports:
                import_path = self._python_import_path(
                    module.path, import_stmt.path
                )
                names = ", ".join(import_stmt.names)
                lines.append(f"from {import_path} import {names}")
            lines.append("")

        # Generate constants first
        for const_def in module.constants:
            lines.extend(self._generate_constant(const_def))
        if module.constants:
            lines.append("")

        # Generate enums
        for enum_def in module.enums:
            lines.extend(self._generate_enum(enum_def))
            lines.append("")

        # Generate Pydantic models (types)
        for type_def in module.types:
            lines.extend(self._generate_type(type_def))
            lines.append("")

        return "\n".join(lines).rstrip() + "\n"

    def _generate_constant(self, const_def: ConstDef) -> list[str]:
        """Generate a Python constant definition."""
        lines: list[str] = []
        if const_def.doc_comment:
            for line in const_def.doc_comment.splitlines():
                lines.append(f"# {line}")
        py_type = self._type_to_py(const_def.type_expr)
        value = self._const_value_to_py(const_def.value)
        lines.append(f"{const_def.name}: {py_type} = {value}")
        return lines

    def _generate_enum(self, enum_def: EnumDef) -> list[str]:
        """Generate a Python enum class."""
        lines: list[str] = []
        lines.append(f"class {enum_def.name}(str, Enum):")
        if enum_def.doc_comment:
            lines.extend(self._format_docstring(enum_def.doc_comment, "    "))
        if enum_def.variants:
            for variant in enum_def.variants:
                if variant.doc_comment:
                    for line in variant.doc_comment.splitlines():
                        lines.append(f"    # {line}")
                lines.append(f'    {variant.name.upper()} = "{variant.name}"')
        else:
            lines.append("    pass")
        return lines

    def _generate_type(self, type_def: TypeDef) -> list[str]:
        """Generate a Pydantic BaseModel class."""
        lines: list[str] = []

        # Class declaration
        lines.append(f"class {type_def.name}(BaseModel):")

        # Docstring
        if type_def.doc_comment:
            lines.extend(self._format_docstring(type_def.doc_comment, "    "))

        # Model config for strict validation
        lines.append('    model_config = ConfigDict(extra="forbid")')
        lines.append("")

        # Fields - sort so optional fields come last
        required_fields = [f for f in type_def.fields if not self._is_optional(f)]
        optional_fields = [f for f in type_def.fields if self._is_optional(f)]

        if type_def.fields:
            for field in required_fields + optional_fields:
                if field.doc_comment:
                    for line in field.doc_comment.splitlines():
                        lines.append(f"    # {line}")
                field_type, is_optional = self._field_type(field)
                if is_optional:
                    lines.append(f"    {field.name}: {field_type} = None")
                else:
                    lines.append(f"    {field.name}: {field_type}")
        else:
            lines.append("    pass")

        return lines

    def _is_optional(self, field: Field) -> bool:
        """Check if a field is optional (nullable)."""
        return isinstance(field.type_expr, NullableTypeExpr)

    def _const_value_to_py(self, value: "ConstDef.value") -> str:
        """Convert a constant value to Python literal."""
        from synclangs.parser.ast import ConstValue

        if not isinstance(value, ConstValue):
            return str(value)
        if isinstance(value.value, str):
            return f'"{value.value}"'
        if isinstance(value.value, bool):
            return "True" if value.value else "False"
        return str(value.value)

    def _collect_typing_imports(self, module: Module) -> set[str]:
        """Collect typing imports needed by the module."""
        imports: set[str] = set()
        for type_def in module.types:
            for field in type_def.fields:
                self._collect_type_imports(field.type_expr, imports)
        # Check constants for Any type
        for const_def in module.constants:
            self._collect_type_imports(const_def.type_expr, imports)
        return imports

    def _collect_type_imports(self, type_expr: TypeExpr, imports: set[str]) -> None:
        """Collect typing imports required for a type expression."""
        if isinstance(type_expr, NullableTypeExpr):
            # Don't need Optional import - use T | None syntax
            self._collect_type_imports(type_expr.inner_type, imports)
        elif isinstance(type_expr, ListTypeExpr):
            self._collect_type_imports(type_expr.element_type, imports)
        elif isinstance(type_expr, MapTypeExpr):
            self._collect_type_imports(type_expr.key_type, imports)
            self._collect_type_imports(type_expr.value_type, imports)
        elif isinstance(type_expr, PrimitiveTypeExpr):
            if type_expr.primitive == PrimitiveType.ANY:
                imports.add("Any")
        elif isinstance(type_expr, TypeRef):
            return

    def _field_type(self, field: Field) -> tuple[str, bool]:
        """Return the Python type and optional flag for a field."""
        if isinstance(field.type_expr, NullableTypeExpr):
            inner = self._type_to_py(field.type_expr.inner_type)
            return f"{inner} | None", True
        return self._type_to_py(field.type_expr), False

    def _type_to_py(self, type_expr: TypeExpr) -> str:
        """Convert a type expression to a Python type hint."""
        if isinstance(type_expr, PrimitiveTypeExpr):
            return self._primitive_to_py(type_expr.primitive)
        if isinstance(type_expr, ListTypeExpr):
            inner = self._type_to_py(type_expr.element_type)
            return f"list[{inner}]"
        if isinstance(type_expr, MapTypeExpr):
            key = self._type_to_py(type_expr.key_type)
            value = self._type_to_py(type_expr.value_type)
            return f"dict[{key}, {value}]"
        if isinstance(type_expr, NullableTypeExpr):
            inner = self._type_to_py(type_expr.inner_type)
            return f"{inner} | None"
        if isinstance(type_expr, TypeRef):
            return type_expr.name
        raise TypeError(f"Unsupported type expression: {type_expr}")

    def _primitive_to_py(self, primitive: PrimitiveType) -> str:
        """Map primitive SyncLangs types to Python types."""
        mapping = {
            PrimitiveType.STRING: "str",
            PrimitiveType.INT: "int",
            PrimitiveType.FLOAT: "float",
            PrimitiveType.BOOL: "bool",
            PrimitiveType.ANY: "Any",
        }
        return mapping[primitive]

    def _python_import_path(self, module_path: str, import_path: str) -> str:
        """Resolve an import path to a Python relative module path."""
        current_dir = posixpath.dirname(module_path)
        target_path = posixpath.normpath(posixpath.join(current_dir, import_path))
        if target_path.endswith(".syln"):
            target_path = target_path[: -len(".syln")] + self._file_extension
        if target_path.endswith(".py"):
            target_path = target_path[: -len(".py")]
        base = current_dir if current_dir else "."
        rel_path = posixpath.relpath(target_path, base)
        parts = rel_path.split("/")
        up_levels = 0
        while parts and parts[0] == "..":
            up_levels += 1
            parts.pop(0)
        prefix = "." * (up_levels + 1)
        suffix = ".".join(parts)
        return f"{prefix}{suffix}" if suffix else prefix

    def _format_docstring(self, text: str, indent: str) -> list[str]:
        """Format a docstring with the provided indentation."""
        lines = text.splitlines()
        if len(lines) == 1:
            return [f'{indent}"""{lines[0]}"""']
        formatted = [f'{indent}"""']
        formatted.extend(f"{indent}{line}" for line in lines)
        formatted.append(f'{indent}"""')
        return formatted
