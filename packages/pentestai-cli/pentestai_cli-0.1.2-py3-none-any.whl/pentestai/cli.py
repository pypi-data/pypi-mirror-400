from __future__ import annotations

import asyncio
import json
from pathlib import Path
from typing import List, Optional, Dict

import typer
from rich import print

from pentestai.core.config import load_config
from pentestai.core.artifacts import ws_paths
from pentestai.plugins.registry import default_registry
from pentestai.ai.router import AIRouter
from pentestai.ai.tasks import surface_analyze, triage_findings, build_report

app = typer.Typer(add_completion=False)


# helpers
def _csv(s: str) -> List[str]:
    return [x.strip() for x in (s or "").split(",") if x.strip()]


def _model_overrides(items: List[str]) -> Dict[str, str]:
    out: Dict[str, str] = {}
    for it in items or []:
        if "=" not in it:
            continue
        k, v = it.split("=", 1)
        out[k.strip()] = v.strip()
    return out


def ensure_workspace(cfg, target: str, workspace: str | None) -> Path:
    root = Path(cfg.workspace_root)
    ws = Path(workspace) if workspace else (root / target)
    paths = ws_paths(ws)
    for p in paths.values():
        Path(p).mkdir(parents=True, exist_ok=True)
    return ws


def _resolve_safe_override(safe: bool, unsafe: bool) -> Optional[bool]:
    if safe and unsafe:
        raise typer.BadParameter("Use only one: --safe OR --unsafe")
    if safe:
        return True
    if unsafe:
        return False
    return None


def _resolve_bool_override(enable: bool, disable: bool) -> Optional[bool]:
    """
    tri-state for features like follow-redirects/status-code:
      - none: None (use default)
      - --enable: True
      - --disable: False
    """
    if enable and disable:
        raise typer.BadParameter("Use only one enable/disable flag for this option")
    if enable:
        return True
    if disable:
        return False
    return None


def _load_scope_safe(cfg, ws: Path, target: str, scope_override: str, safe_override: Optional[bool]):
    paths = ws_paths(ws)
    scope_path = paths["inputs"] / "scope.json"
    if not scope_path.exists():
        raise typer.BadParameter("Run: pentestai init --target ... first")

    data = json.loads(scope_path.read_text(encoding="utf-8"))
    scope_list = _csv(scope_override) or data.get("scope", []) or [target]

    safe_mode_file = data.get("safe_mode", cfg.safe_mode_default)
    safe_mode = safe_mode_file if safe_override is None else safe_override

    return scope_list, safe_mode


def _build_router(cfg, provider: str, fallback: str, model_override: List[str], timeout: int):
    try:
        if provider:
            cfg.ai.default_provider = provider
    except Exception:
        pass

    try:
        if fallback:
            cfg.ai.fallback_providers = _csv(fallback)
    except Exception:
        pass

    try:
        cfg.ai.model_overrides = _model_overrides(model_override)
    except Exception:
        pass

    try:
        cfg.ai.request_timeout = timeout
    except Exception:
        pass

    return AIRouter(cfg)


# global options
GlobalWorkspace = typer.Option("", "--workspace", help="Workspace path override")
GlobalScope = typer.Option("", "--scope", help="Override scope allowlist: 'a.com,*.a.com'")
GlobalDryRun = typer.Option(False, "--dry-run", help="Print commands only (plugins must support)")
GlobalVerbose = typer.Option(False, "--verbose", help="Verbose logging (plugins may print more)")

AIProvider = typer.Option("", "--provider", help="AI provider: openai|anthropic|gemini|deepseek")
AIFallback = typer.Option("", "--fallback", help="Fallback chain: 'anthropic,gemini,deepseek'")
AIModelOverride = typer.Option([], "--model-override", help="Override model: provider=model (repeatable)")
AITimeout = typer.Option(60, "--timeout", help="AI request timeout seconds")


# init (NO --safe/--unsafe slash; default safe=True, use --unsafe to store false)
@app.command()
def init(
    target: str = typer.Option(..., "--target"),
    scope: str = typer.Option("", "--scope"),
    workspace: str = GlobalWorkspace,
    unsafe: bool = typer.Option(False, "--unsafe", help="Store unsafe mode in workspace (default is safe)"),
):
    cfg = load_config()
    ws = ensure_workspace(cfg, target, workspace or None)
    paths = ws_paths(ws)
    scope_list = _csv(scope) or [target]

    safe_mode = not unsafe

    (paths["inputs"] / "scope.json").write_text(
        json.dumps({"target": target, "scope": scope_list, "safe_mode": safe_mode}, indent=2),
        encoding="utf-8",
    )
    print(f"[bold green]Initialized[/bold green] workspace: {ws}")
    print(f"Scope: {scope_list}")
    print(f"Safe mode: {safe_mode}")


# recon
recon_app = typer.Typer()
app.add_typer(recon_app, name="recon")


@recon_app.command("run")
def recon_run(
    target: str = typer.Option(..., "--target"),
    workspace: str = GlobalWorkspace,
    scope: str = GlobalScope,

    # safe override (tri-state)
    safe: bool = typer.Option(False, "--safe", help="Force safe mode for this run"),
    unsafe: bool = typer.Option(False, "--unsafe", help="Force unsafe mode for this run"),

    dry_run: bool = GlobalDryRun,
    verbose: bool = GlobalVerbose,

    # subfinder flags
    subfinder_timeout: int = typer.Option(30, "--subfinder-timeout", help="Subfinder timeout (seconds)"),

    # httpx flags (NO slash dual flags)
    httpx_threads: int = typer.Option(50, "--httpx-threads", help="httpx threads"),
    httpx_timeout: int = typer.Option(10, "--httpx-timeout", help="httpx timeout (seconds)"),
    httpx_follow_redirects: bool = typer.Option(False, "--httpx-follow-redirects", help="Enable follow redirects"),
    httpx_no_follow_redirects: bool = typer.Option(False, "--httpx-no-follow-redirects", help="Disable follow redirects"),
    httpx_status_code: bool = typer.Option(False, "--httpx-status-code", help="Enable status code output"),
    httpx_no_status_code: bool = typer.Option(False, "--httpx-no-status-code", help="Disable status code output"),

    # nmap flags
    nmap_top_ports: int = typer.Option(1000, "--nmap-top-ports", help="Nmap top ports"),
    nmap_ports: str = typer.Option("", "--nmap-ports", help='Explicit ports list: "80,443,8080"'),
    nmap_args: str = typer.Option("", "--nmap-args", help='Extra args (safe): e.g. "-sV"'),
):
    cfg = load_config()
    ws = ensure_workspace(cfg, target, workspace or None)
    paths = ws_paths(ws)

    safe_override = _resolve_safe_override(safe, unsafe)
    scope_list, safe_mode = _load_scope_safe(cfg, ws, target, scope, safe_override)

    follow_override = _resolve_bool_override(httpx_follow_redirects, httpx_no_follow_redirects)
    status_override = _resolve_bool_override(httpx_status_code, httpx_no_status_code)

    # defaults if user didn't override
    follow_final = True if follow_override is None else follow_override
    status_final = True if status_override is None else status_override

    from pentestai.core.workflow import Context
    ctx = Context(
        workspace=ws,
        target=target,
        scope=scope_list,
        safe_mode=safe_mode,
        vars={
            "dry_run": dry_run,
            "verbose": verbose,
            "subfinder_timeout": subfinder_timeout,
            "httpx_threads": httpx_threads,
            "httpx_timeout": httpx_timeout,
            "httpx_follow_redirects": follow_final,
            "httpx_status_code": status_final,
            "nmap_top_ports": nmap_top_ports,
            "nmap_ports": nmap_ports,
            "nmap_args": nmap_args,
        },
    )

    plugins = default_registry()
    print("[cyan]Running subfinder...[/cyan]")
    plugins["subfinder"].run(ctx, {})
    print("[cyan]Running httpx...[/cyan]")
    plugins["httpx"].run(ctx, {})
    print("[cyan]Running nmap...[/cyan]")
    plugins["nmap"].run(ctx, {})

    print("[bold green]Recon done[/bold green]. Artifacts in:", paths["artifacts"])


# surface
surface_app = typer.Typer()
app.add_typer(surface_app, name="surface")


@surface_app.command("analyze")
def surface_cmd(
    target: str = typer.Option(..., "--target"),
    workspace: str = GlobalWorkspace,
    provider: str = AIProvider,
    fallback: str = AIFallback,
    model_override: List[str] = AIModelOverride,
    timeout: int = AITimeout,
):
    cfg = load_config()
    ws = ensure_workspace(cfg, target, workspace or None)
    router = _build_router(cfg, provider, fallback, model_override, timeout)

    asyncio.run(surface_analyze(router, ws, target))
    print("[bold green]Surface analysis saved[/bold green] -> artifacts/ai_surface.json")


# scan
scan_app = typer.Typer()
app.add_typer(scan_app, name="scan")


@scan_app.command("run")
def scan_run(
    target: str = typer.Option(..., "--target"),
    workspace: str = GlobalWorkspace,
    scope: str = GlobalScope,

    safe: bool = typer.Option(False, "--safe", help="Force safe mode for this run"),
    unsafe: bool = typer.Option(False, "--unsafe", help="Force unsafe mode for this run"),

    dry_run: bool = GlobalDryRun,
    verbose: bool = GlobalVerbose,

    # nuclei flags
    severity: str = typer.Option("low,medium,high,critical", "--severity"),
    tags: str = typer.Option("", "--tags", help="Include tags: 'cve,misconfig'"),
    exclude_tags: str = typer.Option("", "--exclude-tags", help="Exclude tags: 'dos,bruteforce'"),
    templates: str = typer.Option("", "--templates", help="Custom templates path"),
    rate_limit: int = typer.Option(150, "--rate-limit"),
    concurrency: int = typer.Option(25, "--concurrency"),
    retries: int = typer.Option(1, "--retries"),
):
    cfg = load_config()
    ws = ensure_workspace(cfg, target, workspace or None)
    paths = ws_paths(ws)

    safe_override = _resolve_safe_override(safe, unsafe)
    scope_list, safe_mode = _load_scope_safe(cfg, ws, target, scope, safe_override)

    from pentestai.core.workflow import Context
    ctx = Context(
        workspace=ws,
        target=target,
        scope=scope_list,
        safe_mode=safe_mode,
        vars={
            "dry_run": dry_run,
            "verbose": verbose,
            "nuclei_severity": severity,
            "nuclei_tags": tags,
            "nuclei_exclude_tags": exclude_tags,
            "nuclei_templates": templates,
            "nuclei_rate_limit": rate_limit,
            "nuclei_concurrency": concurrency,
            "nuclei_retries": retries,
        },
    )

    plugins = default_registry()
    print("[cyan]Running nuclei...[/cyan]")
    plugins["nuclei"].run(ctx, {})
    print("[bold green]Scan done[/bold green] -> artifacts/scan_findings.json")


# validate
validate_app = typer.Typer()
app.add_typer(validate_app, name="validate")


@validate_app.command("run")
def validate_run(
    target: str = typer.Option(..., "--target"),
    workspace: str = GlobalWorkspace,
    provider: str = AIProvider,
    fallback: str = AIFallback,
    model_override: List[str] = AIModelOverride,
    timeout: int = AITimeout,
    max_findings: int = typer.Option(200, "--max-findings", help="Cap findings sent to AI"),
    focus: str = typer.Option("", "--focus", help="Focus areas: 'auth,idor,headers'"),
    review: bool = typer.Option(False, "--review", help="Enable reviewer pass (if implemented)"),
):
    cfg = load_config()
    ws = ensure_workspace(cfg, target, workspace or None)
    router = _build_router(cfg, provider, fallback, model_override, timeout)

    try:
        cfg.ai.max_findings = max_findings
        cfg.ai.focus = focus
        cfg.ai.review = review
    except Exception:
        pass

    asyncio.run(triage_findings(router, ws))
    print("[bold green]Triage/Validation helper saved[/bold green] -> artifacts/ai_triage.json")


# report
report_app = typer.Typer()
app.add_typer(report_app, name="report")


@report_app.command("build")
def report_build(
    target: str = typer.Option(..., "--target"),
    workspace: str = GlobalWorkspace,
    provider: str = AIProvider,
    fallback: str = AIFallback,
    model_override: List[str] = AIModelOverride,
    timeout: int = AITimeout,
    out: str = typer.Option("", "--out", help="Output report path (md). Default: workspace/reports/report.md"),
):
    cfg = load_config()
    ws = ensure_workspace(cfg, target, workspace or None)
    router = _build_router(cfg, provider, fallback, model_override, timeout)

    asyncio.run(build_report(router, ws, target))

    if out:
        paths = ws_paths(ws)
        src = paths["reports"] / "report.md"
        dst = Path(out)
        dst.parent.mkdir(parents=True, exist_ok=True)
        dst.write_text(src.read_text(encoding="utf-8"), encoding="utf-8")
        print(f"[bold green]Report copied[/bold green] -> {dst}")
    else:
        print("[bold green]Report built[/bold green] -> reports/report.md")
