import asyncio
import logging
import datetime
import builtins
from numbers import Number
from collections.abc import Callable
from asyncdb.exceptions import NoDataFound, ProviderError
from querysource.exceptions import DataNotFound
from querysource.utils.functions import format_date
import querysource.utils.functions as qsfunctions
from ..exceptions import ComponentError, NotSupported
from ..utils import fnExecutor
from .IteratorBase import IteratorBase


class DateList(IteratorBase):
    """
    DateList.

    Overview

            Run as many times as dates generated by this component.
       :widths: auto

    | range        |   Yes    | Start and end date range parameter                                |
    | inc          |   Yes    | Increases the counter value N times                               |
    | format       |   Yes    | Date format to generate                                           |
    | vars         |   Yes    | Generate variables from the start date you generate in each       |
    |              |          | iterator                                                          |


    Return the list of arbitrary days



        Example:

    |---|---|---|
    | version | No | version of component |


        Example:

        | Name | Required | Summary |
    |---|---|---|
    | version | No | version of component |


        Example:

        ```yaml
          DateList:
          range:
          start: 01-12-2021
          end: 24-12-2021
          format: '%d-%m-%Y'
          inc: 1
          format: '%Y-%m-%dT%H:%M:%S'
          vars:
          firstdate: '{date}'
          lastdate:
          - to_midnight
          - mask: '%Y-%m-%d %H:%M:%S'
          iterate: true
        ```
    """
    _version = "1.0.0"

    def __init__(
        self,
        loop: asyncio.AbstractEventLoop = None,
        job: Callable = None,
        stat: Callable = None,
        **kwargs,
    ):
        self._path = None
        self.pattern = None
        self._increment = 1
        self._iterator = None
        self._format = "%Y-%m-%d"
        super(DateList, self).__init__(loop=loop, job=job, stat=stat, **kwargs)

    async def start(self, **kwargs):
        """Get Range of Dates."""
        await super(DateList, self).start()
        if not hasattr(self, "range"):
            raise ComponentError("Error: you need to specify a range attribute")
        # get start and end dates
        if "start" not in self.range:
            raise ComponentError("Error: you need to specify a start Date")
        if "end" not in self.range:
            raise ComponentError("Error: you need to specify an End Date")
        ### Incremental:
        if hasattr(self, "inc"):
            self._increment = self.inc
        if "increment" in self._variables:
            self._increment = int(self._variables["increment"])
        elif "inc" in self._args:
            self._increment = int(self._args["inc"])
        self.setVar("inc", self._increment)
        if hasattr(self, "format"):
            self._format = self.format
        # set the start:end of the range
        if "start" in self._args:
            range_start = self._args["start"]
        elif isinstance(self.range["start"], list):
            range_start = fnExecutor(self.range["start"])
        else:
            range_start = self.range["start"]
        if "end" in self._args:
            range_end = self._args["end"]
        elif isinstance(self.range["end"], list):
            range_end = fnExecutor(self.range["end"])
        else:
            range_end = self.range["end"]
        # build the dates
        start = datetime.datetime.strptime(range_start, self.range["format"])
        end = datetime.datetime.strptime(range_end, self.range["format"])
        if self._debug:
            self._logger.debug(f"RANGE> {start!s} - {end!s}")
            self._logger.debug(f'INCREMENT> {self._increment}')
        # define the generator
        self._iterator = (
            start + datetime.timedelta(days=x)
            for x in range(0, (end - start).days + 1, self._increment)
        )
        self.add_metric("RANGE", f"{start!s} - {end!s}")
        self.add_metric("INCREMENT", self._increment)
        return True

    def createJob(self, target, params, dt, d):
        """Create the Job Component."""
        self._result = str(dt)
        if hasattr(self, "vars"):
            for name, value in self.vars.items():
                kwargs = {}
                if value == "{date}":
                    val = value.format(date=dt)
                elif name in self._params:
                    val = self._params[name]
                elif name in self.conditions:
                    val = self.conditions[name]
                elif isinstance(value, list):
                    fname = value[0]
                    try:
                        kwargs = value[1].copy()
                        for k, v in value[1].items():
                            if isinstance(v, int):
                                kwargs[k] = v
                            elif "{increment}" in v:
                                kwargs[k] = self._increment - 1
                            elif "{date}" in v:
                                kwargs[k] = v.format(date=dt)
                    except IndexError:
                        kwargs = {}
                    if 'value' not in kwargs:
                        t = {"value": d}
                    else:
                        t = {}
                    kwargs = {**kwargs, **t}
                    try:
                        f = getattr(qsfunctions, fname)
                    except AttributeError:
                        f = getattr(builtins, fname)
                    try:
                        val = f(**kwargs)
                    except (TypeError, AttributeError):
                        try:
                            val = globals()[fname](**kwargs)
                        except (TypeError, ValueError) as err:
                            print(str(err))
                            val = None
                elif name in self._mask:
                    val = self._mask[name]
                elif isinstance(value, int):
                    val = int(value)
                elif isinstance(value, Number):
                    val = value
                elif isinstance(value, str):
                    val = value.format(date=dt)
                else:
                    val = value.format(date=dt)
                params[name] = val
                self.setVar(name, val)
        else:
            # think if we need to create the vars using self._vars
            for name, value in self._vars.items():
                print("VARIABLES::: ", name, value)
                if value == "{date}":
                    params[name] = dt
                    self.setVar(name, dt)
                else:
                    params[name] = value
                    self.setVar(name, value)
        params["date"] = dt
        params["filterdate"] = dt
        return self.get_job(target, **params)

    def setAttributes(self, dt):
        """Defining the result to component."""
        try:
            self.setVar("{}_{}".format(self.StepName, "DATE"), dt)
            self._result = str(dt)
        except Exception as err:
            print(err)
            return False

    async def close(self, job=None):
        close = getattr(job, "close", None)
        if job:
            if asyncio.iscoroutinefunction(close):
                await job.close()
            else:
                job.close()

    async def run(self):
        """Async Run Method."""
        status = False
        if not self._iterator:
            return False
        if self.iterate:
            # iterate over next task
            step, target, params = self.get_step()
            step_name = step.name
            for d in self._iterator:
                dt = format_date(d, self._format)

                self.setAttributes(dt)
                job = self.createJob(target, params, dt, d)
                if job:
                    try:
                        status = await self.async_job(job, step_name)
                    except (NoDataFound, DataNotFound) as err:
                        # its a data component a no data was found
                        logging.debug(
                            f"Data not Found for Task {step_name}, Error: {err}"
                        )
                        continue
                    except (ProviderError, ComponentError) as err:
                        raise ComponentError(
                            f"Error running Component {step_name}, error: {err}"
                        ) from err
                    except NotSupported as err:
                        raise NotSupported(
                            f"Not Supported: Error on Component {step_name}, error: {err}"
                        ) from err
                    except Exception as err:
                        raise ComponentError(
                            f"DateList: Component Error on {step_name}, error: {err}"
                        ) from err
                    finally:
                        await self.close(job)
            if status is False:
                return False
            else:
                return True
        else:
            # return the list of date
            self._result = list(self._iterator)
            return True
