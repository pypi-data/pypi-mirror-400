\
from __future__ import annotations

import json
import re
from pathlib import Path
from typing import Dict, List, Tuple

from ..core import detect_repo_type, read_text, write_text, rel


def cmd_index(args) -> int:
    root = Path(args.path).resolve()
    repo_type = detect_repo_type(root)

    commands = collect_commands(root)
    md = render_commands_md(root, commands)

    print(md)

    if args.write:
        outp = root / "COMMANDS.md"
        write_text(outp, md, overwrite=True)
        print(f"\n[OK] wrote {rel(outp)}")

    if args.update_readme and (root / "README.md").exists():
        _ensure_readme_link(root)

    return 0


def collect_commands(root: Path) -> Dict[str, List[str]]:
    out: Dict[str, List[str]] = {}

    # Makefile targets
    mk = root / "Makefile"
    if mk.exists():
        out["Makefile"] = parse_makefile_targets(mk)

    # package.json scripts
    pj = root / "package.json"
    if pj.exists():
        out["npm scripts"] = parse_package_json_scripts(pj)

    # pyproject scripts (very small parser)
    pp = root / "pyproject.toml"
    if pp.exists():
        scripts = parse_pyproject_scripts(pp)
        if scripts:
            out["pyproject scripts"] = scripts

    # scripts/ folder
    scripts_dir = root / "scripts"
    if scripts_dir.exists() and scripts_dir.is_dir():
        files = []
        for p in sorted(scripts_dir.rglob("*")):
            if p.is_file() and p.suffix.lower() in [".sh", ".ps1", ".bat", ".py", ".js"]:
                files.append(str(p.relative_to(root)))
        if files:
            out["scripts/"] = files

    return out


def parse_makefile_targets(path: Path) -> List[str]:
    text = read_text(path)
    targets = []
    for line in text.splitlines():
        if line.startswith("\t") or line.strip().startswith("#"):
            continue
        m = re.match(r"^([A-Za-z0-9_.-]+)\s*:(?![=]).*$", line)
        if m:
            t = m.group(1)
            if t not in targets and t not in [".PHONY"]:
                targets.append(t)
    return targets


def parse_package_json_scripts(path: Path) -> List[str]:
    data = json.loads(read_text(path))
    scripts = data.get("scripts", {}) if isinstance(data, dict) else {}
    return [f"npm run {k}" for k in scripts.keys()]


def parse_pyproject_scripts(path: Path) -> List[str]:
    """
    Minimal parser: look for [project.scripts] or [tool.poetry.scripts]
    and read key/value lines until next section.
    """
    text = read_text(path).splitlines()
    out = []

    def scan(section: str):
        nonlocal out
        in_sec = False
        for line in text:
            s = line.strip()
            if s.startswith("[") and s.endswith("]"):
                in_sec = (s == section)
                continue
            if not in_sec:
                continue
            if not s or s.startswith("#"):
                continue
            # key = "value"
            if "=" in s:
                key = s.split("=", 1)[0].strip()
                if key:
                    out.append(key)

    scan("[project.scripts]")
    scan("[tool.poetry.scripts]")
    return out


def render_commands_md(root: Path, commands: Dict[str, List[str]]) -> str:
    lines = [f"# Command Index ({root.name})", ""]
    if not commands:
        lines += ["No common entrypoints detected.", ""]
        return "\n".join(lines) + "\n"

    lines += ["This file is auto-generated by **rebo index**.", ""]

    for group, cmds in commands.items():
        lines.append(f"## {group}")
        lines.append("")
        for c in cmds:
            lines.append(f"- `{c}`")
        lines.append("")

    return "\n".join(lines) + "\n"


def _ensure_readme_link(root: Path) -> None:
    readme = root / "README.md"
    txt = read_text(readme)

    link_line = "- [COMMANDS.md](COMMANDS.md) â€” command index\n"
    if "COMMANDS.md" in txt:
        return

    # naive insertion after title
    lines = txt.splitlines(True)
    out = []
    inserted = False
    for i, line in enumerate(lines):
        out.append(line)
        if (not inserted) and line.startswith("# "):
            # insert a small "Docs" section
            out.append("\n## Docs\n\n")
            out.append(link_line + "\n")
            inserted = True

    if not inserted:
        out = [txt, "\n## Docs\n\n", link_line, "\n"]

    write_text(readme, "".join(out), overwrite=True)
    print(f"[OK] updated {rel(readme)} (added COMMANDS.md link)")
