//
// Copyright 2025 Formata, Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//


#[test]
fn async_expr() {
    // any function can be an async function
    const promise = async self.async_expr_test();
    assert_eq(await promise, 578);
}
fn async_expr_test() -> int {
    578
}

#[test]
fn async_block_expr() {
    const res = async {
        return await async {
            let v = 7;
            v * 2
        };
    };
    assert_eq(typeof res, 'Promise<void>'); // basically an unknown promise type
    assert_eq(await res, 14);
}

#[test]
fn async_block() {
    const v = [];

    // creates a new process, just like an async function call
    async {
        v.push_back('hello');
        assert_eq(v, ['hello']);
    }

    // might be empty or have a 'hello' depending on when the process gets executed
    assert(v == [] || v == ['hello']);
}

#[test]
fn async_functions() {
    // can await lists of handles to get a list
    const results = await [self.this_is_async(), self.this_is_also_async()];
    assert_eq(results, ['hello, async', 'async is actually just an attribute']);
}
async fn this_is_async() -> str {
    'hello, async'
}
#[async]
fn this_is_also_async() -> str {
    return 'async is actually just an attribute';
}

#[test]
fn promise_type() {
    const promise = self.async_with_promise();
    assert_eq(typeof promise, 'Promise<str>');
    assert_eq(await promise, 'hello, promises');
    assert_eq(await 'hello', 'hello'); // await is passthrough if not a promise

    assert_eq(self.takes_promise_param(self.async_with_promise()), 'hello, promises');
    assert_eq(self.takes_promise_param('hello, values'), 'hello, values');
}
async fn async_with_promise() -> Promise<str> {
    'hello, promises'
}
fn takes_promise_param(param: Promise<str>) -> str {
    await param
}

#[test]
fn cast_promises() {
    let promise = (async { return '100'; }) as Promise<str>;
    assert_eq(typeof promise, 'Promise<str>');
    
    promise = promise as int;
    assert_eq(typeof promise, 'Promise<int>');

    const res = await promise;
    assert_eq(typeof res, 'int');
    assert_eq(res, 100);
}

#[test]
fn await_void_handles() {
    let handles = [];
    for (const _ in 10) handles.push_back(async {
        let res = 10 * 10; // just something silly i guess
    });
    await handles;
}
