import typing
from PalmSens.Fitting import IModelBase, Parameters, FitOptionsCircuit
from PalmSens.Plottables import EISData, Curve
from System import Array_1
from System.Collections.Generic import List_1, IList_1
from PalmSens.Fitting.Models.Circuits import ISubGroup
from System.Numerics import Complex
from MathNet.Numerics.LinearAlgebra import Vector_1

class CircuitModel(IModelBase):
    def __init__(self) -> None: ...
    @property
    def ChiSq(self) -> float: ...
    @ChiSq.setter
    def ChiSq(self, value: float) -> float: ...
    @property
    def EISData(self) -> EISData: ...
    @property
    def InitialParameters(self) -> Parameters: ...
    @InitialParameters.setter
    def InitialParameters(self, value: Parameters) -> Parameters: ...
    @property
    def Name(self) -> str: ...
    @property
    def NIterations(self) -> int: ...
    @NIterations.setter
    def NIterations(self, value: int) -> int: ...
    @property
    def NParameters(self) -> int: ...
    @property
    def ParameterSDs(self) -> Array_1[float]: ...
    @ParameterSDs.setter
    def ParameterSDs(self, value: Array_1[float]) -> Array_1[float]: ...
    @property
    def PrefixMultiplier(self) -> Array_1[float]: ...
    def CloneModelParameters(self, cloneFrom: CircuitModel) -> None: ...
    def GetCapacitance(self) -> Array_1[Curve]: ...
    def GetCircuitParameterValues(self, circuit: List_1[ISubGroup], excludePreviews: bool = ...) -> Array_1[float]: ...
    def GetCurvePhaseOverFrequency(self, logF: bool = ...) -> Array_1[Curve]: ...
    def GetCurveZabsOverFrequency(self, logF: bool = ...) -> Array_1[Curve]: ...
    def GetEISDataResult(self) -> EISData: ...
    def GetErrorPhase(self, logF: bool = ...) -> Array_1[Curve]: ...
    def GetErrorZabs(self, logF: bool = ...) -> Array_1[Curve]: ...
    def GetErrorZreal(self, logF: bool = ...) -> Array_1[Curve]: ...
    def GetNyquist(self) -> Array_1[Curve]: ...
    def GetResidualValue(self, parameters: Array_1[float], omega: float, zRaw: Complex) -> Complex: ...
    def GetResidualValues(self, parameters: Array_1[float], x: Array_1[float], y: Array_1[float]) -> Array_1[float]: ...
    def GetValue(self, parameters: Array_1[float], omega: float) -> Complex: ...
    def GetValues(self, parameters: Array_1[float], omega: Array_1[float]) -> Array_1[Complex]: ...
    def InitialParameterValues(self) -> Array_1[float]: ...
    def InitOmega(self, omega: Vector_1[float]) -> None: ...
    def SetCircuitParameterValues(self, circuit: List_1[ISubGroup], values: Array_1[float]) -> List_1[ISubGroup]: ...
    def SetEISdata(self, data: EISData) -> None: ...
    def SetFitResults(self, chiSquare: float, parSDs: Array_1[float], iterations: int, exitCode: int) -> None: ...
    def SetFixedParameters(self, fixedParameters: IList_1[bool]) -> None: ...
    def SetInitialParameters(self, newParameters: Array_1[float]) -> None: ...
    # Skipped EvaluatePointError due to it being static, abstract and generic.

    EvaluatePointError : EvaluatePointError_MethodGroup
    class EvaluatePointError_MethodGroup:
        @typing.overload
        def __call__(self, parameters: Array_1[float]) -> float:...
        @typing.overload
        def __call__(self, parameters: Array_1[float], fitOptionsCircuit: FitOptionsCircuit) -> float:...

    # Skipped SetCircuit due to it being static, abstract and generic.

    SetCircuit : SetCircuit_MethodGroup
    class SetCircuit_MethodGroup:
        @typing.overload
        def __call__(self, _circuit: List_1[ISubGroup]) -> None:...
        @typing.overload
        def __call__(self, cdc: str) -> None:...
