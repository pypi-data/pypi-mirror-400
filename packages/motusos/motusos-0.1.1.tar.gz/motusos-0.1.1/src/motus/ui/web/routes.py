# Copyright (c) 2024-2025 Veritas Collaborative, LLC
# SPDX-License-Identifier: LicenseRef-MCSL

"""
HTTP route handlers for Motus Web UI.

Handles dashboard serving and API endpoints.
"""

from pathlib import Path

from fastapi import FastAPI
from fastapi.responses import HTMLResponse

from motus import __version__
from motus.cli import analyze_session, extract_decisions
from motus.logging import get_logger
from motus.orchestrator import get_orchestrator

logger = get_logger(__name__)

# Static files and template paths
# Note: routes.py is in ui/web/, but templates/static are in ui/
UI_DIR = Path(__file__).parent.parent
TEMPLATES_DIR = UI_DIR / "templates"


def register_routes(app: FastAPI) -> None:
    """Register HTTP routes on the FastAPI app.

    Args:
        app: FastAPI application instance
    """

    @app.get("/", response_class=HTMLResponse)
    async def dashboard():
        """Serve the dashboard HTML page."""
        # Serve from template file (required - no embedded fallback)
        template_file = TEMPLATES_DIR / "dashboard.html"
        if not template_file.exists():
            raise FileNotFoundError(
                f"Dashboard template not found: {template_file}. "
                "Ensure motusos is properly installed with template files."
            )

        try:
            content = template_file.read_text()
        except OSError as e:
            logger.error(
                "Failed to read dashboard template",
                template_file=str(template_file),
                error_type=type(e).__name__,
                error=str(e),
            )
            raise RuntimeError(f"Failed to read dashboard template: {template_file}") from e
        content = content.replace("{{ version }}", __version__)
        return HTMLResponse(content=content)

    @app.get("/api/summary/{session_id}")
    async def get_summary(session_id: str):
        """Generate session summary markdown (same as CLI motus summary).

        Args:
            session_id: Session ID to generate summary for

        Returns:
            Dict with session_id, summary markdown, and project path
        """
        # Use get_session() with cache instead of discover_all()
        target_session = get_orchestrator().get_session(session_id)

        if not target_session:
            return {"error": f"Session not found: {session_id}"}

        try:
            stats = analyze_session(target_session)
            decisions = extract_decisions(target_session.file_path)

            # Generate rich markdown for CLAUDE.md
            summary = f"""## Motus Session Memory

> Auto-generated by Motus. Inject this into CLAUDE.md for agent continuity.

### Session Info
- **ID:** `{target_session.session_id[:12]}`
- **Project:** `{target_session.project_path}`
- **Size:** {target_session.size // 1024}KB
- **Last Active:** {target_session.last_modified.strftime("%Y-%m-%d %H:%M")}

### Activity Summary
| Metric | Count |
|--------|-------|
| Thinking blocks | {stats.thinking_count} |
| Tool calls | {stats.tool_count} |
| Agents spawned | {stats.agent_count} |
| Files modified | {len(stats.files_modified)} |
| High-risk ops | {stats.high_risk_ops} |

### Files Modified This Session
"""
            if stats.files_modified:
                for f in list(stats.files_modified)[:15]:
                    short_path = f
                    if len(f) > 60:
                        parts = f.split("/")
                        short_path = "/".join(parts[-3:]) if len(parts) > 3 else f
                    summary += f"- `{short_path}`\n"
            else:
                summary += "- None yet\n"

            summary += "\n### Decisions Made (from thinking blocks)\n"
            if decisions:
                for d in decisions[:8]:
                    summary += f"- {d}\n"
            else:
                summary += "- No explicit decisions captured\n"

            return {
                "session_id": target_session.session_id,
                "summary": summary,
                "project": target_session.project_path,
            }
        except Exception as e:
            logger.error(
                "Error generating summary",
                error_type=type(e).__name__,
                error=str(e),
            )
            return {"error": str(e)}
