"""
CLI entry point for clidup

Provides backup and restore commands for database operations.
"""

import sys
import re
import typer
from pathlib import Path
from typing import Optional
from enum import Enum

from ..config.loader import ConfigLoader
from ..databases.postgres import PostgresHandler
from ..core.backup import perform_backup
from ..core.restore import perform_restore
from ..logging.logger import setup_logger


# Create Typer app
app = typer.Typer(
    name="clidup",
    help="Professional CLI tool for database backups and restores",
    add_completion=False
)


class DatabaseType(str, Enum):
    """Supported database types"""
    postgres = "postgres"


def extract_db_name_from_filename(filename: str) -> Optional[str]:
    """
    Extract database name from backup filename using regex
    
    Format: <db_type>_<db_name>_full_<YYYY-MM-DD>_<HH-MM-SS>.sql[.tar.gz]
    
    Args:
        filename: Backup filename (without path)
        
    Returns:
        Database name if found, None otherwise
        
    Examples:
        >>> extract_db_name_from_filename("postgres_mydb_full_2026-01-07_23-45-12.sql")
        'mydb'
        >>> extract_db_name_from_filename("postgres_my_production_db_full_2026-01-07_23-45-12.sql.tar")
        'my_production_db'
    """
    # Remove common extensions
    name = filename.replace('.tar.gz', '').replace('.tar', '').replace('.sql', '')
    
    # Pattern: postgres_<db_name>_full_<date>_<time>
    # db_name can contain underscores, so we use non-greedy match (.+?)
    pattern = r'^postgres_(.+?)_full_\d{4}-\d{2}-\d{2}_\d{2}-\d{2}(?:-\d{2})?$'
    match = re.match(pattern, name)
    
    if match:
        return match.group(1)
    return None


@app.command()
def init():
    """
    Initialize clidup configuration
    
    Creates config.yaml and .env files with your database settings.
    Run this once before using backup/restore commands.
    
    Example:
        clidup init
    """
    from pathlib import Path
    import getpass
    
    typer.echo("\nWelcome to clidup initialization!")
    typer.echo("=" * 50)
    typer.echo("This will create config.yaml and .env files")
    typer.echo("in the current directory.\n")
    
    # Check if files already exist
    config_file = Path("config.yaml")
    env_file = Path(".env")
    
    if config_file.exists() or env_file.exists():
        typer.echo("Warning: config.yaml or .env already exists.")
        overwrite = typer.confirm("Do you want to overwrite?", default=False)
        if not overwrite:
            typer.echo("Initialization cancelled.")
            raise typer.Exit()
    
    # Collect PostgreSQL configuration
    typer.echo("\nPostgreSQL Configuration:")
    typer.echo("-" * 50)
    
    host = typer.prompt("Host", default="localhost")
    port = typer.prompt("Port", default="5432")
    username = typer.prompt("Username", default="postgres")
    database = typer.prompt("Default database", default="postgres")
    password = getpass.getpass("Password (hidden): ")
    
    # Collect backup settings
    typer.echo("\nBackup Settings:")
    typer.echo("-" * 50)
    
    backup_dir = typer.prompt("Backup directory", default="./backups")
    
    # Create config.yaml
    config_content = f"""# clidup Configuration File
# Generated by: clidup init

# PostgreSQL Database Configuration
postgres:
  host: {host}
  port: {port}
  username: {username}
  database: {database}

# Backup Settings
backup:
  directory: {backup_dir}
"""
    
    with open(config_file, 'w') as f:
        f.write(config_content)
    
    typer.echo(f"\nCreated: {config_file.absolute()}")
    
    # Create .env file
    env_content = f"""# clidup Environment Variables
# Generated by: clidup init
# IMPORTANT: Never commit this file to version control

POSTGRES_PASSWORD={password}
"""
    
    with open(env_file, 'w') as f:
        f.write(env_content)
    
    typer.echo(f"Created: {env_file.absolute()}")
    
    # Create backup directory
    backup_path = Path(backup_dir)
    backup_path.mkdir(parents=True, exist_ok=True)
    typer.echo(f"Created: {backup_path.absolute()}")
    
    # Success message
    typer.echo("\n" + "=" * 50)
    typer.echo("Initialization complete!")
    typer.echo("=" * 50)
    typer.echo("\nYou can now use clidup:")
    typer.echo("  clidup backup --db postgres --db-name mydb")
    typer.echo("  clidup restore --db postgres --file backup.sql")
    typer.echo("\nFor help: clidup --help")



@app.command()
def backup(
    db: DatabaseType = typer.Option(
        ...,
        "--db",
        help="Database type (currently only 'postgres' is supported)"
    ),
    db_name: str = typer.Option(
        ...,
        "--db-name",
        help="Name of the database to backup"
    ),
    compress: bool = typer.Option(
        False,
        "--compress",
        help="Compress the backup file using tar.gz"
    ),
    config_file: Optional[str] = typer.Option(
        None,
        "--config",
        help="Path to config.yaml file (default: searches current directory)"
    )
):
    """
    Create a backup of a database
    
    Example:
        clidup backup --db postgres --db-name myapp_db --compress
    """
    try:
        # Load configuration
        config = ConfigLoader(config_file)
        
        # Setup logger
        log_file = config.get_backup_directory() / "clidup.log"
        logger = setup_logger(log_file=log_file)
        
        # Get database configuration
        if db == DatabaseType.postgres:
            db_config = config.get_postgres_config()
            db_handler = PostgresHandler(db_config)
        else:
            typer.echo(f"Error: Unsupported database type: {db}", err=True)
            raise typer.Exit(code=1)
        
        # Get backup directory
        backup_dir = config.get_backup_directory()
        
        # Perform backup
        backup_file = perform_backup(
            db_handler=db_handler,
            db_type=db.value,
            db_name=db_name,
            backup_dir=backup_dir,
            compress=compress
        )
        
        typer.echo(f"\nBackup completed successfully!")
        typer.echo(f"Backup file: {backup_file}")
        typer.echo(f"Logs: {log_file}")
        
    except FileNotFoundError as e:
        typer.echo(f"Error: File not found: {e}", err=True)
        raise typer.Exit(code=1)
    except ValueError as e:
        typer.echo(f"Error: Configuration error: {e}", err=True)
        raise typer.Exit(code=1)
    except RuntimeError as e:
        typer.echo(f"Error: Backup failed: {e}", err=True)
        raise typer.Exit(code=1)
    except Exception as e:
        typer.echo(f"Error: Unexpected error: {e}", err=True)
        raise typer.Exit(code=1)


@app.command()
def restore(
    db: DatabaseType = typer.Option(
        ...,
        "--db",
        help="Database type (currently only 'postgres' is supported)"
    ),
    file: str = typer.Option(
        ...,
        "--file",
        help="Path to backup file to restore from"
    ),
    db_name: Optional[str] = typer.Option(
        None,
        "--db-name",
        help="Name of the database to restore to (if different from backup)"
    ),
    config_file: Optional[str] = typer.Option(
        None,
        "--config",
        help="Path to config.yaml file (default: searches current directory)"
    ),
    yes: bool = typer.Option(
        False,
        "--yes",
        "-y",
        help="Skip confirmation prompt (use with caution)"
    )
):
    """
    Restore a database from a backup file
    
    Example:
        clidup restore --db postgres --file backups/postgres_myapp_db_full_2026-01-07_22-30.sql
    """
    try:
        # Load configuration
        config = ConfigLoader(config_file)
        
        # Setup logger
        log_file = config.get_backup_directory() / "clidup.log"
        logger = setup_logger(log_file=log_file)
        
        # Get database configuration
        if db == DatabaseType.postgres:
            db_config = config.get_postgres_config()
            db_handler = PostgresHandler(db_config)
        else:
            typer.echo(f"‚ùå Unsupported database type: {db}", err=True)
            raise typer.Exit(code=1)
        
        # Determine database name
        if db_name is None:
            # Try to extract from filename using regex
            backup_path = Path(file)
            db_name = extract_db_name_from_filename(backup_path.name)
            
            if db_name:
                typer.echo(f"Info: Detected database name from filename: {db_name}")
            else:
                typer.echo(
                    "Error: Could not detect database name from filename. "
                    "Please specify --db-name explicitly.\n"
                    "Expected format: postgres_<db_name>_full_<YYYY-MM-DD>_<HH-MM-SS>.sql",
                    err=True
                )
                raise typer.Exit(code=1)
        
        # Perform restore
        backup_file = Path(file)
        perform_restore(
            db_handler=db_handler,
            db_name=db_name,
            backup_file=backup_file,
            skip_confirmation=yes
        )
        
        typer.echo(f"Logs: {log_file}")
        
    except FileNotFoundError as e:
        typer.echo(f"Error: File not found: {e}", err=True)
        raise typer.Exit(code=1)
    except ValueError as e:
        typer.echo(f"Error: Configuration error: {e}", err=True)
        raise typer.Exit(code=1)
    except RuntimeError as e:
        typer.echo(f"Error: Restore failed: {e}", err=True)
        raise typer.Exit(code=1)
    except Exception as e:
        typer.echo(f"Error: Unexpected error: {e}", err=True)
        raise typer.Exit(code=1)


@app.callback(invoke_without_command=True)
def main(
    version: bool = typer.Option(
        False,
        "--version",
        "-v",
        help="Show version information"
    )
):
    """
    clidup - Professional CLI tool for database backups and restores
    
    Currently supports:
    - PostgreSQL (backup and restore)
    - Compression (tar.gz)
    - Configuration via YAML and environment variables
    """
    if version:
        from .. import __version__
        typer.echo(f"clidup version {__version__}")
        raise typer.Exit()


if __name__ == "__main__":
    app()
