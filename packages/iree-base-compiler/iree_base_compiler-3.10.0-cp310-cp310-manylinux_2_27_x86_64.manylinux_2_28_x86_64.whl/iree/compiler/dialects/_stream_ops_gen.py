
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union, Optional as _Optional


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "stream"

@_ods_cext.register_operation(_Dialect)
class AsyncAllocaOp(_ods_ir.OpView):
  r"""
  Allocates a transient value (one that is short-lived and local to the
  current computation) with undefined contents. Consumers of the allocated
  result must assume nothing of the contents and use `discard` access.
  """

  OPERATION_NAME = "stream.async.alloca"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, storage_size, *, affinity=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(storage_size)
    _ods_context = _ods_get_default_loc_context(loc)
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def storage_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[0]

  @builtins.property
  def affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def async_alloca(result, storage_size, *, affinity=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AsyncAllocaOp(result=result, storage_size=storage_size, affinity=affinity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AsyncBarrierOp(_ods_ir.OpView):
  r"""
  Prevents fusion and scheduling of a value across an affinity boundary.
  May introduce copy-on-write behavior if the operand value is used as well as
  the result and users should try to keep the operand to a single use by this
  op.
  """

  OPERATION_NAME = "stream.async.barrier"

  _ODS_REGIONS = (0, True)

  def __init__(self, source, size, *, affinity=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(size)
    _ods_context = _ods_get_default_loc_context(loc)
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def async_barrier(source, size, *, affinity=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AsyncBarrierOp(source=source, size=size, affinity=affinity, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AsyncCallOp(_ods_ir.OpView):
  r"""
  Calls a function taking/returning resource values with stream semantics.
  Asynchronous calls must have no side-effects.
  
  Note that returned resources must have their sizes declared prior to the
  call as this is what allows the call to be made on the stream. If external
  host logic is required to compute the size (avoid at all costs!) a separate
  func.call can be used outside of the stream to do so. If sizes are
  unknownable until the operation is performed it should be made as a normal
  asynchronous host call with 'coarse-fences' instead.
  """

  OPERATION_NAME = "stream.async.call"

  _ODS_OPERAND_SEGMENTS = [-1,-1,-1,-1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, callee, resource_operands, resource_operand_sizes, resource_operand_offsets, resource_operand_ends, resource_operand_lengths, result_sizes, *, tied_operands=None, arg_attrs=None, res_attrs=None, affinity=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(resource_operands))
    operands.append(_get_op_results_or_values(resource_operand_sizes))
    operands.append(_get_op_results_or_values(resource_operand_offsets))
    operands.append(_get_op_results_or_values(resource_operand_ends))
    operands.append(_get_op_results_or_values(resource_operand_lengths))
    operands.append(_get_op_results_or_values(result_sizes))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["callee"] = (callee if (
    isinstance(callee, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(callee, context=_ods_context))
    if tied_operands is not None: attributes["tied_operands"] = (tied_operands if (
        isinstance(tied_operands, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Util_TiedOpStorageAttr')) else
          _ods_ir.AttrBuilder.get('Util_TiedOpStorageAttr')(tied_operands, context=_ods_context))
    if arg_attrs is not None: attributes["arg_attrs"] = (arg_attrs if (
        isinstance(arg_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(arg_attrs, context=_ods_context))
    if res_attrs is not None: attributes["res_attrs"] = (res_attrs if (
        isinstance(res_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(res_attrs, context=_ods_context))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    results = []
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def resource_operands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def resource_operand_sizes(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def resource_operand_offsets(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def resource_operand_ends(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def resource_operand_lengths(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range

  @builtins.property
  def result_sizes(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 5)
    return operand_range

  @builtins.property
  def callee(self) -> _ods_ir.FlatSymbolRefAttr:
    return self.operation.attributes["callee"]

  @callee.setter
  def callee(self, value: _ods_ir.FlatSymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["callee"] = value

  @builtins.property
  def tied_operands(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tied_operands" not in self.operation.attributes:
      return None
    return self.operation.attributes["tied_operands"]

  @tied_operands.setter
  def tied_operands(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tied_operands"] = value
    elif "tied_operands" in self.operation.attributes:
      del self.operation.attributes["tied_operands"]

  @tied_operands.deleter
  def tied_operands(self):
    del self.operation.attributes["tied_operands"]

  @builtins.property
  def arg_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "arg_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["arg_attrs"]

  @arg_attrs.setter
  def arg_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["arg_attrs"] = value
    elif "arg_attrs" in self.operation.attributes:
      del self.operation.attributes["arg_attrs"]

  @arg_attrs.deleter
  def arg_attrs(self):
    del self.operation.attributes["arg_attrs"]

  @builtins.property
  def res_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "res_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["res_attrs"]

  @res_attrs.setter
  def res_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["res_attrs"] = value
    elif "res_attrs" in self.operation.attributes:
      del self.operation.attributes["res_attrs"]

  @res_attrs.deleter
  def res_attrs(self):
    del self.operation.attributes["res_attrs"]

  @builtins.property
  def affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def results_(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def async_call(results_, callee, resource_operands, resource_operand_sizes, resource_operand_offsets, resource_operand_ends, resource_operand_lengths, result_sizes, *, tied_operands=None, arg_attrs=None, res_attrs=None, affinity=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, AsyncCallOp]:
  op = AsyncCallOp(results_=results_, callee=callee, resource_operands=resource_operands, resource_operand_sizes=resource_operand_sizes, resource_operand_offsets=resource_operand_offsets, resource_operand_ends=resource_operand_ends, resource_operand_lengths=resource_operand_lengths, result_sizes=result_sizes, tied_operands=tied_operands, arg_attrs=arg_attrs, res_attrs=res_attrs, affinity=affinity, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class AsyncCloneOp(_ods_ir.OpView):
  r"""
  Clones the contents of a value at a snapshot in time. Future changes to the
  cloned value will not effect the result. Acts as a copy-on-write operation.
  """

  OPERATION_NAME = "stream.async.clone"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, source, source_size, result_size, *, affinity=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(source_size)
    operands.append(result_size)
    _ods_context = _ods_get_default_loc_context(loc)
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def source_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def result_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[2]

  @builtins.property
  def affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def async_clone(result, source, source_size, result_size, *, affinity=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AsyncCloneOp(result=result, source=source, source_size=source_size, result_size=result_size, affinity=affinity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AsyncCollectiveOp(_ods_ir.OpView):
  r"""
  TODO: document different usage. For now this should be considered a
  prototype and that modeling of collective operations may change in the
  future to better ensure in-place operations (where send/recv is a subset of
  recv/send). We may have dedicated operations for the send and recv verbs as
  they have sequencing implications - or we could add optional sequencing to
  this base op.
  """

  OPERATION_NAME = "stream.async.collective"

  _ODS_REGIONS = (0, True)

  def __init__(self, op, target, target_size, target_offset, target_end, target_length, source, source_size, source_offset, source_end, source_length, element_count, channel, *, param=None, affinity=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(target)
    operands.append(target_size)
    operands.append(target_offset)
    operands.append(target_end)
    operands.append(target_length)
    operands.append(source)
    operands.append(source_size)
    operands.append(source_offset)
    operands.append(source_end)
    operands.append(source_length)
    operands.append(element_count)
    operands.append(channel)
    if param is not None: operands.append(param)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["op"] = (op if (
    isinstance(op, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Stream_CollectiveAttr')) else
      _ods_ir.AttrBuilder.get('Stream_CollectiveAttr')(op, context=_ods_context))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def target_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def target_offset(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[2]

  @builtins.property
  def target_end(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[3]

  @builtins.property
  def target_length(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[4]

  @builtins.property
  def source(self) -> _ods_ir.Value:
    return self.operation.operands[5]

  @builtins.property
  def source_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[6]

  @builtins.property
  def source_offset(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[7]

  @builtins.property
  def source_end(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[8]

  @builtins.property
  def source_length(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[9]

  @builtins.property
  def element_count(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[10]

  @builtins.property
  def channel(self) -> _ods_ir.Value:
    return self.operation.operands[11]

  @builtins.property
  def param(self) -> _Optional[_ods_ir.Value[_ods_ir.IntegerType]]:
    return None if len(self.operation.operands) < 13 else self.operation.operands[12]

  @builtins.property
  def op(self) -> _ods_ir.Attribute:
    return self.operation.attributes["op"]

  @op.setter
  def op(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["op"] = value

  @builtins.property
  def affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def async_collective(op, target, target_size, target_offset, target_end, target_length, source, source_size, source_offset, source_end, source_length, element_count, channel, *, param=None, affinity=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AsyncCollectiveOp(op=op, target=target, target_size=target_size, target_offset=target_offset, target_end=target_end, target_length=target_length, source=source, source_size=source_size, source_offset=source_offset, source_end=source_end, source_length=source_length, element_count=element_count, channel=channel, param=param, affinity=affinity, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AsyncConcurrentOp(_ods_ir.OpView):
  r"""
  Represents a wave of work scheduled concurrently (each op executing at the
  same time). All resource inputs must be captured explicitly. All results are
  only ready once all nested ops complete execution.
  
  Waves can be nested to create a DAG. For example, take the following graph:
  ```
                    |
          v---------+---------v
  +-------|-------+   +-------|-------+
  |    v--+--v    |   |    v--+--v    |
  | +----+ +----+ |   | +----+ +----+ |
  | | %a | | %b | |   | | %c | | %d | |
  | +----+ +----+ |   | +----+ +----+ |
  |    +--v--+    |   |    +--v--+    |
  +-------|-------+   +-------|-------+
          +---------v---------+
                    |
  ```
  
  Represented with nested waves:
  ```mlir
    %0 = stream.async.concurrent with(%arg) -> ... {
      %1 = stream.async.concurrent with(%arg as %arg0) -> ... {
        %a = ...
        %b = ...
        stream.yield %a, %b
      }
      %2 = stream.async.concurrent with(%arg as %arg1) -> ... {
        %c = ...
        %d = ...
        stream.yield %c, %d
      }
      stream.yield %1, %2
    }
  ```
  """

  OPERATION_NAME = "stream.async.concurrent"

  _ODS_OPERAND_SEGMENTS = [-1,-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, results_, resource_operands, resource_operand_sizes, result_sizes, *, tied_operands=None, affinity=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(resource_operands))
    operands.append(_get_op_results_or_values(resource_operand_sizes))
    operands.append(_get_op_results_or_values(result_sizes))
    _ods_context = _ods_get_default_loc_context(loc)
    if tied_operands is not None: attributes["tied_operands"] = (tied_operands if (
        isinstance(tied_operands, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Util_TiedOpStorageAttr')) else
          _ods_ir.AttrBuilder.get('Util_TiedOpStorageAttr')(tied_operands, context=_ods_context))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    results = []
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def resource_operands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def resource_operand_sizes(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def result_sizes(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def tied_operands(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tied_operands" not in self.operation.attributes:
      return None
    return self.operation.attributes["tied_operands"]

  @tied_operands.setter
  def tied_operands(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tied_operands"] = value
    elif "tied_operands" in self.operation.attributes:
      del self.operation.attributes["tied_operands"]

  @tied_operands.deleter
  def tied_operands(self):
    del self.operation.attributes["tied_operands"]

  @builtins.property
  def affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def results_(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def async_concurrent(results_, resource_operands, resource_operand_sizes, result_sizes, *, tied_operands=None, affinity=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, AsyncConcurrentOp]:
  op = AsyncConcurrentOp(results_=results_, resource_operands=resource_operands, resource_operand_sizes=resource_operand_sizes, result_sizes=result_sizes, tied_operands=tied_operands, affinity=affinity, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class AsyncConstantOp(_ods_ir.OpView):
  r"""
  Returns a new resource with the given constant value.
  """

  OPERATION_NAME = "stream.async.constant"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, value, result_size, *, affinity=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(result_size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AnyAttr')) else
      _ods_ir.AttrBuilder.get('AnyAttr')(value, context=_ods_context))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def result_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[0]

  @builtins.property
  def value(self) -> _ods_ir.Attribute:
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def async_constant(result, value, result_size, *, affinity=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AsyncConstantOp(result=result, value=value, result_size=result_size, affinity=affinity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AsyncCopyOp(_ods_ir.OpView):
  r"""
  Copies a subview of a resource into a subview of another.
  As with memcpy this does not support overlapping updates into the same
  resource. Unlike `stream.async.update` copy sources cannot be allocated
  in-place.
  
  Equivalent to a stream.async.slice + stream.async.update.
  """

  OPERATION_NAME = "stream.async.copy"

  _ODS_REGIONS = (0, True)

  def __init__(self, target, target_size, target_offset, target_end, source, source_size, source_offset, source_end, length, *, affinity=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(target)
    operands.append(target_size)
    operands.append(target_offset)
    operands.append(target_end)
    operands.append(source)
    operands.append(source_size)
    operands.append(source_offset)
    operands.append(source_end)
    operands.append(length)
    _ods_context = _ods_get_default_loc_context(loc)
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def target_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def target_offset(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[2]

  @builtins.property
  def target_end(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[3]

  @builtins.property
  def source(self) -> _ods_ir.Value:
    return self.operation.operands[4]

  @builtins.property
  def source_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[5]

  @builtins.property
  def source_offset(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[6]

  @builtins.property
  def source_end(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[7]

  @builtins.property
  def length(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[8]

  @builtins.property
  def affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def async_copy(target, target_size, target_offset, target_end, source, source_size, source_offset, source_end, length, *, affinity=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AsyncCopyOp(target=target, target_size=target_size, target_offset=target_offset, target_end=target_end, source=source, source_size=source_size, source_offset=source_offset, source_end=source_end, length=length, affinity=affinity, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AsyncDispatchOp(_ods_ir.OpView):
  r"""
  Calls the specified entry point function once for each element in the
  specified workgroup count. Each workgroup has access to the same operands
  and results and is able to load/store at will.
  """

  OPERATION_NAME = "stream.async.dispatch"

  _ODS_OPERAND_SEGMENTS = [-1,-1,-1,-1,-1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, workload, entry_points, resource_operands, resource_operand_sizes, resource_operand_offsets, resource_operand_ends, resource_operand_lengths, result_sizes, *, tied_operands=None, affinity=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(workload))
    operands.append(_get_op_results_or_values(resource_operands))
    operands.append(_get_op_results_or_values(resource_operand_sizes))
    operands.append(_get_op_results_or_values(resource_operand_offsets))
    operands.append(_get_op_results_or_values(resource_operand_ends))
    operands.append(_get_op_results_or_values(resource_operand_lengths))
    operands.append(_get_op_results_or_values(result_sizes))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["entry_points"] = (entry_points if (
    isinstance(entry_points, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolRefArrayAttr')) else
      _ods_ir.AttrBuilder.get('SymbolRefArrayAttr')(entry_points, context=_ods_context))
    if tied_operands is not None: attributes["tied_operands"] = (tied_operands if (
        isinstance(tied_operands, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Util_TiedOpStorageAttr')) else
          _ods_ir.AttrBuilder.get('Util_TiedOpStorageAttr')(tied_operands, context=_ods_context))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    results = []
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def workload(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def resource_operands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def resource_operand_sizes(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def resource_operand_offsets(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def resource_operand_ends(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range

  @builtins.property
  def resource_operand_lengths(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 5)
    return operand_range

  @builtins.property
  def result_sizes(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 6)
    return operand_range

  @builtins.property
  def entry_points(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["entry_points"]

  @entry_points.setter
  def entry_points(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["entry_points"] = value

  @builtins.property
  def tied_operands(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tied_operands" not in self.operation.attributes:
      return None
    return self.operation.attributes["tied_operands"]

  @tied_operands.setter
  def tied_operands(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tied_operands"] = value
    elif "tied_operands" in self.operation.attributes:
      del self.operation.attributes["tied_operands"]

  @tied_operands.deleter
  def tied_operands(self):
    del self.operation.attributes["tied_operands"]

  @builtins.property
  def affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def results_(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def async_dispatch(results_, workload, entry_points, resource_operands, resource_operand_sizes, resource_operand_offsets, resource_operand_ends, resource_operand_lengths, result_sizes, *, tied_operands=None, affinity=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, AsyncDispatchOp]:
  op = AsyncDispatchOp(results_=results_, workload=workload, entry_points=entry_points, resource_operands=resource_operands, resource_operand_sizes=resource_operand_sizes, resource_operand_offsets=resource_operand_offsets, resource_operand_ends=resource_operand_ends, resource_operand_lengths=resource_operand_lengths, result_sizes=result_sizes, tied_operands=tied_operands, affinity=affinity, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class AsyncExecuteOp(_ods_ir.OpView):
  r"""
  Evaluates the operations within the region by dependency order while obeying
  ties when present. Nested ops execute serially in block order and nested
  `stream.async.concurrent` ops can be used to run multiple ops concurrently
  within the stream. All resource inputs must be captured explicitly. All
  results are only ready once all nested ops complete execution and the
  returned timepoint is reached. Zero or more timepoints may be provided to
  block execution until they are all reached; zero timepoints indicates that
  execution may begin immediately.
  """

  OPERATION_NAME = "stream.async.execute"

  _ODS_OPERAND_SEGMENTS = [-1,-1,-1,0,]

  _ODS_REGIONS = (1, True)

  def __init__(self, results_, result_timepoint, resource_operands, resource_operand_sizes, result_sizes, *, await_timepoint=None, tied_operands=None, affinity=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(resource_operands))
    operands.append(_get_op_results_or_values(resource_operand_sizes))
    operands.append(_get_op_results_or_values(result_sizes))
    operands.append(await_timepoint)
    _ods_context = _ods_get_default_loc_context(loc)
    if tied_operands is not None: attributes["tied_operands"] = (tied_operands if (
        isinstance(tied_operands, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Util_TiedOpStorageAttr')) else
          _ods_ir.AttrBuilder.get('Util_TiedOpStorageAttr')(tied_operands, context=_ods_context))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    results = []
    results.extend(results_)
    results.append(result_timepoint)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def resource_operands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def resource_operand_sizes(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def result_sizes(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def await_timepoint(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def tied_operands(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tied_operands" not in self.operation.attributes:
      return None
    return self.operation.attributes["tied_operands"]

  @tied_operands.setter
  def tied_operands(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tied_operands"] = value
    elif "tied_operands" in self.operation.attributes:
      del self.operation.attributes["tied_operands"]

  @tied_operands.deleter
  def tied_operands(self):
    del self.operation.attributes["tied_operands"]

  @builtins.property
  def affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def results_(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 2 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result_timepoint(self) -> _ods_ir.OpResult:
    _ods_variadic_group_length = len(self.operation.results) - 2 + 1
    return self.operation.results[1 + _ods_variadic_group_length - 1]

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def async_execute(results_, result_timepoint, resource_operands, resource_operand_sizes, result_sizes, *, await_timepoint=None, tied_operands=None, affinity=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, AsyncExecuteOp]:
  op = AsyncExecuteOp(results_=results_, result_timepoint=result_timepoint, resource_operands=resource_operands, resource_operand_sizes=resource_operand_sizes, result_sizes=result_sizes, await_timepoint=await_timepoint, tied_operands=tied_operands, affinity=affinity, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class AsyncFillOp(_ods_ir.OpView):
  r"""
  Splats a value into a subview of the given stream resource and returns the
  resource with the update applied.
  
  Equivalent to a stream.async.splat + stream.async.update.
  """

  OPERATION_NAME = "stream.async.fill"

  _ODS_REGIONS = (0, True)

  def __init__(self, target, target_size, target_offset, target_end, target_length, value, *, affinity=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(target)
    operands.append(target_size)
    operands.append(target_offset)
    operands.append(target_end)
    operands.append(target_length)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def target_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def target_offset(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[2]

  @builtins.property
  def target_end(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[3]

  @builtins.property
  def target_length(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[4]

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[5]

  @builtins.property
  def affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def async_fill(target, target_size, target_offset, target_end, target_length, value, *, affinity=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AsyncFillOp(target=target, target_size=target_size, target_offset=target_offset, target_end=target_end, target_length=target_length, value=value, affinity=affinity, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AsyncFuncOp(_ods_ir.OpView):
  r"""
  Declares a function that can be called as an asynchronous streaming
  operation via `stream.async.call`. Today only external functions are
  allowed.
  """

  OPERATION_NAME = "stream.async.func"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, function_type, *, tied_operands=None, sym_visibility=None, arg_attrs=None, res_attrs=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["function_type"] = (function_type if (
    isinstance(function_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_767')) else
      _ods_ir.AttrBuilder.get('anonymous_767')(function_type, context=_ods_context))
    if tied_operands is not None: attributes["tied_operands"] = (tied_operands if (
        isinstance(tied_operands, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Util_TiedOpStorageAttr')) else
          _ods_ir.AttrBuilder.get('Util_TiedOpStorageAttr')(tied_operands, context=_ods_context))
    if sym_visibility is not None: attributes["sym_visibility"] = (sym_visibility if (
        isinstance(sym_visibility, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(sym_visibility, context=_ods_context))
    if arg_attrs is not None: attributes["arg_attrs"] = (arg_attrs if (
        isinstance(arg_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(arg_attrs, context=_ods_context))
    if res_attrs is not None: attributes["res_attrs"] = (res_attrs if (
        isinstance(res_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(res_attrs, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def function_type(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["function_type"]

  @function_type.setter
  def function_type(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["function_type"] = value

  @builtins.property
  def tied_operands(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tied_operands" not in self.operation.attributes:
      return None
    return self.operation.attributes["tied_operands"]

  @tied_operands.setter
  def tied_operands(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tied_operands"] = value
    elif "tied_operands" in self.operation.attributes:
      del self.operation.attributes["tied_operands"]

  @tied_operands.deleter
  def tied_operands(self):
    del self.operation.attributes["tied_operands"]

  @builtins.property
  def sym_visibility(self) -> _Optional[_ods_ir.StringAttr]:
    if "sym_visibility" not in self.operation.attributes:
      return None
    return self.operation.attributes["sym_visibility"]

  @sym_visibility.setter
  def sym_visibility(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["sym_visibility"] = value
    elif "sym_visibility" in self.operation.attributes:
      del self.operation.attributes["sym_visibility"]

  @sym_visibility.deleter
  def sym_visibility(self):
    del self.operation.attributes["sym_visibility"]

  @builtins.property
  def arg_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "arg_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["arg_attrs"]

  @arg_attrs.setter
  def arg_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["arg_attrs"] = value
    elif "arg_attrs" in self.operation.attributes:
      del self.operation.attributes["arg_attrs"]

  @arg_attrs.deleter
  def arg_attrs(self):
    del self.operation.attributes["arg_attrs"]

  @builtins.property
  def res_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "res_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["res_attrs"]

  @res_attrs.setter
  def res_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["res_attrs"] = value
    elif "res_attrs" in self.operation.attributes:
      del self.operation.attributes["res_attrs"]

  @res_attrs.deleter
  def res_attrs(self):
    del self.operation.attributes["res_attrs"]

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def async_func(sym_name, function_type, *, tied_operands=None, sym_visibility=None, arg_attrs=None, res_attrs=None, loc=None, ip=None) -> AsyncFuncOp:
  return AsyncFuncOp(sym_name=sym_name, function_type=function_type, tied_operands=tied_operands, sym_visibility=sym_visibility, arg_attrs=arg_attrs, res_attrs=res_attrs, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class AsyncLoadOp(_ods_ir.OpView):
  r"""
  Returns the element at the given location from within the resource.
  """

  OPERATION_NAME = "stream.async.load"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, source, source_size, source_offset, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(source_size)
    operands.append(source_offset)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def source_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def source_offset(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[2]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def async_load(result, source, source_size, source_offset, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return AsyncLoadOp(result=result, source=source, source_size=source_size, source_offset=source_offset, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AsyncSliceOp(_ods_ir.OpView):
  r"""
  Slices a subrange of a stream resource based on a byte range. Acts as a
  copy-on-write operation.
  """

  OPERATION_NAME = "stream.async.slice"

  _ODS_REGIONS = (0, True)

  def __init__(self, source, source_size, source_offset, source_end, result_size, *, affinity=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(source_size)
    operands.append(source_offset)
    operands.append(source_end)
    operands.append(result_size)
    _ods_context = _ods_get_default_loc_context(loc)
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def source_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def source_offset(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[2]

  @builtins.property
  def source_end(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[3]

  @builtins.property
  def result_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[4]

  @builtins.property
  def affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def async_slice(source, source_size, source_offset, source_end, result_size, *, affinity=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AsyncSliceOp(source=source, source_size=source_size, source_offset=source_offset, source_end=source_end, result_size=result_size, affinity=affinity, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AsyncSplatOp(_ods_ir.OpView):
  r"""
  Returns a new resource with the given primitive value splatted out to fill
  the entire contents.
  """

  OPERATION_NAME = "stream.async.splat"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, value, result_size, *, affinity=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    operands.append(result_size)
    _ods_context = _ods_get_default_loc_context(loc)
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def async_splat(result, value, result_size, *, affinity=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AsyncSplatOp(result=result, value=value, result_size=result_size, affinity=affinity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AsyncStoreOp(_ods_ir.OpView):
  r"""
  Returns a resource with the element at the given offset set to the given
  value.
  """

  OPERATION_NAME = "stream.async.store"

  _ODS_REGIONS = (0, True)

  def __init__(self, target, target_size, target_offset, value, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(target)
    operands.append(target_size)
    operands.append(target_offset)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def target_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def target_offset(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[2]

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def async_store(target, target_size, target_offset, value, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AsyncStoreOp(target=target, target_size=target_size, target_offset=target_offset, value=value, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AsyncTransferOp(_ods_ir.OpView):
  r"""
  Transfers a resource between different states (such as a `staging` lifetime
  to a `local` lifetime) or different affinities. This is roughly equivalent
  to a cast but may have special semantics when later lowered to one or more
  devices with discrete memory spaces or pools.
  """

  OPERATION_NAME = "stream.async.transfer"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, source, source_size, result_size, *, source_affinity=None, target_affinity=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(source_size)
    operands.append(result_size)
    _ods_context = _ods_get_default_loc_context(loc)
    if source_affinity is not None: attributes["source_affinity"] = (source_affinity if (
        isinstance(source_affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(source_affinity, context=_ods_context))
    if target_affinity is not None: attributes["target_affinity"] = (target_affinity if (
        isinstance(target_affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(target_affinity, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def source_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def result_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[2]

  @builtins.property
  def source_affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "source_affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["source_affinity"]

  @source_affinity.setter
  def source_affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["source_affinity"] = value
    elif "source_affinity" in self.operation.attributes:
      del self.operation.attributes["source_affinity"]

  @source_affinity.deleter
  def source_affinity(self):
    del self.operation.attributes["source_affinity"]

  @builtins.property
  def target_affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "target_affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["target_affinity"]

  @target_affinity.setter
  def target_affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["target_affinity"] = value
    elif "target_affinity" in self.operation.attributes:
      del self.operation.attributes["target_affinity"]

  @target_affinity.deleter
  def target_affinity(self):
    del self.operation.attributes["target_affinity"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def async_transfer(result, source, source_size, result_size, *, source_affinity=None, target_affinity=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AsyncTransferOp(result=result, source=source, source_size=source_size, result_size=result_size, source_affinity=source_affinity, target_affinity=target_affinity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AsyncUpdateOp(_ods_ir.OpView):
  r"""
  Copies a value into a resource based on a byte range. The returned value
  is the entire updated target value. Updates can be turned into placement
  allocations and avoid copies.
  """

  OPERATION_NAME = "stream.async.update"

  _ODS_REGIONS = (0, True)

  def __init__(self, target, target_size, target_offset, target_end, update, update_size, *, affinity=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(target)
    operands.append(target_size)
    operands.append(target_offset)
    operands.append(target_end)
    operands.append(update)
    operands.append(update_size)
    _ods_context = _ods_get_default_loc_context(loc)
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def target_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def target_offset(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[2]

  @builtins.property
  def target_end(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[3]

  @builtins.property
  def update(self) -> _ods_ir.Value:
    return self.operation.operands[4]

  @builtins.property
  def update_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[5]

  @builtins.property
  def affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def async_update(target, target_size, target_offset, target_end, update, update_size, *, affinity=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AsyncUpdateOp(target=target, target_size=target_size, target_offset=target_offset, target_end=target_end, update=update, update_size=update_size, affinity=affinity, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BindingSubspanOp(_ods_ir.OpView):
  r"""
  Returns a subview to a tensor or memref-like type from a binding. The same
  binding may have multiple subviews at different byte offsets.
  """

  OPERATION_NAME = "stream.binding.subspan"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, binding, byte_offset, dynamic_dims, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(binding)
    operands.append(byte_offset)
    operands.extend(_get_op_results_or_values(dynamic_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def binding(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def byte_offset(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def dynamic_dims(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[2:2 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def binding_subspan(result, binding, byte_offset, dynamic_dims, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return BindingSubspanOp(result=result, binding=binding, byte_offset=byte_offset, dynamic_dims=dynamic_dims, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ChannelCountOp(_ods_ir.OpView):
  r"""
  Returns the total participant count in the collective communicator group.
  """

  OPERATION_NAME = "stream.channel.count"

  _ODS_REGIONS = (0, True)

  def __init__(self, channel, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(channel)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def channel(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IndexType]:
    return self.operation.results[0]

def channel_count(channel, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ChannelCountOp(channel=channel, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ChannelCreateOp(_ods_ir.OpView):
  r"""
  Returns a new channel with the given rank associated with the specified
  affinity. Collective operations using this channel must only be submitted on
  compatible affinities.
  
  The group and ID are optional and may be null. The rank and count can be
  omitted to indicate a default inherited from the environment or device
  configuration at runtime.
  """

  OPERATION_NAME = "stream.channel.create"

  _ODS_OPERAND_SEGMENTS = [0,0,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, *, id=None, group=None, rank=None, count=None, affinity=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(id)
    operands.append(rank)
    operands.append(count)
    _ods_context = _ods_get_default_loc_context(loc)
    if group is not None: attributes["group"] = (group if (
        isinstance(group, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(group, context=_ods_context))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def id(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def rank(self) -> _Optional[_ods_ir.Value[_ods_ir.IndexType]]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def count(self) -> _Optional[_ods_ir.Value[_ods_ir.IndexType]]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def group(self) -> _Optional[_ods_ir.StringAttr]:
    if "group" not in self.operation.attributes:
      return None
    return self.operation.attributes["group"]

  @group.setter
  def group(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["group"] = value
    elif "group" in self.operation.attributes:
      del self.operation.attributes["group"]

  @group.deleter
  def group(self):
    del self.operation.attributes["group"]

  @builtins.property
  def affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def channel_create(*, id=None, group=None, rank=None, count=None, affinity=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ChannelCreateOp(id=id, group=group, rank=rank, count=count, affinity=affinity, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ChannelRankOp(_ods_ir.OpView):
  r"""
  Returns the rank the channel represents as a participant in a collective
  group in `[0, count)`.
  """

  OPERATION_NAME = "stream.channel.rank"

  _ODS_REGIONS = (0, True)

  def __init__(self, channel, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(channel)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def channel(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IndexType]:
    return self.operation.results[0]

def channel_rank(channel, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ChannelRankOp(channel=channel, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ChannelSplitOp(_ods_ir.OpView):
  r"""
  Partitions the group associated with the given channel into disjoint
  subgroups for each unique value of color. Each new subgroup contains all
  participants of the same color and within each subgroup the key argument
  is used to define the rank order. When multiple participants in a group
  use the same key the tie will be broken using their rank in the parent
  group. A color of -1 indicates that the rank does not participate in any
  subgroup and will return a null channel.
  """

  OPERATION_NAME = "stream.channel.split"

  _ODS_REGIONS = (0, True)

  def __init__(self, channel, color, key, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(channel)
    operands.append(color)
    operands.append(key)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def channel(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def color(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def key(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[2]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def channel_split(channel, color, key, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ChannelSplitOp(channel=channel, color=color, key=key, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmdCallOp(_ods_ir.OpView):
  r"""
  Calls a function operating on resource values with stream semantics.
  Asynchronous calls must have no side-effects.
  """

  OPERATION_NAME = "stream.cmd.call"

  _ODS_OPERAND_SEGMENTS = [-1,-1,-1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, callee, resource_operands, resource_operand_sizes, resource_operand_offsets, resource_operand_lengths, result_sizes, resource_operand_accesses, *, tied_operands=None, arg_attrs=None, res_attrs=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(resource_operands))
    operands.append(_get_op_results_or_values(resource_operand_sizes))
    operands.append(_get_op_results_or_values(resource_operand_offsets))
    operands.append(_get_op_results_or_values(resource_operand_lengths))
    operands.append(_get_op_results_or_values(result_sizes))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["callee"] = (callee if (
    isinstance(callee, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(callee, context=_ods_context))
    if tied_operands is not None: attributes["tied_operands"] = (tied_operands if (
        isinstance(tied_operands, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Util_TiedOpStorageAttr')) else
          _ods_ir.AttrBuilder.get('Util_TiedOpStorageAttr')(tied_operands, context=_ods_context))
    if arg_attrs is not None: attributes["arg_attrs"] = (arg_attrs if (
        isinstance(arg_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(arg_attrs, context=_ods_context))
    if res_attrs is not None: attributes["res_attrs"] = (res_attrs if (
        isinstance(res_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(res_attrs, context=_ods_context))
    attributes["resource_operand_accesses"] = (resource_operand_accesses if (
    isinstance(resource_operand_accesses, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Stream_ResourceAccessArrayAttr')) else
      _ods_ir.AttrBuilder.get('Stream_ResourceAccessArrayAttr')(resource_operand_accesses, context=_ods_context))
    results = []
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def resource_operands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def resource_operand_sizes(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def resource_operand_offsets(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def resource_operand_lengths(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def result_sizes(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range

  @builtins.property
  def callee(self) -> _ods_ir.FlatSymbolRefAttr:
    return self.operation.attributes["callee"]

  @callee.setter
  def callee(self, value: _ods_ir.FlatSymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["callee"] = value

  @builtins.property
  def tied_operands(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tied_operands" not in self.operation.attributes:
      return None
    return self.operation.attributes["tied_operands"]

  @tied_operands.setter
  def tied_operands(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tied_operands"] = value
    elif "tied_operands" in self.operation.attributes:
      del self.operation.attributes["tied_operands"]

  @tied_operands.deleter
  def tied_operands(self):
    del self.operation.attributes["tied_operands"]

  @builtins.property
  def arg_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "arg_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["arg_attrs"]

  @arg_attrs.setter
  def arg_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["arg_attrs"] = value
    elif "arg_attrs" in self.operation.attributes:
      del self.operation.attributes["arg_attrs"]

  @arg_attrs.deleter
  def arg_attrs(self):
    del self.operation.attributes["arg_attrs"]

  @builtins.property
  def res_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "res_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["res_attrs"]

  @res_attrs.setter
  def res_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["res_attrs"] = value
    elif "res_attrs" in self.operation.attributes:
      del self.operation.attributes["res_attrs"]

  @res_attrs.deleter
  def res_attrs(self):
    del self.operation.attributes["res_attrs"]

  @builtins.property
  def resource_operand_accesses(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["resource_operand_accesses"]

  @resource_operand_accesses.setter
  def resource_operand_accesses(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["resource_operand_accesses"] = value

  @builtins.property
  def results_(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def cmd_call(results_, callee, resource_operands, resource_operand_sizes, resource_operand_offsets, resource_operand_lengths, result_sizes, resource_operand_accesses, *, tied_operands=None, arg_attrs=None, res_attrs=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, CmdCallOp]:
  op = CmdCallOp(results_=results_, callee=callee, resource_operands=resource_operands, resource_operand_sizes=resource_operand_sizes, resource_operand_offsets=resource_operand_offsets, resource_operand_lengths=resource_operand_lengths, result_sizes=result_sizes, resource_operand_accesses=resource_operand_accesses, tied_operands=tied_operands, arg_attrs=arg_attrs, res_attrs=res_attrs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class CmdCollectiveOp(_ods_ir.OpView):
  r"""
  Dispatches a collective operation specified against the device. If grouped
  with other collectives in a `stream.cmd.concurrent` region the collective
  operations may fuse and execute more efficiently.
  """

  OPERATION_NAME = "stream.cmd.collective"

  _ODS_OPERAND_SEGMENTS = [1,1,0,-1,-1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, op, channel, element_count, resources, resource_sizes, resource_offsets, resource_lengths, resource_accesses, *, param=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(channel)
    operands.append(element_count)
    operands.append(param)
    operands.append(_get_op_results_or_values(resources))
    operands.append(_get_op_results_or_values(resource_sizes))
    operands.append(_get_op_results_or_values(resource_offsets))
    operands.append(_get_op_results_or_values(resource_lengths))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["op"] = (op if (
    isinstance(op, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Stream_CollectiveAttr')) else
      _ods_ir.AttrBuilder.get('Stream_CollectiveAttr')(op, context=_ods_context))
    attributes["resource_accesses"] = (resource_accesses if (
    isinstance(resource_accesses, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Stream_ResourceAccessArrayAttr')) else
      _ods_ir.AttrBuilder.get('Stream_ResourceAccessArrayAttr')(resource_accesses, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def channel(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def element_count(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def param(self) -> _Optional[_ods_ir.Value[_ods_ir.IntegerType]]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def resources(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def resource_sizes(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range

  @builtins.property
  def resource_offsets(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 5)
    return operand_range

  @builtins.property
  def resource_lengths(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 6)
    return operand_range

  @builtins.property
  def op(self) -> _ods_ir.Attribute:
    return self.operation.attributes["op"]

  @op.setter
  def op(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["op"] = value

  @builtins.property
  def resource_accesses(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["resource_accesses"]

  @resource_accesses.setter
  def resource_accesses(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["resource_accesses"] = value

def cmd_collective(op, channel, element_count, resources, resource_sizes, resource_offsets, resource_lengths, resource_accesses, *, param=None, loc=None, ip=None) -> CmdCollectiveOp:
  return CmdCollectiveOp(op=op, channel=channel, element_count=element_count, resources=resources, resource_sizes=resource_sizes, resource_offsets=resource_offsets, resource_lengths=resource_lengths, resource_accesses=resource_accesses, param=param, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CmdConcurrentOp(_ods_ir.OpView):
  r"""
  Represents a wave of work scheduled concurrently (each op executing at the
  same time).
  
  Waves can be nested to create a DAG. For example, take the following graph:
  ```
                    |
          v---------+---------v
  +-------|-------+   +-------|-------+
  |    v--+--v    |   |    v--+--v    |
  | +----+ +----+ |   | +----+ +----+ |
  | | @a | | @b | |   | | @c | | @d | |
  | +----+ +----+ |   | +----+ +----+ |
  |    +--v--+    |   |    +--v--+    |
  +-------|-------+   +-------|-------+
          +---------v---------+
                    |
  ```
  
  Represented with nested waves:
  ```mlir
    stream.cmd.concurrent {
      stream.cmd.concurrent {
        stream.cmd.dispatch @a
        stream.cmd.dispatch @b
      }
      stream.cmd.concurrent {
        stream.cmd.dispatch @c
        stream.cmd.dispatch @d
      }
    }
  ```
  """

  OPERATION_NAME = "stream.cmd.concurrent"

  _ODS_REGIONS = (1, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def cmd_concurrent(*, loc=None, ip=None) -> CmdConcurrentOp:
  return CmdConcurrentOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CmdCopyOp(_ods_ir.OpView):
  r"""
  Copies a subview of a resource into a subview of another.
  As with memcpy this does not support overlapping updates into the same
  resource.
  """

  OPERATION_NAME = "stream.cmd.copy"

  _ODS_REGIONS = (0, True)

  def __init__(self, source, source_size, source_offset, target, target_size, target_offset, length, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(source_size)
    operands.append(source_offset)
    operands.append(target)
    operands.append(target_size)
    operands.append(target_offset)
    operands.append(length)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def source_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def source_offset(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[2]

  @builtins.property
  def target(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def target_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[4]

  @builtins.property
  def target_offset(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[5]

  @builtins.property
  def length(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[6]

def cmd_copy(source, source_size, source_offset, target, target_size, target_offset, length, *, loc=None, ip=None) -> CmdCopyOp:
  return CmdCopyOp(source=source, source_size=source_size, source_offset=source_offset, target=target, target_size=target_size, target_offset=target_offset, length=length, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CmdDiscardOp(_ods_ir.OpView):
  r"""
  Discards a subview of a resource, indicating that after this command the
  specified contents are no longer needed. This can be used to trim memory
  or invalidate caches.
  """

  OPERATION_NAME = "stream.cmd.discard"

  _ODS_REGIONS = (0, True)

  def __init__(self, target, target_size, target_offset, target_length, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(target)
    operands.append(target_size)
    operands.append(target_offset)
    operands.append(target_length)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def target_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def target_offset(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[2]

  @builtins.property
  def target_length(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[3]

def cmd_discard(target, target_size, target_offset, target_length, *, loc=None, ip=None) -> CmdDiscardOp:
  return CmdDiscardOp(target=target, target_size=target_size, target_offset=target_offset, target_length=target_length, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CmdDispatchOp(_ods_ir.OpView):
  r"""
  Calls the specified entry point function once for each element in the
  specified workgroup count. Each workgroup has access to the same operands
  and results and is able to load/store at will.
  """

  OPERATION_NAME = "stream.cmd.dispatch"

  _ODS_OPERAND_SEGMENTS = [-1,-1,-1,-1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, workload, entry_points, uniform_operands, resources, resource_sizes, resource_offsets, resource_lengths, resource_accesses, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(workload))
    operands.append(_get_op_results_or_values(uniform_operands))
    operands.append(_get_op_results_or_values(resources))
    operands.append(_get_op_results_or_values(resource_sizes))
    operands.append(_get_op_results_or_values(resource_offsets))
    operands.append(_get_op_results_or_values(resource_lengths))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["entry_points"] = (entry_points if (
    isinstance(entry_points, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolRefArrayAttr')) else
      _ods_ir.AttrBuilder.get('SymbolRefArrayAttr')(entry_points, context=_ods_context))
    attributes["resource_accesses"] = (resource_accesses if (
    isinstance(resource_accesses, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Stream_ResourceAccessArrayAttr')) else
      _ods_ir.AttrBuilder.get('Stream_ResourceAccessArrayAttr')(resource_accesses, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def workload(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def uniform_operands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def resources(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def resource_sizes(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def resource_offsets(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range

  @builtins.property
  def resource_lengths(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 5)
    return operand_range

  @builtins.property
  def entry_points(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["entry_points"]

  @entry_points.setter
  def entry_points(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["entry_points"] = value

  @builtins.property
  def resource_accesses(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["resource_accesses"]

  @resource_accesses.setter
  def resource_accesses(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["resource_accesses"] = value

def cmd_dispatch(workload, entry_points, uniform_operands, resources, resource_sizes, resource_offsets, resource_lengths, resource_accesses, *, loc=None, ip=None) -> CmdDispatchOp:
  return CmdDispatchOp(workload=workload, entry_points=entry_points, uniform_operands=uniform_operands, resources=resources, resource_sizes=resource_sizes, resource_offsets=resource_offsets, resource_lengths=resource_lengths, resource_accesses=resource_accesses, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CmdExecuteOp(_ods_ir.OpView):
  r"""
  Evaluates the operations within the region by dependency order while obeying
  ties when present. Nested ops execute serially in block order and nested
  `stream.cmd.concurrent` ops can be used to run multiple ops concurrently
  within the stream. All resource inputs must be captured explicitly. All
  results are only ready once all nested ops complete execution and the
  returned timepoint is reached. Zero or more timepoints may be provided to
  block execution until they are all reached; zero timepoints indicates that
  execution may begin immediately.
  """

  OPERATION_NAME = "stream.cmd.execute"

  _ODS_OPERAND_SEGMENTS = [-1,-1,0,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_timepoint, resource_operands, resource_operand_sizes, *, once=None, await_timepoint=None, affinity=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(resource_operands))
    operands.append(_get_op_results_or_values(resource_operand_sizes))
    operands.append(await_timepoint)
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(once): attributes["once"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    results = []
    results.append(result_timepoint)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def resource_operands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def resource_operand_sizes(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def await_timepoint(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def once(self) -> bool:
    return "once" in self.operation.attributes

  @once.setter
  def once(self, value):
    if bool(value):
      self.operation.attributes["once"] = _ods_ir.UnitAttr.get()
    elif "once" in self.operation.attributes:
      del self.operation.attributes["once"]

  @once.deleter
  def once(self):
    del self.operation.attributes["once"]

  @builtins.property
  def affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result_timepoint(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def cmd_execute(result_timepoint, resource_operands, resource_operand_sizes, *, once=None, await_timepoint=None, affinity=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmdExecuteOp(result_timepoint=result_timepoint, resource_operands=resource_operands, resource_operand_sizes=resource_operand_sizes, once=once, await_timepoint=await_timepoint, affinity=affinity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmdFillOp(_ods_ir.OpView):
  r"""
  Splats a value into a subview of the given stream resource and returns the
  resource with the update applied.
  """

  OPERATION_NAME = "stream.cmd.fill"

  _ODS_REGIONS = (0, True)

  def __init__(self, target, target_size, target_offset, target_length, value, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(target)
    operands.append(target_size)
    operands.append(target_offset)
    operands.append(target_length)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def target_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def target_offset(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[2]

  @builtins.property
  def target_length(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[3]

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[4]

def cmd_fill(target, target_size, target_offset, target_length, value, *, loc=None, ip=None) -> CmdFillOp:
  return CmdFillOp(target=target, target_size=target_size, target_offset=target_offset, target_length=target_length, value=value, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CmdFlushOp(_ods_ir.OpView):
  r"""
  Transfers a resource to an external target. The resource memory is made
  available to the target and can be made visible there using
  `stream.cmd.invalidate`.
  """

  OPERATION_NAME = "stream.cmd.flush"

  _ODS_REGIONS = (0, True)

  def __init__(self, target, target_size, target_offset, target_length, *, source_affinity=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(target)
    operands.append(target_size)
    operands.append(target_offset)
    operands.append(target_length)
    _ods_context = _ods_get_default_loc_context(loc)
    if source_affinity is not None: attributes["source_affinity"] = (source_affinity if (
        isinstance(source_affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(source_affinity, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def target_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def target_offset(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[2]

  @builtins.property
  def target_length(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[3]

  @builtins.property
  def source_affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "source_affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["source_affinity"]

  @source_affinity.setter
  def source_affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["source_affinity"] = value
    elif "source_affinity" in self.operation.attributes:
      del self.operation.attributes["source_affinity"]

  @source_affinity.deleter
  def source_affinity(self):
    del self.operation.attributes["source_affinity"]

def cmd_flush(target, target_size, target_offset, target_length, *, source_affinity=None, loc=None, ip=None) -> CmdFlushOp:
  return CmdFlushOp(target=target, target_size=target_size, target_offset=target_offset, target_length=target_length, source_affinity=source_affinity, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CmdFuncOp(_ods_ir.OpView):
  r"""
  Declares a function that can be called as an asynchronous streaming
  operation via `stream.cmd.call`. Today only external functions are
  allowed.
  """

  OPERATION_NAME = "stream.cmd.func"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, function_type, *, sym_visibility=None, arg_attrs=None, res_attrs=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["function_type"] = (function_type if (
    isinstance(function_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_767')) else
      _ods_ir.AttrBuilder.get('anonymous_767')(function_type, context=_ods_context))
    if sym_visibility is not None: attributes["sym_visibility"] = (sym_visibility if (
        isinstance(sym_visibility, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(sym_visibility, context=_ods_context))
    if arg_attrs is not None: attributes["arg_attrs"] = (arg_attrs if (
        isinstance(arg_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(arg_attrs, context=_ods_context))
    if res_attrs is not None: attributes["res_attrs"] = (res_attrs if (
        isinstance(res_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(res_attrs, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def function_type(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["function_type"]

  @function_type.setter
  def function_type(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["function_type"] = value

  @builtins.property
  def sym_visibility(self) -> _Optional[_ods_ir.StringAttr]:
    if "sym_visibility" not in self.operation.attributes:
      return None
    return self.operation.attributes["sym_visibility"]

  @sym_visibility.setter
  def sym_visibility(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["sym_visibility"] = value
    elif "sym_visibility" in self.operation.attributes:
      del self.operation.attributes["sym_visibility"]

  @sym_visibility.deleter
  def sym_visibility(self):
    del self.operation.attributes["sym_visibility"]

  @builtins.property
  def arg_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "arg_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["arg_attrs"]

  @arg_attrs.setter
  def arg_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["arg_attrs"] = value
    elif "arg_attrs" in self.operation.attributes:
      del self.operation.attributes["arg_attrs"]

  @arg_attrs.deleter
  def arg_attrs(self):
    del self.operation.attributes["arg_attrs"]

  @builtins.property
  def res_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "res_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["res_attrs"]

  @res_attrs.setter
  def res_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["res_attrs"] = value
    elif "res_attrs" in self.operation.attributes:
      del self.operation.attributes["res_attrs"]

  @res_attrs.deleter
  def res_attrs(self):
    del self.operation.attributes["res_attrs"]

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def cmd_func(sym_name, function_type, *, sym_visibility=None, arg_attrs=None, res_attrs=None, loc=None, ip=None) -> CmdFuncOp:
  return CmdFuncOp(sym_name=sym_name, function_type=function_type, sym_visibility=sym_visibility, arg_attrs=arg_attrs, res_attrs=res_attrs, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CmdInvalidateOp(_ods_ir.OpView):
  r"""
  Transfers a resource from an external source into the current target. The
  resource memory is assumed to have been made available at the source via
  `stream.cmd.flush`.
  """

  OPERATION_NAME = "stream.cmd.invalidate"

  _ODS_REGIONS = (0, True)

  def __init__(self, target, target_size, target_offset, target_length, *, source_affinity=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(target)
    operands.append(target_size)
    operands.append(target_offset)
    operands.append(target_length)
    _ods_context = _ods_get_default_loc_context(loc)
    if source_affinity is not None: attributes["source_affinity"] = (source_affinity if (
        isinstance(source_affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(source_affinity, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def target_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def target_offset(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[2]

  @builtins.property
  def target_length(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[3]

  @builtins.property
  def source_affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "source_affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["source_affinity"]

  @source_affinity.setter
  def source_affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["source_affinity"] = value
    elif "source_affinity" in self.operation.attributes:
      del self.operation.attributes["source_affinity"]

  @source_affinity.deleter
  def source_affinity(self):
    del self.operation.attributes["source_affinity"]

def cmd_invalidate(target, target_size, target_offset, target_length, *, source_affinity=None, loc=None, ip=None) -> CmdInvalidateOp:
  return CmdInvalidateOp(target=target, target_size=target_size, target_offset=target_offset, target_length=target_length, source_affinity=source_affinity, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CmdParameterGatherOp(_ods_ir.OpView):
  r"""
  Asynchronously gathers one or more resources into a single target stream
  resource. This is equivalent to one `stream.cmd.parameter.read` per
  parameter but allows implementations that can batch operations to do so
  without additional timeline overhead.
  """

  OPERATION_NAME = "stream.cmd.parameter.gather"

  _ODS_OPERAND_SEGMENTS = [-1,1,1,-1,-1,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, source_keys, source_offsets, target, target_size, target_offsets, target_lengths, *, source_scope=None, await_timepoint=None, affinity=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(source_offsets))
    operands.append(target)
    operands.append(target_size)
    operands.append(_get_op_results_or_values(target_offsets))
    operands.append(_get_op_results_or_values(target_lengths))
    operands.append(await_timepoint)
    _ods_context = _ods_get_default_loc_context(loc)
    if source_scope is not None: attributes["source_scope"] = (source_scope if (
        isinstance(source_scope, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(source_scope, context=_ods_context))
    attributes["source_keys"] = (source_keys if (
    isinstance(source_keys, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrArrayAttr')) else
      _ods_ir.AttrBuilder.get('StrArrayAttr')(source_keys, context=_ods_context))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source_offsets(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def target(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def target_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0]

  @builtins.property
  def target_offsets(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def target_lengths(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range

  @builtins.property
  def await_timepoint(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 5)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def source_scope(self) -> _Optional[_ods_ir.StringAttr]:
    if "source_scope" not in self.operation.attributes:
      return None
    return self.operation.attributes["source_scope"]

  @source_scope.setter
  def source_scope(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["source_scope"] = value
    elif "source_scope" in self.operation.attributes:
      del self.operation.attributes["source_scope"]

  @source_scope.deleter
  def source_scope(self):
    del self.operation.attributes["source_scope"]

  @builtins.property
  def source_keys(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["source_keys"]

  @source_keys.setter
  def source_keys(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["source_keys"] = value

  @builtins.property
  def affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result_timepoint(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cmd_parameter_gather(source_keys, source_offsets, target, target_size, target_offsets, target_lengths, *, source_scope=None, await_timepoint=None, affinity=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmdParameterGatherOp(source_keys=source_keys, source_offsets=source_offsets, target=target, target_size=target_size, target_offsets=target_offsets, target_lengths=target_lengths, source_scope=source_scope, await_timepoint=await_timepoint, affinity=affinity, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmdParameterLoadOp(_ods_ir.OpView):
  r"""
  Asynchronously reads one or more resources from an external parameter
  provider and returns the resulting stream resources. Depending on the
  resource type this may alias existing cached storage or be directly mapped
  to the parameter origin or result in a copy as if `stream.resource.alloca`
  and `stream.cmd.parameter.read` had been used per parameter.
  """

  OPERATION_NAME = "stream.cmd.parameter.load"

  _ODS_OPERAND_SEGMENTS = [-1,-1,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, result_timepoint, source_keys, source_offsets, result_sizes, *, source_scope=None, await_timepoint=None, affinity=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(source_offsets))
    operands.append(_get_op_results_or_values(result_sizes))
    operands.append(await_timepoint)
    _ods_context = _ods_get_default_loc_context(loc)
    if source_scope is not None: attributes["source_scope"] = (source_scope if (
        isinstance(source_scope, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(source_scope, context=_ods_context))
    attributes["source_keys"] = (source_keys if (
    isinstance(source_keys, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrArrayAttr')) else
      _ods_ir.AttrBuilder.get('StrArrayAttr')(source_keys, context=_ods_context))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    results = []
    results.extend(results_)
    results.append(result_timepoint)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source_offsets(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def result_sizes(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def await_timepoint(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def source_scope(self) -> _Optional[_ods_ir.StringAttr]:
    if "source_scope" not in self.operation.attributes:
      return None
    return self.operation.attributes["source_scope"]

  @source_scope.setter
  def source_scope(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["source_scope"] = value
    elif "source_scope" in self.operation.attributes:
      del self.operation.attributes["source_scope"]

  @source_scope.deleter
  def source_scope(self):
    del self.operation.attributes["source_scope"]

  @builtins.property
  def source_keys(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["source_keys"]

  @source_keys.setter
  def source_keys(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["source_keys"] = value

  @builtins.property
  def affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def results_(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 2 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result_timepoint(self) -> _ods_ir.OpResult:
    _ods_variadic_group_length = len(self.operation.results) - 2 + 1
    return self.operation.results[1 + _ods_variadic_group_length - 1]

def cmd_parameter_load(results_, result_timepoint, source_keys, source_offsets, result_sizes, *, source_scope=None, await_timepoint=None, affinity=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, CmdParameterLoadOp]:
  op = CmdParameterLoadOp(results_=results_, result_timepoint=result_timepoint, source_keys=source_keys, source_offsets=source_offsets, result_sizes=result_sizes, source_scope=source_scope, await_timepoint=await_timepoint, affinity=affinity, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class CmdParameterReadOp(_ods_ir.OpView):
  r"""
  Asynchronously reads a resource from an external parameter provider into the
  provided target resource range.
  """

  OPERATION_NAME = "stream.cmd.parameter.read"

  _ODS_REGIONS = (0, True)

  def __init__(self, source_key, source_offset, target, target_size, target_offset, target_length, *, source_scope=None, await_timepoint=None, affinity=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(source_offset)
    operands.append(target)
    operands.append(target_size)
    operands.append(target_offset)
    operands.append(target_length)
    if await_timepoint is not None: operands.append(await_timepoint)
    _ods_context = _ods_get_default_loc_context(loc)
    if source_scope is not None: attributes["source_scope"] = (source_scope if (
        isinstance(source_scope, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(source_scope, context=_ods_context))
    attributes["source_key"] = (source_key if (
    isinstance(source_key, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(source_key, context=_ods_context))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source_offset(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def target(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def target_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[2]

  @builtins.property
  def target_offset(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[3]

  @builtins.property
  def target_length(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[4]

  @builtins.property
  def await_timepoint(self) -> _Optional[_ods_ir.Value]:
    return None if len(self.operation.operands) < 6 else self.operation.operands[5]

  @builtins.property
  def source_scope(self) -> _Optional[_ods_ir.StringAttr]:
    if "source_scope" not in self.operation.attributes:
      return None
    return self.operation.attributes["source_scope"]

  @source_scope.setter
  def source_scope(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["source_scope"] = value
    elif "source_scope" in self.operation.attributes:
      del self.operation.attributes["source_scope"]

  @source_scope.deleter
  def source_scope(self):
    del self.operation.attributes["source_scope"]

  @builtins.property
  def source_key(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["source_key"]

  @source_key.setter
  def source_key(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["source_key"] = value

  @builtins.property
  def affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result_timepoint(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cmd_parameter_read(source_key, source_offset, target, target_size, target_offset, target_length, *, source_scope=None, await_timepoint=None, affinity=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmdParameterReadOp(source_key=source_key, source_offset=source_offset, target=target, target_size=target_size, target_offset=target_offset, target_length=target_length, source_scope=source_scope, await_timepoint=await_timepoint, affinity=affinity, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmdParameterScatterOp(_ods_ir.OpView):
  r"""
  Asynchronously scatters one or more resources from a single source resource
  into one or more parameters. This is equivalent to one
  `stream.cmd.parameter.write` per parameter but allows implementations that
  can batch operations to do so without additional overhead.
  """

  OPERATION_NAME = "stream.cmd.parameter.scatter"

  _ODS_OPERAND_SEGMENTS = [1,1,-1,-1,-1,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, source, source_size, source_offsets, source_lengths, target_keys, target_offsets, *, target_scope=None, await_timepoint=None, affinity=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(source_size)
    operands.append(_get_op_results_or_values(source_offsets))
    operands.append(_get_op_results_or_values(source_lengths))
    operands.append(_get_op_results_or_values(target_offsets))
    operands.append(await_timepoint)
    _ods_context = _ods_get_default_loc_context(loc)
    if target_scope is not None: attributes["target_scope"] = (target_scope if (
        isinstance(target_scope, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(target_scope, context=_ods_context))
    attributes["target_keys"] = (target_keys if (
    isinstance(target_keys, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrArrayAttr')) else
      _ods_ir.AttrBuilder.get('StrArrayAttr')(target_keys, context=_ods_context))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def source_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def source_offsets(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def source_lengths(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def target_offsets(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range

  @builtins.property
  def await_timepoint(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 5)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def target_scope(self) -> _Optional[_ods_ir.StringAttr]:
    if "target_scope" not in self.operation.attributes:
      return None
    return self.operation.attributes["target_scope"]

  @target_scope.setter
  def target_scope(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["target_scope"] = value
    elif "target_scope" in self.operation.attributes:
      del self.operation.attributes["target_scope"]

  @target_scope.deleter
  def target_scope(self):
    del self.operation.attributes["target_scope"]

  @builtins.property
  def target_keys(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["target_keys"]

  @target_keys.setter
  def target_keys(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["target_keys"] = value

  @builtins.property
  def affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result_timepoint(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cmd_parameter_scatter(source, source_size, source_offsets, source_lengths, target_keys, target_offsets, *, target_scope=None, await_timepoint=None, affinity=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmdParameterScatterOp(source=source, source_size=source_size, source_offsets=source_offsets, source_lengths=source_lengths, target_keys=target_keys, target_offsets=target_offsets, target_scope=target_scope, await_timepoint=await_timepoint, affinity=affinity, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmdParameterWriteOp(_ods_ir.OpView):
  r"""
  Asynchronously writes a resource to an external parameter provider from
  the provided source resource range.
  """

  OPERATION_NAME = "stream.cmd.parameter.write"

  _ODS_REGIONS = (0, True)

  def __init__(self, source, source_size, source_offset, source_length, target_key, target_offset, *, target_scope=None, await_timepoint=None, affinity=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(source_size)
    operands.append(source_offset)
    operands.append(source_length)
    operands.append(target_offset)
    if await_timepoint is not None: operands.append(await_timepoint)
    _ods_context = _ods_get_default_loc_context(loc)
    if target_scope is not None: attributes["target_scope"] = (target_scope if (
        isinstance(target_scope, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(target_scope, context=_ods_context))
    attributes["target_key"] = (target_key if (
    isinstance(target_key, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(target_key, context=_ods_context))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def source_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def source_offset(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[2]

  @builtins.property
  def source_length(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[3]

  @builtins.property
  def target_offset(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[4]

  @builtins.property
  def await_timepoint(self) -> _Optional[_ods_ir.Value]:
    return None if len(self.operation.operands) < 6 else self.operation.operands[5]

  @builtins.property
  def target_scope(self) -> _Optional[_ods_ir.StringAttr]:
    if "target_scope" not in self.operation.attributes:
      return None
    return self.operation.attributes["target_scope"]

  @target_scope.setter
  def target_scope(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["target_scope"] = value
    elif "target_scope" in self.operation.attributes:
      del self.operation.attributes["target_scope"]

  @target_scope.deleter
  def target_scope(self):
    del self.operation.attributes["target_scope"]

  @builtins.property
  def target_key(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["target_key"]

  @target_key.setter
  def target_key(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["target_key"] = value

  @builtins.property
  def affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result_timepoint(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cmd_parameter_write(source, source_size, source_offset, source_length, target_key, target_offset, *, target_scope=None, await_timepoint=None, affinity=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmdParameterWriteOp(source=source, source_size=source_size, source_offset=source_offset, source_length=source_length, target_key=target_key, target_offset=target_offset, target_scope=target_scope, await_timepoint=await_timepoint, affinity=affinity, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmdSerialOp(_ods_ir.OpView):
  r"""
  Represents a sequence of work scheduled serially (each op executing one
  after the other).
  
  Regions can be nested to create a DAG. For example, take the following graph:
  ```
                    |
          v---------+-----v
  +-------|-------+   +---|----+
  |    v--+--v    |   |   v    |
  | +----+ +----+ |   | +----+ |
  | | @a | | @b | |   | | @c | |
  | +----+ +----+ |   | +----+ |
  |    |     |    |   |   |    |
  |    |     |    |   | +-v--+ |
  |    |     |    |   | | @d | |
  |    |     |    |   | +----+ |
  |    +--v--+    |   |   |    |
  +-------|-------+   +---|----+
          +---------v-----+
                    |
  ```
  
  Represented with nested regions:
  ```mlir
    stream.cmd.concurrent {
      stream.cmd.concurrent {
        stream.cmd.dispatch @a
        stream.cmd.dispatch @b
      }
      stream.cmd.serial {
        stream.cmd.dispatch @c
        stream.cmd.dispatch @d
      }
    }
  ```
  """

  OPERATION_NAME = "stream.cmd.serial"

  _ODS_REGIONS = (1, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def cmd_serial(*, loc=None, ip=None) -> CmdSerialOp:
  return CmdSerialOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ContextResolveOp(_ods_ir.OpView):
  r"""
  WIP; allows for accessing the implementation details of lower-level dialects
  such as the HAL. This will likely be reworked in the future to either
  live inside other dialects, use some op interface instead of having a
  dedicated op here, or remove the op entirely and make resolution happen
  explicitly.
  
  Examples:
  ```
  // Returns a HAL device.
  = stream.context.resolve on(#something) : !hal.device
  // Returns a HAL device and (optional) queue affinity.
  = stream.context.resolve on(#something) : !hal.device, i64
  // Returns a HAL allocator and (optional) queue affinity.
  = stream.context.resolve on(#something) : !hal.allocator, i64
  ```
  """

  OPERATION_NAME = "stream.context.resolve"

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, *, affinity=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    results = []
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def results_(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def context_resolve(results_, *, affinity=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, ContextResolveOp]:
  op = ContextResolveOp(results_=results_, affinity=affinity, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class DispatchWorkgroupCountOp(_ods_ir.OpView):
  r"""
  The total number of workgroups along each dimension in the dispatch grid.
  
  Represented as a 3D grid classically written as XYZ.
  Corresponds to the `NumWorkgroups` SPIR-V built-in and the `gridDim` CUDA
  built-in variable.
  
  ```mlir
  %x = stream.dispatch.workgroup.count[0] : index
  %y = stream.dispatch.workgroup.count[1] : index
  %z = stream.dispatch.workgroup.count[2] : index
  ```
  """

  OPERATION_NAME = "stream.dispatch.workgroup.count"

  _ODS_REGIONS = (0, True)

  def __init__(self, dimension, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dimension"] = (dimension if (
    isinstance(dimension, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IndexAttr')) else
      _ods_ir.AttrBuilder.get('IndexAttr')(dimension, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def dimension(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["dimension"]

  @dimension.setter
  def dimension(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dimension"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IndexType]:
    return self.operation.results[0]

def dispatch_workgroup_count(dimension, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return DispatchWorkgroupCountOp(dimension=dimension, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DispatchWorkgroupIDOp(_ods_ir.OpView):
  r"""
  The global workgroup ID of the current workgroup in the range of
  `[0, stream.dispatch.workgroup.count)` along each dimension.
  
  Represented as a 3D grid classically written as XYZ.
  Corresponds to the `WorkgroupId` SPIR-V built-in and the `blockIdx` CUDA
  built-in variable.
  
  ```mlir
  %x = stream.dispatch.workgroup.id[0] : index
  %y = stream.dispatch.workgroup.id[1] : index
  %z = stream.dispatch.workgroup.id[2] : index
  ```
  """

  OPERATION_NAME = "stream.dispatch.workgroup.id"

  _ODS_REGIONS = (0, True)

  def __init__(self, dimension, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dimension"] = (dimension if (
    isinstance(dimension, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IndexAttr')) else
      _ods_ir.AttrBuilder.get('IndexAttr')(dimension, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def dimension(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["dimension"]

  @dimension.setter
  def dimension(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dimension"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IndexType]:
    return self.operation.results[0]

def dispatch_workgroup_id(dimension, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return DispatchWorkgroupIDOp(dimension=dimension, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DispatchWorkgroupSizeOp(_ods_ir.OpView):
  r"""
  The number of local invocations within the current workgroup along each
  dimension. Depending on backend this may map to the SIMT thread count or
  inner loop nest parameters.
  
  Workgroup sizes are not determined at the stream dialect level as they are
  dependent on the target backend determined when lowering into the HAL. It's
  still possible to use the symbolic workgroup size inside of dispatch
  executables as a placeholder for the resolved value once in the HAL.
  
  Represented as a 3D grid classically written as XYZ.
  Corresponds to the `WorkgroupSize` SPIR-V built-in and the `blockDim` CUDA
  built-in variable.
  
  ```mlir
  %x = stream.dispatch.workgroup.size[0] : index
  %y = stream.dispatch.workgroup.size[1] : index
  %z = stream.dispatch.workgroup.size[2] : index
  ```
  """

  OPERATION_NAME = "stream.dispatch.workgroup.size"

  _ODS_REGIONS = (0, True)

  def __init__(self, dimension, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dimension"] = (dimension if (
    isinstance(dimension, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IndexAttr')) else
      _ods_ir.AttrBuilder.get('IndexAttr')(dimension, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def dimension(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["dimension"]

  @dimension.setter
  def dimension(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dimension"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IndexType]:
    return self.operation.results[0]

def dispatch_workgroup_size(dimension, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return DispatchWorkgroupSizeOp(dimension=dimension, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ExecutableEndOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.executable.end"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def executable_end(*, loc=None, ip=None) -> ExecutableEndOp:
  return ExecutableEndOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ExecutableExportOp(_ods_ir.OpView):
  r"""
  Specifies an exported function with an externally-visible alias. Multiple
  exports can reference the same internal function.
  
  Each entry point can have a unique workgroup count calculation region.
  This region takes the workload parameters passed to each flow.dispatch and
  produces an XYZ workgroup count for the 3D grid dispatch.
  """

  OPERATION_NAME = "stream.executable.export"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, function_ref, *, sym_visibility=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if sym_visibility is not None: attributes["sym_visibility"] = (sym_visibility if (
        isinstance(sym_visibility, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(sym_visibility, context=_ods_context))
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["function_ref"] = (function_ref if (
    isinstance(function_ref, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(function_ref, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_visibility(self) -> _Optional[_ods_ir.StringAttr]:
    if "sym_visibility" not in self.operation.attributes:
      return None
    return self.operation.attributes["sym_visibility"]

  @sym_visibility.setter
  def sym_visibility(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["sym_visibility"] = value
    elif "sym_visibility" in self.operation.attributes:
      del self.operation.attributes["sym_visibility"]

  @sym_visibility.deleter
  def sym_visibility(self):
    del self.operation.attributes["sym_visibility"]

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def function_ref(self) -> _ods_ir.FlatSymbolRefAttr:
    return self.operation.attributes["function_ref"]

  @function_ref.setter
  def function_ref(self, value: _ods_ir.FlatSymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["function_ref"] = value

  @builtins.property
  def workgroup_count(self) -> _ods_ir.Region:
    return self.regions[0]

def executable_export(sym_name, function_ref, *, sym_visibility=None, loc=None, ip=None) -> ExecutableExportOp:
  return ExecutableExportOp(sym_name=sym_name, function_ref=function_ref, sym_visibility=sym_visibility, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ExecutableOp(_ods_ir.OpView):
  r"""
  An executable module containing one or more public functions. The contents
  of the functions are safe to dispatch and can be lowered further to
  target-specific backend IR representations.
  """

  OPERATION_NAME = "stream.executable"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, *, sym_visibility=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if sym_visibility is not None: attributes["sym_visibility"] = (sym_visibility if (
        isinstance(sym_visibility, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(sym_visibility, context=_ods_context))
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_visibility(self) -> _Optional[_ods_ir.StringAttr]:
    if "sym_visibility" not in self.operation.attributes:
      return None
    return self.operation.attributes["sym_visibility"]

  @sym_visibility.setter
  def sym_visibility(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["sym_visibility"] = value
    elif "sym_visibility" in self.operation.attributes:
      del self.operation.attributes["sym_visibility"]

  @sym_visibility.deleter
  def sym_visibility(self):
    del self.operation.attributes["sym_visibility"]

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def executable(sym_name, *, sym_visibility=None, loc=None, ip=None) -> ExecutableOp:
  return ExecutableOp(sym_name=sym_name, sym_visibility=sym_visibility, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class FileConstantOp(_ods_ir.OpView):
  r"""
  Synchronously wraps a host heap buffer into a stream-accessible file handle.
  Changing the source buffer after definition has undefined behavior.
  """

  OPERATION_NAME = "stream.file.constant"

  _ODS_REGIONS = (0, True)

  def __init__(self, source, source_size, source_offset, source_length, *, affinity=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(source_size)
    operands.append(source_offset)
    operands.append(source_length)
    _ods_context = _ods_get_default_loc_context(loc)
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def source_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def source_offset(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[2]

  @builtins.property
  def source_length(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[3]

  @builtins.property
  def affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def file_constant(source, source_size, source_offset, source_length, *, affinity=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return FileConstantOp(source=source, source_size=source_size, source_offset=source_offset, source_length=source_length, affinity=affinity, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FileReadOp(_ods_ir.OpView):
  r"""
  Asynchronously reads a segment of a file into a resource.
  
  Some implementations can stream directly from the source file into
  device-local memory and file ops should be preferred to manually staging
  memory through host buffers.
  """

  OPERATION_NAME = "stream.file.read"

  _ODS_REGIONS = (0, True)

  def __init__(self, source, source_offset, target, target_size, target_offset, length, *, await_timepoint=None, affinity=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(source_offset)
    operands.append(target)
    operands.append(target_size)
    operands.append(target_offset)
    operands.append(length)
    if await_timepoint is not None: operands.append(await_timepoint)
    _ods_context = _ods_get_default_loc_context(loc)
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def source_offset(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def target(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def target_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[3]

  @builtins.property
  def target_offset(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[4]

  @builtins.property
  def length(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[5]

  @builtins.property
  def await_timepoint(self) -> _Optional[_ods_ir.Value]:
    return None if len(self.operation.operands) < 7 else self.operation.operands[6]

  @builtins.property
  def affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result_timepoint(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def file_read(source, source_offset, target, target_size, target_offset, length, *, await_timepoint=None, affinity=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return FileReadOp(source=source, source_offset=source_offset, target=target, target_size=target_size, target_offset=target_offset, length=length, await_timepoint=await_timepoint, affinity=affinity, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FileWriteOp(_ods_ir.OpView):
  r"""
  Asynchronously writes a segment of a resource into a file.
  The file range must be valid within the file as this operation cannot
  grow the underlying file storage.
  
  Some implementations can stream directly from device-local memory into the
  target file and file ops should be preferred to manually staging memory
  through host buffers.
  """

  OPERATION_NAME = "stream.file.write"

  _ODS_REGIONS = (0, True)

  def __init__(self, source, source_size, source_offset, target, target_offset, length, *, await_timepoint=None, affinity=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(source_size)
    operands.append(source_offset)
    operands.append(target)
    operands.append(target_offset)
    operands.append(length)
    if await_timepoint is not None: operands.append(await_timepoint)
    _ods_context = _ods_get_default_loc_context(loc)
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def source_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def source_offset(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[2]

  @builtins.property
  def target(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def target_offset(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[4]

  @builtins.property
  def length(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[5]

  @builtins.property
  def await_timepoint(self) -> _Optional[_ods_ir.Value]:
    return None if len(self.operation.operands) < 7 else self.operation.operands[6]

  @builtins.property
  def affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result_timepoint(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def file_write(source, source_size, source_offset, target, target_offset, length, *, await_timepoint=None, affinity=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return FileWriteOp(source=source, source_size=source_size, source_offset=source_offset, target=target, target_offset=target_offset, length=length, await_timepoint=await_timepoint, affinity=affinity, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ResourceAllocOp(_ods_ir.OpView):
  r"""
  Allocates a persistent value (one that is long-lived and possibly external
  to the program) with undefined contents. Consumers of the allocated
  result must assume nothing of the contents and use `discard` access.
  
  Uninitialized allocations will have undefined contents and must only be used
  when all bytes are discarded prior to any reads. Runtimes decide what
  "undefined contents" means and here it only indicates that execution will be
  correct even if the memory starts with non-zero values.
  
  If multiple values are allocated from the same operation it implies that
  they have matching lifetimes. When lowering to execution environments the
  separate allocations may be fused into one or more slab allocations in order
  to reduce overheads. How many allocations can be fused is based on the size
  of the individual resources and the target constraints (how large any single
  buffer may be, etc).
  """

  OPERATION_NAME = "stream.resource.alloc"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, storage_size, *, uninitialized=None, affinity=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(storage_size)
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(uninitialized): attributes["uninitialized"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def storage_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[0]

  @builtins.property
  def uninitialized(self) -> bool:
    return "uninitialized" in self.operation.attributes

  @uninitialized.setter
  def uninitialized(self, value):
    if bool(value):
      self.operation.attributes["uninitialized"] = _ods_ir.UnitAttr.get()
    elif "uninitialized" in self.operation.attributes:
      del self.operation.attributes["uninitialized"]

  @uninitialized.deleter
  def uninitialized(self):
    del self.operation.attributes["uninitialized"]

  @builtins.property
  def affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def resource_alloc(result, storage_size, *, uninitialized=None, affinity=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ResourceAllocOp(result=result, storage_size=storage_size, uninitialized=uninitialized, affinity=affinity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ResourceAllocaOp(_ods_ir.OpView):
  r"""
  Allocates a transient value (one that is short-lived and local to the
  current computation) with undefined contents. Consumers of the allocated
  result must assume nothing of the contents and use `discard` access.
  
  The resource returned is not valid for use until the timepoint is reached;
  execution using this resource must await on the timepoint.
  
  If the lifetime of the allocation is unknowable (analysis fails, etc) the
  `indeterminate_lifetime` will be set indicating that the resource should not
  be deallocated asynchronously and only after all references have been
  released.
  """

  OPERATION_NAME = "stream.resource.alloca"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, result_timepoint, storage_size, *, indeterminate_lifetime=None, await_timepoint=None, affinity=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(storage_size)
    if await_timepoint is not None: operands.append(await_timepoint)
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(indeterminate_lifetime): attributes["indeterminate_lifetime"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    results = []
    results.append(result)
    results.append(result_timepoint)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def storage_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[0]

  @builtins.property
  def await_timepoint(self) -> _Optional[_ods_ir.Value]:
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def indeterminate_lifetime(self) -> bool:
    return "indeterminate_lifetime" in self.operation.attributes

  @indeterminate_lifetime.setter
  def indeterminate_lifetime(self, value):
    if bool(value):
      self.operation.attributes["indeterminate_lifetime"] = _ods_ir.UnitAttr.get()
    elif "indeterminate_lifetime" in self.operation.attributes:
      del self.operation.attributes["indeterminate_lifetime"]

  @indeterminate_lifetime.deleter
  def indeterminate_lifetime(self):
    del self.operation.attributes["indeterminate_lifetime"]

  @builtins.property
  def affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

  @builtins.property
  def result_timepoint(self) -> _ods_ir.OpResult:
    return self.operation.results[1]

def resource_alloca(result, result_timepoint, storage_size, *, indeterminate_lifetime=None, await_timepoint=None, affinity=None, loc=None, ip=None) -> _ods_ir.OpResultList:
  return ResourceAllocaOp(result=result, result_timepoint=result_timepoint, storage_size=storage_size, indeterminate_lifetime=indeterminate_lifetime, await_timepoint=await_timepoint, affinity=affinity, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class ResourceConstantsOp(_ods_ir.OpView):
  r"""
  Represents an upload of constant resources that may be packed, suballocated,
  and mapped depending on the final lowering target.
  
  In runtime environments where memory is shared between host and device this
  turns into a mapping operation that avoids additional memory allocation and
  copies. When memory cannot be shared an asynchronous stream will be created
  to allocate and copy all of the constant values.
  
  Though this op returns a unique resource for each constant value it's
  expected that almost all end up aliasing into the same storage. The exact
  packing and number of storage resources that are needed are not known until
  lowering to a particular backend, though, so they are separate here for
  proper usage tracking.
  
  Both constant and variable resources can be produced; a constant is
  immutable while a variable will be treated as a constant-value initializer
  for a mutable resource. By modeling these together it's not required that
  variable initializers first be allocated, copied to the target, and then
  copied into the variable storage if the target is capable of doing a direct
  upload or mapping.
  """

  OPERATION_NAME = "stream.resource.constants"

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, result_timepoint, values, result_sizes, *, affinity=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(result_sizes))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["values"] = (values if (
    isinstance(values, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_728')) else
      _ods_ir.AttrBuilder.get('anonymous_728')(values, context=_ods_context))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    results = []
    results.extend(results_)
    results.append(result_timepoint)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def result_sizes(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def values(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["values"]

  @values.setter
  def values(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["values"] = value

  @builtins.property
  def affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def results_(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 2 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result_timepoint(self) -> _ods_ir.OpResult:
    _ods_variadic_group_length = len(self.operation.results) - 2 + 1
    return self.operation.results[1 + _ods_variadic_group_length - 1]

def resource_constants(results_, result_timepoint, values, result_sizes, *, affinity=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, ResourceConstantsOp]:
  op = ResourceConstantsOp(results_=results_, result_timepoint=result_timepoint, values=values, result_sizes=result_sizes, affinity=affinity, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class ResourceDeallocaOp(_ods_ir.OpView):
  r"""
  Deallocates a transient value (one that is short-lived and local to the
  current computation) previously allocated using `stream.resource.alloca`.
  
  The resource is considered live and valid until the provided timepoint is
  reached and the memory is only made available for future requests after
  the result timepoint is reached.
  
  If `prefer_origin` is set then the deallocation will be scheduled against
  the original placement affinity of the allocation at runtime. In cases where
  the original placement is unavailable the affinity of the deallocation op
  will be used to perform a barrier operation.
  """

  OPERATION_NAME = "stream.resource.dealloca"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, operand_size, *, prefer_origin=None, await_timepoint=None, affinity=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    operands.append(operand_size)
    if await_timepoint is not None: operands.append(await_timepoint)
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(prefer_origin): attributes["prefer_origin"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def await_timepoint(self) -> _Optional[_ods_ir.Value]:
    return None if len(self.operation.operands) < 3 else self.operation.operands[2]

  @builtins.property
  def prefer_origin(self) -> bool:
    return "prefer_origin" in self.operation.attributes

  @prefer_origin.setter
  def prefer_origin(self, value):
    if bool(value):
      self.operation.attributes["prefer_origin"] = _ods_ir.UnitAttr.get()
    elif "prefer_origin" in self.operation.attributes:
      del self.operation.attributes["prefer_origin"]

  @prefer_origin.deleter
  def prefer_origin(self):
    del self.operation.attributes["prefer_origin"]

  @builtins.property
  def affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result_timepoint(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def resource_dealloca(operand, operand_size, *, prefer_origin=None, await_timepoint=None, affinity=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ResourceDeallocaOp(operand=operand, operand_size=operand_size, prefer_origin=prefer_origin, await_timepoint=await_timepoint, affinity=affinity, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ResourceIsTerminalOp(_ods_ir.OpView):
  r"""
  Resources may have multiple conceptual owners and are generally only safe to
  deallocate if the code performing the deallocation is the last owner. This
  op can be used to see if the current owner is the last one claiming
  ownership and can deallocate or reuse the resource for other purposes.
  """

  OPERATION_NAME = "stream.resource.is_terminal"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, operand_size, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    operands.append(operand_size)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def resource_is_terminal(operand, operand_size, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ResourceIsTerminalOp(operand=operand, operand_size=operand_size, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ResourceLoadOp(_ods_ir.OpView):
  r"""
  Returns the element(s) at the given offset in the staging resource.
  The operation will complete synchronously against the resource though it may
  introduce a yield point if the staging resource needs to be transferred.
  """

  OPERATION_NAME = "stream.resource.load"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, source, source_size, source_offset, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(source_size)
    operands.append(source_offset)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def source_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def source_offset(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[2]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def resource_load(result, source, source_size, source_offset, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ResourceLoadOp(result=result, source=source, source_size=source_size, source_offset=source_offset, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ResourcePackOp(_ods_ir.OpView):
  r"""
  Performs a greedy packing of one or more sized slices with specified
  lifetimes and returns their relative offsets in an aliased linear space.
  
  Slices are `[start, end] = %slice_byte_size`, where the start and end values
  define an inclusive lifetime range and the size is the total number of bytes
  required to be live for that range.
  
  ```mlir
  // Computes the total length required for the packed values and the offsets
  // of the 3 slices requested relative to the base of the packed memory:
  %total_length, %offset_0, %offset_1, %offset_2 =
      stream.resource.pack
          // Each slice gets one result offset:
          slices({
            // 3 slices where A and B overlap and will get unique offsets
            // while B and C do not overlap and are allowed to alias.
            [0, 10] = %size_0,  // A => %offset_0
            [3,  8] = %size_1,  // B => %offset_1
            [9, 10] = %size_2,  // C => %offset_2
            ...
          }) : index
  ```
  
  The lifetime start and end points (inclusive) are only used for relative
  comparisons and may originate with any meaning (op order in block, epoch,
  phase of the moon, etc). The packing algorithm uses the intervals to
  determine slice liveness and when aliasing is safe.
  
  The size of each slice may either be a constant or runtime-computed dynamic
  value. Constant slices can achieve more dense packing than the dynamic
  values and CSE/canonicalization should be applied to ensure that as many of
  the dynamic values are equivalent if possible.
  
  The total length required to pack all slices is returned and can be used to
  acquire storage. The individual slice offsets are 0-based and as such if are
  directly used as buffer offsets may need additional offsetting. This can
  either be applied via the optional `offset` operand or slicing of the
  underlying allocation buffer.
  """

  OPERATION_NAME = "stream.resource.pack"

  _ODS_OPERAND_SEGMENTS = [0,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, total_length, packed_offsets, lifetime_intervals, dynamic_slice_sizes, *, offset=None, affinity=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(offset)
    operands.append(_get_op_results_or_values(dynamic_slice_sizes))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["lifetime_intervals"] = (lifetime_intervals if (
    isinstance(lifetime_intervals, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Stream_IndexArrayAttr')) else
      _ods_ir.AttrBuilder.get('Stream_IndexArrayAttr')(lifetime_intervals, context=_ods_context))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    results = []
    results.append(total_length)
    results.extend(packed_offsets)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def offset(self) -> _Optional[_ods_ir.Value[_ods_ir.IndexType]]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def dynamic_slice_sizes(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def lifetime_intervals(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["lifetime_intervals"]

  @lifetime_intervals.setter
  def lifetime_intervals(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["lifetime_intervals"] = value

  @builtins.property
  def affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def total_length(self) -> _ods_ir.OpResult[_ods_ir.IndexType]:
    return self.operation.results[0]

  @builtins.property
  def packed_offsets(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 2 + 1
    return self.operation.results[1:1 + _ods_variadic_group_length]

def resource_pack(total_length, packed_offsets, lifetime_intervals, dynamic_slice_sizes, *, offset=None, affinity=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, ResourcePackOp]:
  op = ResourcePackOp(total_length=total_length, packed_offsets=packed_offsets, lifetime_intervals=lifetime_intervals, dynamic_slice_sizes=dynamic_slice_sizes, offset=offset, affinity=affinity, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class ResourceReleaseOp(_ods_ir.OpView):
  r"""
  A resource is allowed to be deallocated or reused once the last owner
  releases their ownership. Returns a boolean indicating whether the owner
  releasing their claim was the last owner (equivalent to having used
  `stream.resource.is_terminal`).
  """

  OPERATION_NAME = "stream.resource.release"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, operand_size, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    operands.append(operand_size)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def resource_release(operand, operand_size, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ResourceReleaseOp(operand=operand, operand_size=operand_size, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ResourceRetainOp(_ods_ir.OpView):
  r"""
  Retains ownership of the resource for the parent code until a corresponding
  `stream.resource.release` is used to release the ownership claim. A
  particular resource may have multiple owners at any given time indicating
  that multiple parts of the program are sharing responsibility for
  deallocating the resource.
  
  This is primarily only relevant for resources allocated asynchronously and
  that need `stream.resource.dealloca` operations scheduled on timelines.
  Synchronously allocated resources have their lifetimes tied directly to
  their reference-type and do not need additional ownership management.
  """

  OPERATION_NAME = "stream.resource.retain"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, operand_size, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    operands.append(operand_size)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

def resource_retain(operand, operand_size, *, loc=None, ip=None) -> ResourceRetainOp:
  return ResourceRetainOp(operand=operand, operand_size=operand_size, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ResourceSizeOp(_ods_ir.OpView):
  r"""
  Returns a possibly runtime-dynamic byte size of the resource backing
  storage. This may differ from the logical storage size of a value based on
  the alignment requirements of the target as well as encoding of higher level
  values such as sparse tensor formats.
  """

  OPERATION_NAME = "stream.resource.size"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, affinity=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IndexType]:
    return self.operation.results[0]

def resource_size(operand, *, affinity=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ResourceSizeOp(operand=operand, affinity=affinity, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ResourceStoreOp(_ods_ir.OpView):
  r"""
  The operation will complete synchronously against the resource though it may
  introduce a yield point if the staging resource needs to be acquired.
  """

  OPERATION_NAME = "stream.resource.store"

  _ODS_REGIONS = (0, True)

  def __init__(self, target, target_size, target_offset, value, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(target)
    operands.append(target_size)
    operands.append(target_offset)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def target_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def target_offset(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[2]

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[3]

def resource_store(target, target_size, target_offset, value, *, loc=None, ip=None) -> ResourceStoreOp:
  return ResourceStoreOp(target=target, target_size=target_size, target_offset=target_offset, value=value, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ResourceSubviewOp(_ods_ir.OpView):
  r"""
  Aliases a byte subrange of a resource.
  """

  OPERATION_NAME = "stream.resource.subview"

  _ODS_REGIONS = (0, True)

  def __init__(self, source, source_size, source_offset, result_size, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(source_size)
    operands.append(source_offset)
    operands.append(result_size)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def source_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def source_offset(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[2]

  @builtins.property
  def result_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[3]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def resource_subview(source, source_size, source_offset, result_size, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ResourceSubviewOp(source=source, source_size=source_size, source_offset=source_offset, result_size=result_size, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ResourceTransientsOp(_ods_ir.OpView):
  r"""
  Annotates that any transient memory used in the production of the given
  resource should be suballocated from the provided storage. This allows
  users to control transient allocations by providing their own backing
  storage enabling zero-allocation execution in steady state.
  
  The storage provided must have sufficient space for all transient
  allocations required to produce the resource. Unless otherwise overridden
  the compiler will verify that all allocation sizes are computable and
  generate size query functions to allow users to query the required storage
  size. If size checks are disabled then the user must ensure they pass in
  storage with sufficient capacity.
  
  This operation preserves SSA use-def chains by returning the same resource
  value it receives. It exists purely for annotation purposes and will be
  lowered away during compilation. The operation is timeline-aware and
  threads timepoints through to enable proper synchronization.
  
  Example:
  ```mlir
  %result, %result_timepoint = some.operation(%input) : !stream.resource<*>
  %annotated, %annotated_tp = stream.resource.transients
      await(%result_timepoint) => %result : !stream.resource<*>{%size}
      from %storage : !stream.resource<transient>{%storage_size}
      => !stream.timepoint
  ```
  """

  OPERATION_NAME = "stream.resource.transients"

  _ODS_REGIONS = (0, True)

  def __init__(self, resource, resource_size, storage, storage_size, *, await_timepoint=None, affinity=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(resource)
    operands.append(resource_size)
    operands.append(storage)
    operands.append(storage_size)
    if await_timepoint is not None: operands.append(await_timepoint)
    _ods_context = _ods_get_default_loc_context(loc)
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def resource(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def resource_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def storage(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def storage_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[3]

  @builtins.property
  def await_timepoint(self) -> _Optional[_ods_ir.Value]:
    return None if len(self.operation.operands) < 5 else self.operation.operands[4]

  @builtins.property
  def affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

  @builtins.property
  def result_timepoint(self) -> _ods_ir.OpResult:
    return self.operation.results[1]

def resource_transients(resource, resource_size, storage, storage_size, *, await_timepoint=None, affinity=None, results=None, loc=None, ip=None) -> _ods_ir.OpResultList:
  return ResourceTransientsOp(resource=resource, resource_size=resource_size, storage=storage, storage_size=storage_size, await_timepoint=await_timepoint, affinity=affinity, results=results, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class ResourceTryMapOp(_ods_ir.OpView):
  r"""
  Synchronously maps a host heap buffer into a stream-accessible resource
  with the requested lifetime. If the given source cannot be mapped the
  `did_map` result will be 0 and users must find another route into memory
  (such as file I/O). The resulting resource is not coherent with the source
  and behavior is undefined if the underlying contents change.
  """

  OPERATION_NAME = "stream.resource.try_map"

  _ODS_REGIONS = (0, True)

  def __init__(self, did_map, result, source, source_offset, result_size, *, affinity=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(source_offset)
    operands.append(result_size)
    _ods_context = _ods_get_default_loc_context(loc)
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    results = []
    results.append(did_map)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def source_offset(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def result_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[2]

  @builtins.property
  def affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def did_map(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[1]

def resource_try_map(did_map, result, source, source_offset, result_size, *, affinity=None, loc=None, ip=None) -> _ods_ir.OpResultList:
  return ResourceTryMapOp(did_map=did_map, result=result, source=source, source_offset=source_offset, result_size=result_size, affinity=affinity, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class ReturnOp(_ods_ir.OpView):
  r"""
  The values returned are copied by-value.
  """

  OPERATION_NAME = "stream.return"

  _ODS_REGIONS = (0, True)

  def __init__(self, operands_, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def return_(operands_, *, loc=None, ip=None) -> ReturnOp:
  return ReturnOp(operands_=operands_, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class TensorCloneOp(_ods_ir.OpView):
  r"""
  Clones the contents of a value at a snapshot in time. Future changes to the
  cloned value will not effect the result. Acts as a copy-on-write operation.
  """

  OPERATION_NAME = "stream.tensor.clone"

  _ODS_OPERAND_SEGMENTS = [1,-1,1,-1,1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, result, source, source_encoding, source_encoding_dims, source_size, result_encoding, result_encoding_dims, result_size, *, affinity=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(_get_op_results_or_values(source_encoding_dims))
    operands.append(source_size)
    operands.append(_get_op_results_or_values(result_encoding_dims))
    operands.append(result_size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["source_encoding"] = (source_encoding if (
    isinstance(source_encoding, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(source_encoding, context=_ods_context))
    attributes["result_encoding"] = (result_encoding if (
    isinstance(result_encoding, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(result_encoding, context=_ods_context))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def source_encoding_dims(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def source_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0]

  @builtins.property
  def result_encoding_dims(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def result_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range[0]

  @builtins.property
  def source_encoding(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["source_encoding"]

  @source_encoding.setter
  def source_encoding(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["source_encoding"] = value

  @builtins.property
  def result_encoding(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["result_encoding"]

  @result_encoding.setter
  def result_encoding(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["result_encoding"] = value

  @builtins.property
  def affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def tensor_clone(result, source, source_encoding, source_encoding_dims, source_size, result_encoding, result_encoding_dims, result_size, *, affinity=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return TensorCloneOp(result=result, source=source, source_encoding=source_encoding, source_encoding_dims=source_encoding_dims, source_size=source_size, result_encoding=result_encoding, result_encoding_dims=result_encoding_dims, result_size=result_size, affinity=affinity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorConstantOp(_ods_ir.OpView):
  r"""
  Returns a typed resource initialized to the given constant value.
  """

  OPERATION_NAME = "stream.tensor.constant"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, value, result_encoding, result_encoding_dims, *, affinity=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(result_encoding_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypedAttrInterface')) else
      _ods_ir.AttrBuilder.get('TypedAttrInterface')(value, context=_ods_context))
    attributes["result_encoding"] = (result_encoding if (
    isinstance(result_encoding, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(result_encoding, context=_ods_context))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def result_encoding_dims(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def value(self) -> _ods_ir.Attribute:
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def result_encoding(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["result_encoding"]

  @result_encoding.setter
  def result_encoding(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["result_encoding"] = value

  @builtins.property
  def affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def tensor_constant(result, value, result_encoding, result_encoding_dims, *, affinity=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return TensorConstantOp(result=result, value=value, result_encoding=result_encoding, result_encoding_dims=result_encoding_dims, affinity=affinity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorDispatchOp(_ods_ir.OpView):
  r"""
  Calls the specified entry point function once for each element in the
  specified workgroup count. Each workgroup has access to the same operands
  and results and is able to load/store at will.
  """

  OPERATION_NAME = "stream.tensor.dispatch"

  _ODS_OPERAND_SEGMENTS = [-1,-1,-1,-1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, workload, entry_points, mixed_operands, operand_sizes, operand_encodings, operand_encoding_dims, result_sizes, result_encodings, result_encoding_dims, *, tied_operands=None, affinity=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(workload))
    operands.append(_get_op_results_or_values(mixed_operands))
    operands.append(_get_op_results_or_values(operand_sizes))
    operands.append(_get_op_results_or_values(operand_encoding_dims))
    operands.append(_get_op_results_or_values(result_sizes))
    operands.append(_get_op_results_or_values(result_encoding_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["entry_points"] = (entry_points if (
    isinstance(entry_points, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolRefArrayAttr')) else
      _ods_ir.AttrBuilder.get('SymbolRefArrayAttr')(entry_points, context=_ods_context))
    attributes["operand_encodings"] = (operand_encodings if (
    isinstance(operand_encodings, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeArrayAttr')) else
      _ods_ir.AttrBuilder.get('TypeArrayAttr')(operand_encodings, context=_ods_context))
    attributes["result_encodings"] = (result_encodings if (
    isinstance(result_encodings, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeArrayAttr')) else
      _ods_ir.AttrBuilder.get('TypeArrayAttr')(result_encodings, context=_ods_context))
    if tied_operands is not None: attributes["tied_operands"] = (tied_operands if (
        isinstance(tied_operands, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Util_TiedOpStorageAttr')) else
          _ods_ir.AttrBuilder.get('Util_TiedOpStorageAttr')(tied_operands, context=_ods_context))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    results = []
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def workload(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def mixed_operands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def operand_sizes(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def operand_encoding_dims(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def result_sizes(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range

  @builtins.property
  def result_encoding_dims(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 5)
    return operand_range

  @builtins.property
  def entry_points(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["entry_points"]

  @entry_points.setter
  def entry_points(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["entry_points"] = value

  @builtins.property
  def operand_encodings(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["operand_encodings"]

  @operand_encodings.setter
  def operand_encodings(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["operand_encodings"] = value

  @builtins.property
  def result_encodings(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["result_encodings"]

  @result_encodings.setter
  def result_encodings(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["result_encodings"] = value

  @builtins.property
  def tied_operands(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tied_operands" not in self.operation.attributes:
      return None
    return self.operation.attributes["tied_operands"]

  @tied_operands.setter
  def tied_operands(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tied_operands"] = value
    elif "tied_operands" in self.operation.attributes:
      del self.operation.attributes["tied_operands"]

  @tied_operands.deleter
  def tied_operands(self):
    del self.operation.attributes["tied_operands"]

  @builtins.property
  def affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def results_(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def tensor_dispatch(results_, workload, entry_points, mixed_operands, operand_sizes, operand_encodings, operand_encoding_dims, result_sizes, result_encodings, result_encoding_dims, *, tied_operands=None, affinity=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, TensorDispatchOp]:
  op = TensorDispatchOp(results_=results_, workload=workload, entry_points=entry_points, mixed_operands=mixed_operands, operand_sizes=operand_sizes, operand_encodings=operand_encodings, operand_encoding_dims=operand_encoding_dims, result_sizes=result_sizes, result_encodings=result_encodings, result_encoding_dims=result_encoding_dims, tied_operands=tied_operands, affinity=affinity, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class TensorEmptyOp(_ods_ir.OpView):
  r"""
  Returns a typed resource initialized with no contents. This still carries
  shape metadata and may encode to a non-empty resource such as in cases
  where the empty representation still has data (e.g. sparse tensors).
  Subsequent writes must populate any ranges of the tensor that are later
  read.
  """

  OPERATION_NAME = "stream.tensor.empty"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, result_encoding, result_encoding_dims, result_size, *, affinity=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(result_encoding_dims))
    operands.append(result_size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["result_encoding"] = (result_encoding if (
    isinstance(result_encoding, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(result_encoding, context=_ods_context))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def result_encoding_dims(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1 + _ods_variadic_group_length - 1]

  @builtins.property
  def result_encoding(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["result_encoding"]

  @result_encoding.setter
  def result_encoding(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["result_encoding"] = value

  @builtins.property
  def affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def tensor_empty(result, result_encoding, result_encoding_dims, result_size, *, affinity=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return TensorEmptyOp(result=result, result_encoding=result_encoding, result_encoding_dims=result_encoding_dims, result_size=result_size, affinity=affinity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorEncodeOp(_ods_ir.OpView):
  r"""
  Elones the contents of a value at a snapshot in time. Future changes to the
  identity encoding will not effect the result. Acts as a copy-on-write
  operation. Otherwise, an executable for encoding the value is generated
  during lowering.
  """

  OPERATION_NAME = "stream.tensor.encode"

  _ODS_OPERAND_SEGMENTS = [1,-1,1,-1,1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, result, source, source_encoding, source_encoding_dims, source_size, result_encoding, result_encoding_dims, result_size, *, affinity=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(_get_op_results_or_values(source_encoding_dims))
    operands.append(source_size)
    operands.append(_get_op_results_or_values(result_encoding_dims))
    operands.append(result_size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["source_encoding"] = (source_encoding if (
    isinstance(source_encoding, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(source_encoding, context=_ods_context))
    attributes["result_encoding"] = (result_encoding if (
    isinstance(result_encoding, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(result_encoding, context=_ods_context))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def source_encoding_dims(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def source_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0]

  @builtins.property
  def result_encoding_dims(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def result_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range[0]

  @builtins.property
  def source_encoding(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["source_encoding"]

  @source_encoding.setter
  def source_encoding(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["source_encoding"] = value

  @builtins.property
  def result_encoding(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["result_encoding"]

  @result_encoding.setter
  def result_encoding(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["result_encoding"] = value

  @builtins.property
  def affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def tensor_encode(result, source, source_encoding, source_encoding_dims, source_size, result_encoding, result_encoding_dims, result_size, *, affinity=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return TensorEncodeOp(result=result, source=source, source_encoding=source_encoding, source_encoding_dims=source_encoding_dims, source_size=source_size, result_encoding=result_encoding, result_encoding_dims=result_encoding_dims, result_size=result_size, affinity=affinity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorExportOp(_ods_ir.OpView):
  r"""
  Defines a conversion to a higher-level dialect type such as `tensor` that
  is resolved during lowering into the stream dialect. This can be used to
  interoperate between levels of the stack that require specifying stream
  types and those that prior to lowering do not handle them.
  """

  OPERATION_NAME = "stream.tensor.export"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, source, source_encoding, source_encoding_dims, source_size, *, affinity=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.extend(_get_op_results_or_values(source_encoding_dims))
    operands.append(source_size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["source_encoding"] = (source_encoding if (
    isinstance(source_encoding, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(source_encoding, context=_ods_context))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def source_encoding_dims(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def source_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[2 + _ods_variadic_group_length - 1]

  @builtins.property
  def source_encoding(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["source_encoding"]

  @source_encoding.setter
  def source_encoding(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["source_encoding"] = value

  @builtins.property
  def affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def tensor_export(result, source, source_encoding, source_encoding_dims, source_size, *, affinity=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return TensorExportOp(result=result, source=source, source_encoding=source_encoding, source_encoding_dims=source_encoding_dims, source_size=source_size, affinity=affinity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorFillOp(_ods_ir.OpView):
  r"""
  Splats a value into a subview of the given stream resource and returns the
  resource with the update applied.
  
  Equivalent to a stream.tensor.splat + stream.tensor.update.
  """

  OPERATION_NAME = "stream.tensor.fill"

  _ODS_OPERAND_SEGMENTS = [1,-1,1,-1,-1,1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, target, target_encoding, target_encoding_dims, target_size, start_indices, lengths, value, *, affinity=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(target)
    operands.append(_get_op_results_or_values(target_encoding_dims))
    operands.append(target_size)
    operands.append(_get_op_results_or_values(start_indices))
    operands.append(_get_op_results_or_values(lengths))
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["target_encoding"] = (target_encoding if (
    isinstance(target_encoding, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(target_encoding, context=_ods_context))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def target_encoding_dims(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def target_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0]

  @builtins.property
  def start_indices(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def lengths(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range

  @builtins.property
  def value(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 5)
    return operand_range[0]

  @builtins.property
  def target_encoding(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["target_encoding"]

  @target_encoding.setter
  def target_encoding(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["target_encoding"] = value

  @builtins.property
  def affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def tensor_fill(target, target_encoding, target_encoding_dims, target_size, start_indices, lengths, value, *, affinity=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return TensorFillOp(target=target, target_encoding=target_encoding, target_encoding_dims=target_encoding_dims, target_size=target_size, start_indices=start_indices, lengths=lengths, value=value, affinity=affinity, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorImportOp(_ods_ir.OpView):
  r"""
  Defines a conversion from a higher-level dialect type such as `tensor` that
  is resolved during lowering into the stream dialect. This can be used to
  interoperate between levels of the stack that require specifying stream
  types and those that prior to lowering do not handle them.
  
  `consume` can be used to indicate a transfer of ownership. Though the
  imported value may still have external references when consumed a resource
  will be conceptually released from its existing owner and retained by the
  importer atomically.
  """

  OPERATION_NAME = "stream.tensor.import"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, source, result_encoding, result_encoding_dims, result_size, *, consume=None, affinity=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.extend(_get_op_results_or_values(result_encoding_dims))
    operands.append(result_size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["result_encoding"] = (result_encoding if (
    isinstance(result_encoding, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(result_encoding, context=_ods_context))
    if bool(consume): attributes["consume"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result_encoding_dims(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def result_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[2 + _ods_variadic_group_length - 1]

  @builtins.property
  def result_encoding(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["result_encoding"]

  @result_encoding.setter
  def result_encoding(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["result_encoding"] = value

  @builtins.property
  def consume(self) -> bool:
    return "consume" in self.operation.attributes

  @consume.setter
  def consume(self, value):
    if bool(value):
      self.operation.attributes["consume"] = _ods_ir.UnitAttr.get()
    elif "consume" in self.operation.attributes:
      del self.operation.attributes["consume"]

  @consume.deleter
  def consume(self):
    del self.operation.attributes["consume"]

  @builtins.property
  def affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def tensor_import(result, source, result_encoding, result_encoding_dims, result_size, *, consume=None, affinity=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return TensorImportOp(result=result, source=source, result_encoding=result_encoding, result_encoding_dims=result_encoding_dims, result_size=result_size, consume=consume, affinity=affinity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorLoadOp(_ods_ir.OpView):
  r"""
  Returns the element at the given location from within the tensor.
  """

  OPERATION_NAME = "stream.tensor.load"

  _ODS_OPERAND_SEGMENTS = [1,-1,1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, result, source, source_encoding, source_encoding_dims, source_size, indices, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(_get_op_results_or_values(source_encoding_dims))
    operands.append(source_size)
    operands.append(_get_op_results_or_values(indices))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["source_encoding"] = (source_encoding if (
    isinstance(source_encoding, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(source_encoding, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def source_encoding_dims(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def source_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0]

  @builtins.property
  def indices(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def source_encoding(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["source_encoding"]

  @source_encoding.setter
  def source_encoding(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["source_encoding"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def tensor_load(result, source, source_encoding, source_encoding_dims, source_size, indices, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TensorLoadOp(result=result, source=source, source_encoding=source_encoding, source_encoding_dims=source_encoding_dims, source_size=source_size, indices=indices, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorSizeOfOp(_ods_ir.OpView):
  r"""
  Target-dependent storage size calculation using a high-level annotated type.
  While within the stream dialect the storage size of a value is left as a
  placeholder using this op. The requisite target-specific parameters for
  expanding the size calculation are only available after affinities have been
  assigned.
  """

  OPERATION_NAME = "stream.tensor.sizeof"

  _ODS_REGIONS = (0, True)

  def __init__(self, encoding, encoding_dims, *, affinity=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(encoding_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["encoding"] = (encoding if (
    isinstance(encoding, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(encoding, context=_ods_context))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def encoding_dims(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def encoding(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["encoding"]

  @encoding.setter
  def encoding(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["encoding"] = value

  @builtins.property
  def affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def storage_size(self) -> _ods_ir.OpResult[_ods_ir.IndexType]:
    return self.operation.results[0]

def tensor_sizeof(encoding, encoding_dims, *, affinity=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return TensorSizeOfOp(encoding=encoding, encoding_dims=encoding_dims, affinity=affinity, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorSliceOp(_ods_ir.OpView):
  r"""
  Slices a subrange of a stream resource based on a tensor encoding. Acts as a
  copy-on-write operation.
  """

  OPERATION_NAME = "stream.tensor.slice"

  _ODS_OPERAND_SEGMENTS = [1,-1,1,-1,-1,-1,1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, result, source, source_encoding, source_encoding_dims, source_size, start_indices, lengths, result_encoding, result_encoding_dims, result_size, *, affinity=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(_get_op_results_or_values(source_encoding_dims))
    operands.append(source_size)
    operands.append(_get_op_results_or_values(start_indices))
    operands.append(_get_op_results_or_values(lengths))
    operands.append(_get_op_results_or_values(result_encoding_dims))
    operands.append(result_size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["source_encoding"] = (source_encoding if (
    isinstance(source_encoding, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(source_encoding, context=_ods_context))
    attributes["result_encoding"] = (result_encoding if (
    isinstance(result_encoding, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(result_encoding, context=_ods_context))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def source_encoding_dims(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def source_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0]

  @builtins.property
  def start_indices(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def lengths(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range

  @builtins.property
  def result_encoding_dims(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 5)
    return operand_range

  @builtins.property
  def result_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 6)
    return operand_range[0]

  @builtins.property
  def source_encoding(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["source_encoding"]

  @source_encoding.setter
  def source_encoding(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["source_encoding"] = value

  @builtins.property
  def result_encoding(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["result_encoding"]

  @result_encoding.setter
  def result_encoding(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["result_encoding"] = value

  @builtins.property
  def affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def tensor_slice(result, source, source_encoding, source_encoding_dims, source_size, start_indices, lengths, result_encoding, result_encoding_dims, result_size, *, affinity=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return TensorSliceOp(result=result, source=source, source_encoding=source_encoding, source_encoding_dims=source_encoding_dims, source_size=source_size, start_indices=start_indices, lengths=lengths, result_encoding=result_encoding, result_encoding_dims=result_encoding_dims, result_size=result_size, affinity=affinity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorSplatOp(_ods_ir.OpView):
  r"""
  Returns a typed resource initialized to the given primitive value.
  """

  OPERATION_NAME = "stream.tensor.splat"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, value, result_encoding, result_encoding_dims, result_size, *, affinity=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    operands.extend(_get_op_results_or_values(result_encoding_dims))
    operands.append(result_size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["result_encoding"] = (result_encoding if (
    isinstance(result_encoding, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(result_encoding, context=_ods_context))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result_encoding_dims(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def result_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[2 + _ods_variadic_group_length - 1]

  @builtins.property
  def result_encoding(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["result_encoding"]

  @result_encoding.setter
  def result_encoding(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["result_encoding"] = value

  @builtins.property
  def affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def tensor_splat(result, value, result_encoding, result_encoding_dims, result_size, *, affinity=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return TensorSplatOp(result=result, value=value, result_encoding=result_encoding, result_encoding_dims=result_encoding_dims, result_size=result_size, affinity=affinity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorStoreOp(_ods_ir.OpView):
  r"""
  Returns a tensor with the element at the given index set to the given value.
  """

  OPERATION_NAME = "stream.tensor.store"

  _ODS_OPERAND_SEGMENTS = [1,-1,1,-1,1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, target, target_encoding, target_encoding_dims, target_size, indices, value, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(target)
    operands.append(_get_op_results_or_values(target_encoding_dims))
    operands.append(target_size)
    operands.append(_get_op_results_or_values(indices))
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["target_encoding"] = (target_encoding if (
    isinstance(target_encoding, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(target_encoding, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def target_encoding_dims(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def target_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0]

  @builtins.property
  def indices(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def value(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range[0]

  @builtins.property
  def target_encoding(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["target_encoding"]

  @target_encoding.setter
  def target_encoding(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["target_encoding"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def tensor_store(target, target_encoding, target_encoding_dims, target_size, indices, value, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return TensorStoreOp(target=target, target_encoding=target_encoding, target_encoding_dims=target_encoding_dims, target_size=target_size, indices=indices, value=value, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorTraceOp(_ods_ir.OpView):
  r"""
  Traces out to a runtime trace sink (console, log file, etc) the given
  tensors. The key is arbitrary and can be used for identifying the set of
  values being traced.
  """

  OPERATION_NAME = "stream.tensor.trace"

  _ODS_OPERAND_SEGMENTS = [-1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, key, resources, resource_sizes, resource_encodings, resource_encoding_dims, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(resources))
    operands.append(_get_op_results_or_values(resource_sizes))
    operands.append(_get_op_results_or_values(resource_encoding_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["key"] = (key if (
    isinstance(key, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(key, context=_ods_context))
    attributes["resource_encodings"] = (resource_encodings if (
    isinstance(resource_encodings, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeArrayAttr')) else
      _ods_ir.AttrBuilder.get('TypeArrayAttr')(resource_encodings, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def resources(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def resource_sizes(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def resource_encoding_dims(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def key(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["key"]

  @key.setter
  def key(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["key"] = value

  @builtins.property
  def resource_encodings(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["resource_encodings"]

  @resource_encodings.setter
  def resource_encodings(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["resource_encodings"] = value

def tensor_trace(key, resources, resource_sizes, resource_encodings, resource_encoding_dims, *, loc=None, ip=None) -> TensorTraceOp:
  return TensorTraceOp(key=key, resources=resources, resource_sizes=resource_sizes, resource_encodings=resource_encodings, resource_encoding_dims=resource_encoding_dims, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class TensorUpdateOp(_ods_ir.OpView):
  r"""
  Copies a value into a resource based on tensor encodings. The returned value
  is the entire updated target value.
  """

  OPERATION_NAME = "stream.tensor.update"

  _ODS_OPERAND_SEGMENTS = [1,-1,1,-1,1,-1,1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, target, target_encoding, target_encoding_dims, target_size, start_indices, update, update_encoding, update_encoding_dims, update_size, *, affinity=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(target)
    operands.append(_get_op_results_or_values(target_encoding_dims))
    operands.append(target_size)
    operands.append(_get_op_results_or_values(start_indices))
    operands.append(update)
    operands.append(_get_op_results_or_values(update_encoding_dims))
    operands.append(update_size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["target_encoding"] = (target_encoding if (
    isinstance(target_encoding, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(target_encoding, context=_ods_context))
    attributes["update_encoding"] = (update_encoding if (
    isinstance(update_encoding, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(update_encoding, context=_ods_context))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def target_encoding_dims(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def target_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0]

  @builtins.property
  def start_indices(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def update(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range[0]

  @builtins.property
  def update_encoding_dims(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 5)
    return operand_range

  @builtins.property
  def update_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 6)
    return operand_range[0]

  @builtins.property
  def target_encoding(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["target_encoding"]

  @target_encoding.setter
  def target_encoding(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["target_encoding"] = value

  @builtins.property
  def update_encoding(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["update_encoding"]

  @update_encoding.setter
  def update_encoding(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["update_encoding"] = value

  @builtins.property
  def affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def tensor_update(target, target_encoding, target_encoding_dims, target_size, start_indices, update, update_encoding, update_encoding_dims, update_size, *, affinity=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return TensorUpdateOp(target=target, target_encoding=target_encoding, target_encoding_dims=target_encoding_dims, target_size=target_size, start_indices=start_indices, update=update, update_encoding=update_encoding, update_encoding_dims=update_encoding_dims, update_size=update_size, affinity=affinity, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TestTimelineAwareOp(_ods_ir.OpView):
  r"""
  Test-only operation that implements TimelineAwareOpInterface directly,
  allowing Stream dialect tests to verify timeline-aware behavior without
  requiring HAL/etc dialect dependencies.
  
  Mimics util.call with the HAL coarse-fences model:
  - Takes wait fences that must complete before execution.
  - Takes a signal fence to signal when complete.
  - Returns an arbitrary result.
  """

  OPERATION_NAME = "stream.test.timeline_aware"

  _ODS_OPERAND_SEGMENTS = [-1,-1,1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, args, wait_fence_likes, signal_fence_like, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(args))
    operands.append(_get_op_results_or_values(wait_fence_likes))
    operands.append(signal_fence_like)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def wait_fence_likes(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def signal_fence_like(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0]

  @builtins.property
  def results_(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def test_timeline_aware(results_, args, wait_fence_likes, signal_fence_like, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, TestTimelineAwareOp]:
  op = TestTimelineAwareOp(results_=results_, args=args, wait_fence_likes=wait_fence_likes, signal_fence_like=signal_fence_like, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class TestTimelineOp(_ods_ir.OpView):
  r"""
  Test-only operation that implements TimelineOpInterface directly,
  allowing Stream dialect tests to verify timeline behavior without
  requiring execution regions or specific op semantics.
  
  This op takes zero or more resource operands with their sizes, zero or more
  await timepoints, and produces zero or more resource results with a result
  timepoint. It has no side effects and no execution region - it purely exists
  to test timepoint propagation, coverage analysis, and timeline scheduling.
  
  The `await_limit` attribute (default -1) controls how many await timepoints
  this op can accept before forcing join creation:
  - await_limit = -1: Unlimited awaits (default, no joins created)
  - await_limit = 0: No awaits allowed (all timepoints must be joined)
  - await_limit = 1: Max 1 await (mimics stream.async.execute behavior)
  - await_limit = N: Max N awaits
  
  Use this op when testing passes that operate on TimelineOpInterface methods.
  It's simpler than stream.async.execute (no execution region) but can still
  model resource-timepoint flows. For example:
  - ElideTimepointsPass coverage analysis (elide_timepoints_coverage.mlir)
  - PropagateTimepointsPass scheduling (propagate_timepoints.mlir)
  - SCF region handling with resources (elide_timepoints_scf.mlir)
  
  Examples:
    // Simple timeline op with no dependencies or resources.
    %tp0 = stream.test.timeline_op with() : () -> () => !stream.timepoint
  
    // Timeline op awaiting other timepoints.
    %tp1 = stream.test.timeline_op await(%tp0) => with() : () -> () => !stream.timepoint
  
    // Timeline op with resource operands and results.
    %r, %tp = stream.test.timeline_op
      with(%arg) : (!stream.resource<external>{%size}) -> !stream.resource<external>{%size}
      => !stream.timepoint
  
    // Timeline op with await_limit to test join creation.
    %r, %tp = stream.test.timeline_op await_limit(1) await(%tp0) =>
      with(%arg) : (!stream.resource<external>{%size}) -> !stream.resource<external>{%size}
      => !stream.timepoint
  """

  OPERATION_NAME = "stream.test.timeline_op"

  _ODS_OPERAND_SEGMENTS = [-1,-1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, result_timepoint, resource_operands, resource_operand_sizes, result_sizes, await_operands, *, tied_operands=None, await_limit=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(resource_operands))
    operands.append(_get_op_results_or_values(resource_operand_sizes))
    operands.append(_get_op_results_or_values(result_sizes))
    operands.append(_get_op_results_or_values(await_operands))
    _ods_context = _ods_get_default_loc_context(loc)
    if tied_operands is not None: attributes["tied_operands"] = (tied_operands if (
        isinstance(tied_operands, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Util_TiedOpStorageAttr')) else
          _ods_ir.AttrBuilder.get('Util_TiedOpStorageAttr')(tied_operands, context=_ods_context))
    if await_limit is not None: attributes["await_limit"] = (await_limit if (
        isinstance(await_limit, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(await_limit, context=_ods_context))
    results = []
    results.extend(results_)
    results.append(result_timepoint)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def resource_operands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def resource_operand_sizes(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def result_sizes(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def await_operands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def tied_operands(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tied_operands" not in self.operation.attributes:
      return None
    return self.operation.attributes["tied_operands"]

  @tied_operands.setter
  def tied_operands(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tied_operands"] = value
    elif "tied_operands" in self.operation.attributes:
      del self.operation.attributes["tied_operands"]

  @tied_operands.deleter
  def tied_operands(self):
    del self.operation.attributes["tied_operands"]

  @builtins.property
  def await_limit(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "await_limit" not in self.operation.attributes:
      return None
    return self.operation.attributes["await_limit"]

  @await_limit.setter
  def await_limit(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["await_limit"] = value
    elif "await_limit" in self.operation.attributes:
      del self.operation.attributes["await_limit"]

  @await_limit.deleter
  def await_limit(self):
    del self.operation.attributes["await_limit"]

  @builtins.property
  def results_(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 2 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result_timepoint(self) -> _ods_ir.OpResult:
    _ods_variadic_group_length = len(self.operation.results) - 2 + 1
    return self.operation.results[1 + _ods_variadic_group_length - 1]

def test_timeline_op(results_, result_timepoint, resource_operands, resource_operand_sizes, result_sizes, await_operands, *, tied_operands=None, await_limit=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, TestTimelineOp]:
  op = TestTimelineOp(results_=results_, result_timepoint=result_timepoint, resource_operands=resource_operands, resource_operand_sizes=resource_operand_sizes, result_sizes=result_sizes, await_operands=await_operands, tied_operands=tied_operands, await_limit=await_limit, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class TimepointAwaitOp(_ods_ir.OpView):
  r"""
  After asynchronous execution scheduling resources may exist in different
  states at different points in the execution timeline. This op enables
  resolving the version of a resource after a particular point in the
  timeline. As timepoints transitively chain the timepoint must only cover the
  resource availability but not be limited to its original production
  timepoint.
  """

  OPERATION_NAME = "stream.timepoint.await"

  _ODS_OPERAND_SEGMENTS = [-1,-1,1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, resource_operands, resource_operand_sizes, await_timepoint, *, sync=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(resource_operands))
    operands.append(_get_op_results_or_values(resource_operand_sizes))
    operands.append(await_timepoint)
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(sync): attributes["sync"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results = []
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def resource_operands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def resource_operand_sizes(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def await_timepoint(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0]

  @builtins.property
  def sync(self) -> bool:
    return "sync" in self.operation.attributes

  @sync.setter
  def sync(self, value):
    if bool(value):
      self.operation.attributes["sync"] = _ods_ir.UnitAttr.get()
    elif "sync" in self.operation.attributes:
      del self.operation.attributes["sync"]

  @sync.deleter
  def sync(self):
    del self.operation.attributes["sync"]

  @builtins.property
  def results_(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def timepoint_await(results_, resource_operands, resource_operand_sizes, await_timepoint, *, sync=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, TimepointAwaitOp]:
  op = TimepointAwaitOp(results_=results_, resource_operands=resource_operands, resource_operand_sizes=resource_operand_sizes, await_timepoint=await_timepoint, sync=sync, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class TimepointBarrierOp(_ods_ir.OpView):
  r"""
  After asynchronous execution scheduling resources may exist in different
  states at different points in the execution timeline. This op enables
  identifying when the version of a resource after a particular point in the
  timeline is available. As timepoints transitively chain the timepoint must
  only cover the resource availability but not be limited to its original
  production timepoint.
  """

  OPERATION_NAME = "stream.timepoint.barrier"

  _ODS_REGIONS = (0, True)

  def __init__(self, resource, resource_size, *, affinity=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(resource)
    operands.append(resource_size)
    _ods_context = _ods_get_default_loc_context(loc)
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def resource(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def resource_size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

  @builtins.property
  def result_timepoint(self) -> _ods_ir.OpResult:
    return self.operation.results[1]

def timepoint_barrier(resource, resource_size, *, affinity=None, results=None, loc=None, ip=None) -> _ods_ir.OpResultList:
  return TimepointBarrierOp(resource=resource, resource_size=resource_size, affinity=affinity, results=results, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class TimepointChainExternalOp(_ods_ir.OpView):
  r"""
  Defines a conversion to an external dialect type such as `hal.fence`
  that is resolved during lowering into the stream dialect. This can be used
  to interoperate between levels of the stack that require specifying stream
  types and those that prior to lowering do not handle them.
  """

  OPERATION_NAME = "stream.timepoint.chain_external"

  _ODS_REGIONS = (0, True)

  def __init__(self, await_timepoint, external_values, *, affinity=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(await_timepoint)
    operands.extend(_get_op_results_or_values(external_values))
    _ods_context = _ods_get_default_loc_context(loc)
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def await_timepoint(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def external_values(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

def timepoint_chain_external(await_timepoint, external_values, *, affinity=None, loc=None, ip=None) -> TimepointChainExternalOp:
  return TimepointChainExternalOp(await_timepoint=await_timepoint, external_values=external_values, affinity=affinity, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class TimepointExportOp(_ods_ir.OpView):
  r"""
  Defines a conversion to an external dialect type such as `hal.fence`
  that is resolved during lowering into the stream dialect. This can be used
  to interoperate between levels of the stack that require specifying stream
  types and those that prior to lowering do not handle them.
  """

  OPERATION_NAME = "stream.timepoint.export"

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, await_timepoint, *, affinity=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(await_timepoint)
    _ods_context = _ods_get_default_loc_context(loc)
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    results = []
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def await_timepoint(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def results_(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def timepoint_export(results_, await_timepoint, *, affinity=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, TimepointExportOp]:
  op = TimepointExportOp(results_=results_, await_timepoint=await_timepoint, affinity=affinity, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class TimepointImmediateOp(_ods_ir.OpView):
  r"""
  Timepoints indicate a point in the execution timeline and this op can be
  used to get a placeholder representing the start of the timeline. Any waits
  on the returned timepoint will resolve immediately. This generally folds
  away but can be useful if needing to initialize globals or branch args.
  """

  OPERATION_NAME = "stream.timepoint.immediate"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def result_timepoint(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def timepoint_immediate(*, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return TimepointImmediateOp(results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TimepointImportOp(_ods_ir.OpView):
  r"""
  Defines a conversion from an external dialect type such as `hal.semaphore`
  that is resolved during lowering into the stream dialect. This can be used
  to interoperate between levels of the stack that require specifying stream
  types and those that prior to lowering do not handle them.
  """

  OPERATION_NAME = "stream.timepoint.import"

  _ODS_REGIONS = (0, True)

  def __init__(self, operands_, *, affinity=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def affinity(self) -> _Optional[_ods_ir.Attribute]:
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result_timepoint(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def timepoint_import(operands_, *, affinity=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return TimepointImportOp(operands_=operands_, affinity=affinity, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TimepointJoinOp(_ods_ir.OpView):
  r"""
  Returns a timepoint that indicates that all of the input timepoints have
  been reached.
  """

  OPERATION_NAME = "stream.timepoint.join"

  _ODS_REGIONS = (0, True)

  def __init__(self, await_timepoints, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(await_timepoints))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def await_timepoints(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result_timepoint(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def timepoint_join(await_timepoints, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return TimepointJoinOp(await_timepoints=await_timepoints, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class YieldOp(_ods_ir.OpView):
  r"""
  The values returned represent the asynchronous value at the point in time
  the SSA value is defined (or tied).
  """

  OPERATION_NAME = "stream.yield"

  _ODS_REGIONS = (0, True)

  def __init__(self, resource_operands, resource_operand_sizes, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(resource_operands))
    operands.extend(_get_op_results_or_values(resource_operand_sizes))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def resource_operands(self) -> _ods_ir.OpOperandList:
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 0, 2, 0, 0)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def resource_operand_sizes(self) -> _ods_ir.OpOperandList:
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 0, 2, 0, 1)
    return self.operation.operands[start:start + elements_per_group]

def yield_(resource_operands, resource_operand_sizes, *, loc=None, ip=None) -> YieldOp:
  return YieldOp(resource_operands=resource_operands, resource_operand_sizes=resource_operand_sizes, loc=loc, ip=ip)
