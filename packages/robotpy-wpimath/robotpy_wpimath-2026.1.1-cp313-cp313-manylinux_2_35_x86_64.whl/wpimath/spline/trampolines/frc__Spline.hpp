// This file is autogenerated. DO NOT EDIT

#pragma once
#include <semiwrap.h>

// wrapped header

#include <frc/spline/Spline.h>

// from extra_includes
#include <pybind11/stl.h>

namespace frc {

template <int Degree, typename CfgBase = swgen::EmptyTrampolineCfg>
struct PyTrampolineCfg_Spline : CfgBase
{
  using Base = frc::Spline<Degree>;
  using override_base_KCoefficients_v = frc::Spline<Degree>;
  using override_base_KGetInitialControlVector_v = frc::Spline<Degree>;
  using override_base_KGetFinalControlVector_v = frc::Spline<Degree>;
};

template <typename PyTrampolineBase, int Degree, typename PyTrampolineCfg>
struct PyTrampoline_Spline : PyTrampolineBase {
  using PyTrampolineBase::PyTrampolineBase;
  using ControlVector [[maybe_unused]] = typename frc::Spline<Degree>::ControlVector;
  using PoseWithCurvature [[maybe_unused]] = typename frc::Spline<Degree>::PoseWithCurvature;

  #ifndef SWGEN_DISABLE_KCoefficients_v
    Matrixd<6, Degree+1> Coefficients() const override {
      throw std::runtime_error("not implemented");
    }
  #endif

  #ifndef SWGEN_DISABLE_KGetInitialControlVector_v
    const ControlVector& GetInitialControlVector() const override {
      throw std::runtime_error("not implemented");
    }
  #endif

  #ifndef SWGEN_DISABLE_KGetFinalControlVector_v
    const ControlVector& GetFinalControlVector() const override {
      throw std::runtime_error("not implemented");
    }
  #endif
};

}; // namespace frc

#include <frc_eigen.h>
#include <pybind11/stl.h>
#include <units_compound_type_caster.h>
#include <wpi_array_type_caster.h>

namespace swgen {

using namespace frc;

template <int Degree>
struct bind_frc__Spline {
  using ControlVector [[maybe_unused]] = typename frc::Spline<Degree>::ControlVector;
  using PoseWithCurvature [[maybe_unused]] = typename frc::Spline<Degree>::PoseWithCurvature;
  struct Spline_Trampoline : frc::PyTrampoline_Spline<typename frc::Spline<Degree>, Degree, typename frc::PyTrampolineCfg_Spline<Degree>>, py::trampoline_self_life_support {
      using RpyBase = frc::PyTrampoline_Spline<typename frc::Spline<Degree>, Degree, typename frc::PyTrampolineCfg_Spline<Degree>>;
      using RpyBase::RpyBase;
  };
  static_assert(std::is_abstract<Spline_Trampoline>::value == false, "frc::Spline<Degree> " SEMIWRAP_BAD_TRAMPOLINE);
  py::class_<typename frc::Spline<Degree>, py::smart_holder, Spline_Trampoline> cls_Spline;
  py::class_<typename frc::Spline<Degree>::ControlVector, py::smart_holder> cls_ControlVector;

  py::module &m;
  std::string clsName;
  bind_frc__Spline(py::module &m, const char * clsName) :
    cls_Spline(m, clsName),
    cls_ControlVector(cls_Spline, "ControlVector"),
    m(m),
    clsName(clsName) {
  }

  void finish(const char * set_doc = NULL, const char * add_doc = NULL) {
    cls_Spline.doc() = 
      "Represents a two-dimensional parametric spline that interpolates between two\n"
      "points.\n"
      "\n"
      "@tparam Degree The degree of the spline.";
    cls_Spline.def(py::init<>()
      , release_gil()
    );
    cls_Spline.def("getPoint", &frc::Spline<Degree>::GetPoint
      , py::arg("t")
      , release_gil()
      , py::doc(
      "Gets the pose and curvature at some point t on the spline.\n"
      "\n"
      ":param t: The point t\n"
      "\n"
      ":returns: The pose and curvature at that point.")
    );
    cls_Spline.def("coefficients", &frc::Spline<Degree>::Coefficients
      , release_gil()
      , py::doc(
      "Returns the coefficients of the spline.\n"
      "\n"
      ":returns: The coefficients of the spline.")
    );
    cls_Spline.def("getInitialControlVector", &frc::Spline<Degree>::GetInitialControlVector
      , release_gil()
      , py::doc(
      "Returns the initial control vector that created this spline.\n"
      "\n"
      ":returns: The initial control vector that created this spline.")
    );
    cls_Spline.def("getFinalControlVector", &frc::Spline<Degree>::GetFinalControlVector
      , release_gil()
      , py::doc(
      "Returns the final control vector that created this spline.\n"
      "\n"
      ":returns: The final control vector that created this spline.")
    );
    cls_ControlVector.doc() = 
      "Represents a control vector for a spline.\n"
      "\n"
      "Each element in each array represents the value of the derivative at the\n"
      "index. For example, the value of x[2] is the second derivative in the x\n"
      "dimension.";
    cls_ControlVector.def_readwrite("x", &frc::Spline<Degree>::ControlVector::x, py::doc("The x components of the control vector."));
    cls_ControlVector.def_readwrite("y", &frc::Spline<Degree>::ControlVector::y, py::doc("The y components of the control vector."));
    if (set_doc) {
      cls_Spline.doc() = set_doc;
    }
    if (add_doc) {
      cls_Spline.doc() = py::cast<std::string>(cls_Spline.doc()) + add_doc;
    }

    cls_ControlVector
    .def(
      py::init<
        wpi::array<double, (Degree + 1) / 2>,
        wpi::array<double, (Degree + 1) / 2>>(),
      py::arg("x"),
      py::arg("y")
    );
  }
}; // struct bind_frc__Spline

}; // namespace swgen
