from typing import ClassVar, overload

import pyomo.common.errors

division: ExprType
external_func: ExprType
inf: float
linear: ExprType
named_expr: ExprType
negation: ExprType
numeric_constant: ExprType
param: ExprType
power: ExprType
product: ExprType
py_float: ExprType
sum: ExprType
unary_func: ExprType
var: ExprType

class Constant(ExpressionBase):
    value: float
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: float) -> None: ...

class Constraint:
    active: bool
    lb: ExpressionBase
    name: str
    ub: ExpressionBase
    def __init__(self) -> None: ...

class ExprType:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    division: ClassVar[ExprType] = ...
    external_func: ClassVar[ExprType] = ...
    linear: ClassVar[ExprType] = ...
    named_expr: ClassVar[ExprType] = ...
    negation: ClassVar[ExprType] = ...
    numeric_constant: ClassVar[ExprType] = ...
    param: ClassVar[ExprType] = ...
    power: ClassVar[ExprType] = ...
    product: ClassVar[ExprType] = ...
    py_float: ClassVar[ExprType] = ...
    sum: ClassVar[ExprType] = ...
    unary_func: ClassVar[ExprType] = ...
    var: ClassVar[ExprType] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Expression(ExpressionBase):
    def __init__(self, arg0: int) -> None: ...
    def get_operators(self) -> list[Operator]: ...

class ExpressionBase(Node):
    def __init__(self, *args, **kwargs) -> None: ...
    def evaluate(self) -> float: ...

class FBBTConstraint(Constraint):
    body: ExpressionBase
    def __init__(
        self, arg0: ExpressionBase, arg1: ExpressionBase, arg2: ExpressionBase
    ) -> None: ...
    def perform_fbbt(
        self, arg0: float, arg1: float, arg2: float, arg3: set[Var], arg4: bool
    ) -> None: ...

class FBBTModel(Model):
    def __init__(self) -> None: ...
    def perform_fbbt(self, arg0: float, arg1: float, arg2: float, arg3: int, arg4: bool) -> int: ...
    def perform_fbbt_with_seed(
        self, arg0: Var, arg1: float, arg2: float, arg3: float, arg4: int, arg5: bool
    ) -> int: ...

class FBBTObjective(Objective):
    expr: ExpressionBase
    def __init__(self, arg0: ExpressionBase) -> None: ...

class InfeasibleConstraintException(pyomo.common.errors.InfeasibleConstraintException): ...
class IntervalException(pyomo.common.errors.IntervalException): ...

class LPBase:
    def __init__(self, *args, **kwargs) -> None: ...

class LPConstraint(LPBase, Constraint):
    def __init__(self) -> None: ...

class LPObjective(LPBase, Objective):
    def __init__(self) -> None: ...

class LPWriter(Model):
    def __init__(self) -> None: ...
    def get_solve_cons(self) -> list[LPConstraint]: ...
    def write(self, arg0: str) -> None: ...

class Model:
    constraints: set[Constraint]
    objective: Objective
    def __init__(self) -> None: ...
    def add_constraint(self, arg0: Constraint) -> None: ...
    def remove_constraint(self, arg0: Constraint) -> None: ...

class NLBase:
    def __init__(self, *args, **kwargs) -> None: ...

class NLConstraint(NLBase, Constraint):
    def __init__(
        self,
        arg0: ExpressionBase,
        arg1: list[ExpressionBase],
        arg2: list[Var],
        arg3: ExpressionBase,
    ) -> None: ...

class NLObjective(NLBase, Objective):
    def __init__(
        self,
        arg0: ExpressionBase,
        arg1: list[ExpressionBase],
        arg2: list[Var],
        arg3: ExpressionBase,
    ) -> None: ...

class NLWriter(Model):
    def __init__(self) -> None: ...
    def get_solve_cons(self) -> list[NLConstraint]: ...
    def get_solve_vars(self) -> list[Var]: ...
    def write(self, arg0: str) -> None: ...

class Node:
    def __init__(self, *args, **kwargs) -> None: ...
    def is_constant_type(self) -> bool: ...
    def is_expression_type(self) -> bool: ...
    def is_leaf(self) -> bool: ...
    def is_operator_type(self) -> bool: ...
    def is_param_type(self) -> bool: ...
    def is_variable_type(self) -> bool: ...

class Objective:
    name: str
    sense: int
    def __init__(self) -> None: ...

class Operator(Node):
    def __init__(self, *args, **kwargs) -> None: ...

class Param(ExpressionBase):
    name: str
    value: float
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: float) -> None: ...
    @overload
    def __init__(self, arg0: str, arg1: float) -> None: ...
    @overload
    def __init__(self, arg0: str) -> None: ...

class PyomoExprTypes:
    def __init__(self) -> None: ...

class Var(ExpressionBase):
    domain: Domain
    fixed: bool
    lb: ExpressionBase
    name: str
    ub: ExpressionBase
    value: float
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: float) -> None: ...
    @overload
    def __init__(self, arg0: str, arg1: float) -> None: ...
    @overload
    def __init__(self, arg0: str) -> None: ...
    def get_domain(self) -> Domain: ...
    def get_lb(self) -> float: ...
    def get_ub(self) -> float: ...

def appsi_expr_from_pyomo_expr(
    arg0: object, arg1: object, arg2: object, arg3: PyomoExprTypes
) -> ExpressionBase: ...
def appsi_exprs_from_pyomo_exprs(arg0: list, arg1: dict, arg2: dict) -> list[ExpressionBase]: ...
def create_constants(arg0: int) -> list[Constant]: ...
def create_params(arg0: int) -> list[Param]: ...
def create_vars(arg0: int) -> list[Var]: ...
def prep_for_repn(arg0: object, arg1: PyomoExprTypes) -> tuple: ...
def process_fbbt_constraints(
    arg0: FBBTModel,
    arg1: PyomoExprTypes,
    arg2: list,
    arg3: dict,
    arg4: dict,
    arg5: dict,
    arg6: dict,
    arg7: dict,
) -> None: ...
def process_lp_constraints(arg0: list, arg1: object) -> None: ...
def process_lp_objective(
    arg0: PyomoExprTypes, arg1: object, arg2: dict, arg3: dict
) -> LPObjective: ...
def process_nl_constraints(
    arg0: NLWriter,
    arg1: PyomoExprTypes,
    arg2: list,
    arg3: dict,
    arg4: dict,
    arg5: dict,
    arg6: dict,
    arg7: dict,
) -> None: ...
def process_pyomo_vars(
    arg0: PyomoExprTypes,
    arg1: list,
    arg2: dict,
    arg3: dict,
    arg4: dict,
    arg5: dict,
    arg6: bool,
    arg7: object,
    arg8: object,
    arg9: bool,
) -> None: ...
def py_interval_abs(arg0: float, arg1: float) -> tuple[float, float]: ...
def py_interval_acos(
    arg0: float, arg1: float, arg2: float, arg3: float, arg4: float
) -> tuple[float, float]: ...
def py_interval_add(arg0: float, arg1: float, arg2: float, arg3: float) -> tuple[float, float]: ...
def py_interval_asin(
    arg0: float, arg1: float, arg2: float, arg3: float, arg4: float
) -> tuple[float, float]: ...
def py_interval_atan(arg0: float, arg1: float, arg2: float, arg3: float) -> tuple[float, float]: ...
def py_interval_cos(arg0: float, arg1: float) -> tuple[float, float]: ...
def py_interval_div(
    arg0: float, arg1: float, arg2: float, arg3: float, arg4: float
) -> tuple[float, float]: ...
def py_interval_exp(arg0: float, arg1: float) -> tuple[float, float]: ...
def py_interval_inv(arg0: float, arg1: float, arg2: float) -> tuple[float, float]: ...
def py_interval_log(arg0: float, arg1: float) -> tuple[float, float]: ...
def py_interval_log10(arg0: float, arg1: float) -> tuple[float, float]: ...
def py_interval_mul(arg0: float, arg1: float, arg2: float, arg3: float) -> tuple[float, float]: ...
def py_interval_power(
    arg0: float, arg1: float, arg2: float, arg3: float, arg4: float
) -> tuple[float, float]: ...
def py_interval_sin(arg0: float, arg1: float) -> tuple[float, float]: ...
def py_interval_sub(arg0: float, arg1: float, arg2: float, arg3: float) -> tuple[float, float]: ...
def py_interval_tan(arg0: float, arg1: float) -> tuple[float, float]: ...
