"""Setup script for the openssl-encrypt package."""
import os
import shutil
import subprocess  # nosec B404
import sys
from typing import List

from setuptools import Command, find_packages, setup
from setuptools.command.develop import develop
from setuptools.command.install import install
from setuptools.command.build_py import build_py

# Dependencies are now specified in pyproject.toml

# Required versions for external dependencies
REQUIRED_LIBOQS_VERSION = "0.12.0"
REQUIRED_LIBOQS_PYTHON_VERSION = "0.12.0"


# Read the contents of your README file
this_directory = os.path.abspath(os.path.dirname(__file__))
with open(os.path.join(this_directory, "README.md"), encoding="utf-8") as f:
    long_description = f.read()

VERSION = "1.4.0b8"  # Define version in a variable for reuse

# Get git commit hash
git_hash = "unknown"

# First check if GitLab CI provides the commit SHA
if os.environ.get("CI_COMMIT_SHA"):
    git_hash = os.environ.get("CI_COMMIT_SHA")
# Otherwise try to get it from git directly
else:
    try:
        # subprocess usage is necessary for getting git commit hash during build
        git_hash = (
            subprocess.check_output(
                ["/usr/bin/git", "rev-parse", "HEAD"], cwd=this_directory  # nosec B603 B607
            )
            .decode("ascii")
            .strip()
        )
    except (subprocess.SubprocessError, FileNotFoundError):
        # Keep default "unknown"
        pass

# Generate version.py from template
template_path = os.path.join(this_directory, "openssl_encrypt/version.py.template")
version_path = os.path.join(this_directory, "openssl_encrypt/version.py")

if os.path.exists(template_path):
    with open(template_path, "r") as template_file:
        template_content = template_file.read()

    # Replace placeholders
    content = template_content.replace("${VERSION}", VERSION).replace("${GIT_COMMIT}", git_hash)

    with open(version_path, "w") as version_file:
        version_file.write(content)
else:
    # Fallback if template doesn't exist
    with open(version_path, "w") as f:
        f.write(
            f"""# This file is automatically generated by setup.py
__version__ = "{VERSION}"
__git_commit__ = "{git_hash}"
"""
        )


def check_liboqs_version():
    """Check if liboqs is already installed with correct version"""
    try:
        result = subprocess.run(
            ['pkg-config', '--modversion', 'liboqs'],
            capture_output=True,
            text=True,
            timeout=5
        )
        if result.returncode == 0:
            version = result.stdout.strip()
            if version == REQUIRED_LIBOQS_VERSION:
                print(f"✓ liboqs {version} already installed")
                return True
            else:
                print(f"⚠ Found liboqs {version}, but need {REQUIRED_LIBOQS_VERSION}")
                return False
    except (FileNotFoundError, subprocess.TimeoutExpired):
        pass
    return False


def check_liboqs_python_version():
    """Check if liboqs-python is installed with correct version"""
    try:
        # Import in a subprocess to avoid affecting current process
        result = subprocess.run(
            [sys.executable, '-c',
             'import oqs; print(oqs.oqs_python_version())'],
            capture_output=True,
            text=True,
            timeout=5
        )
        if result.returncode == 0:
            version = result.stdout.strip()
            if version == REQUIRED_LIBOQS_PYTHON_VERSION:
                print(f"✓ liboqs-python {version} already installed")
                return True
            else:
                print(f"⚠ Found liboqs-python {version}, but need {REQUIRED_LIBOQS_PYTHON_VERSION}")
                return False
    except (subprocess.TimeoutExpired, Exception):
        pass
    return False


def build_local_dependencies():
    """Build liboqs and liboqs-python with specific versions"""

    # Always show that we're checking
    print("\n" + "="*60, flush=True)
    print("Checking liboqs dependencies...", flush=True)
    print("="*60, flush=True)

    # Check if already installed
    liboqs_ok = check_liboqs_version()
    liboqs_python_ok = check_liboqs_python_version()

    if liboqs_ok and liboqs_python_ok:
        print("✓ All liboqs dependencies already installed with correct versions", flush=True)
        print("="*60 + "\n", flush=True)
        return True

    print(f"\nBuilding liboqs {REQUIRED_LIBOQS_VERSION} and "
          f"liboqs-python {REQUIRED_LIBOQS_PYTHON_VERSION}...\n")

    install_script = os.path.join(
        this_directory,
        'scripts',
        'build_local_deps.sh'
    )

    if not os.path.exists(install_script):
        print("⚠ Warning: Build script not found at", install_script)
        print(f"Please install manually:")
        print(f"  liboqs {REQUIRED_LIBOQS_VERSION}: https://github.com/open-quantum-safe/liboqs/releases/tag/{REQUIRED_LIBOQS_VERSION}")
        print(f"  liboqs-python {REQUIRED_LIBOQS_PYTHON_VERSION}: pip install git+https://github.com/open-quantum-safe/liboqs-python.git@{REQUIRED_LIBOQS_PYTHON_VERSION}")
        print("="*60 + "\n")
        return False

    try:
        # Set version environment variables
        env = os.environ.copy()
        env['LIBOQS_INSTALL_PREFIX'] = os.path.expanduser('~/.local')
        env['LIBOQS_VERSION'] = REQUIRED_LIBOQS_VERSION
        env['LIBOQS_PYTHON_VERSION'] = REQUIRED_LIBOQS_PYTHON_VERSION

        # Find bash in common locations
        bash_paths = ['/bin/bash', '/usr/bin/bash', '/usr/local/bin/bash']
        bash_cmd = None
        for bash_path in bash_paths:
            if os.path.exists(bash_path):
                bash_cmd = bash_path
                break

        if bash_cmd is None:
            # Try to find bash via PATH
            bash_cmd = shutil.which('bash')

        if bash_cmd is None:
            raise RuntimeError("bash not found - required to run build script")

        # Run build script
        subprocess.check_call([bash_cmd, install_script], env=env)

        # Verify versions after build
        if not check_liboqs_version():
            raise RuntimeError(f"liboqs {REQUIRED_LIBOQS_VERSION} installation failed verification")

        if not check_liboqs_python_version():
            raise RuntimeError(f"liboqs-python {REQUIRED_LIBOQS_PYTHON_VERSION} installation failed verification")

        print("="*60 + "\n")
        return True

    except subprocess.CalledProcessError as e:
        print(f"\n✗ Error: Failed to build dependencies: {e}")
        print(f"\nPlease install manually:")
        print(f"  1. Install build tools: cmake, ninja, git")
        print(f"  2. Build liboqs {REQUIRED_LIBOQS_VERSION}:")
        print(f"     git clone --branch {REQUIRED_LIBOQS_VERSION} https://github.com/open-quantum-safe/liboqs.git")
        print(f"     cd liboqs && mkdir build && cd build")
        print(f"     cmake -GNinja -DCMAKE_INSTALL_PREFIX=$HOME/.local ..")
        print(f"     ninja && ninja install")
        print(f"  3. Install liboqs-python {REQUIRED_LIBOQS_PYTHON_VERSION}:")
        print(f"     pip install git+https://github.com/open-quantum-safe/liboqs-python.git@{REQUIRED_LIBOQS_PYTHON_VERSION}")
        print("="*60 + "\n")
        return False
    except RuntimeError as e:
        print(f"\n✗ Error: {e}")
        print("="*60 + "\n")
        return False
    except Exception as e:
        print(f"\n✗ Unexpected error during dependency build: {e}")
        print("You can install optional dependencies later with:")
        print("  openssl-encrypt install-dependencies")
        print("="*60 + "\n")
        return False


class PostInstallCommand(Command):
    """Custom install command that runs setup_whirlpool after installation."""

    description = "Command to run post install tasks"
    user_options: List[str] = []

    def initialize_options(self):
        """Initialize command options."""
        pass

    def finalize_options(self):
        """Finalize command options."""
        pass

    def run(self):
        """Run the post-install command."""
        try:
            # subprocess usage is necessary for running post-install script
            subprocess.check_call(
                [sys.executable, "-m", "openssl_encrypt.post_install"]  # nosec B603
            )
        except Exception as e:
            print(f"Warning: Failed to run post-install setup: {e}")
            print("You may need to manually install Whirlpool: pip install whirlpool-py311")


setup(
    cmdclass={
        "post_install": PostInstallCommand,
    },
    name="openssl_encrypt",
    version=VERSION,
    # Read requirements from requirements-prod.txt
    install_requires=[
        line.strip()
        for line in open("requirements-prod.txt")
        if line.strip() and not line.startswith("#") and not line.startswith("-")
    ],
    entry_points={
        "console_scripts": [
            "openssl-encrypt=openssl_encrypt.cli:main",
            "whirlpool-setup=openssl_encrypt.modules.setup_whirlpool:setup_whirlpool",
            "openssl-encrypt-check-deps=openssl_encrypt.versions:main",
        ],
    },
    # Read dev requirements from requirements-dev.txt
    extras_require={
        "dev": [
            line.strip()
            for line in open("requirements-dev.txt")
            if line.strip()
            and not line.startswith("#")
            and not line.startswith("-")
            and line.strip()
            not in [
                prod_line.strip()
                for prod_line in open("requirements-prod.txt")
                if prod_line.strip()
                and not prod_line.startswith("#")
                and not prod_line.startswith("-")
            ]
        ],
        "hsm": [
            line.strip()
            for line in open("requirements-hsm.txt")
            if line.strip()
            and not line.startswith("#")
            and not line.startswith("-")
        ],
        "threefish": [
            "openssl-encrypt-threefish>=1.0.0",
        ],
    },
    project_urls={
        "Homepage": "https://github.com/jahlives/openssl_encrypt/tree/releases/1.4.0",
        "Bug Tracker": "https://github.com/jahlives/openssl_encrypt/issues",
        "Documentation": "https://github.com/jahlives/openssl_encrypt/tree/releases/1.4.0/openssl_encrypt/docs",
        "Source Code": "https://github.com/jahlives/openssl_encrypt/tree/releases/1.4.0",
    },
    packages=find_packages(),
    include_package_data=True,
    package_data={"": ["README.md", "scripts/build_local_deps.sh"]},
    author="Tobi",
    author_email="jahlives@gmx.ch",
    license="Hippocratic-3.0",
    description="A package for secure file encryption and decryption based on modern ciphers using heavy-compute-load chaining of hashing and KDF to generate strong encryption password based on users provided password to ensure secure encryption of files",
    long_description=long_description,
    long_description_content_type="text/markdown",
    keywords="encryption, decryption, random-password, secure shredding, security",
    url="https://github.com/jahlives/openssl_encrypt",
    classifiers=[
        "Development Status :: 5 - Production/Stable",
        "Intended Audience :: Developers",
        "Intended Audience :: End Users/Desktop",
        "Intended Audience :: Information Technology",
        "Intended Audience :: System Administrators",
        "Programming Language :: Python :: 3",
        "Programming Language :: Python :: 3.9",
        "Programming Language :: Python :: 3.10",
        "Programming Language :: Python :: 3.11",
        "Programming Language :: Python :: 3.12",
        "Programming Language :: Python :: 3.13",
        "License :: Other/Proprietary License",
        "Topic :: Security",
        "Topic :: Security :: Cryptography",
        "Topic :: Utilities",
        "Operating System :: OS Independent",
    ],
    python_requires=">=3.9",
)
