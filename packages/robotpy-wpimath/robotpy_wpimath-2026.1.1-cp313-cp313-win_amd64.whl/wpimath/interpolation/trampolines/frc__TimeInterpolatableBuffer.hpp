// This file is autogenerated. DO NOT EDIT

#pragma once
#include <semiwrap.h>

// wrapped header

#include <frc/interpolation/TimeInterpolatableBuffer.h>

// from extra_includes
#include <frc/geometry/Pose3d.h>

#include <pybind11\functional.h>
#include <pybind11\stl.h>
#include <units_time_type_caster.h>

namespace swgen {

using namespace frc;

template <typename T>
struct bind_frc__TimeInterpolatableBuffer {
  py::class_<typename frc::TimeInterpolatableBuffer<T>, py::smart_holder> cls_TimeInterpolatableBuffer;

  py::module &m;
  std::string clsName;
  bind_frc__TimeInterpolatableBuffer(py::module &m, const char * clsName) :
    cls_TimeInterpolatableBuffer(m, clsName),
    m(m),
    clsName(clsName) {
  }

  void finish(const char * set_doc = NULL, const char * add_doc = NULL) {
    cls_TimeInterpolatableBuffer.doc() = 
      "The TimeInterpolatableBuffer provides an easy way to estimate past\n"
      "measurements. One application might be in conjunction with the\n"
      "DifferentialDrivePoseEstimator, where knowledge of the robot pose at the time\n"
      "when vision or other global measurement were recorded is necessary, or for\n"
      "recording the past angles of mechanisms as measured by encoders.\n"
      "\n"
      "When sampling this buffer, a user-provided function or wpi::Lerp can be\n"
      "used. For Pose2ds, we use Twists.\n"
      "\n"
      "@tparam T The type stored in this buffer.";
    cls_TimeInterpolatableBuffer.def(py::init<units::second_t, std::function<T (const T&, const T&, double)>>()
      , py::arg("historySize"), py::arg("func").none(false)
      , release_gil()
      , py::doc(
      "Create a new TimeInterpolatableBuffer.\n"
      "\n"
      ":param historySize: The history size of the buffer.\n"
      ":param func:        The function used to interpolate between values.")
    );
    cls_TimeInterpolatableBuffer.def(py::init<units::second_t>()
      , py::arg("historySize")
      , release_gil()
      , py::doc(
      "Create a new TimeInterpolatableBuffer. By default, the interpolation\n"
      "function is wpi::Lerp except for Pose2d, which uses the pose exponential.\n"
      "\n"
      ":param historySize: The history size of the buffer.")
    );
    cls_TimeInterpolatableBuffer.def("addSample", &frc::TimeInterpolatableBuffer<T>::AddSample
      , py::arg("time"), py::arg("sample")
      , release_gil()
      , py::doc(
      "Add a sample to the buffer.\n"
      "\n"
      ":param time:   The timestamp of the sample.\n"
      ":param sample: The sample object.")
    );
    cls_TimeInterpolatableBuffer.def("clear", &frc::TimeInterpolatableBuffer<T>::Clear
      , release_gil()
      , py::doc("Clear all old samples.")
    );
    cls_TimeInterpolatableBuffer.def("sample", &frc::TimeInterpolatableBuffer<T>::Sample
      , py::arg("time")
      , release_gil()
      , py::doc(
      "Sample the buffer at the given time. If the buffer is empty, an empty\n"
      "optional is returned.\n"
      "\n"
      ":param time: The time at which to sample the buffer.")
    );
    cls_TimeInterpolatableBuffer.def("getInternalBuffer", static_cast<std::vector<std::pair<units::second_t, T>>& (frc::TimeInterpolatableBuffer<T>::*)()>(&frc::TimeInterpolatableBuffer<T>::GetInternalBuffer)
      , release_gil()
      , py::doc(
      "Grant access to the internal sample buffer. Used in Pose Estimation to\n"
      "replay odometry inputs stored within this buffer.")
    );
    if (set_doc) {
      cls_TimeInterpolatableBuffer.doc() = set_doc;
    }
    if (add_doc) {
      cls_TimeInterpolatableBuffer.doc() = py::cast<std::string>(cls_TimeInterpolatableBuffer.doc()) + add_doc;
    }
  }
}; // struct bind_frc__TimeInterpolatableBuffer

}; // namespace swgen
