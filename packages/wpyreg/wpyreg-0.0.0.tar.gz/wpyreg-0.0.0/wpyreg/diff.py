import dataclasses
import pickle
import re
import winreg
import typing
import datetime
import enum
import json


def _error_log(msg: str):
    print(f"[ERROR] {msg}")

def _diagnostic_log(msg: str):
    print(f"[DIAGNOSTIC] {msg}")

#SYSYIMP_VALUEDATATYPE_AUTOGENERATED_START
class ValueDataType(enum.Enum):
    # Section name: Predefined
    # These are just winreg constants
    BINARY = enum.auto()
    DWORD = enum.auto()
    DWORD_LITTLE_ENDIAN = enum.auto()
    DWORD_BIG_ENDIAN = enum.auto()
    EXPAND_STRING = enum.auto()
    LINK = enum.auto()
    MULTI_STRING = enum.auto()
    NONE = enum.auto()
    QWORD = enum.auto()
    QWORD_LITTLE_ENDIAN = enum.auto()
    RESOURCE_LIST = enum.auto()
    FULL_RESOURCE_DESCRIPTOR = enum.auto()
    RESOURCE_REQUIREMENTS_LIST = enum.auto()
    STRING = enum.auto()
    # Section name: Harvested
    # These were extracted during development and experimentation. It could be useful as we can reverse engineer some data handling, but it doesn't have to.
    # Nicely undocumented values but present in registry. 
    # These are related to drivers, as they were found under DRIVERS subkeys.
    DRIVER_0x100000 = enum.auto()
    DRIVER_0x200000 = enum.auto()
    DRIVER_0x20001 = enum.auto()
    DRIVER_0x20003 = enum.auto()
    DRIVER_0x20004 = enum.auto()
    DRIVER_0x20007 = enum.auto()
    DRIVER_0x40007 = enum.auto()
    # NEG means negative. 'DeviceMigration' means it was found within path with 'DeviceMigration' in it.
    SMTH_NEG_0xFFF8_DISPLAY_DeviceMigration = enum.auto()
    # NEG means negative. 'DeviceMigration' means it was found within path with 'DeviceMigration' in it. Same as NetworkDriverBackup.
    SMTH_NEG_0xFFF9_AUDIO_USB_NetworkDriverBackup_DeviceMigration = enum.auto()
    SMTH_NEG_0xFFEE_DeviceMigration_NetworkDriverBackup = enum.auto()
    SMTH_NEG_0xFFF7_DeviceMigration_NetworkDriverBackup = enum.auto()
    SMTH_NEG_0xFFFB_DeviceMigration = enum.auto()
    SMTH_NEG_0xFFEF_DeviceMigration_NetworkDriverBackup = enum.auto()
    SMTH_NEG_0xFFFC_DeviceMigration = enum.auto()
    SMTH_NEG_0xEFFD_DeviceMigration_NetworkDriverBackup = enum.auto()
    SMTH_NEG_0xFFFD_DeviceMigration = enum.auto()
    SMTH_NEG_0xDFEE_DeviceMigration_NetworkDriverBackup = enum.auto()
    SMTH_NEG_0xFFE7_NetworkDriverBackup = enum.auto()
    SMTH_NEG_0xEFF9_NetworkDriverBackup = enum.auto()
    # NEG means 'negative'. SMTH means 'something' DeviceMigration means it was found within path with DeviceMigration in it. Same as NetworkBackup
    SMTH_NEG_0xFFF3_DeviceMigration_NetworkDriverBackup = enum.auto()
    SMTH_NEG_0xEF7F_NetworkDriverBackup = enum.auto()
    SMTH_NEG_0xEFF3_NetworkDriverBackup = enum.auto()
    SMTH_NEG_0xFF7E_NetworkDriverBackup = enum.auto()
    SMTH_NEG_0xFFF0_DeviceMigration = enum.auto()
    # Keys found in LOCAL_MACHINE_SCHEMA under some schema definitions links.
    LOCAL_MACHINE_SCHEMA_0x10000001 = enum.auto()
    LOCAL_MACHINE_SCHEMA_0x10000005 = enum.auto()
    LOCAL_MACHINE_SCHEMA_0x10000006 = enum.auto()
    LOCAL_MACHINE_SCHEMA_0x10000008 = enum.auto()
    LOCAL_MACHINE_SCHEMA_0x1000000B = enum.auto()
    LOCAL_MACHINE_SCHEMA_0x1000000C = enum.auto()
    LOCAL_MACHINE_SCHEMA_0x10002005 = enum.auto()
    LOCAL_MACHINE_SCHEMA_0x10002006 = enum.auto()
    LOCAL_MACHINE_SCHEMA_0x1000200C = enum.auto()
    LOCAL_MACHINE_SCHEMA_0x1000A005 = enum.auto()
    LOCAL_MACHINE_SCHEMA_0x1000A006 = enum.auto()
    LOCAL_MACHINE_SCHEMA_0x1000A00C = enum.auto()
    LOCAL_MACHINE_SCHEMA_0x1000C101 = enum.auto()
    LOCAL_MACHINE_SCHEMA_0x1000800C = enum.auto()
    LOCAL_MACHINE_SCHEMA_0x10008101 = enum.auto()
    # When guesses don't work 
    NOT_RECOGNIZED = enum.auto()

    @staticmethod
    def from_native_data_type_int(data_type: int) -> 'ValueDataType':
        match data_type:
            case winreg.REG_BINARY: return ValueDataType.BINARY
            case winreg.REG_DWORD: return ValueDataType.DWORD
            case winreg.REG_DWORD_LITTLE_ENDIAN: return ValueDataType.DWORD_LITTLE_ENDIAN
            case winreg.REG_DWORD_BIG_ENDIAN: return ValueDataType.DWORD_BIG_ENDIAN
            case winreg.REG_EXPAND_SZ: return ValueDataType.EXPAND_STRING
            case winreg.REG_LINK: return ValueDataType.LINK
            case winreg.REG_MULTI_SZ: return ValueDataType.MULTI_STRING
            case winreg.REG_NONE: return ValueDataType.NONE
            case winreg.REG_QWORD: return ValueDataType.QWORD
            case winreg.REG_QWORD_LITTLE_ENDIAN: return ValueDataType.QWORD_LITTLE_ENDIAN
            case winreg.REG_RESOURCE_LIST: return ValueDataType.RESOURCE_LIST
            case winreg.REG_FULL_RESOURCE_DESCRIPTOR: return ValueDataType.FULL_RESOURCE_DESCRIPTOR
            case winreg.REG_RESOURCE_REQUIREMENTS_LIST: return ValueDataType.RESOURCE_REQUIREMENTS_LIST
            case winreg.REG_SZ: return ValueDataType.STRING
            case 0x100000: return ValueDataType.DRIVER_0x100000
            case 0x200000: return ValueDataType.DRIVER_0x200000
            case 0x20001: return ValueDataType.DRIVER_0x20001
            case 0x20003: return ValueDataType.DRIVER_0x20003
            case 0x20004: return ValueDataType.DRIVER_0x20004
            case 0x20007: return ValueDataType.DRIVER_0x20007
            case 0x40007: return ValueDataType.DRIVER_0x40007
            case -0xFFF8: return ValueDataType.SMTH_NEG_0xFFF8_DISPLAY_DeviceMigration
            case -0xFFF9: return ValueDataType.SMTH_NEG_0xFFF9_AUDIO_USB_NetworkDriverBackup_DeviceMigration
            case -0xFFEE: return ValueDataType.SMTH_NEG_0xFFEE_DeviceMigration_NetworkDriverBackup
            case -0xFFF7: return ValueDataType.SMTH_NEG_0xFFF7_DeviceMigration_NetworkDriverBackup
            case -0xFFFB: return ValueDataType.SMTH_NEG_0xFFFB_DeviceMigration
            case -0xFFEF: return ValueDataType.SMTH_NEG_0xFFEF_DeviceMigration_NetworkDriverBackup
            case -0xFFFC: return ValueDataType.SMTH_NEG_0xFFFC_DeviceMigration
            case -0xEFFD: return ValueDataType.SMTH_NEG_0xEFFD_DeviceMigration_NetworkDriverBackup
            case -0xFFFD: return ValueDataType.SMTH_NEG_0xFFFD_DeviceMigration
            case -0xDFEE: return ValueDataType.SMTH_NEG_0xDFEE_DeviceMigration_NetworkDriverBackup
            case -0xFFE7: return ValueDataType.SMTH_NEG_0xFFE7_NetworkDriverBackup
            case -0xEFF9: return ValueDataType.SMTH_NEG_0xEFF9_NetworkDriverBackup
            case -0xFFF3: return ValueDataType.SMTH_NEG_0xFFF3_DeviceMigration_NetworkDriverBackup
            case -0xEF7F: return ValueDataType.SMTH_NEG_0xEF7F_NetworkDriverBackup
            case -0xEFF3: return ValueDataType.SMTH_NEG_0xEFF3_NetworkDriverBackup
            case -0xFF7E: return ValueDataType.SMTH_NEG_0xFF7E_NetworkDriverBackup
            case -0xFFF0: return ValueDataType.SMTH_NEG_0xFFF0_DeviceMigration
            case 0x10000001: return ValueDataType.LOCAL_MACHINE_SCHEMA_0x10000001
            case 0x10000005: return ValueDataType.LOCAL_MACHINE_SCHEMA_0x10000005
            case 0x10000006: return ValueDataType.LOCAL_MACHINE_SCHEMA_0x10000006
            case 0x10000008: return ValueDataType.LOCAL_MACHINE_SCHEMA_0x10000008
            case 0x1000000B: return ValueDataType.LOCAL_MACHINE_SCHEMA_0x1000000B
            case 0x1000000C: return ValueDataType.LOCAL_MACHINE_SCHEMA_0x1000000C
            case 0x10002005: return ValueDataType.LOCAL_MACHINE_SCHEMA_0x10002005
            case 0x10002006: return ValueDataType.LOCAL_MACHINE_SCHEMA_0x10002006
            case 0x1000200C: return ValueDataType.LOCAL_MACHINE_SCHEMA_0x1000200C
            case 0x1000A005: return ValueDataType.LOCAL_MACHINE_SCHEMA_0x1000A005
            case 0x1000A006: return ValueDataType.LOCAL_MACHINE_SCHEMA_0x1000A006
            case 0x1000A00C: return ValueDataType.LOCAL_MACHINE_SCHEMA_0x1000A00C
            case 0x1000C101: return ValueDataType.LOCAL_MACHINE_SCHEMA_0x1000C101
            case 0x1000800C: return ValueDataType.LOCAL_MACHINE_SCHEMA_0x1000800C
            case 0x10008101: return ValueDataType.LOCAL_MACHINE_SCHEMA_0x10008101
        _error_log(f"from_native_data_type_int(): Unknown data_type: {data_type}: 0x{data_type:X}")
        return ValueDataType.NOT_RECOGNIZED

    def __str__(self):
        return self.to_string()

    def __repr__(self):
        return self.to_string()

    def to_string(self) -> str:
        match self:
            case self.BINARY: return "BINARY"
            case self.DWORD: return "DWORD"
            case self.DWORD_LITTLE_ENDIAN: return "DWORD_LITTLE_ENDIAN"
            case self.DWORD_BIG_ENDIAN: return "DWORD_BIG_ENDIAN"
            case self.EXPAND_STRING: return "EXPAND_STRING"
            case self.LINK: return "LINK"
            case self.MULTI_STRING: return "MULTI_STRING"
            case self.NONE: return "NONE"
            case self.QWORD: return "QWORD"
            case self.QWORD_LITTLE_ENDIAN: return "QWORD_LITTLE_ENDIAN"
            case self.RESOURCE_LIST: return "RESOURCE_LIST"
            case self.FULL_RESOURCE_DESCRIPTOR: return "FULL_RESOURCE_DESCRIPTOR"
            case self.RESOURCE_REQUIREMENTS_LIST: return "RESOURCE_REQUIREMENTS_LIST"
            case self.STRING: return "STRING"
            case self.DRIVER_0x100000: return "DRIVER_0x100000"
            case self.DRIVER_0x200000: return "DRIVER_0x200000"
            case self.DRIVER_0x20001: return "DRIVER_0x20001"
            case self.DRIVER_0x20003: return "DRIVER_0x20003"
            case self.DRIVER_0x20004: return "DRIVER_0x20004"
            case self.DRIVER_0x20007: return "DRIVER_0x20007"
            case self.DRIVER_0x40007: return "DRIVER_0x40007"
            case self.SMTH_NEG_0xFFF8_DISPLAY_DeviceMigration: return "SMTH_NEG_0xFFF8_DISPLAY_DeviceMigration"
            case self.SMTH_NEG_0xFFF9_AUDIO_USB_NetworkDriverBackup_DeviceMigration: return "SMTH_NEG_0xFFF9_AUDIO_USB_NetworkDriverBackup_DeviceMigration"
            case self.SMTH_NEG_0xFFEE_DeviceMigration_NetworkDriverBackup: return "SMTH_NEG_0xFFEE_DeviceMigration_NetworkDriverBackup"
            case self.SMTH_NEG_0xFFF7_DeviceMigration_NetworkDriverBackup: return "SMTH_NEG_0xFFF7_DeviceMigration_NetworkDriverBackup"
            case self.SMTH_NEG_0xFFFB_DeviceMigration: return "SMTH_NEG_0xFFFB_DeviceMigration"
            case self.SMTH_NEG_0xFFEF_DeviceMigration_NetworkDriverBackup: return "SMTH_NEG_0xFFEF_DeviceMigration_NetworkDriverBackup"
            case self.SMTH_NEG_0xFFFC_DeviceMigration: return "SMTH_NEG_0xFFFC_DeviceMigration"
            case self.SMTH_NEG_0xEFFD_DeviceMigration_NetworkDriverBackup: return "SMTH_NEG_0xEFFD_DeviceMigration_NetworkDriverBackup"
            case self.SMTH_NEG_0xFFFD_DeviceMigration: return "SMTH_NEG_0xFFFD_DeviceMigration"
            case self.SMTH_NEG_0xDFEE_DeviceMigration_NetworkDriverBackup: return "SMTH_NEG_0xDFEE_DeviceMigration_NetworkDriverBackup"
            case self.SMTH_NEG_0xFFE7_NetworkDriverBackup: return "SMTH_NEG_0xFFE7_NetworkDriverBackup"
            case self.SMTH_NEG_0xEFF9_NetworkDriverBackup: return "SMTH_NEG_0xEFF9_NetworkDriverBackup"
            case self.SMTH_NEG_0xFFF3_DeviceMigration_NetworkDriverBackup: return "SMTH_NEG_0xFFF3_DeviceMigration_NetworkDriverBackup"
            case self.SMTH_NEG_0xEF7F_NetworkDriverBackup: return "SMTH_NEG_0xEF7F_NetworkDriverBackup"
            case self.SMTH_NEG_0xEFF3_NetworkDriverBackup: return "SMTH_NEG_0xEFF3_NetworkDriverBackup"
            case self.SMTH_NEG_0xFF7E_NetworkDriverBackup: return "SMTH_NEG_0xFF7E_NetworkDriverBackup"
            case self.SMTH_NEG_0xFFF0_DeviceMigration: return "SMTH_NEG_0xFFF0_DeviceMigration"
            case self.LOCAL_MACHINE_SCHEMA_0x10000001: return "LOCAL_MACHINE_SCHEMA_0x10000001"
            case self.LOCAL_MACHINE_SCHEMA_0x10000005: return "LOCAL_MACHINE_SCHEMA_0x10000005"
            case self.LOCAL_MACHINE_SCHEMA_0x10000006: return "LOCAL_MACHINE_SCHEMA_0x10000006"
            case self.LOCAL_MACHINE_SCHEMA_0x10000008: return "LOCAL_MACHINE_SCHEMA_0x10000008"
            case self.LOCAL_MACHINE_SCHEMA_0x1000000B: return "LOCAL_MACHINE_SCHEMA_0x1000000B"
            case self.LOCAL_MACHINE_SCHEMA_0x1000000C: return "LOCAL_MACHINE_SCHEMA_0x1000000C"
            case self.LOCAL_MACHINE_SCHEMA_0x10002005: return "LOCAL_MACHINE_SCHEMA_0x10002005"
            case self.LOCAL_MACHINE_SCHEMA_0x10002006: return "LOCAL_MACHINE_SCHEMA_0x10002006"
            case self.LOCAL_MACHINE_SCHEMA_0x1000200C: return "LOCAL_MACHINE_SCHEMA_0x1000200C"
            case self.LOCAL_MACHINE_SCHEMA_0x1000A005: return "LOCAL_MACHINE_SCHEMA_0x1000A005"
            case self.LOCAL_MACHINE_SCHEMA_0x1000A006: return "LOCAL_MACHINE_SCHEMA_0x1000A006"
            case self.LOCAL_MACHINE_SCHEMA_0x1000A00C: return "LOCAL_MACHINE_SCHEMA_0x1000A00C"
            case self.LOCAL_MACHINE_SCHEMA_0x1000C101: return "LOCAL_MACHINE_SCHEMA_0x1000C101"
            case self.LOCAL_MACHINE_SCHEMA_0x1000800C: return "LOCAL_MACHINE_SCHEMA_0x1000800C"
            case self.LOCAL_MACHINE_SCHEMA_0x10008101: return "LOCAL_MACHINE_SCHEMA_0x10008101"
        raise Exception(f"ValueDataType().to_string({self.name}) not recognized")
#SYSYIMP_VALUEDATATYPE_AUTOGENERATED_END

@dataclasses.dataclass
class KeyInfo:
    sub_keys_count: int
    values_count: int
    last_modification_date: datetime.datetime | None

@dataclasses.dataclass
class Value:
    def __init__(self, name: str, type: ValueDataType, value, _native_data_type: int):
        self.name = name
        self.value: bytes | int | str | None = value
        self.type = type
        self._native_data_type = _native_data_type

    def value_string(self) -> str:
        if type(self.value) == bytes:
            return self.value.hex().upper()
        return self.value.__str__()
    
    def to_string(self) -> str:
        return f'KeyValue: {self.name} {self.value_string()} {self.type} {self._native_data_type}'
    
    def to_json_dict(self) -> dict[str, typing.Any]:
        return {
            'name': self.name,
            'value': self.value_string(),
            'type': self.type,
            '_native_data_type': self._native_data_type
        }
    
    def to_json(self) -> str:
        def _json(obj):
            if isinstance(obj, Value):
                return obj.to_json_dict()
            return obj.__str__()
        return json.dumps(self, default=_json, indent=2)
    
    def __str__(self):
        return self.to_string()
    
    def __repr__(self):
        return self.to_string()


class Key:
    def __init__(self, 
        name: str, 
        values: list[Value], 
        parent: 'Key | None',
        last_modification_date: datetime.datetime | None
    ):
        self.name = name
        self.values = values
        self.children: dict[str, 'Key'] = {} 
        self.last_modification_date = last_modification_date
        self._parent = parent

    def full_path(self) -> str:
        names = []
        parent: Key | None = self
        while parent is not None:
            names.append(parent.name)
            parent = parent._parent
        names.reverse()
        path = '/'.join(names)
        return path[1:] if path.startswith('/') else path

    def add_child(self, name: str, node: 'Key'):
        # Apparently registry allows many values with the same name so this will list every exception 
        # It should be like this, bug was reported already
        # buf ifs will stay forever
        if name in self.children:
            _error_log(f"Key '{node.full_path()}' duplicate, as there can be despite documentation saying otherwise. Leaving first saved value")
            return
        # if name in self.children:
        #     raise Exception(f"'{name}' already present in a nodes: '{self.full_path()}' children")
        self.children[name] = node

    def to_string(self) -> str:
        return f'KeyNode: {self.full_path()} | {self.name} ({self.last_modification_date}) ch: {len(self.children)}'
    
    def to_json_dict(self) -> dict[str, typing.Any]:
        return {
            'name': self.name,
            'lmd': self.last_modification_date,
            'values': [value.to_json_dict() for value in self.values],
            'children': list(self.children.values())
        }
    
    def to_json(self):
        def _json(obj):
            if isinstance(obj, Key):
                return obj.to_json_dict()
            return obj.__str__()
        return json.dumps(self, default=_json, indent=2)
    
    def to_pickle(self) -> bytes:
        return pickle.dumps(self, protocol=pickle.HIGHEST_PROTOCOL)
    
    def __str__(self):
        return self.to_string()
    
    def __repr__(self):
        return self.to_string()
    
class RegistryDump:
    def __init__(self, tree: dict[str, Key | Exception]):
        self._tree = tree

    def get_filtered_tree(self) -> dict[str, Key]:
        output: dict[str, Key] = {}
        for key, value in self._tree.items():
            if not isinstance(value, Exception):
                output[key] = value
        return output

    def to_json_dict(self) -> dict[str, dict]:
        json_dict: dict[str, dict] = {} 
        for key, value in self._tree.items():
            if not isinstance(value, Exception):
                json_dict[key] = value.to_json_dict()
        return json_dict

    def to_json(self, indent: int = 2) -> str:
        def _serialize_with_datetime(obj):
            if isinstance(obj, datetime.datetime):
                return obj.__str__()
            if isinstance(obj, ValueDataType):
                return obj.to_string()
            if isinstance(obj, Key):
                return obj.to_json_dict()
            return obj.copy() # Poor mans solution, but I don't have a clue how to do it better
        return json.dumps(self.to_json_dict(), indent=indent, default=_serialize_with_datetime)
    
    def to_pickle(self) -> bytes:
        return pickle.dumps(self, protocol=pickle.HIGHEST_PROTOCOL)
    
def _root_to_string(root: int) -> str:
    match root:
        case winreg.HKEY_CLASSES_ROOT: return "HKEY_CLASSES_ROOT"
        case winreg.HKEY_CURRENT_USER: return "HKEY_CURRENT_USER"
        case winreg.HKEY_LOCAL_MACHINE: return "HKEY_LOCAL_MACHINE"
        case winreg.HKEY_USERS: return "HKEY_USERS"
        case winreg.HKEY_PERFORMANCE_DATA: return "HKEY_PERFORMANCE_DATA"
        case winreg.HKEY_CURRENT_CONFIG: return "HKEY_CURRENT_CONFIG"
        case winreg.HKEY_DYN_DATA: return "HKEY_DYN_DATA"
    raise Exception(f"root_to_string(): Unknown root key: {root}")

def _root_from_string(root: str):
    match root:
        case "HKEY_CLASSES_ROOT": return winreg.HKEY_CLASSES_ROOT
        case "HKEY_CURRENT_USER": return winreg.HKEY_CURRENT_USER
        case "HKEY_LOCAL_MACHINE": return winreg.HKEY_LOCAL_MACHINE
        case "HKEY_USERS": return winreg.HKEY_USERS
        case "HKEY_PERFORMANCE_DATA": return winreg.HKEY_PERFORMANCE_DATA
        case "HKEY_CURRENT_CONFIG": return winreg.HKEY_CURRENT_CONFIG
        case "HKEY_DYN_DATA": return winreg.HKEY_DYN_DATA
    raise Exception(f"_root_from_string(): Unrecognized root string '{root}'")

def _normalize_key_path(path: str):
    path = path.replace('\\', '/')
    path = re.sub('\\/+', '/', path)
    if path.endswith('/'):
        path = path[0:len(path) - 1]
    return path

def _query_key_info(key_type: winreg.HKEYType) -> KeyInfo:
    sub_keys_count, values_count, last_mod_weird_time = winreg.QueryInfoKey(key_type)
    # last_mod_weird_time:
    #     An integer that identifies when the key was last modified (if available)
    #     as 100's of nanoseconds since Jan 1, 1600.
    def _create_datetime() -> datetime.datetime | None:
        if last_mod_weird_time == 0:
            return None
        last_modification_date = datetime.datetime(
            year=1600,
            month=1,
            day=1
        )
        nanos_delta = last_mod_weird_time * 100
        # Python datetime doesn't support nanoseconds so we trim to microseconds
        micros_delta = nanos_delta / 1000
        delta = datetime.timedelta(microseconds=micros_delta)
        last_modification_date += delta
        return last_modification_date
    return KeyInfo(sub_keys_count, values_count, _create_datetime())

def _extract_values(key_info: KeyInfo, key_type: winreg.HKEYType):
    values: list[Value] = []
    for value_index in range(key_info.values_count):
        value_name, value_data, data_type = winreg.EnumValue(key_type, value_index)
        value = Value(
            value_name, 
            ValueDataType.from_native_data_type_int(data_type), 
            value_data, 
            data_type
        )
        values.append(value)
    return values

def _traverse_key_node(
    parent_key_node: Key, 
    parent_key_type: winreg.HKEYType,
    parent_sub_keys_count: int,
    yell_about_access_denied: bool,
    yell_about_data_type_not_recognized: bool
):
    for child_key_index in range(parent_sub_keys_count):
        child_key_name = winreg.EnumKey(parent_key_type, child_key_index)
        try:
            with winreg.OpenKeyEx(parent_key_type, child_key_name) as child_key_type:
                child_key_info = _query_key_info(child_key_type)
                child_key_value = _extract_values(child_key_info, child_key_type)
                child_key_node = Key(
                    child_key_name, 
                    child_key_value,
                    parent_key_node,
                    child_key_info.last_modification_date
                )
                    
                
                # DIAGNOSTICS
                if yell_about_data_type_not_recognized:
                    for value in child_key_node.values:
                        if value.type == ValueDataType.NOT_RECOGNIZED:
                            _diagnostic_log(f"Data not recognized in: {child_key_node.full_path()}/{value.name} | NativeType: 0x{value._native_data_type:X}")
                # DIAGNOSTICS

                _traverse_key_node(
                    child_key_node, 
                    child_key_type,
                    child_key_info.sub_keys_count,
                    yell_about_access_denied,
                    yell_about_data_type_not_recognized
                )
                parent_key_node.add_child(child_key_name, child_key_node)
        except PermissionError:
            if yell_about_access_denied:
                _error_log(f"Access Denied on: {parent_key_node.full_path()}/{child_key_name}")

def dump_key(
    full_key_path: str,
    yell_about_access_denied: bool = False,
    yell_about_data_type_not_recognized: bool = False
) -> Key | Exception | None:
    try:
        normalized_key_path = _normalize_key_path(full_key_path)
        key_path_parts = normalized_key_path.split('/')
        if len(key_path_parts) <= 0:
            raise Exception("Invalid key path")
        root_name = key_path_parts[0]
        root = _root_from_string(root_name)
        last_key_name = key_path_parts[len(key_path_parts) - 1]

        rootless_path = '\\'.join(key_path_parts[1:])
        with winreg.OpenKeyEx(root, rootless_path) as last_key_type:
            last_key_info = _query_key_info(last_key_type)
            last_key_value = _extract_values(last_key_info, last_key_type)
            last_key_node = Key(
                last_key_name, 
                last_key_value,
                None,
                last_key_info.last_modification_date
            )
            _traverse_key_node(
                last_key_node,
                last_key_type,
                last_key_info.sub_keys_count,
                yell_about_access_denied,
                yell_about_data_type_not_recognized
            )
            return last_key_node
    except Exception as e:
        if isinstance(e, OSError):
            if e.winerror == 120: # Root not supported on this system
                return None
            if e.winerror == 6: # Root not present or invalid
                return None
        print(f"Dumping '{full_key_path}' has error. Error stored instead of dump. Message: {e}")
        return e

def dump_registry(
    yell_about_access_denied: bool = False,
    yell_about_data_type_not_recognized: bool = False
) -> RegistryDump:
    roots: typing.Final[list[int]]  = [
        winreg.HKEY_CLASSES_ROOT,
        winreg.HKEY_CURRENT_USER,
        winreg.HKEY_LOCAL_MACHINE,
        winreg.HKEY_USERS,
        winreg.HKEY_PERFORMANCE_DATA,
        winreg.HKEY_CURRENT_CONFIG,
        winreg.HKEY_DYN_DATA,
    ]
    tree: dict[str, Key | Exception] = {}
    for root in roots:
        dump = dump_key(
            _root_to_string(root), 
            yell_about_access_denied, 
            yell_about_data_type_not_recognized
        )
        if dump != None:
            tree[_root_to_string(root)] = dump
    return RegistryDump(tree)
