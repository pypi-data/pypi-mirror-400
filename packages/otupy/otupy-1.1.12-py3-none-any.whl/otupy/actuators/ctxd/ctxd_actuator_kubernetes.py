""" Kubernetes Actuator Manager

	This module implements a simple Actuator Manager for Kubernetes.
	It discovers Kubernetes resources by invoking its APIs. 


	The actuator-specific configuration includes:
		
		- ``auth``:

			- ``api_key``: A token generated by the Kubernetes cluster for the service account used for context discovery.
			- ``host``: DNS name or IP address of the Kubernetes endpoint (including port number)

		- ``config``:
		
			- ``cacert``: Location of the CA certificate used to sign the endpoint HTTPS certificate (if not installed in the local host).
 			- ``namespaces``: list of namespace names to query (all namespace if not given).

"""

import socket
import subprocess
import json
import os
import logging
import sys

from otupy.profiles import slpf
from otupy.profiles.ctxd.data.application import Application
from otupy.types.data.ipv4_addr import IPv4Addr

from kubernetes import config, client
from kubernetes.client.rest import ApiException

from otupy.actuators.ctxd.ctxd_actuator import CTXDActuator
from otupy.profiles.ctxd.data.cloud import Cloud
from otupy.profiles.ctxd.data.consumer import Consumer
from otupy.profiles.ctxd.data.container import Container
from otupy.profiles.ctxd.data.pod import Pod
from otupy.profiles.ctxd.data.port import Port
from otupy.profiles.ctxd.data.computer import Computer
from otupy.profiles.ctxd.data.link_type import LinkType
from otupy.profiles.ctxd.data.network import Network
from otupy.profiles.ctxd.data.network_type import NetworkType
from otupy.profiles.ctxd.data.os import OS
from otupy.profiles.ctxd.data.peer import Peer
from otupy.profiles.ctxd.data.peer_role import PeerRole
from otupy.profiles.ctxd.data.server import Server
from otupy.profiles.ctxd.data.service_type import ServiceType
from otupy.profiles.ctxd.data.vm import VM
from otupy.types.data.hostname import Hostname
from otupy.types.data.l4_protocol import L4Protocol



from otupy import ArrayOf, Nsid, Version,Actions, Response, StatusCode, StatusCodeDescription, Features, ResponseType, Feature, actuator_implementation
import otupy.profiles.ctxd as ctxd

from otupy.profiles.ctxd.data.name import Name
from otupy.profiles.ctxd.data.service import Service
from otupy.profiles.ctxd.data.link import Link

logger = logging.getLogger(__name__)


@actuator_implementation("ctxd-kubernetes")
class CTXDActuator_kubernetes(CTXDActuator):
	""" Kubernetes Actuator Manager

		Extend the base `CTDXActuator` to retrieve services and links for a Kubernetes cluster. Currently discovery is mostly limited to pods,
		nodes, and containers. It should be extended in future releases with additional resources (e.g., services and file systems).

	"""

	namespace = [] #it contains only the name of the namespaces
	""" Namespaces list"""
	api_client : any = None #api client for kubernetes
	config_file : any = None #configuration file path
	kube_context : any = None #kubernetes context

	def __init__(self, auth, **kwargs):
		""" Initialization

			The necessary parameters are:
			- auth: Authentication information to connect to a Kubernetes cluster
			Optional parameters:
			- namespaces: List of namespaces which resources are to be discovered. If not provided, resources from all namespaces will be discovered.
		"""
		kwargs['auth']=auth
		super().__init__(**kwargs)

		try:
			self.namespaces = kwargs['config']['namespaces']
		except:
			self.namespaces = None

		self._connect_to_kubernetes()


	def discover_services(self):
		""" Discovers K8S services

			Implements the required method to discover services. Currently it discover:
			- K8S base services (e.g., dns)
			- Pods in selected namespaces
			- Nodes
			- Namespaces available
		"""
		self._discover_k8s_services()
		self._discover_k8s_pods()
		self._discover_k8s_namespaces()		
		self._discover_k8s_nodes()
		# TODO: Discover:
		# - networks
		# - images

	def discover_links(self):
		""" Automatically discover links between Kubernetes components

			The current implementation discovers links between:
			- Kubernetes and nodes
			- Kubernetes  and pods 
			- Pods and containers
			- Network Policy firewall and pods
		"""
		self._discover_k8s_links_nodes()
		self._discover_k8s_links_pods()
		self._discover_pod_links_nodes()
		self._discover_k8s_links_np()
		self._discover_np_links_pods()
		pass


	def _discover_k8s_namespaces(self):
		namespaces = self._k8s_namespaces_list()

		# There might be a null configuration
		if namespaces is []:
			return

		# WARNING: Namespaces are not converted to services so far!!!


	def _k8s_namespaces_list(self):
		namespace_list = []
		namespace_list = self.api_client.list_namespace(field_selector="status.phase=Active").items

		if self.namespaces is None: # Retrieve all namespaces
			return namespace_list
		else:
			return [ ns for ns in namespace_list if ns.metadata.name in self.namespaces ]

		

	def _discover_k8s_services(self):
		""" Discover Kubernetes services 

			Currently a single service is returned, but additional subservices can be returned in the future for network
			and other components
		"""
		cloud_services = self._k8s_service_list(namespaces=['kube-system'])

		# The root service: K8S system
		# --------------------------------------------------
		# K8S is considered PaaS when managed by an external service provider
		k8s = Cloud(description='Kubernetes cloud', id=None, name='kubernetes', type='IaaS')
		# TODO: Fill in with k8s version/release
		# Subservices should be kube-adm and kubelets
		self.services.append(Service(name=Name(k8s.name),type=ServiceType(k8s), #links=ArrayOf(Name)(),
				subservices=ArrayOf(Name)(), owner=self.owner, release=None))

		# Services of openstack
		# ---------------------------------
		for service in cloud_services:
			# I couldn't find a "description" field in the service data
			app = (Application(description=service.spec.type, name=service.metadata.name,
						id=service.metadata.uid, owner=self.owner, app_type='service'))
			logger.debug("Found application: %s", str(app.name))
			# TODO: Add software release (maybe with its SBOM)
			name=Name(app.name)
			self.services.append(Service(name=name, type=ServiceType(app), #links=ArrayOf(Link)(),
						subservices=ArrayOf(Service)(), owner=self.owner, release=None))
			# Paranoid check nobody modified the order of the instraction
			assert  str(self.services[0].name) == k8s.name , "Wrong position of parent openstack service in array!"
			self.services[0].subservices.append(name)

	def _k8s_service_list(self, namespaces=None):
		""" Discover k8s services in the given namespace

			:param namespace: the namespace name
		"""
		service_list=[]
		if namespaces is None:
			service_list+= self.api_client.list_service_for_all_namespaces().items 
		else:
			for n in namespaces:
				service_list+= self.api_client.list_service_for_all_namespaces(field_selector='metadata.namespace='+n).items 
		
		return service_list	
	
	def _k8s_pod_node(self, pod):
		nodes = self.api_client.list_pod_for_all_namespaces(field_selector="metadata.name="+pod.name+",metadata.namespace="+pod.namespace)
#nodes = self.api_client.list_pod_for_all_namespaces(field_selector="metadata.name="+pod+", metadata.namespace=default")
		for n in nodes.items:
			# Just one item will be present because the pod name is unique in the same namespace
			return n.spec.node_name
			

	def _discover_pod_links_nodes(self):
		""" Add links between pods and nodes where they are hosted 
		"""

		k8s_pods = self.get_services(filter=Pod)
		k8s_nodes = self.get_services(filter=Computer)

		for p in k8s_pods:
			node = self._k8s_pod_node(p.type.getObj())
			consumer=self.get_consumer(Name(node))
			peer = Peer(service_name=Name(node),
						role=PeerRole.host, # Node hosts pods
						consumer=consumer)
			description="Pod "+p.name.getObj()+" hosted on "+node
			self.links.append(Link(name=p.name, description=description,
						link_type=LinkType.hosting, peers=ArrayOf(Peer)([peer])))

	def _discover_k8s_links_nodes(self):
		""" Discover K8S links to nodes

			Kube-api is hosted on master
			Kubelets are hosted on slaves(/master)
			
			For now, a simplification is used and only Kubernetes hosted on master is reported
		"""

		k8s_service = self.get_services(name=Name('kubernetes'),filter=Cloud)

		master = self._k8s_node_list(label_selector="node-role.kubernetes.io/control-plane")
		k8s_nodes = self.get_services(name=Name(master[0].metadata.name), filter=Computer)

		for k in k8s_service:
			for n in k8s_nodes:
					consumer=self.get_consumer(n.name)
					peer = Peer(service_name=n.name,
								role=PeerRole.host, # K8S is hosted on master node
								consumer=consumer)
					description="Kubernetes hosted on "+n.name.getObj()
					self.links.append(Link(name=k.name, description=description,
								link_type=LinkType.hosting, peers=ArrayOf(Peer)([peer])))


			


	def _discover_k8s_links_pods(self):
		""" Discover K8S links to pods

			This is an oversimplification: indeed, kude-admin (hosted on master) controls kubelets (hosted on slaves),
			and kubelets controls pods. The first relationship should be build by _discover_k8s_links_nodes().
		"""

		k8s_service = self.get_services(name=Name('kubernetes'),filter=Cloud)
		k8s_pods = self.get_services(filter=Pod)

		for s in k8s_service:
			for p in k8s_pods:
				peer = Peer(service_name=p.name,
							role=PeerRole.controlled, # Kubernetes controls its pods
							consumer=None)
				description="Kubernetes controls pod "+p.name.getObj()
				self.links.append(Link(name=s.name, description=description,
							link_type=LinkType.control, peers=ArrayOf(Peer)([peer])))



	def _discover_k8s_nodes(self):
		""" Discover kubernetes working nodes

			Nodes are the physical servers/vms that host pods. It is questionable if such service 
			should be reported, since the Computer subsystem should have its own actuator describing 
			the full stack of services/software hosted.
		"""
		nodes = self._k8s_node_list()

		for n in nodes:
			node = Computer(hostname=Hostname(n.metadata.name), id=n.metadata.uid,
						description="Kubernetes node",
                  os= OS(family=n.status.node_info.operating_system, name=n.status.node_info.os_image))
			logger.debug("Found node: %s", str(node))

			self.services.append(Service(name=Name(str(n.metadata.name)), type=ServiceType(node), #links=ArrayOf(Name)(),
						subservices=None, owner=self.owner, release=n.metadata.resource_version))

	def _k8s_node_list(self, field_selector=None, label_selector=None):
		return self.api_client.list_node(field_selector=field_selector, label_selector=label_selector).items
	
	def _discover_k8s_links_np(self):
		""" Add link between Kubernetes and Network Policies

			Network Policies implement sort of a slpf firewall, hence they are a security function. However, they are not
			standalone software, and they are implemented by kubernetes..
		"""
		k8s_service = self.get_services(name=Name('kubernetes'),filter=Cloud)

		for s in k8s_service:
			consumer = self.get_consumer(Name("kubernetes-networkpolicies"))
			peer = Peer(service_name=Name("kubernetes-networkpolicies"),
							role=PeerRole.controlled, # Kubernetes controls its Network Policies (indeed, they are controlled by a CNI)
							consumer=consumer)
			description="Kubernetes Network Policies"
			self.links.append(Link(name=s.name, description=description,
							link_type=LinkType.control, peers=ArrayOf(Peer)([peer])))

 
	
	def _discover_k8s_pods(self):
		""" Discovers pods

			Discovers pods and describes them including network interfaces and hosted containers.
		"""
			
		pods = self._k8s_pod_list()

		for pod in pods:
			# pod.status.pod_ip and pod.status.pod_i_ps return wrong values (host ip) and
			# do not include multus networks
			if pod.metadata.annotations is not None and 'k8s.v1.cni.cncf.io/network-status' in pod.metadata.annotations:
				ports = json.loads(pod.metadata.annotations['k8s.v1.cni.cncf.io/network-status'])
				port_list = []
				for p in ports:
					name = p['name'] if 'name' in p else None
					iface = p['iface'] if 'iface' in p else None
					ips = []
					if 'ips' in p:
						for ip in p['ips']:
							ips.append(ip)
					port_list.append( Port(id=name, description="Pod network interfaces",  iface=iface, addresses=ips) )
			pod_type = Pod(description="Kubernetes pod", id=pod.metadata.uid,
				  name=Hostname(pod.metadata.name), namespace=pod.metadata.namespace, ports=port_list)	

			# Get the Containers (init and main) used by this pod
			def _get_container_status(c):
				state='unknown'
				if c.state.running is not None:
					state='running'
				if c.state.waiting is not None:
					state='waiting'
				if c.state.terminated is not None:
					state='terminated'
				return state

			def _get_container_list(containers, description=None):
				container_list = []
				try:
					for c in containers:
						state=_get_container_status(c)
						container_list.append( Container(name=c.name, id=c.container_id, 
								description=description, image=c.image, status=state))
				except:	# no containers
					pass
				return container_list


			container_list = _get_container_list(pod.status.container_statuses, "Kubernetes container") + _get_container_list(pod.status.init_container_statuses, "Kubernetes init container")

			# Create services for each container
			container_name_list = ArrayOf(Name)()
			for c in container_list:
				self.services.append(Service(name=Name(c.name), type=ServiceType(c), 
                  subservices=None, owner=self.owner, release=None))
				container_name_list.append(Name(c.name))

			# Create the pod service with containers as subservices 
			self.services.append(Service(name= Name(pod.metadata.name), 
						type=ServiceType(pod_type), #links= ArrayOf(Name)([]),
                  subservices=container_name_list, owner=self.owner, release=pod.metadata.resource_version))


	def _k8s_pod_list(self):
		""" Retrieve the list of pods from the K8S API. """
		array_container = ArrayOf(Service)()

		if self.namespaces is None:
			return self.api_client.list_pod_for_all_namespaces().items
	
		pods = []
		for ns in self.namespaces:
			pods += self.api_client.list_pod_for_all_namespaces(field_selector="metadata.namespace="+ns).items 

		return pods



	def _discover_np_links_pods(self):
		""" Add links from Network Policies to pods

			Automatically add a link from Network Policies to pods
			Network policies are modelled as a security function implemented by an external actuator.
			They protect all pods hosted in Kubernetes..
		"""
		# TODO
		pass

# Old implementation, kept only as reference.
#	def get_namespace_service(self, namespace_name):
#		#process = subprocess.Popen('kubectl get namespace '  + namespace_name + ' -o json', shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
#		#stdout, stderr = process.communicate()
#		namespace = self.api_client.read_namespace(name=str(namespace_name))
#        
#		namespace_network = Network(description='network',
#                                      name=Name(namespace.metadata.name),
#                                      type=NetworkType('wan'))
#        
#		namespace_service = Service(name=Name(namespace.metadata.name),
#                                      type=ServiceType(namespace_network),
#                                      links= ArrayOf(Name)(),
#                                      subservices=None,
#                                      owner=None,
#                                      release=None,
#                                      security_functions=None,
#                                      actuator=None)
#        
#	
#		return ArrayOf(Service)([namespace_service])
	
	def _connect_to_kubernetes(self):
		""" Connects to Kubernetes

			Use the available configuration to carry out authentication to a Kubernetes cluster.
		"""
			
		# The config module loads configuration from .kube (or provided file) into the _default member of the client.Configuration
		# class (which is a class member!). After invoking one of the config method to load these values, the client module
		# has access to such configuration through the Configuration. Note that certificates provided as values in the 
		# configuration file are then stored as files by the Configuration class.

		try:
			configuration = client.Configuration()
			# Configure API key authorization: BearerToken
			configuration.api_key['authorization'] = self.auth['api_key']
			# Uncomment below to setup prefix (e.g. Bearer) for API key, if needed
			configuration.api_key_prefix['authorization'] = 'Bearer'
			# Defining host is optional and default to http://localhost
			configuration.host = self.auth['host']
			# Set the cluster CA	certificate or disable certificate validation
			if self.config is not None and 'cacert' in self.config:
				configuration.ssl_ca_cert=self.config['cacert']
			else:
				configuration.verify_ssl=False
	
			# Create an API client
			self.api_client = client.CoreV1Api(client.ApiClient(configuration))
		except Exception as e:
			logger.error("Failed to connect to kubernetes: ", e)
			return Exception("Failed to connect to kubernetes")
		
