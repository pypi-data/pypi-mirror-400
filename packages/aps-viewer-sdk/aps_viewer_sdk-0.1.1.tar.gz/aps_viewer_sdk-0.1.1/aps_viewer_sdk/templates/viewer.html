<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>APS Viewer with View Selector</title>
  <link rel="stylesheet" href="https://developer.api.autodesk.com/modelderivative/v2/viewers/7.*/style.min.css" type="text/css">
  <script src="https://developer.api.autodesk.com/modelderivative/v2/viewers/7.*/viewer3D.min.js"></script>
  <style>
    html, body, #apsViewerDiv { width: 100%; height: 100%; margin: 0; }
    #viewSelector {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 100;
      background: rgba(255, 255, 255, 0.95);
      padding: 8px 12px;
      border-radius: 6px;
      font: 13px/1.4 system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      border: 1px solid #e0e0e0;
    }
    #viewSelector label {
      color: #1a73e8;
      margin-right: 8px;
      font-weight: 600;
    }
    #viewDropdown {
      padding: 6px 10px;
      border: 1px solid #d0d0d0;
      border-radius: 4px;
      background: #fff;
      color: #333;
      font-size: 13px;
      min-width: 200px;
      cursor: pointer;
    }
    #viewDropdown:hover { border-color: #1a73e8; }
    #viewDropdown:focus {
      outline: none;
      border-color: #1a73e8;
      box-shadow: 0 0 0 2px rgba(26, 115, 232, 0.2);
    }
  </style>

  <!-- Injected inline plugin JS (registerExtension calls) -->
  PLUGINS_JS_PLACEHOLDER
</head>
<body>
  <div id="apsViewerDiv"></div>
  <div id="viewSelector">
    <label for="viewDropdown">View:</label>
    <select id="viewDropdown">
      <option value="">Loading views...</option>
    </select>
  </div>

  <script>
  // Injected configuration from backend (UNCHANGED NAMES)
  var EXTERNAL_IDS = EXTERNAL_IDS_PLACEHOLDER;
  var ACCESS_TOKEN = 'APS_TOKEN_PLACEHOLDER';
  var DOCUMENT_URN = 'urn:URN_PLACEHOLDER';
  var VIEWABLES = VIEWABLES_PLACEHOLDER;
  var SELECTED_VIEW_GUID = 'SELECTED_VIEW_GUID_PLACEHOLDER';

  // Injected plugins list (each item: { extensionId, only2d, options })
  var PLUGINS = PLUGINS_PLACEHOLDER;

  function clamp01(x) { return Math.max(0, Math.min(1, x)); }

  function colorStringToVec4(str, alphaDefault, THREE_REF) {
    let a = typeof alphaDefault === 'number' ? alphaDefault : 0.85;
    if (!str) return new THREE_REF.Vector4(0, 1, 0, a);

    let s = String(str).trim().toLowerCase();

    let m = s.match(/^rgba?\s*\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})(?:\s*,\s*([0-9]*\.?[0-9]+))?\s*\)$/i);
    if (m) {
      const r = clamp01(parseInt(m[1], 10) / 255);
      const g = clamp01(parseInt(m[2], 10) / 255);
      const b = clamp01(parseInt(m[3], 10) / 255);
      a = m[4] != null ? clamp01(parseFloat(m[4])) : a;
      return new THREE_REF.Vector4(r, g, b, a);
    }

    if (s.startsWith('#') && s.length === 7) {
      const r = clamp01(parseInt(s.slice(1, 3), 16) / 255);
      const g = clamp01(parseInt(s.slice(3, 5), 16) / 255);
      const b = clamp01(parseInt(s.slice(5, 7), 16) / 255);
      return new THREE_REF.Vector4(r, g, b, a);
    }

    if (s.startsWith('0x') && s.length === 8) {
      const val = parseInt(s, 16);
      const r = clamp01(((val >> 16) & 0xff) / 255);
      const g = clamp01(((val >> 8) & 0xff) / 255);
      const b = clamp01((val & 0xff) / 255);
      return new THREE_REF.Vector4(r, g, b, a);
    }

    return new THREE_REF.Vector4(0, 1, 0, a);
  }

  function buildExternalColorMap(list) {
    const map = Object.create(null);
    if (!Array.isArray(list)) return map;
    for (let i = 0; i < list.length; i++) {
      const obj = list[i];
      if (obj && typeof obj === 'object') {
        const keys = Object.keys(obj);
        if (keys.length === 1) {
          const extId = String(keys[0]);
          const color = String(obj[extId] || '').trim();
          if (extId && color) map[extId] = color;
        }
      }
    }
    return map;
  }

  try { Autodesk.Viewing.Private.analytics.optOut(); } catch (e) { /* ignore */ }

  let viewer = null;
  let loadedDocument = null;
  let modelLoaded = null;

  function isCurrentModel2D() {
    return !!(viewer && viewer.model && typeof viewer.model.is2d === 'function' && viewer.model.is2d());
  }

  async function syncPlugins() {
    if (!viewer || !Array.isArray(PLUGINS)) return;

    const in2d = isCurrentModel2D();

    for (let i = 0; i < PLUGINS.length; i++) {
      const p = PLUGINS[i];
      if (!p || !p.extensionId) continue;

      const shouldLoad = p.only2d ? in2d : true;
      const loaded = !!viewer.getExtension(p.extensionId);

      if (shouldLoad && !loaded) {
        try {
          await viewer.loadExtension(p.extensionId, p.options || {});
        } catch (e) {
          console.error('[Plugins] loadExtension failed:', p.extensionId, e);
        }
      } else if (!shouldLoad && loaded) {
        try {
          viewer.unloadExtension(p.extensionId);
        } catch (e) {
          console.error('[Plugins] unloadExtension failed:', p.extensionId, e);
        }
      }
    }
  }

  function populateViewDropdown() {
    const dropdown = document.getElementById('viewDropdown');
    dropdown.innerHTML = '';

    const defaultOption = document.createElement('option');
    defaultOption.value = '';
    defaultOption.textContent = 'Default View';
    defaultOption.selected = true;
    dropdown.appendChild(defaultOption);

    if (Array.isArray(VIEWABLES) && VIEWABLES.length > 0) {
      VIEWABLES.forEach(function(viewable) {
        const option = document.createElement('option');
        option.value = viewable.guid;
        option.textContent = viewable.name + ' (' + viewable.role + ')';
        dropdown.appendChild(option);
      });
    } else {
      const fallback = document.createElement('option');
      fallback.value = '';
      fallback.textContent = 'No additional views available';
      dropdown.appendChild(fallback);
    }
  }

  function applyExternalIdIsolationAndColoring() {
    if (!viewer || !modelLoaded) return;

    modelLoaded.getExternalIdMapping(
      function onMap(map) {
        if (!map) {
          console.warn('[Filter] externalId map not available');
          return;
        }

        const extColorMap = buildExternalColorMap(EXTERNAL_IDS);
        const dbIds = [];
        const rev = {};

        for (const extId in map) {
          if (Object.prototype.hasOwnProperty.call(map, extId)) {
            rev[map[extId]] = extId;
          }
        }

        for (const extId in extColorMap) {
          if (map[extId]) dbIds.push(map[extId]);
        }

        if (dbIds.length === 0) {
          console.info('No dbIds match EXTERNAL_IDS');
          return;
        }

        viewer.clearThemingColors();
        viewer.isolate(dbIds);
        viewer.fitToView(dbIds);

        const THREE_REF = (Autodesk && Autodesk.Viewing && Autodesk.Viewing.Private && Autodesk.Viewing.Private.THREE) || window.THREE;
        const defaultV4 = colorStringToVec4(null, 0.85, THREE_REF);

        for (let i = 0; i < dbIds.length; i++) {
          viewer.setThemingColor(dbIds[i], defaultV4, modelLoaded, false);
        }

        for (let i = 0; i < dbIds.length; i++) {
          const dbId = dbIds[i];
          const ext = rev[dbId];
          if (ext && extColorMap[ext]) {
            const v4 = colorStringToVec4(extColorMap[ext], 0.95, THREE_REF);
            viewer.setThemingColor(dbId, v4, modelLoaded, false);
          }
        }

        viewer.impl.invalidate(true, true, true);
      },
      function onErr(err) {
        console.error('[Filter] getExternalIdMapping failed', err);
      }
    );
  }

  function loadViewByGuid(guid) {
    if (!viewer || !loadedDocument) return;

    const root = loadedDocument.getRoot();
    let node = null;

    if (guid) node = root.findByGuid(guid);
    if (!node) node = root.getDefaultGeometry();

    if (!node) {
      console.warn('No viewable geometry found.');
      return;
    }

    viewer.loadDocumentNode(loadedDocument, node, { keepCurrentModels: false })
      .then(function(model) {
        modelLoaded = model;
        applyExternalIdIsolationAndColoring();
        syncPlugins();
        console.log('View loaded successfully:', guid || 'default');
      })
      .catch(function(e) {
        console.error('Error loading view:', e);
      });
  }

  Autodesk.Viewing.Initializer(
    { env: 'AutodeskProduction2', api: 'streamingV2', accessToken: ACCESS_TOKEN },
    function () {
      const container = document.getElementById('apsViewerDiv');
      viewer = new Autodesk.Viewing.GuiViewer3D(container, { disableBimWalkInfoIcon: true });
      viewer.start();

      viewer.addEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, function () {
        syncPlugins();
      });

      if (!DOCUMENT_URN) {
        console.error('Missing URN, provide it via window.DOCUMENT_URN or the urn query param');
        return;
      }

      Autodesk.Viewing.Document.load(
        DOCUMENT_URN,
        function onSuccess(doc) {
          loadedDocument = doc;
          populateViewDropdown();

          if (SELECTED_VIEW_GUID) {
            document.getElementById('viewDropdown').value = SELECTED_VIEW_GUID;
          }

          loadViewByGuid(SELECTED_VIEW_GUID || '');

          document.getElementById('viewDropdown').addEventListener('change', function(e) {
            loadViewByGuid(e.target.value);
          });
        },
        function onFailure(code, message) {
          console.error('Document load failed:', code, message);
        }
      );
    }
  );

  </script>
</body>
</html>
