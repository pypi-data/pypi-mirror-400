"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .activitiesresponsedto import ActivitiesResponseDto, ActivitiesResponseDtoTypedDict
from .channeltypeenum import ChannelTypeEnum
from novu_py.types import BaseModel
from novu_py.utils import FieldMetadata, HeaderMetadata, QueryParamMetadata
import pydantic
from typing import Dict, List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class NotificationsControllerListNotificationsRequestTypedDict(TypedDict):
    channels: NotRequired[List[ChannelTypeEnum]]
    r"""Array of channel types"""
    templates: NotRequired[List[str]]
    r"""Array of template IDs or a single template ID"""
    emails: NotRequired[List[str]]
    r"""Array of email addresses or a single email address"""
    search: NotRequired[str]
    r"""Search term (deprecated)"""
    subscriber_ids: NotRequired[List[str]]
    r"""Array of subscriber IDs or a single subscriber ID"""
    severity: NotRequired[List[str]]
    r"""Array of severity levels or a single severity level"""
    page: NotRequired[float]
    r"""Page number for pagination"""
    limit: NotRequired[float]
    r"""Limit for pagination"""
    transaction_id: NotRequired[str]
    r"""The transaction ID to filter by"""
    topic_key: NotRequired[str]
    r"""Topic Key for filtering notifications by topic"""
    subscription_id: NotRequired[str]
    r"""Subscription ID for filtering notifications by subscription"""
    context_keys: NotRequired[List[str]]
    r"""Filter by exact context keys, order insensitive (format: \"type:id\")"""
    after: NotRequired[str]
    r"""Date filter for records after this timestamp. Defaults to earliest date allowed by subscription plan"""
    before: NotRequired[str]
    r"""Date filter for records before this timestamp. Defaults to current time of request (now)"""
    idempotency_key: NotRequired[str]
    r"""A header for idempotency purposes"""


class NotificationsControllerListNotificationsRequest(BaseModel):
    channels: Annotated[
        Optional[List[ChannelTypeEnum]],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Array of channel types"""

    templates: Annotated[
        Optional[List[str]],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Array of template IDs or a single template ID"""

    emails: Annotated[
        Optional[List[str]],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Array of email addresses or a single email address"""

    search: Annotated[
        Optional[str],
        pydantic.Field(
            deprecated="warning: ** DEPRECATED ** - This will be removed in a future release, please migrate away from it as soon as possible."
        ),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Search term (deprecated)"""

    subscriber_ids: Annotated[
        Optional[List[str]],
        pydantic.Field(alias="subscriberIds"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Array of subscriber IDs or a single subscriber ID"""

    severity: Annotated[
        Optional[List[str]],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Array of severity levels or a single severity level"""

    page: Annotated[
        Optional[float],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = 0
    r"""Page number for pagination"""

    limit: Annotated[
        Optional[float],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = 10
    r"""Limit for pagination"""

    transaction_id: Annotated[
        Optional[str],
        pydantic.Field(alias="transactionId"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""The transaction ID to filter by"""

    topic_key: Annotated[
        Optional[str],
        pydantic.Field(alias="topicKey"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Topic Key for filtering notifications by topic"""

    subscription_id: Annotated[
        Optional[str],
        pydantic.Field(alias="subscriptionId"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Subscription ID for filtering notifications by subscription"""

    context_keys: Annotated[
        Optional[List[str]],
        pydantic.Field(alias="contextKeys"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Filter by exact context keys, order insensitive (format: \"type:id\")"""

    after: Annotated[
        Optional[str],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Date filter for records after this timestamp. Defaults to earliest date allowed by subscription plan"""

    before: Annotated[
        Optional[str],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Date filter for records before this timestamp. Defaults to current time of request (now)"""

    idempotency_key: Annotated[
        Optional[str],
        pydantic.Field(alias="idempotency-key"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""A header for idempotency purposes"""


class NotificationsControllerListNotificationsResponseTypedDict(TypedDict):
    headers: Dict[str, List[str]]
    result: ActivitiesResponseDtoTypedDict


class NotificationsControllerListNotificationsResponse(BaseModel):
    headers: Dict[str, List[str]]

    result: ActivitiesResponseDto
