"""
S2 Decomposed: micro-motion
==========================================

Auto-generated by S2 Auto-Decomposer.

Original skill: design/micro-motion
Scale structure:
  L0 (Micro): 4 operations
  L1 (Meso): 2 operations
  L2 (Macro): 1 operations
  L3 (Meta): 1 orchestrator

Model routing:
  L0 -> codegemma
  L1 -> qwen3
  L2 -> qwen3
  L3 -> deepseek_r1
"""

```python
from typing import Any, Dict, List, Optional
from skills.s2.context_stack import ScaleLevel
from skills.s2.composer import S2Composer

# L0 MICRO SKILLS
def micro_identify_ui_element_with_animation_need(element_type: str, **kwargs) -> Dict[str, Any]:
    """Determine if a UI element requires animation feedback."""
    needs_animation = False
    if element_type in ["button", "slider", "toggle", "progress_bar", "dropdown"]:
        needs_animation = True
    return {
        "element_type": element_type,
        "requires_animation": needs_animation,
        "reason": f"UI element {element_type} typically benefits from micro-animation feedback"
    }

def micro_define_motion_timing_duration_for_atomic_operation(operation_type: str, **kwargs) -> Dict[str, Any]:
    """Define duration and timing for atomic operations."""
    duration = 200  # ms
    timing = "immediate"
    if operation_type == "quick":
        duration = 150
        timing = "instant"
    elif operation_type == "medium":
        duration = 300
        timing = "smooth"
    elif operation_type == "long":
        duration = 500
        timing = "gradual"
    return {
        "operation_type": operation_type,
        "timing": timing,
        "duration_ms": duration,
        "timing_start": "start",
        "timing_end": "end"
    }

def micro_define_easing_curve_for_micro_motion(easing_type: str, **kwargs) -> Dict[str, Any]:
    """Select or create an easing function for micro-motion."""
    easing_function = "linear"
    if easing_type == "ease-in":
        easing_function = "cubic-bezier(0.42, 0, 0.58, 1)"
    elif easing_type == "ease-out":
        easing_function = "cubic-bezier(0.25, 0.1, 0.25, 1)"
    elif easing_type == "ease-in-out":
        easing_function = "cubic-bezier(0.42, 0, 0.58, 1)"
    return {
        "easing_type": easing_type,
        "easing_function": easing_function,
        "curve_description": f"{easing_type} easing curve for smooth motion"
    }

def micro_specify_animation_type_for_feedback_cue(animation_purpose: str, **kwargs) -> Dict[str, Any]:
    """Determine if animation is purely visual feedback or part of interaction flow."""
    is_feedback_cue = False
    if animation_purpose in ["confirmation", "error", "loading", "transition"]:
        is_feedback_cue = True
    return {
        "animation_purpose": animation_purpose,
        "is_feedback_cue": is_feedback_cue,
        "feedback_type": "visual" if is_feedback_cue else "interaction"
    }

# L1 MESO SKILLS
def meso_apply_motion_specification_to_ui_element(element_data: Dict[str, Any], **kwargs) -> Dict[str, Any]:
    """Combine motion specs for a UI element."""
    # Identify element needs
    element_type = element_data.get("element_type", "button")
    micro_identify_result = micro_identify_ui_element_with_animation_need(element_type)
    
    # Define motion timing
    operation_type = "medium"  # Default for UI elements
    micro_duration_result = micro_define_motion_timing_duration_for_atomic_operation(operation_type)
    
    # Define easing curve
    easing_type = "ease-out"
    micro_easing_result = micro_define_easing_curve_for_micro_motion(easing_type)
    
    # Specify animation type
    animation_purpose = "transition"
    micro_animation_result = micro_specify_animation_type_for_feedback_cue(animation_purpose)
    
    return {
        "element_spec": {
            "needs_animation": micro_identify_result["requires_animation"],
            "timing": micro_duration_result["timing"],
            "duration": micro_duration_result["duration_ms"],
            "easing": micro_easing_result["easing_function"],
            "animation_type": micro_animation_result["feedback_type"]
        },
        "element_type": element_type
    }

def meso_define_micro_motion_sequence_for_interaction_flow(sequence_data: List[Dict[str, Any]], **kwargs) -> Dict[str, Any]:
    """Bundle multiple animations into a coherent sequence."""
    sequence = []
    for item in sequence_data:
        element_type = item.get("element_type", "button")
        operation_type = item.get("operation_type", "medium")
        easing_type = item.get("easing_type", "ease-out")
        animation_purpose = item.get("animation_purpose", "transition")
        
        # Process each item
        micro_identify_result = micro_identify_ui_element_with_animation_need(element_type)
        micro_duration_result = micro_define_motion_timing_duration_for_atomic_operation(operation_type)
        micro_easing_result = micro_define_easing_curve_for_micro_motion(easing_type)
        micro_animation_result = micro_specify_animation_type_for_feedback_cue(animation_purpose)
        
        sequence.append({
            "element": element_type,
            "timing": micro_duration_result["timing"],
            "duration": micro_duration_result["duration_ms"],
            "easing": micro_easing_result["easing_function"],
            "animation_type": micro_animation_result["feedback_type"]
        })
    
    return {
        "motion_sequence": sequence,
        "sequence_description": "Coherent micro-motion sequence for interaction flow"
    }

# L2 MACRO SKILLS
def macro_validate_micro_motion_component_specification(component_data: Dict[str, Any], **kwargs) -> Dict[str, Any]:
    """Validate all micro-motion specs for a component."""
    # Check if element requires animation
    if not component_data.get("requires_animation", False):
        return {
            "validation_result": "skip",
            "reason": "Component does not require micro-motion feedback"
        }
    
    # Validate timing and easing
    if not component_data.get("timing") or not component_data.get("duration"):
        return {
            "validation_result": "error",
            "reason": "Missing timing or duration specifications"
        }
    
    # Validate easing function
    if not component_data.get("easing"):
        return {
            "validation_result": "error",
            "reason":


# Skill metadata
SKILL_METADATA = {
    "original_id": "design/micro-motion",
    "original_name": "micro-motion",
    "scale_structure": {
    "L0": [
        "identify_ui_element_with_animation_need: Check if a specific UI component requires animation feedback",
        "define_motion_timing_duration_for_atomic_operation: Set the duration and timing start/end points for an individu",
        "define_easing_curve_for_micro_motion: Select or create the easing function defining subtle acceler",
        "specify_animation_type_for_feedback_cue: Determine whether an animation is purely visual feedback, in"
    ],
    "L1": [
        "apply_motion_specification_to_ui_element: Combine defining timing/duration and easing for all applicab",
        "define_micro_motion_sequence_for_interaction_flow: Bundle multiple individual animations into a coherent reacti"
    ],
    "L2": [
        "validate_micro_motion_component_specification: Combine identifying animation needs, defining the specs (tim"
    ],
    "L3": [
        "design_micro_motion_orchestrator"
    ]
},
    "skill_tree": {
    "design/micro_motion/orchestrator": [
        "design/micro_motion/validate_micro_motion_component_specification"
    ],
    "design/micro_motion/validate_micro_motion_component_specification": [
        "design/micro_motion/apply_motion_specification_to_ui_element",
        "design/micro_motion/define_micro_motion_sequence_for_interaction_flow"
    ],
    "design/micro_motion/apply_motion_specification_to_ui_element": [
        "design/micro_motion/identify_ui_element_with_animation_need",
        "design/micro_motion/define_motion_timing_duration_for_atomic_operation",
        "design/micro_motion/define_easing_curve_for_micro_motion"
    ],
    "design/micro_motion/define_micro_motion_sequence_for_interaction_flow": [
        "design/micro_motion/identify_ui_element_with_animation_need",
        "design/micro_motion/define_motion_timing_duration_for_atomic_operation",
        "design/micro_motion/define_easing_curve_for_micro_motion"
    ]
},
    "model_routing": {
    "L0": "codegemma",
    "L1": "qwen3",
    "L2": "qwen3",
    "L3": "deepseek_r1"
},
}
