from typing import Mapping, Sequence

from _typeshed import Incomplete
from pyomo.common.collections import ComponentMap as ComponentMap
from pyomo.common.config import ConfigValue as ConfigValue
from pyomo.common.config import NonNegativeInt as NonNegativeInt
from pyomo.common.errors import PyomoException as PyomoException
from pyomo.common.fileutils import Executable as Executable
from pyomo.common.log import LogStream as LogStream
from pyomo.common.tee import TeeStream as TeeStream
from pyomo.common.tempfiles import TempfileManager as TempfileManager
from pyomo.common.timing import HierarchicalTimer as HierarchicalTimer
from pyomo.contrib.appsi.base import PersistentSolutionLoader as PersistentSolutionLoader
from pyomo.contrib.appsi.base import PersistentSolver as PersistentSolver
from pyomo.contrib.appsi.base import Results as Results
from pyomo.contrib.appsi.base import SolverConfig as SolverConfig
from pyomo.contrib.appsi.base import TerminationCondition as TerminationCondition
from pyomo.contrib.appsi.cmodel import cmodel_available as cmodel_available
from pyomo.contrib.appsi.writers import NLWriter as NLWriter
from pyomo.core.base.block import BlockData as BlockData
from pyomo.core.base.constraint import ConstraintData as ConstraintData
from pyomo.core.base.objective import ObjectiveData as ObjectiveData
from pyomo.core.base.param import ParamData as ParamData
from pyomo.core.base.var import VarData as VarData
from pyomo.core.expr.numvalue import value as value
from pyomo.core.expr.visitor import replace_expressions as replace_expressions
from pyomo.core.kernel.objective import minimize as minimize
from pyomo.core.staleflag import StaleFlagManager as StaleFlagManager

logger: Incomplete

class IpoptConfig(SolverConfig):
    executable: Incomplete
    filename: Incomplete
    keepfiles: bool
    solver_output_logger: Incomplete
    log_level: Incomplete
    def __init__(
        self,
        description=None,
        doc=None,
        implicit: bool = False,
        implicit_domain=None,
        visibility: int = 0,
    ) -> None: ...

ipopt_command_line_options: Incomplete

class Ipopt(PersistentSolver):
    def __init__(self, only_child_vars: bool = False) -> None: ...
    def available(self): ...
    def version(self): ...
    def nl_filename(self): ...
    def sol_filename(self): ...
    def options_filename(self): ...
    @property
    def config(self): ...
    @config.setter
    def config(self, val) -> None: ...
    @property
    def ipopt_options(self): ...
    @ipopt_options.setter
    def ipopt_options(self, val: dict): ...
    @property
    def update_config(self): ...
    @property
    def writer(self): ...
    @property
    def symbol_map(self): ...
    def set_instance(self, model) -> None: ...
    def add_variables(self, variables: list[VarData]): ...
    def add_params(self, params: list[ParamData]): ...
    def add_constraints(self, cons: list[ConstraintData]): ...
    def add_block(self, block: BlockData): ...
    def remove_variables(self, variables: list[VarData]): ...
    def remove_params(self, params: list[ParamData]): ...
    def remove_constraints(self, cons: list[ConstraintData]): ...
    def remove_block(self, block: BlockData): ...
    def set_objective(self, obj: ObjectiveData): ...
    def update_variables(self, variables: list[VarData]): ...
    def update_params(self) -> None: ...
    def solve(self, model, timer: HierarchicalTimer = None): ...
    def get_primals(
        self, vars_to_load: Sequence[VarData] | None = None
    ) -> Mapping[VarData, float]: ...
    def get_duals(self, cons_to_load: Sequence[ConstraintData] | None = None): ...
    def get_reduced_costs(
        self, vars_to_load: Sequence[VarData] | None = None
    ) -> Mapping[VarData, float]: ...
    def has_linear_solver(self, linear_solver): ...
