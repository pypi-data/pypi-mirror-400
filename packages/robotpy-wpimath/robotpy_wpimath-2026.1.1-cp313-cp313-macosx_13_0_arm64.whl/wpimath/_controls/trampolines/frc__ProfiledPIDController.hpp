// This file is autogenerated. DO NOT EDIT

#pragma once
#include <semiwrap.h>

// wrapped header

#include <frc/controller/ProfiledPIDController.h>

#include <trampolines/wpi__Sendable.hpp>

namespace frc {

template <typename Distance, typename CfgBase = swgen::EmptyTrampolineCfg>
struct PyTrampolineCfg_ProfiledPIDController :
  wpi::PyTrampolineCfg_Sendable<
  CfgBase
  >
{
  using Base = frc::ProfiledPIDController<Distance>;
  using override_base_InitSendable_RTSendableBuilder = frc::ProfiledPIDController<Distance>;
};

template <typename PyTrampolineBase, typename Distance, typename PyTrampolineCfg>
using PyTrampolineBase_ProfiledPIDController =
  wpi::PyTrampoline_Sendable<
    PyTrampolineBase
    , PyTrampolineCfg>
;

template <typename PyTrampolineBase, typename Distance, typename PyTrampolineCfg>
struct PyTrampoline_ProfiledPIDController : PyTrampolineBase_ProfiledPIDController<PyTrampolineBase, Distance, PyTrampolineCfg> {
  using PyTrampolineBase_ProfiledPIDController<PyTrampolineBase, Distance, PyTrampolineCfg>::PyTrampolineBase_ProfiledPIDController;
  using Velocity = typename frc::ProfiledPIDController<Distance>::Velocity;
  using Velocity_t = typename frc::ProfiledPIDController<Distance>::Velocity_t;
  using Distance_t [[maybe_unused]] = typename frc::ProfiledPIDController<Distance>::Distance_t;
  using Acceleration [[maybe_unused]] = typename frc::ProfiledPIDController<Distance>::Acceleration;
  using Acceleration_t [[maybe_unused]] = typename frc::ProfiledPIDController<Distance>::Acceleration_t;
  using State [[maybe_unused]] = typename frc::ProfiledPIDController<Distance>::State;
  using Constraints [[maybe_unused]] = typename frc::ProfiledPIDController<Distance>::Constraints;

  #ifndef SWGEN_DISABLE_InitSendable_RTSendableBuilder
    void InitSendable(wpi::SendableBuilder& builder) override {
      using LookupBase = typename PyTrampolineCfg::Base;
      using CxxCallBase = typename PyTrampolineCfg::override_base_InitSendable_RTSendableBuilder;
      PYBIND11_OVERRIDE_IMPL(PYBIND11_TYPE(void), LookupBase,
        "initSendable", builder);
      return CxxCallBase::InitSendable(std::forward<decltype(builder)>(builder));
    }
  #endif
};

}; // namespace frc

#include <units_angle_type_caster.h>
#include <units_angular_velocity_type_caster.h>
#include <units_compound_type_caster.h>
#include <units_misc_type_caster.h>
#include <units_time_type_caster.h>

namespace swgen {

using namespace frc;

template <typename Distance>
struct bind_frc__ProfiledPIDController {
  using Velocity = typename frc::ProfiledPIDController<Distance>::Velocity;
  using Velocity_t = typename frc::ProfiledPIDController<Distance>::Velocity_t;
  using Distance_t [[maybe_unused]] = typename frc::ProfiledPIDController<Distance>::Distance_t;
  using Acceleration [[maybe_unused]] = typename frc::ProfiledPIDController<Distance>::Acceleration;
  using Acceleration_t [[maybe_unused]] = typename frc::ProfiledPIDController<Distance>::Acceleration_t;
  using State [[maybe_unused]] = typename frc::ProfiledPIDController<Distance>::State;
  using Constraints [[maybe_unused]] = typename frc::ProfiledPIDController<Distance>::Constraints;
  struct ProfiledPIDController_Trampoline : frc::PyTrampoline_ProfiledPIDController<typename frc::ProfiledPIDController<Distance>, Distance, typename frc::PyTrampolineCfg_ProfiledPIDController<Distance>>, py::trampoline_self_life_support {
      using RpyBase = frc::PyTrampoline_ProfiledPIDController<typename frc::ProfiledPIDController<Distance>, Distance, typename frc::PyTrampolineCfg_ProfiledPIDController<Distance>>;
      using RpyBase::RpyBase;
  };
  static_assert(std::is_abstract<ProfiledPIDController_Trampoline>::value == false, "frc::ProfiledPIDController<Distance> " SEMIWRAP_BAD_TRAMPOLINE);
  py::class_<typename frc::ProfiledPIDController<Distance>, py::smart_holder, ProfiledPIDController_Trampoline, wpi::Sendable> cls_ProfiledPIDController;

  py::module &m;
  std::string clsName;
  bind_frc__ProfiledPIDController(py::module &m, const char * clsName) :
    cls_ProfiledPIDController(m, clsName),
    m(m),
    clsName(clsName) {
  }

  void finish(const char * set_doc = NULL, const char * add_doc = NULL) {
    cls_ProfiledPIDController.doc() = 
      "Implements a PID control loop whose setpoint is constrained by a trapezoid\n"
      "profile.";
    cls_ProfiledPIDController.def(py::init<double, double, double, typename TrapezoidProfile<Distance>::Constraints, units::second_t>()
      , py::arg("Kp"), py::arg("Ki"), py::arg("Kd"), py::arg("constraints"), py::arg("period") = (units::second_t)0.020_s
      , release_gil()
      , py::doc(
      "Allocates a ProfiledPIDController with the given constants for Kp, Ki, and\n"
      "Kd. Users should call reset() when they first start running the controller\n"
      "to avoid unwanted behavior.\n"
      "\n"
      ":param Kp:          The proportional coefficient. Must be >= 0.\n"
      ":param Ki:          The integral coefficient. Must be >= 0.\n"
      ":param Kd:          The derivative coefficient. Must be >= 0.\n"
      ":param constraints: Velocity and acceleration constraints for goal.\n"
      ":param period:      The period between controller updates in seconds. The\n"
      "                    default is 20 milliseconds. Must be positive.")
    );
    cls_ProfiledPIDController.def("setPID", &frc::ProfiledPIDController<Distance>::SetPID
      , py::arg("Kp"), py::arg("Ki"), py::arg("Kd")
      , release_gil()
      , py::doc(
      "Sets the PID Controller gain parameters.\n"
      "\n"
      "Sets the proportional, integral, and differential coefficients.\n"
      "\n"
      ":param Kp: The proportional coefficient. Must be >= 0.\n"
      ":param Ki: The integral coefficient. Must be >= 0.\n"
      ":param Kd: The differential coefficient. Must be >= 0.")
    );
    cls_ProfiledPIDController.def("setP", &frc::ProfiledPIDController<Distance>::SetP
      , py::arg("Kp")
      , release_gil()
      , py::doc(
      "Sets the proportional coefficient of the PID controller gain.\n"
      "\n"
      ":param Kp: The proportional coefficient. Must be >= 0.")
    );
    cls_ProfiledPIDController.def("setI", &frc::ProfiledPIDController<Distance>::SetI
      , py::arg("Ki")
      , release_gil()
      , py::doc(
      "Sets the integral coefficient of the PID controller gain.\n"
      "\n"
      ":param Ki: The integral coefficient. Must be >= 0.")
    );
    cls_ProfiledPIDController.def("setD", &frc::ProfiledPIDController<Distance>::SetD
      , py::arg("Kd")
      , release_gil()
      , py::doc(
      "Sets the differential coefficient of the PID controller gain.\n"
      "\n"
      ":param Kd: The differential coefficient. Must be >= 0.")
    );
    cls_ProfiledPIDController.def("setIZone", &frc::ProfiledPIDController<Distance>::SetIZone
      , py::arg("iZone")
      , release_gil()
      , py::doc(
      "Sets the IZone range. When the absolute value of the position error is\n"
      "greater than IZone, the total accumulated error will reset to zero,\n"
      "disabling integral gain until the absolute value of the position error is\n"
      "less than IZone. This is used to prevent integral windup. Must be\n"
      "non-negative. Passing a value of zero will effectively disable integral\n"
      "gain. Passing a value of infinity disables IZone functionality.\n"
      "\n"
      ":param iZone: Maximum magnitude of error to allow integral control. Must be\n"
      "              >= 0.")
    );
    cls_ProfiledPIDController.def("getP", &frc::ProfiledPIDController<Distance>::GetP
      , release_gil()
      , py::doc(
      "Gets the proportional coefficient.\n"
      "\n"
      ":returns: proportional coefficient")
    );
    cls_ProfiledPIDController.def("getI", &frc::ProfiledPIDController<Distance>::GetI
      , release_gil()
      , py::doc(
      "Gets the integral coefficient.\n"
      "\n"
      ":returns: integral coefficient")
    );
    cls_ProfiledPIDController.def("getD", &frc::ProfiledPIDController<Distance>::GetD
      , release_gil()
      , py::doc(
      "Gets the differential coefficient.\n"
      "\n"
      ":returns: differential coefficient")
    );
    cls_ProfiledPIDController.def("getIZone", &frc::ProfiledPIDController<Distance>::GetIZone
      , release_gil()
      , py::doc(
      "Get the IZone range.\n"
      "\n"
      ":returns: Maximum magnitude of error to allow integral control.")
    );
    cls_ProfiledPIDController.def("getPeriod", &frc::ProfiledPIDController<Distance>::GetPeriod
      , release_gil()
      , py::doc(
      "Gets the period of this controller.\n"
      "\n"
      ":returns: The period of the controller.")
    );
    cls_ProfiledPIDController.def("getPositionTolerance", &frc::ProfiledPIDController<Distance>::GetPositionTolerance
      , release_gil()
      , py::doc(
      "Gets the position tolerance of this controller.\n"
      "\n"
      ":returns: The position tolerance of the controller.")
    );
    cls_ProfiledPIDController.def("getVelocityTolerance", &frc::ProfiledPIDController<Distance>::GetVelocityTolerance
      , release_gil()
      , py::doc(
      "Gets the velocity tolerance of this controller.\n"
      "\n"
      ":returns: The velocity tolerance of the controller.")
    );
    cls_ProfiledPIDController.def("getAccumulatedError", &frc::ProfiledPIDController<Distance>::GetAccumulatedError
      , release_gil()
      , py::doc(
      "Gets the accumulated error used in the integral calculation of this\n"
      "controller.\n"
      "\n"
      ":returns: The accumulated error of this controller.")
    );
    cls_ProfiledPIDController.def("setGoal", static_cast<void (frc::ProfiledPIDController<Distance>::*)(State)>(&frc::ProfiledPIDController<Distance>::SetGoal)
      , py::arg("goal")
      , release_gil()
      , py::doc(
      "Sets the goal for the ProfiledPIDController.\n"
      "\n"
      ":param goal: The desired unprofiled setpoint.")
    );
    cls_ProfiledPIDController.def("setGoal", static_cast<void (frc::ProfiledPIDController<Distance>::*)(Distance_t)>(&frc::ProfiledPIDController<Distance>::SetGoal)
      , py::arg("goal")
      , release_gil()
      , py::doc(
      "Sets the goal for the ProfiledPIDController.\n"
      "\n"
      ":param goal: The desired unprofiled setpoint.")
    );
    cls_ProfiledPIDController.def("getGoal", &frc::ProfiledPIDController<Distance>::GetGoal
      , release_gil()
      , py::doc("Gets the goal for the ProfiledPIDController.")
    );
    cls_ProfiledPIDController.def("atGoal", &frc::ProfiledPIDController<Distance>::AtGoal
      , release_gil()
      , py::doc(
      "Returns true if the error is within the tolerance of the error.\n"
      "\n"
      "This will return false until at least one input value has been computed.")
    );
    cls_ProfiledPIDController.def("setConstraints", &frc::ProfiledPIDController<Distance>::SetConstraints
      , py::arg("constraints")
      , release_gil()
      , py::doc(
      "Set velocity and acceleration constraints for goal.\n"
      "\n"
      ":param constraints: Velocity and acceleration constraints for goal.")
    );
    cls_ProfiledPIDController.def("getConstraints", &frc::ProfiledPIDController<Distance>::GetConstraints
      , release_gil()
      , py::doc(
      "Get the velocity and acceleration constraints for this controller.\n"
      "\n"
      ":returns: Velocity and acceleration constraints.")
    );
    cls_ProfiledPIDController.def("getSetpoint", &frc::ProfiledPIDController<Distance>::GetSetpoint
      , release_gil()
      , py::doc(
      "Returns the current setpoint of the ProfiledPIDController.\n"
      "\n"
      ":returns: The current setpoint.")
    );
    cls_ProfiledPIDController.def("atSetpoint", &frc::ProfiledPIDController<Distance>::AtSetpoint
      , release_gil()
      , py::doc(
      "Returns true if the error is within the tolerance of the error.\n"
      "\n"
      "Currently this just reports on target as the actual value passes through\n"
      "the setpoint. Ideally it should be based on being within the tolerance for\n"
      "some period of time.\n"
      "\n"
      "This will return false until at least one input value has been computed.")
    );
    cls_ProfiledPIDController.def("enableContinuousInput", &frc::ProfiledPIDController<Distance>::EnableContinuousInput
      , py::arg("minimumInput"), py::arg("maximumInput")
      , release_gil()
      , py::doc(
      "Enables continuous input.\n"
      "\n"
      "Rather then using the max and min input range as constraints, it considers\n"
      "them to be the same point and automatically calculates the shortest route\n"
      "to the setpoint.\n"
      "\n"
      ":param minimumInput: The minimum value expected from the input.\n"
      ":param maximumInput: The maximum value expected from the input.")
    );
    cls_ProfiledPIDController.def("disableContinuousInput", &frc::ProfiledPIDController<Distance>::DisableContinuousInput
      , release_gil()
      , py::doc("Disables continuous input.")
    );
    cls_ProfiledPIDController.def("setIntegratorRange", &frc::ProfiledPIDController<Distance>::SetIntegratorRange
      , py::arg("minimumIntegral"), py::arg("maximumIntegral")
      , release_gil()
      , py::doc(
      "Sets the minimum and maximum contributions of the integral term.\n"
      "\n"
      "The internal integrator is clamped so that the integral term's contribution\n"
      "to the output stays between minimumIntegral and maximumIntegral. This\n"
      "prevents integral windup.\n"
      "\n"
      ":param minimumIntegral: The minimum contribution of the integral term.\n"
      ":param maximumIntegral: The maximum contribution of the integral term.")
    );
    cls_ProfiledPIDController.def("setTolerance", &frc::ProfiledPIDController<Distance>::SetTolerance
      , py::arg("positionTolerance"), py::arg("velocityTolerance") = Velocity_t{std::numeric_limits<double>::infinity ()}
      , release_gil()
      , py::doc(
      "Sets the error which is considered tolerable for use with\n"
      "AtSetpoint().\n"
      "\n"
      ":param positionTolerance: Position error which is tolerable.\n"
      ":param velocityTolerance: Velocity error which is tolerable.")
    );
    cls_ProfiledPIDController.def("getPositionError", &frc::ProfiledPIDController<Distance>::GetPositionError
      , release_gil()
      , py::doc(
      "Returns the difference between the setpoint and the measurement.\n"
      "\n"
      ":returns: The error.")
    );
    cls_ProfiledPIDController.def("getVelocityError", &frc::ProfiledPIDController<Distance>::GetVelocityError
      , release_gil()
      , py::doc("Returns the change in error per second.")
    );
    cls_ProfiledPIDController.def("calculate", static_cast<double (frc::ProfiledPIDController<Distance>::*)(Distance_t)>(&frc::ProfiledPIDController<Distance>::Calculate)
      , py::arg("measurement")
      , release_gil()
      , py::doc(
      "Returns the next output of the PID controller.\n"
      "\n"
      ":param measurement: The current measurement of the process variable.")
    );
    cls_ProfiledPIDController.def("calculate", static_cast<double (frc::ProfiledPIDController<Distance>::*)(Distance_t, State)>(&frc::ProfiledPIDController<Distance>::Calculate)
      , py::arg("measurement"), py::arg("goal")
      , release_gil()
      , py::doc(
      "Returns the next output of the PID controller.\n"
      "\n"
      ":param measurement: The current measurement of the process variable.\n"
      ":param goal:        The new goal of the controller.")
    );
    cls_ProfiledPIDController.def("calculate", static_cast<double (frc::ProfiledPIDController<Distance>::*)(Distance_t, Distance_t)>(&frc::ProfiledPIDController<Distance>::Calculate)
      , py::arg("measurement"), py::arg("goal")
      , release_gil()
      , py::doc(
      "Returns the next output of the PID controller.\n"
      "\n"
      ":param measurement: The current measurement of the process variable.\n"
      ":param goal:        The new goal of the controller.")
    );
    cls_ProfiledPIDController.def("calculate", static_cast<double (frc::ProfiledPIDController<Distance>::*)(Distance_t, Distance_t, typename TrapezoidProfile<Distance>::Constraints)>(&frc::ProfiledPIDController<Distance>::Calculate)
      , py::arg("measurement"), py::arg("goal"), py::arg("constraints")
      , release_gil()
      , py::doc(
      "Returns the next output of the PID controller.\n"
      "\n"
      ":param measurement: The current measurement of the process variable.\n"
      ":param goal:        The new goal of the controller.\n"
      ":param constraints: Velocity and acceleration constraints for goal.")
    );
    cls_ProfiledPIDController.def("reset", static_cast<void (frc::ProfiledPIDController<Distance>::*)(const State&)>(&frc::ProfiledPIDController<Distance>::Reset)
      , py::arg("measurement")
      , release_gil()
      , py::doc(
      "Reset the previous error and the integral term.\n"
      "\n"
      ":param measurement: The current measured State of the system.")
    );
    cls_ProfiledPIDController.def("reset", static_cast<void (frc::ProfiledPIDController<Distance>::*)(Distance_t, Velocity_t)>(&frc::ProfiledPIDController<Distance>::Reset)
      , py::arg("measuredPosition"), py::arg("measuredVelocity")
      , release_gil()
      , py::doc(
      "Reset the previous error and the integral term.\n"
      "\n"
      ":param measuredPosition: The current measured position of the system.\n"
      ":param measuredVelocity: The current measured velocity of the system.")
    );
    cls_ProfiledPIDController.def("reset", static_cast<void (frc::ProfiledPIDController<Distance>::*)(Distance_t)>(&frc::ProfiledPIDController<Distance>::Reset)
      , py::arg("measuredPosition")
      , release_gil()
      , py::doc(
      "Reset the previous error and the integral term.\n"
      "\n"
      ":param measuredPosition: The current measured position of the system. The\n"
      "                         velocity is assumed to be zero.")
    );
    cls_ProfiledPIDController.def("initSendable", &frc::ProfiledPIDController<Distance>::InitSendable
      , py::arg("builder")
      , release_gil()
    );
    if (set_doc) {
      cls_ProfiledPIDController.doc() = set_doc;
    }
    if (add_doc) {
      cls_ProfiledPIDController.doc() = py::cast<std::string>(cls_ProfiledPIDController.doc()) + add_doc;
    }
  }
}; // struct bind_frc__ProfiledPIDController

}; // namespace swgen
