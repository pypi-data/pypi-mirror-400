# Copyright (c) 2023-2026 Arista Networks, Inc.
# Use of this source code is governed by the Apache License 2.0
# that can be found in the LICENSE file.
"""Factory functions used by PyAVD for ANTA."""

from __future__ import annotations

from itertools import chain
from logging import getLogger
from typing import TYPE_CHECKING, Any

from anta.catalog import AntaCatalog, AntaTestDefinition
from anta.models import AntaTest

from pyavd._eos_cli_config_gen.schema import EosCliConfigGen
from pyavd._utils import get_v2

from .constants import StructuredConfigKey
from .logs import LogMessage, TestLoggerAdapter
from .models import DeviceTestContext

if TYPE_CHECKING:
    from collections.abc import Iterator

    from pyavd.api._anta import AvdCatalogGenerationSettings, AvdFabricData, TestSpec


def create_catalog(
    hostname: str,
    structured_config: dict[str, Any],
    fabric_data: AvdFabricData,
    settings: AvdCatalogGenerationSettings,
    test_specs: list[TestSpec],
) -> AntaCatalog:
    """Create an ANTA catalog for a device from the provided test specs."""
    device_context = DeviceTestContext(
        hostname=hostname,
        structured_config=EosCliConfigGen._load(structured_config),
        fabric_data=fabric_data,
        settings=settings,
    )

    all_test_defs_iterator = chain.from_iterable(create_test_definitions(test_spec, device_context) for test_spec in test_specs)

    tests = [update_test_definition_metadata(test_def, hostname) for test_def in all_test_defs_iterator]

    # Sort by module and test name for consistent output
    tests.sort(key=lambda x: (x.test.__module__, x.test.name))

    return AntaCatalog(tests=tests)


def create_test_definitions(test_spec: TestSpec, device_context: DeviceTestContext) -> Iterator[AntaTestDefinition]:
    """Generate the AntaTestDefinition from this TestSpec instance."""
    logger_adapter = TestLoggerAdapter(logger=getLogger(__name__), extra={"device": device_context.hostname, "test": test_spec.test_class.name})

    # Skip the test if the conditional keys are not present in the structured config
    if test_spec.conditional_keys and not all(get_v2(device_context.structured_config, key.value) for key in test_spec.conditional_keys):
        keys = StructuredConfigKey.to_string_list(test_spec.conditional_keys)
        logger_adapter.debug(LogMessage.INPUT_NO_DATA_MODELS, data_models=", ".join(keys))
        return

    # Generate the test definitions from the input factory if provided
    if test_spec.input_factory is not None:
        factory = test_spec.input_factory(device_context, test_spec.test_class.name)
        for inputs in factory.create():
            yield AntaTestDefinition(test=test_spec.test_class, inputs=inputs)
        return

    # Otherwise AntaTestDefinition takes `inputs=None` if the test does not require any inputs
    yield AntaTestDefinition(test=test_spec.test_class, inputs=None)


def update_test_definition_metadata(test_definition: AntaTestDefinition, hostname: str) -> AntaTestDefinition:
    """Tag the test definition with the device name for the final catalog and add metadata."""
    # Tag the test with the device name
    test_definition.inputs.filters = AntaTest.Input.Filters(tags={hostname})

    # Ensure result_overwrite is initialized or updated
    if test_definition.inputs.result_overwrite is None:
        test_definition.inputs.result_overwrite = AntaTest.Input.ResultOverwrite(custom_field="Generated by AVD")
    else:
        test_definition.inputs.result_overwrite.custom_field = "Generated by AVD"

    return test_definition
