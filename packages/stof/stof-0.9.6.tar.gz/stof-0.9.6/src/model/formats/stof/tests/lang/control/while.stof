//
// Copyright 2025 Formata, Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

/*!
 * While statement tests.
 */


Break: {
    #[test]
    fn break_in_while() {
        let i = 0;
        let additions = 0;
        while (i < 200) {
            i += 1;
            if (i > 100) break;
            additions += 1;
        }
        assert_eq(additions, 100);
    }

    #[test]
    fn tagged_break() {
        let i = 0;
        let total = 0;
        ^outer while (i < 10) {
            let j = 0;
            while (j < 10) {
                if (i >= 5 && j >= 5) break ^outer;
                j += 1;
                total += 1;
            }
            total += 1;
            i += 1;
        }
        assert_eq(total, 60);
    }

    #[test]
    fn break_in_nested() {
        const first = [0, 1, 2];
        const second = [1, 2, 3];
        const third = [2, 3, 4];
        let array = [[first, first, first], [second, second, second], [third, third, third]];
        let total = 0;
        for (let i = 0; i < 3; i += 1) {
            for (let j = 0; j < 3; j += 1) { // 3 times
                for (let k = 0; k < 3; k += 1) { // 9 times
                    let num = array[i][j][k];
                    total += num;
                    if (k > 1) break;
                }
                if (j > 1) break;
            }
            if (i > 1) break;
        }
        assert_eq(total, 54);
    }
}

Contunue: {
    #[test]
    fn continue_in_nested() {
        let total = 0;
        for (let i = 0; i < 10; i += 1) {
            if (i < 1) continue;

            for (let j = 0; j < 10; j += 1) {
                if (j < 2) continue;

                for (let k = 0; k < 10; k += 1) {
                    if (k < 5) continue;
                    total += k;
                }
            }
        }
        assert_eq(total, 2520);
    }

    #[test]
    fn tagged_continue() {
        let total = 0;
        let i = 0;
        ^outer while (i < 10) {
            i += 1;

            let j = 0;
            while (j < 10) {
                if (j > 5) continue ^outer;
                j += 1;
                total += i + j;
            }
        }
        assert_eq(total, 540);
    }
}

Return: {
    fn loop_ret() -> int {
        let i = 0;
        while (i < 10) {
            if (i > 5) return i;
            i += 1;
        }
        return -1;
    }

    #[test]
    fn return_from_loop() {
        const res = self.loop_ret();
        assert_eq(res, 6);
    }

    fn nested_return(total: int) {
        let i = 0;
        while (i < 10) {
            let j = 0;
            while (j < 10) {
                let k = 0;
                while (k < 10) {
                    if (i > 2 && j > 2 && k > 2) {
                        return;
                    }
                    total += 1;
                    k += 1;
                }
                j += 1;
            }
            i += 1;
        }
    }

    #[test]
    fn return_from_nested() {
        let total = 0;
        self.nested_return(&total);
        assert_eq(total, 333);
    }
}

Loop: {
    #[test]
    fn loop_syntax() {
        let i = 0;

        loop {
            if (i > 5) break;
            i += 1;
        }

        assert_eq(i, 6);
    }
}
