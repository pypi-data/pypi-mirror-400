"""
Skill Code Generator - Generate Python skill implementations from specifications.

This generator creates:
- skill.py: Main skill class with execute() method
- primitives.py: Hardware-abstracted primitive wrappers
- validators.py: Input/output validation
- state_machine.py: Execution flow state machine
"""

import re
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional

from ..skill_schema import SkillSpecification, SkillParameter, PrimitiveCall
from ..primitives import PRIMITIVE_REGISTRY, get_primitive


def to_pascal_case(name: str) -> str:
    """Convert snake_case or kebab-case to PascalCase."""
    # Replace hyphens with underscores
    name = name.replace("-", "_")
    # Split on underscores and capitalize each word
    return "".join(word.capitalize() for word in name.split("_"))


def to_snake_case(name: str) -> str:
    """Convert PascalCase or kebab-case to snake_case."""
    # Replace hyphens with underscores
    name = name.replace("-", "_")
    # Insert underscore before uppercase letters
    name = re.sub(r"(?<!^)(?=[A-Z])", "_", name)
    return name.lower()


def python_type(param_type: str) -> str:
    """Convert skill parameter type to Python type annotation."""
    type_map = {
        "Pose": "Dict[str, Any]",
        "float": "float",
        "int": "int",
        "bool": "bool",
        "string": "str",
        "array": "List[Any]",
        "JointState": "List[float]",
        "Trajectory": "List[Dict[str, Any]]",
        "Point": "Tuple[float, float, float]",
        "Quaternion": "Tuple[float, float, float, float]",
        "Transform": "Dict[str, Any]",
    }
    return type_map.get(param_type, "Any")


class SkillCodeGenerator:
    """
    Generate Python code for a skill from its specification.

    This generator creates a complete Python package structure with:
    - Main skill class
    - Primitive wrappers
    - Input/output validators
    - State machine for execution flow
    """

    def __init__(self, spec: SkillSpecification):
        """
        Initialize the generator.

        Args:
            spec: The skill specification to generate code for
        """
        self.spec = spec
        self.class_name = to_pascal_case(spec.name)
        self.module_name = to_snake_case(spec.name)

    def generate_skill_class(self) -> str:
        """
        Generate the main skill.py file.

        Returns:
            Python source code for the skill class
        """
        lines = [
            '"""',
            f'{self.spec.name} - {self.spec.description}',
            '',
            f'Generated by Skill Compiler v1.0.0',
            f'Generated at: {datetime.now().isoformat()}',
            '',
            'Do not edit manually - regenerate from skill.yaml',
            '"""',
            '',
            'from dataclasses import dataclass',
            'from typing import Any, Dict, List, Optional, Tuple',
            'import logging',
            '',
            f'from .primitives import PrimitiveExecutor',
            f'from .validators import validate_{self.module_name}_input, validate_{self.module_name}_output',
            '',
            '',
            'logger = logging.getLogger(__name__)',
            '',
        ]

        # Generate input dataclass
        lines.extend(self._generate_input_class())
        lines.append('')

        # Generate output dataclass
        lines.extend(self._generate_output_class())
        lines.append('')

        # Generate main skill class
        lines.extend(self._generate_skill_class_body())

        return '\n'.join(lines)

    def _generate_input_class(self) -> List[str]:
        """Generate the input dataclass."""
        lines = [
            '@dataclass',
            f'class {self.class_name}Input:',
            f'    """Input parameters for {self.spec.name} skill."""',
        ]

        if not self.spec.parameters:
            lines.append('    pass')
            return lines

        for param in self.spec.parameters:
            type_annotation = python_type(param.type)
            if param.default is not None:
                default_str = repr(param.default)
                lines.append(f'    {param.name}: {type_annotation} = {default_str}')
            elif not param.required:
                lines.append(f'    {param.name}: Optional[{type_annotation}] = None')
            else:
                lines.append(f'    {param.name}: {type_annotation}')

        return lines

    def _generate_output_class(self) -> List[str]:
        """Generate the output dataclass."""
        lines = [
            '@dataclass',
            f'class {self.class_name}Output:',
            f'    """Output from {self.spec.name} skill execution."""',
            '    success: bool',
            '    message: str',
            '    error_code: Optional[str] = None',
            '    execution_time: float = 0.0',
        ]

        # Add success criteria as output fields
        for criterion in self.spec.success_criteria:
            lines.append(f'    {criterion.name}: bool = False')

        return lines

    def _generate_skill_class_body(self) -> List[str]:
        """Generate the main skill class."""
        lines = [
            f'class {self.class_name}Skill:',
            f'    """',
            f'    {self.spec.description}',
            f'    ',
            f'    Version: {self.spec.version}',
        ]

        if self.spec.author:
            lines.append(f'    Author: {self.spec.author}')

        lines.extend([
            f'    """',
            '',
            '    def __init__(self, hardware_config: Dict[str, Any]):',
            '        """',
            '        Initialize the skill with hardware configuration.',
            '        ',
            '        Args:',
            '            hardware_config: Hardware mapping configuration',
            '        """',
            '        self.config = hardware_config',
            '        self.primitives = PrimitiveExecutor(hardware_config)',
            '        self._setup_hardware()',
            '',
            '    def _setup_hardware(self) -> None:',
            '        """Initialize hardware components."""',
        ])

        # Add hardware setup for each requirement
        for req in self.spec.hardware_requirements:
            comp_type = req.component_type
            lines.extend([
                f'        self.{comp_type} = self.config.get("{comp_type}")',
                f'        if not self.{comp_type}:',
                f'            logger.warning("No {comp_type} configured")',
            ])

        lines.extend([
            '',
            f'    def execute(self, input: {self.class_name}Input) -> {self.class_name}Output:',
            '        """',
            '        Execute the skill.',
            '        ',
            '        Args:',
            '            input: Skill input parameters',
            '        ',
            '        Returns:',
            '            Skill execution output with success status',
            '        """',
            '        import time',
            '        start_time = time.time()',
            '',
            '        # Validate input',
            f'        validation_errors = validate_{self.module_name}_input(input)',
            '        if validation_errors:',
            f'            return {self.class_name}Output(',
            '                success=False,',
            '                message=f"Input validation failed: {validation_errors}",',
            '                error_code="INPUT_VALIDATION_ERROR"',
            '            )',
            '',
            '        try:',
            '            # Execute skill logic',
            '            result = self._execute_impl(input)',
            '            execution_time = time.time() - start_time',
            '',
            '            # Build output',
            f'            output = {self.class_name}Output(',
            '                success=result.get("success", False),',
            '                message=result.get("message", ""),',
            '                execution_time=execution_time,',
        ])

        # Add success criteria outputs
        for criterion in self.spec.success_criteria:
            lines.append(f'                {criterion.name}=result.get("{criterion.name}", False),')

        lines.extend([
            '            )',
            '',
            '            # Validate output',
            f'            output_errors = validate_{self.module_name}_output(output)',
            '            if output_errors:',
            '                logger.warning(f"Output validation warnings: {output_errors}")',
            '',
            '            return output',
            '',
            '        except Exception as e:',
            '            execution_time = time.time() - start_time',
            '            logger.error(f"Skill execution failed: {e}")',
            f'            return {self.class_name}Output(',
            '                success=False,',
            '                message=str(e),',
            '                error_code="EXECUTION_ERROR",',
            '                execution_time=execution_time',
            '            )',
            '',
        ])

        # Generate implementation method
        lines.extend(self._generate_execute_impl())

        return lines

    def _generate_execute_impl(self) -> List[str]:
        """Generate the _execute_impl method with skill logic."""
        lines = [
            f'    def _execute_impl(self, input: {self.class_name}Input) -> Dict[str, Any]:',
            '        """',
            '        Internal skill implementation.',
            '        ',
            '        Override this method to customize skill behavior.',
            '        """',
            '        result = {"success": True, "message": ""}',
            '',
        ]

        # Generate execution flow from primitives
        if self.spec.execution_flow:
            lines.append('        # Execute primitive sequence')
            for i, call in enumerate(self.spec.execution_flow):
                lines.extend(self._generate_primitive_call(call, i))
        elif self.spec.primitives:
            # Default execution: call each primitive in order
            lines.append('        # Default execution sequence')
            for i, prim_name in enumerate(self.spec.primitives):
                call = PrimitiveCall(primitive=prim_name)
                lines.extend(self._generate_primitive_call(call, i))
        else:
            lines.extend([
                '        # TODO: Implement skill logic',
                '        logger.warning("Skill implementation not complete")',
            ])

        # Check success criteria
        lines.append('')
        lines.append('        # Evaluate success criteria')
        for criterion in self.spec.success_criteria:
            lines.extend([
                f'        result["{criterion.name}"] = self._check_{criterion.name}(input)',
            ])

        lines.extend([
            '',
            '        # Overall success is all criteria met',
            '        all_criteria = [',
        ])
        for criterion in self.spec.success_criteria:
            lines.append(f'            result.get("{criterion.name}", False),')
        lines.extend([
            '        ]',
            '        result["success"] = all(all_criteria) if all_criteria else True',
            '        result["message"] = "Skill completed successfully" if result["success"] else "Some criteria not met"',
            '',
            '        return result',
            '',
        ])

        # Generate success criterion check methods
        for criterion in self.spec.success_criteria:
            lines.extend([
                f'    def _check_{criterion.name}(self, input: {self.class_name}Input) -> bool:',
                f'        """Check if {criterion.name} criterion is met."""',
                f'        # Condition: {criterion.condition}',
            ])
            if criterion.tolerance is not None:
                lines.append(f'        # Tolerance: {criterion.tolerance}')
            lines.extend([
                '        # TODO: Implement criterion check',
                '        return True',
                '',
            ])

        return lines

    def _generate_primitive_call(self, call: PrimitiveCall, index: int) -> List[str]:
        """Generate code for a single primitive call."""
        lines = []

        # Add condition check if present
        if call.condition:
            lines.append(f'        if {call.condition}:')
            indent = '            '
        else:
            indent = '        '

        # Generate the primitive call
        prim = get_primitive(call.primitive)
        if prim:
            # Build parameter string
            params = []
            for param_name, param_value in call.parameters.items():
                if isinstance(param_value, str) and param_value.startswith('input.'):
                    params.append(f'{param_name}={param_value}')
                else:
                    params.append(f'{param_name}={repr(param_value)}')

            param_str = ', '.join(params)
            lines.append(f'{indent}step_{index}_result = self.primitives.{call.primitive}({param_str})')
        else:
            lines.append(f'{indent}# Unknown primitive: {call.primitive}')
            lines.append(f'{indent}step_{index}_result = True')

        # Handle failure
        if call.on_failure:
            lines.extend([
                f'{indent}if not step_{index}_result:',
            ])
            if call.on_failure == 'abort':
                lines.append(f'{indent}    raise RuntimeError("Primitive {call.primitive} failed")')
            elif call.on_failure == 'retry' and call.retries > 0:
                lines.extend([
                    f'{indent}    for retry in range({call.retries}):',
                    f'{indent}        step_{index}_result = self.primitives.{call.primitive}()',
                    f'{indent}        if step_{index}_result:',
                    f'{indent}            break',
                ])
            # 'continue' just continues execution

        lines.append('')
        return lines

    def generate_primitives_wrapper(self) -> str:
        """
        Generate primitives.py with hardware-abstracted primitive calls.

        Returns:
            Python source code for the primitives wrapper
        """
        lines = [
            '"""',
            f'Primitives wrapper for {self.spec.name} skill.',
            '',
            'Provides hardware-abstracted calls to robot primitives.',
            f'Generated by Skill Compiler v1.0.0',
            '"""',
            '',
            'from typing import Any, Dict, List, Optional',
            'import logging',
            '',
            '',
            'logger = logging.getLogger(__name__)',
            '',
            '',
            'class PrimitiveExecutor:',
            '    """',
            '    Execute primitives with hardware abstraction.',
            '    ',
            '    Wraps low-level hardware calls and provides a consistent interface.',
            '    """',
            '',
            '    def __init__(self, hardware_config: Dict[str, Any]):',
            '        """Initialize with hardware configuration."""',
            '        self.config = hardware_config',
            '        self._setup_drivers()',
            '',
            '    def _setup_drivers(self) -> None:',
            '        """Setup hardware drivers based on config."""',
        ]

        # Setup hardware drivers
        for req in self.spec.hardware_requirements:
            comp_type = req.component_type
            lines.extend([
                f'        self.{comp_type}_driver = self._get_{comp_type}_driver()',
            ])

        lines.append('')

        # Generate driver getter methods
        for req in self.spec.hardware_requirements:
            comp_type = req.component_type
            lines.extend([
                f'    def _get_{comp_type}_driver(self):',
                f'        """Get or create {comp_type} hardware driver."""',
                f'        config = self.config.get("{comp_type}", {{}})',
                f'        driver_type = config.get("driver", "mock")',
                '        # TODO: Implement driver factory',
                '        return MockDriver()',
                '',
            ])

        # Generate primitive methods
        for prim_name in self.spec.primitives:
            prim = get_primitive(prim_name)
            if prim:
                lines.extend(self._generate_primitive_method(prim))
            else:
                lines.extend([
                    f'    def {prim_name}(self, **kwargs) -> bool:',
                    f'        """Unknown primitive: {prim_name}"""',
                    f'        logger.warning("Primitive {prim_name} not implemented")',
                    '        return False',
                    '',
                ])

        # Add mock driver class
        lines.extend([
            '',
            'class MockDriver:',
            '    """Mock hardware driver for testing."""',
            '',
            '    def __getattr__(self, name):',
            '        def mock_method(*args, **kwargs):',
            '            logger.info(f"Mock call: {name}({args}, {kwargs})")',
            '            return True',
            '        return mock_method',
        ])

        return '\n'.join(lines)

    def _generate_primitive_method(self, prim) -> List[str]:
        """Generate a method for a single primitive."""
        lines = []

        # Build parameter list
        params = ['self']
        for param_name, param_def in prim.parameters.items():
            type_str = python_type(param_def.type)
            if param_def.required:
                params.append(f'{param_name}: {type_str}')
            else:
                default_val = repr(param_def.default)
                params.append(f'{param_name}: {type_str} = {default_val}')

        param_str = ', '.join(params)
        return_type = python_type(prim.returns)

        lines.extend([
            f'    def {prim.name}({param_str}) -> {return_type}:',
            f'        """',
            f'        {prim.description}',
            f'        ',
        ])

        # Document parameters
        for param_name, param_def in prim.parameters.items():
            lines.append(f'        Args:')
            lines.append(f'            {param_name}: {param_def.description}')

        lines.extend([
            f'        ',
            f'        Returns:',
            f'            {prim.returns}: Success status',
            f'        """',
            '        try:',
        ])

        # Generate hardware call based on primitive hardware requirements
        if 'arm' in prim.hardware:
            lines.append('            driver = self.arm_driver')
        elif 'gripper' in prim.hardware:
            lines.append('            driver = self.gripper_driver')
        elif prim.hardware:
            lines.append(f'            driver = self.{prim.hardware[0]}_driver')
        else:
            lines.append('            driver = None')

        # Generate the actual call
        param_names = list(prim.parameters.keys())
        call_args = ', '.join(f'{p}={p}' for p in param_names)

        lines.extend([
            f'            result = driver.{prim.name}({call_args})',
            '            return result',
            '        except Exception as e:',
            f'            logger.error(f"Primitive {prim.name} failed: {{e}}")',
            '            return False' if prim.returns == 'bool' else '            return None',
            '',
        ])

        return lines

    def generate_validators(self) -> str:
        """
        Generate validators.py for input/output validation.

        Returns:
            Python source code for validators
        """
        lines = [
            '"""',
            f'Validators for {self.spec.name} skill.',
            '',
            'Provides input and output validation.',
            f'Generated by Skill Compiler v1.0.0',
            '"""',
            '',
            'from typing import Any, Dict, List, Optional',
            '',
            '',
        ]

        # Import the input/output classes
        lines.extend([
            f'def validate_{self.module_name}_input(input) -> List[str]:',
            '    """',
            '    Validate skill input parameters.',
            '    ',
            '    Args:',
            '        input: Input dataclass instance',
            '    ',
            '    Returns:',
            '        List of validation errors (empty if valid)',
            '    """',
            '    errors = []',
            '',
        ])

        # Generate validation for each parameter
        for param in self.spec.parameters:
            if param.required and param.default is None:
                lines.extend([
                    f'    # Validate {param.name}',
                    f'    if input.{param.name} is None:',
                    f'        errors.append("{param.name} is required")',
                ])

            if param.range:
                min_val, max_val = param.range
                lines.extend([
                    f'    if input.{param.name} is not None:',
                    f'        if input.{param.name} < {min_val} or input.{param.name} > {max_val}:',
                    f'            errors.append("{param.name} must be between {min_val} and {max_val}")',
                ])

        lines.extend([
            '',
            '    return errors',
            '',
            '',
        ])

        # Output validation
        lines.extend([
            f'def validate_{self.module_name}_output(output) -> List[str]:',
            '    """',
            '    Validate skill output.',
            '    ',
            '    Args:',
            '        output: Output dataclass instance',
            '    ',
            '    Returns:',
            '        List of validation warnings',
            '    """',
            '    warnings = []',
            '',
            '    if output.success and not output.message:',
            '        warnings.append("Success output should have a message")',
            '',
            '    if not output.success and not output.error_code:',
            '        warnings.append("Failed output should have an error code")',
            '',
            '    return warnings',
        ])

        return '\n'.join(lines)

    def generate_state_machine(self) -> str:
        """
        Generate state_machine.py for execution flow.

        Returns:
            Python source code for state machine
        """
        lines = [
            '"""',
            f'State machine for {self.spec.name} skill execution.',
            '',
            'Manages execution flow and state transitions.',
            f'Generated by Skill Compiler v1.0.0',
            '"""',
            '',
            'from enum import Enum, auto',
            'from typing import Any, Callable, Dict, Optional',
            'import logging',
            '',
            '',
            'logger = logging.getLogger(__name__)',
            '',
            '',
            f'class {self.class_name}State(Enum):',
            '    """States for skill execution."""',
            '    IDLE = auto()',
            '    INITIALIZING = auto()',
        ]

        # Add states for each primitive
        for i, prim in enumerate(self.spec.primitives):
            state_name = prim.upper().replace('-', '_')
            lines.append(f'    {state_name} = auto()')

        lines.extend([
            '    VALIDATING = auto()',
            '    COMPLETED = auto()',
            '    FAILED = auto()',
            '',
            '',
            f'class {self.class_name}StateMachine:',
            '    """',
            '    State machine for managing skill execution flow.',
            '    """',
            '',
            '    def __init__(self):',
            f'        self.state = {self.class_name}State.IDLE',
            '        self.error: Optional[str] = None',
            '        self._transitions: Dict[tuple, Callable] = {}',
            '        self._setup_transitions()',
            '',
            '    def _setup_transitions(self) -> None:',
            '        """Define valid state transitions."""',
            f'        S = {self.class_name}State',
            '',
            '        # Define transitions',
            '        self._transitions = {',
            '            (S.IDLE, "start"): S.INITIALIZING,',
        ])

        # Add transitions between primitives
        prev_state = 'INITIALIZING'
        for prim in self.spec.primitives:
            state_name = prim.upper().replace('-', '_')
            lines.append(f'            (S.{prev_state}, "next"): S.{state_name},')
            prev_state = state_name

        lines.extend([
            f'            (S.{prev_state}, "next"): S.VALIDATING,',
            '            (S.VALIDATING, "success"): S.COMPLETED,',
            '            (S.VALIDATING, "failure"): S.FAILED,',
            '        }',
            '',
            '    def transition(self, event: str) -> bool:',
            '        """',
            '        Attempt to transition to a new state.',
            '        ',
            '        Args:',
            '            event: Event triggering the transition',
            '        ',
            '        Returns:',
            '            True if transition succeeded',
            '        """',
            '        key = (self.state, event)',
            '        if key in self._transitions:',
            '            old_state = self.state',
            '            self.state = self._transitions[key]',
            '            logger.info(f"State transition: {old_state} -> {self.state}")',
            '            return True',
            '        else:',
            '            logger.warning(f"Invalid transition: {self.state} + {event}")',
            '            return False',
            '',
            '    def reset(self) -> None:',
            '        """Reset state machine to initial state."""',
            f'        self.state = {self.class_name}State.IDLE',
            '        self.error = None',
            '',
            '    @property',
            '    def is_complete(self) -> bool:',
            '        """Check if execution is complete."""',
            f'        return self.state in ({self.class_name}State.COMPLETED, {self.class_name}State.FAILED)',
            '',
            '    @property',
            '    def is_success(self) -> bool:',
            '        """Check if execution succeeded."""',
            f'        return self.state == {self.class_name}State.COMPLETED',
        ])

        return '\n'.join(lines)

    def generate(self, output_dir: Path) -> Dict[str, str]:
        """
        Generate all skill code files.

        Args:
            output_dir: Directory to write files to

        Returns:
            Dict mapping filenames to generated content
        """
        output_dir = Path(output_dir)
        skill_dir = output_dir / self.module_name

        files = {
            'skill.py': self.generate_skill_class(),
            'primitives.py': self.generate_primitives_wrapper(),
            'validators.py': self.generate_validators(),
            'state_machine.py': self.generate_state_machine(),
            '__init__.py': self._generate_init(),
        }

        # Create directory and write files
        skill_dir.mkdir(parents=True, exist_ok=True)
        for filename, content in files.items():
            (skill_dir / filename).write_text(content)

        return files

    def _generate_init(self) -> str:
        """Generate __init__.py for the skill package."""
        return f'''"""
{self.spec.name} skill package.

{self.spec.description}
"""

from .skill import {self.class_name}Skill, {self.class_name}Input, {self.class_name}Output
from .primitives import PrimitiveExecutor
from .state_machine import {self.class_name}State, {self.class_name}StateMachine

__all__ = [
    "{self.class_name}Skill",
    "{self.class_name}Input",
    "{self.class_name}Output",
    "PrimitiveExecutor",
    "{self.class_name}State",
    "{self.class_name}StateMachine",
]

__version__ = "{self.spec.version}"
'''
