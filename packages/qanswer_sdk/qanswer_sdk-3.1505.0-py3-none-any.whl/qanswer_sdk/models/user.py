# coding: utf-8

"""
    QAnswer: Api Documentation

    APIs provided by QAnswer

    The version of the OpenAPI document: 1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional, Union
from typing_extensions import Annotated
from qanswer_sdk.models.logo import Logo
from qanswer_sdk.models.organization import Organization
from qanswer_sdk.models.role import Role
from qanswer_sdk.models.team import Team
from typing import Optional, Set
from typing_extensions import Self

class User(BaseModel):
    """
    User
    """ # noqa: E501
    id: Optional[StrictInt] = None
    name: Annotated[str, Field(min_length=0, strict=True, max_length=50)]
    username: Annotated[str, Field(min_length=0, strict=True, max_length=50)]
    email: Annotated[str, Field(min_length=0, strict=True, max_length=100)]
    password: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=100)]] = None
    origin: Optional[StrictStr] = None
    enabled: Optional[StrictBool] = None
    blocked: Optional[StrictBool] = None
    created: Optional[datetime] = None
    updated: Optional[datetime] = None
    last_login: Optional[datetime] = Field(default=None, alias="lastLogin")
    stripe_customer_id: Optional[StrictStr] = Field(default=None, alias="stripeCustomerId")
    pricing_plan: Optional[StrictStr] = Field(default=None, alias="pricingPlan")
    data_package: Optional[StrictInt] = Field(default=None, alias="dataPackage")
    pricing_plan_subscription: Optional[datetime] = Field(default=None, alias="pricingPlanSubscription")
    question_credits_start: Optional[datetime] = Field(default=None, alias="questionCreditsStart")
    question_credits_used: Optional[StrictInt] = Field(default=None, alias="questionCreditsUsed")
    quota_question_credits: Optional[StrictInt] = Field(default=None, alias="quotaQuestionCredits")
    quota_dataset_number: Optional[StrictInt] = Field(default=None, alias="quotaDatasetNumber")
    quota_dataset_space_mb: Optional[StrictInt] = Field(default=None, alias="quotaDatasetSpaceMb")
    credit_capacity: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="creditCapacity")
    credit_usage: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="creditUsage")
    language: Optional[StrictStr] = None
    running_out_of_quota_warned: Optional[StrictBool] = Field(default=None, alias="runningOutOfQuotaWarned")
    run_out_of_quota_warned: Optional[StrictBool] = Field(default=None, alias="runOutOfQuotaWarned")
    remove_branding: Optional[StrictBool] = Field(default=None, alias="removeBranding")
    roles: Optional[List[Role]] = None
    user_chatbot_setting: Optional[UserChatbotSetting] = Field(default=None, alias="userChatbotSetting")
    user_llm_features: Optional[UserLlmFeatures] = Field(default=None, alias="userLlmFeatures")
    logo: Optional[Logo] = None
    user_dataset: Optional[List[UserDataset]] = Field(default=None, alias="userDataset")
    user_dataset_shared: Optional[List[UserDatasetShared]] = Field(default=None, alias="userDatasetShared")
    favorite_dataset: Optional[List[UserDataset]] = Field(default=None, alias="favoriteDataset")
    llm_consumptions: Optional[List[LlmConsumption]] = Field(default=None, alias="llmConsumptions")
    embedder_consumptions: Optional[List[EmbedderConsumption]] = Field(default=None, alias="embedderConsumptions")
    authorized_team_accesses: Optional[List[SharedTeamAccess]] = Field(default=None, alias="authorizedTeamAccesses")
    requested_team_accesses: Optional[List[SharedTeamAccess]] = Field(default=None, alias="requestedTeamAccesses")
    authorized_organization_accesses: Optional[List[SharedOrganizationAccess]] = Field(default=None, alias="authorizedOrganizationAccesses")
    requested_organization_accesses: Optional[List[SharedOrganizationAccess]] = Field(default=None, alias="requestedOrganizationAccesses")
    verification_tokens: Optional[List[VerificationToken]] = Field(default=None, alias="verificationTokens")
    refresh_token: Optional[JwtRefreshToken] = Field(default=None, alias="refreshToken")
    teams: Optional[List[Team]] = None
    administered_teams: Optional[List[Team]] = Field(default=None, alias="administeredTeams")
    organizations: Optional[List[Organization]] = None
    administered_organizations: Optional[List[Organization]] = Field(default=None, alias="administeredOrganizations")
    user_logs: Optional[List[UserLog]] = Field(default=None, alias="userLogs")
    user_info: Optional[UserInfo] = Field(default=None, alias="userInfo")
    credit_quota_exceeded: Optional[StrictBool] = Field(default=None, alias="creditQuotaExceeded")
    __properties: ClassVar[List[str]] = ["id", "name", "username", "email", "password", "origin", "enabled", "blocked", "created", "updated", "lastLogin", "stripeCustomerId", "pricingPlan", "dataPackage", "pricingPlanSubscription", "questionCreditsStart", "questionCreditsUsed", "quotaQuestionCredits", "quotaDatasetNumber", "quotaDatasetSpaceMb", "creditCapacity", "creditUsage", "language", "runningOutOfQuotaWarned", "runOutOfQuotaWarned", "removeBranding", "roles", "userChatbotSetting", "userLlmFeatures", "logo", "userDataset", "userDatasetShared", "favoriteDataset", "llmConsumptions", "embedderConsumptions", "authorizedTeamAccesses", "requestedTeamAccesses", "authorizedOrganizationAccesses", "requestedOrganizationAccesses", "verificationTokens", "refreshToken", "teams", "administeredTeams", "organizations", "administeredOrganizations", "userLogs", "userInfo", "creditQuotaExceeded"]

    @field_validator('pricing_plan')
    def pricing_plan_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['NOT_LOGGED', 'FREE', 'BASIC', 'BASIC_DOLLAR', 'BASIC_ANNUAL', 'BASIC_ANNUAL_DOLLAR', 'PROFESSIONAL', 'PROFESSIONAL_DOLLAR', 'PROFESSIONAL_ANNUAL', 'PROFESSIONAL_ANNUAL_DOLLAR', 'CUSTOM', 'UNLIMITED']):
            raise ValueError("must be one of enum values ('NOT_LOGGED', 'FREE', 'BASIC', 'BASIC_DOLLAR', 'BASIC_ANNUAL', 'BASIC_ANNUAL_DOLLAR', 'PROFESSIONAL', 'PROFESSIONAL_DOLLAR', 'PROFESSIONAL_ANNUAL', 'PROFESSIONAL_ANNUAL_DOLLAR', 'CUSTOM', 'UNLIMITED')")
        return value

    @field_validator('language')
    def language_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['en', 'fr']):
            raise ValueError("must be one of enum values ('en', 'fr')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of User from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in roles (list)
        _items = []
        if self.roles:
            for _item_roles in self.roles:
                if _item_roles:
                    _items.append(_item_roles.to_dict())
            _dict['roles'] = _items
        # override the default output from pydantic by calling `to_dict()` of user_chatbot_setting
        if self.user_chatbot_setting:
            _dict['userChatbotSetting'] = self.user_chatbot_setting.to_dict()
        # override the default output from pydantic by calling `to_dict()` of user_llm_features
        if self.user_llm_features:
            _dict['userLlmFeatures'] = self.user_llm_features.to_dict()
        # override the default output from pydantic by calling `to_dict()` of logo
        if self.logo:
            _dict['logo'] = self.logo.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in user_dataset (list)
        _items = []
        if self.user_dataset:
            for _item_user_dataset in self.user_dataset:
                if _item_user_dataset:
                    _items.append(_item_user_dataset.to_dict())
            _dict['userDataset'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in user_dataset_shared (list)
        _items = []
        if self.user_dataset_shared:
            for _item_user_dataset_shared in self.user_dataset_shared:
                if _item_user_dataset_shared:
                    _items.append(_item_user_dataset_shared.to_dict())
            _dict['userDatasetShared'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in favorite_dataset (list)
        _items = []
        if self.favorite_dataset:
            for _item_favorite_dataset in self.favorite_dataset:
                if _item_favorite_dataset:
                    _items.append(_item_favorite_dataset.to_dict())
            _dict['favoriteDataset'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in llm_consumptions (list)
        _items = []
        if self.llm_consumptions:
            for _item_llm_consumptions in self.llm_consumptions:
                if _item_llm_consumptions:
                    _items.append(_item_llm_consumptions.to_dict())
            _dict['llmConsumptions'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in embedder_consumptions (list)
        _items = []
        if self.embedder_consumptions:
            for _item_embedder_consumptions in self.embedder_consumptions:
                if _item_embedder_consumptions:
                    _items.append(_item_embedder_consumptions.to_dict())
            _dict['embedderConsumptions'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in authorized_team_accesses (list)
        _items = []
        if self.authorized_team_accesses:
            for _item_authorized_team_accesses in self.authorized_team_accesses:
                if _item_authorized_team_accesses:
                    _items.append(_item_authorized_team_accesses.to_dict())
            _dict['authorizedTeamAccesses'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in requested_team_accesses (list)
        _items = []
        if self.requested_team_accesses:
            for _item_requested_team_accesses in self.requested_team_accesses:
                if _item_requested_team_accesses:
                    _items.append(_item_requested_team_accesses.to_dict())
            _dict['requestedTeamAccesses'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in authorized_organization_accesses (list)
        _items = []
        if self.authorized_organization_accesses:
            for _item_authorized_organization_accesses in self.authorized_organization_accesses:
                if _item_authorized_organization_accesses:
                    _items.append(_item_authorized_organization_accesses.to_dict())
            _dict['authorizedOrganizationAccesses'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in requested_organization_accesses (list)
        _items = []
        if self.requested_organization_accesses:
            for _item_requested_organization_accesses in self.requested_organization_accesses:
                if _item_requested_organization_accesses:
                    _items.append(_item_requested_organization_accesses.to_dict())
            _dict['requestedOrganizationAccesses'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in verification_tokens (list)
        _items = []
        if self.verification_tokens:
            for _item_verification_tokens in self.verification_tokens:
                if _item_verification_tokens:
                    _items.append(_item_verification_tokens.to_dict())
            _dict['verificationTokens'] = _items
        # override the default output from pydantic by calling `to_dict()` of refresh_token
        if self.refresh_token:
            _dict['refreshToken'] = self.refresh_token.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in teams (list)
        _items = []
        if self.teams:
            for _item_teams in self.teams:
                if _item_teams:
                    _items.append(_item_teams.to_dict())
            _dict['teams'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in administered_teams (list)
        _items = []
        if self.administered_teams:
            for _item_administered_teams in self.administered_teams:
                if _item_administered_teams:
                    _items.append(_item_administered_teams.to_dict())
            _dict['administeredTeams'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in organizations (list)
        _items = []
        if self.organizations:
            for _item_organizations in self.organizations:
                if _item_organizations:
                    _items.append(_item_organizations.to_dict())
            _dict['organizations'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in administered_organizations (list)
        _items = []
        if self.administered_organizations:
            for _item_administered_organizations in self.administered_organizations:
                if _item_administered_organizations:
                    _items.append(_item_administered_organizations.to_dict())
            _dict['administeredOrganizations'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in user_logs (list)
        _items = []
        if self.user_logs:
            for _item_user_logs in self.user_logs:
                if _item_user_logs:
                    _items.append(_item_user_logs.to_dict())
            _dict['userLogs'] = _items
        # override the default output from pydantic by calling `to_dict()` of user_info
        if self.user_info:
            _dict['userInfo'] = self.user_info.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of User from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "id": obj.get("id"),
            "name": obj.get("name"),
            "username": obj.get("username"),
            "email": obj.get("email"),
            "password": obj.get("password"),
            "origin": obj.get("origin"),
            "enabled": obj.get("enabled"),
            "blocked": obj.get("blocked"),
            "created": obj.get("created"),
            "updated": obj.get("updated"),
            "lastLogin": obj.get("lastLogin"),
            "stripeCustomerId": obj.get("stripeCustomerId"),
            "pricingPlan": obj.get("pricingPlan"),
            "dataPackage": obj.get("dataPackage"),
            "pricingPlanSubscription": obj.get("pricingPlanSubscription"),
            "questionCreditsStart": obj.get("questionCreditsStart"),
            "questionCreditsUsed": obj.get("questionCreditsUsed"),
            "quotaQuestionCredits": obj.get("quotaQuestionCredits"),
            "quotaDatasetNumber": obj.get("quotaDatasetNumber"),
            "quotaDatasetSpaceMb": obj.get("quotaDatasetSpaceMb"),
            "creditCapacity": obj.get("creditCapacity"),
            "creditUsage": obj.get("creditUsage"),
            "language": obj.get("language"),
            "runningOutOfQuotaWarned": obj.get("runningOutOfQuotaWarned"),
            "runOutOfQuotaWarned": obj.get("runOutOfQuotaWarned"),
            "removeBranding": obj.get("removeBranding"),
            "roles": [Role.from_dict(_item) for _item in obj["roles"]] if obj.get("roles") is not None else None,
            "userChatbotSetting": UserChatbotSetting.from_dict(obj["userChatbotSetting"]) if obj.get("userChatbotSetting") is not None else None,
            "userLlmFeatures": UserLlmFeatures.from_dict(obj["userLlmFeatures"]) if obj.get("userLlmFeatures") is not None else None,
            "logo": Logo.from_dict(obj["logo"]) if obj.get("logo") is not None else None,
            "userDataset": [UserDataset.from_dict(_item) for _item in obj["userDataset"]] if obj.get("userDataset") is not None else None,
            "userDatasetShared": [UserDatasetShared.from_dict(_item) for _item in obj["userDatasetShared"]] if obj.get("userDatasetShared") is not None else None,
            "favoriteDataset": [UserDataset.from_dict(_item) for _item in obj["favoriteDataset"]] if obj.get("favoriteDataset") is not None else None,
            "llmConsumptions": [LlmConsumption.from_dict(_item) for _item in obj["llmConsumptions"]] if obj.get("llmConsumptions") is not None else None,
            "embedderConsumptions": [EmbedderConsumption.from_dict(_item) for _item in obj["embedderConsumptions"]] if obj.get("embedderConsumptions") is not None else None,
            "authorizedTeamAccesses": [SharedTeamAccess.from_dict(_item) for _item in obj["authorizedTeamAccesses"]] if obj.get("authorizedTeamAccesses") is not None else None,
            "requestedTeamAccesses": [SharedTeamAccess.from_dict(_item) for _item in obj["requestedTeamAccesses"]] if obj.get("requestedTeamAccesses") is not None else None,
            "authorizedOrganizationAccesses": [SharedOrganizationAccess.from_dict(_item) for _item in obj["authorizedOrganizationAccesses"]] if obj.get("authorizedOrganizationAccesses") is not None else None,
            "requestedOrganizationAccesses": [SharedOrganizationAccess.from_dict(_item) for _item in obj["requestedOrganizationAccesses"]] if obj.get("requestedOrganizationAccesses") is not None else None,
            "verificationTokens": [VerificationToken.from_dict(_item) for _item in obj["verificationTokens"]] if obj.get("verificationTokens") is not None else None,
            "refreshToken": JwtRefreshToken.from_dict(obj["refreshToken"]) if obj.get("refreshToken") is not None else None,
            "teams": [Team.from_dict(_item) for _item in obj["teams"]] if obj.get("teams") is not None else None,
            "administeredTeams": [Team.from_dict(_item) for _item in obj["administeredTeams"]] if obj.get("administeredTeams") is not None else None,
            "organizations": [Organization.from_dict(_item) for _item in obj["organizations"]] if obj.get("organizations") is not None else None,
            "administeredOrganizations": [Organization.from_dict(_item) for _item in obj["administeredOrganizations"]] if obj.get("administeredOrganizations") is not None else None,
            "userLogs": [UserLog.from_dict(_item) for _item in obj["userLogs"]] if obj.get("userLogs") is not None else None,
            "userInfo": UserInfo.from_dict(obj["userInfo"]) if obj.get("userInfo") is not None else None,
            "creditQuotaExceeded": obj.get("creditQuotaExceeded")
        })
        return _obj

from qanswer_sdk.models.embedder_consumption import EmbedderConsumption
from qanswer_sdk.models.jwt_refresh_token import JwtRefreshToken
from qanswer_sdk.models.llm_consumption import LlmConsumption
from qanswer_sdk.models.shared_organization_access import SharedOrganizationAccess
from qanswer_sdk.models.shared_team_access import SharedTeamAccess
from qanswer_sdk.models.user_chatbot_setting import UserChatbotSetting
from qanswer_sdk.models.user_dataset import UserDataset
from qanswer_sdk.models.user_dataset_shared import UserDatasetShared
from qanswer_sdk.models.user_info import UserInfo
from qanswer_sdk.models.user_llm_features import UserLlmFeatures
from qanswer_sdk.models.user_log import UserLog
from qanswer_sdk.models.verification_token import VerificationToken
# TODO: Rewrite to not use raise_errors
User.model_rebuild(raise_errors=False)

