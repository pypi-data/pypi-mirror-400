{"version":3,"file":"LazyImage.vue_vue_type_script_setup_true_lang-g3Uhye0Z.js","sources":["../../../../../../../../../../../assets/images/default-template.png","../../../../../../ComfyUI_frontend/src/composables/useIntersectionObserver.ts","../../../../../../ComfyUI_frontend/src/services/mediaCacheService.ts","../../../../../../ComfyUI_frontend/src/components/common/LazyImage.vue"],"sourcesContent":["export default \"__VITE_PUBLIC_ASSET__c8cdd13f__\"","import { onBeforeUnmount, ref, watch } from 'vue'\nimport type { Ref } from 'vue'\n\ninterface UseIntersectionObserverOptions extends IntersectionObserverInit {\n  immediate?: boolean\n}\n\nexport function useIntersectionObserver(\n  target: Ref<Element | null>,\n  callback: IntersectionObserverCallback,\n  options: UseIntersectionObserverOptions = {}\n) {\n  const { immediate = true, ...observerOptions } = options\n\n  const isSupported =\n    typeof window !== 'undefined' && 'IntersectionObserver' in window\n  const isIntersecting = ref(false)\n\n  let observer: IntersectionObserver | null = null\n\n  const cleanup = () => {\n    if (observer) {\n      observer.disconnect()\n      observer = null\n    }\n  }\n\n  const observe = () => {\n    cleanup()\n\n    if (!isSupported || !target.value) return\n\n    observer = new IntersectionObserver((entries) => {\n      isIntersecting.value = entries.some((entry) => entry.isIntersecting)\n      callback(entries, observer!)\n    }, observerOptions)\n\n    observer.observe(target.value)\n  }\n\n  const unobserve = () => {\n    if (observer && target.value) {\n      observer.unobserve(target.value)\n    }\n  }\n\n  if (immediate) {\n    watch(target, observe, { immediate: true, flush: 'post' })\n  }\n\n  onBeforeUnmount(cleanup)\n\n  return {\n    isSupported,\n    isIntersecting,\n    observe,\n    unobserve,\n    cleanup\n  }\n}\n","import { reactive } from 'vue'\n\ninterface CachedMedia {\n  src: string\n  blob?: Blob\n  objectUrl?: string\n  error?: boolean\n  isLoading: boolean\n  lastAccessed: number\n}\n\ninterface MediaCacheOptions {\n  maxSize?: number\n  maxAge?: number // in milliseconds\n  preloadDistance?: number // pixels from viewport\n}\n\nclass MediaCacheService {\n  public cache = reactive(new Map<string, CachedMedia>())\n  private readonly maxSize: number\n  private readonly maxAge: number\n  private cleanupInterval: number | null = null\n  private urlRefCount = new Map<string, number>()\n\n  constructor(options: MediaCacheOptions = {}) {\n    this.maxSize = options.maxSize ?? 100\n    this.maxAge = options.maxAge ?? 30 * 60 * 1000 // 30 minutes\n\n    // Start cleanup interval\n    this.startCleanupInterval()\n  }\n\n  private startCleanupInterval() {\n    // Clean up every 5 minutes\n    this.cleanupInterval = window.setInterval(\n      () => {\n        this.cleanup()\n      },\n      5 * 60 * 1000\n    )\n  }\n\n  private cleanup() {\n    const now = Date.now()\n    const keysToDelete: string[] = []\n\n    // Find expired entries\n    for (const [key, entry] of Array.from(this.cache.entries())) {\n      if (now - entry.lastAccessed > this.maxAge) {\n        // Only revoke object URL if no components are using it\n        if (entry.objectUrl) {\n          const refCount = this.urlRefCount.get(entry.objectUrl) || 0\n          if (refCount === 0) {\n            URL.revokeObjectURL(entry.objectUrl)\n            this.urlRefCount.delete(entry.objectUrl)\n            keysToDelete.push(key)\n          }\n          // Don't delete cache entry if URL is still in use\n        } else {\n          keysToDelete.push(key)\n        }\n      }\n    }\n\n    // Remove expired entries\n    keysToDelete.forEach((key) => this.cache.delete(key))\n\n    // If still over size limit, remove oldest entries that aren't in use\n    if (this.cache.size > this.maxSize) {\n      const entries = Array.from(this.cache.entries())\n      entries.sort((a, b) => a[1].lastAccessed - b[1].lastAccessed)\n\n      let removedCount = 0\n      const targetRemoveCount = this.cache.size - this.maxSize\n\n      for (const [key, entry] of entries) {\n        if (removedCount >= targetRemoveCount) break\n\n        if (entry.objectUrl) {\n          const refCount = this.urlRefCount.get(entry.objectUrl) || 0\n          if (refCount === 0) {\n            URL.revokeObjectURL(entry.objectUrl)\n            this.urlRefCount.delete(entry.objectUrl)\n            this.cache.delete(key)\n            removedCount++\n          }\n        } else {\n          this.cache.delete(key)\n          removedCount++\n        }\n      }\n    }\n  }\n\n  async getCachedMedia(src: string): Promise<CachedMedia> {\n    let entry = this.cache.get(src)\n\n    if (entry) {\n      // Update last accessed time\n      entry.lastAccessed = Date.now()\n      return entry\n    }\n\n    // Create new entry\n    entry = {\n      src,\n      isLoading: true,\n      lastAccessed: Date.now()\n    }\n\n    // Update cache with loading entry\n    this.cache.set(src, entry)\n\n    try {\n      // Fetch the media\n      const response = await fetch(src, { cache: 'force-cache' })\n      if (!response.ok) {\n        throw new Error(`Failed to fetch: ${response.status}`)\n      }\n\n      const blob = await response.blob()\n      const objectUrl = URL.createObjectURL(blob)\n\n      // Update entry with successful result\n      const updatedEntry: CachedMedia = {\n        src,\n        blob,\n        objectUrl,\n        isLoading: false,\n        lastAccessed: Date.now()\n      }\n\n      this.cache.set(src, updatedEntry)\n      return updatedEntry\n    } catch (error) {\n      console.warn('Failed to cache media:', src, error)\n\n      // Update entry with error\n      const errorEntry: CachedMedia = {\n        src,\n        error: true,\n        isLoading: false,\n        lastAccessed: Date.now()\n      }\n\n      this.cache.set(src, errorEntry)\n      return errorEntry\n    }\n  }\n\n  acquireUrl(src: string): string | undefined {\n    const entry = this.cache.get(src)\n    if (entry?.objectUrl) {\n      const currentCount = this.urlRefCount.get(entry.objectUrl) || 0\n      this.urlRefCount.set(entry.objectUrl, currentCount + 1)\n      return entry.objectUrl\n    }\n    return undefined\n  }\n\n  releaseUrl(src: string): void {\n    const entry = this.cache.get(src)\n    if (entry?.objectUrl) {\n      const count = (this.urlRefCount.get(entry.objectUrl) || 1) - 1\n      if (count <= 0) {\n        URL.revokeObjectURL(entry.objectUrl)\n        this.urlRefCount.delete(entry.objectUrl)\n        // Remove from cache as well\n        this.cache.delete(src)\n      } else {\n        this.urlRefCount.set(entry.objectUrl, count)\n      }\n    }\n  }\n\n  clearCache() {\n    // Revoke all object URLs\n    for (const entry of Array.from(this.cache.values())) {\n      if (entry.objectUrl) {\n        URL.revokeObjectURL(entry.objectUrl)\n      }\n    }\n    this.cache.clear()\n    this.urlRefCount.clear()\n  }\n\n  destroy() {\n    if (this.cleanupInterval) {\n      clearInterval(this.cleanupInterval)\n      this.cleanupInterval = null\n    }\n    this.clearCache()\n  }\n}\n\n// Global instance\nlet mediaCacheInstance: MediaCacheService | null = null\n\nexport function useMediaCache(options?: MediaCacheOptions) {\n  if (!mediaCacheInstance) {\n    mediaCacheInstance = new MediaCacheService(options)\n  }\n\n  const getCachedMedia = (src: string) =>\n    mediaCacheInstance!.getCachedMedia(src)\n  const clearCache = () => mediaCacheInstance!.clearCache()\n  const acquireUrl = (src: string) => mediaCacheInstance!.acquireUrl(src)\n  const releaseUrl = (src: string) => mediaCacheInstance!.releaseUrl(src)\n\n  return {\n    getCachedMedia,\n    clearCache,\n    acquireUrl,\n    releaseUrl,\n    cache: mediaCacheInstance.cache\n  }\n}\n\n// Cleanup on page unload\nif (typeof window !== 'undefined') {\n  window.addEventListener('beforeunload', () => {\n    if (mediaCacheInstance) {\n      mediaCacheInstance.destroy()\n    }\n  })\n}\n","<template>\n  <div\n    ref=\"containerRef\"\n    class=\"relative flex h-full w-full items-center justify-center overflow-hidden\"\n    :class=\"containerClass\"\n  >\n    <Skeleton\n      v-if=\"!isImageLoaded\"\n      width=\"100%\"\n      height=\"100%\"\n      class=\"absolute inset-0\"\n    />\n    <img\n      v-if=\"cachedSrc\"\n      ref=\"imageRef\"\n      :src=\"cachedSrc\"\n      :alt=\"alt\"\n      draggable=\"false\"\n      :class=\"imageClass\"\n      :style=\"imageStyle\"\n      @load=\"onImageLoad\"\n      @error=\"onImageError\"\n    />\n    <div\n      v-if=\"hasError\"\n      class=\"absolute inset-0 flex items-center justify-center\"\n    >\n      <img\n        src=\"/assets/images/default-template.png\"\n        :alt=\"alt\"\n        draggable=\"false\"\n        :class=\"imageClass\"\n        :style=\"imageStyle\"\n      />\n    </div>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport Skeleton from 'primevue/skeleton'\nimport { computed, onUnmounted, ref, watch } from 'vue'\n\nimport { useIntersectionObserver } from '@/composables/useIntersectionObserver'\nimport { useMediaCache } from '@/services/mediaCacheService'\nimport type { ClassValue } from '@/utils/tailwindUtil'\n\nconst {\n  src,\n  alt = '',\n  containerClass = '',\n  imageClass = '',\n  imageStyle,\n  rootMargin = '300px'\n} = defineProps<{\n  src: string\n  alt?: string\n  containerClass?: ClassValue\n  imageClass?: ClassValue\n  imageStyle?: Record<string, any>\n  rootMargin?: string\n}>()\n\nconst containerRef = ref<HTMLElement | null>(null)\nconst imageRef = ref<HTMLImageElement | null>(null)\nconst isIntersecting = ref(false)\nconst isImageLoaded = ref(false)\nconst hasError = ref(false)\nconst cachedSrc = ref<string | undefined>(undefined)\n\nconst { getCachedMedia, acquireUrl, releaseUrl } = useMediaCache()\n\n// Use intersection observer to detect when the image container comes into view\nuseIntersectionObserver(\n  containerRef,\n  (entries) => {\n    const entry = entries[0]\n    isIntersecting.value = entry?.isIntersecting ?? false\n  },\n  {\n    rootMargin,\n    threshold: 0.1\n  }\n)\n\n// Only start loading the image when it's in view\nconst shouldLoad = computed(() => isIntersecting.value)\n\nwatch(\n  shouldLoad,\n  async (shouldLoadVal) => {\n    if (shouldLoadVal && src && !cachedSrc.value && !hasError.value) {\n      try {\n        const cachedMedia = await getCachedMedia(src)\n        if (cachedMedia.error) {\n          hasError.value = true\n        } else if (cachedMedia.objectUrl) {\n          const acquiredUrl = acquireUrl(src)\n          cachedSrc.value = acquiredUrl || cachedMedia.objectUrl\n        } else {\n          cachedSrc.value = src\n        }\n      } catch (error) {\n        console.warn('Failed to load cached media:', error)\n        cachedSrc.value = src\n      }\n    } else if (!shouldLoadVal) {\n      if (cachedSrc.value?.startsWith('blob:')) {\n        releaseUrl(src)\n      }\n      // Hide image when out of view\n      isImageLoaded.value = false\n      cachedSrc.value = undefined\n      hasError.value = false\n    }\n  },\n  { immediate: true }\n)\n\nconst onImageLoad = () => {\n  isImageLoaded.value = true\n  hasError.value = false\n}\n\nconst onImageError = () => {\n  hasError.value = true\n  isImageLoaded.value = false\n}\n\nonUnmounted(() => {\n  if (cachedSrc.value?.startsWith('blob:')) {\n    releaseUrl(src)\n  }\n})\n</script>\n"],"names":["_imports_0","useIntersectionObserver","target","callback","options","immediate","observerOptions","isSupported","isIntersecting","ref","observer","cleanup","__name","observe","entries","entry","unobserve","watch","onBeforeUnmount","MediaCacheService","reactive","now","keysToDelete","key","a","b","removedCount","targetRemoveCount","src","response","blob","objectUrl","updatedEntry","error","errorEntry","currentCount","count","mediaCacheInstance","useMediaCache","containerRef","imageRef","isImageLoaded","hasError","cachedSrc","getCachedMedia","acquireUrl","releaseUrl","__props","shouldLoad","computed","shouldLoadVal","cachedMedia","acquiredUrl","onImageLoad","onImageError","onUnmounted"],"mappings":"uYAAA,MAAeA,EAAA,gDCOR,SAASC,EACdC,EACAC,EACAC,EAA0C,CAAA,EAC1C,CACA,KAAM,CAAE,UAAAC,EAAY,GAAM,GAAGC,GAAoBF,EAE3CG,EACJ,OAAO,OAAW,KAAe,yBAA0B,OACvDC,EAAiBC,EAAI,EAAK,EAEhC,IAAIC,EAAwC,KAE5C,MAAMC,EAAUC,EAAA,IAAM,CAChBF,IACFA,EAAS,WAAW,EACTA,EAAA,KACb,EAJc,WAOVG,EAAUD,EAAA,IAAM,CACZD,IAEJ,GAACJ,GAAe,CAACL,EAAO,SAEjBQ,EAAA,IAAI,qBAAsBI,GAAY,CAC/CN,EAAe,MAAQM,EAAQ,KAAMC,GAAUA,EAAM,cAAc,EACnEZ,EAASW,EAASJ,CAAS,GAC1BJ,CAAe,EAETI,EAAA,QAAQR,EAAO,KAAK,EAAA,EAVf,WAaVc,EAAYJ,EAAA,IAAM,CAClBF,GAAYR,EAAO,OACZQ,EAAA,UAAUR,EAAO,KAAK,CACjC,EAHgB,aAMlB,OAAIG,GACFY,EAAMf,EAAQW,EAAS,CAAE,UAAW,GAAM,MAAO,OAAQ,EAG3DK,EAAgBP,CAAO,EAEhB,CACL,YAAAJ,EACA,eAAAC,EACA,QAAAK,EACA,UAAAG,EACA,QAAAL,CAAA,CAEJ,CApDgBC,EAAAX,EAAA,2BCUhB,MAAMkB,CAAkB,OAAA,CAAAP,EAAA,0BACf,MAAQQ,EAAa,IAAA,GAA0B,EACrC,QACA,OACT,gBAAiC,KACjC,gBAAkB,IAE1B,YAAYhB,EAA6B,GAAI,CACtC,KAAA,QAAUA,EAAQ,SAAW,IAClC,KAAK,OAASA,EAAQ,QAAU,GAAK,GAAK,IAG1C,KAAK,qBAAqB,CAC5B,CAEQ,sBAAuB,CAE7B,KAAK,gBAAkB,OAAO,YAC5B,IAAM,CACJ,KAAK,QAAQ,CACf,EACA,EAAI,GAAK,GAAA,CAEb,CAEQ,SAAU,CACV,MAAAiB,EAAM,KAAK,MACXC,EAAyB,CAAA,EAGpB,SAAA,CAACC,EAAKR,CAAK,IAAK,MAAM,KAAK,KAAK,MAAM,QAAQ,CAAC,EACpDM,EAAMN,EAAM,aAAe,KAAK,SAE9BA,EAAM,WACS,KAAK,YAAY,IAAIA,EAAM,SAAS,GAAK,KACzC,IACX,IAAA,gBAAgBA,EAAM,SAAS,EAC9B,KAAA,YAAY,OAAOA,EAAM,SAAS,EACvCO,EAAa,KAAKC,CAAG,GAIvBD,EAAa,KAAKC,CAAG,GAS3B,GAHAD,EAAa,QAASC,GAAQ,KAAK,MAAM,OAAOA,CAAG,CAAC,EAGhD,KAAK,MAAM,KAAO,KAAK,QAAS,CAClC,MAAMT,EAAU,MAAM,KAAK,KAAK,MAAM,SAAS,EACvCA,EAAA,KAAK,CAACU,EAAGC,IAAMD,EAAE,CAAC,EAAE,aAAeC,EAAE,CAAC,EAAE,YAAY,EAE5D,IAAIC,EAAe,EACnB,MAAMC,EAAoB,KAAK,MAAM,KAAO,KAAK,QAEjD,SAAW,CAACJ,EAAKR,CAAK,IAAKD,EAAS,CAClC,GAAIY,GAAgBC,EAAmB,MAEnCZ,EAAM,WACS,KAAK,YAAY,IAAIA,EAAM,SAAS,GAAK,KACzC,IACX,IAAA,gBAAgBA,EAAM,SAAS,EAC9B,KAAA,YAAY,OAAOA,EAAM,SAAS,EAClC,KAAA,MAAM,OAAOQ,CAAG,EACrBG,MAGG,KAAA,MAAM,OAAOH,CAAG,EACrBG,IAEJ,CACF,CACF,CAEA,MAAM,eAAeE,EAAmC,CACtD,IAAIb,EAAQ,KAAK,MAAM,IAAIa,CAAG,EAE9B,GAAIb,EAEI,OAAAA,EAAA,aAAe,KAAK,MACnBA,EAIDA,EAAA,CACN,IAAAa,EACA,UAAW,GACX,aAAc,KAAK,IAAI,CAAA,EAIpB,KAAA,MAAM,IAAIA,EAAKb,CAAK,EAErB,GAAA,CAEF,MAAMc,EAAW,MAAM,MAAMD,EAAK,CAAE,MAAO,cAAe,EACtD,GAAA,CAACC,EAAS,GACZ,MAAM,IAAI,MAAM,oBAAoBA,EAAS,MAAM,EAAE,EAGjD,MAAAC,EAAO,MAAMD,EAAS,OACtBE,EAAY,IAAI,gBAAgBD,CAAI,EAGpCE,EAA4B,CAChC,IAAAJ,EACA,KAAAE,EACA,UAAAC,EACA,UAAW,GACX,aAAc,KAAK,IAAI,CAAA,EAGpB,YAAA,MAAM,IAAIH,EAAKI,CAAY,EACzBA,QACAC,EAAO,CACN,QAAA,KAAK,yBAA0BL,EAAKK,CAAK,EAGjD,MAAMC,EAA0B,CAC9B,IAAAN,EACA,MAAO,GACP,UAAW,GACX,aAAc,KAAK,IAAI,CAAA,EAGpB,YAAA,MAAM,IAAIA,EAAKM,CAAU,EACvBA,CACT,CACF,CAEA,WAAWN,EAAiC,CAC1C,MAAMb,EAAQ,KAAK,MAAM,IAAIa,CAAG,EAChC,GAAIb,GAAO,UAAW,CACpB,MAAMoB,EAAe,KAAK,YAAY,IAAIpB,EAAM,SAAS,GAAK,EAC9D,YAAK,YAAY,IAAIA,EAAM,UAAWoB,EAAe,CAAC,EAC/CpB,EAAM,SACf,CAEF,CAEA,WAAWa,EAAmB,CAC5B,MAAMb,EAAQ,KAAK,MAAM,IAAIa,CAAG,EAChC,GAAIb,GAAO,UAAW,CACpB,MAAMqB,GAAS,KAAK,YAAY,IAAIrB,EAAM,SAAS,GAAK,GAAK,EACzDqB,GAAS,GACP,IAAA,gBAAgBrB,EAAM,SAAS,EAC9B,KAAA,YAAY,OAAOA,EAAM,SAAS,EAElC,KAAA,MAAM,OAAOa,CAAG,GAErB,KAAK,YAAY,IAAIb,EAAM,UAAWqB,CAAK,CAE/C,CACF,CAEA,YAAa,CAEX,UAAWrB,KAAS,MAAM,KAAK,KAAK,MAAM,OAAA,CAAQ,EAC5CA,EAAM,WACJ,IAAA,gBAAgBA,EAAM,SAAS,EAGvC,KAAK,MAAM,QACX,KAAK,YAAY,OACnB,CAEA,SAAU,CACJ,KAAK,kBACP,cAAc,KAAK,eAAe,EAClC,KAAK,gBAAkB,MAEzB,KAAK,WAAW,CAClB,CACF,CAGA,IAAIsB,EAA+C,KAE5C,SAASC,EAAclC,EAA6B,CACzD,OAAKiC,IACkBA,EAAA,IAAIlB,EAAkBf,CAAO,GAS7C,CACL,eAPqBQ,EAACgB,GACtBS,EAAoB,eAAeT,CAAG,EADjB,kBAQrB,WANiBhB,EAAA,IAAMyB,EAAoB,aAA1B,cAOjB,WANiBzB,EAACgB,GAAgBS,EAAoB,WAAWT,CAAG,EAAnD,cAOjB,WANiBhB,EAACgB,GAAgBS,EAAoB,WAAWT,CAAG,EAAnD,cAOjB,MAAOS,EAAmB,KAAA,CAE9B,CAlBgBzB,EAAA0B,EAAA,iBAqBZ,OAAO,OAAW,KACb,OAAA,iBAAiB,eAAgB,IAAM,CACxCD,GACFA,EAAmB,QAAQ,CAC7B,CACD,oWClKG,MAAAE,EAAe9B,EAAwB,IAAI,EAC3C+B,EAAW/B,EAA6B,IAAI,EAC5CD,EAAiBC,EAAI,EAAK,EAC1BgC,EAAgBhC,EAAI,EAAK,EACzBiC,EAAWjC,EAAI,EAAK,EACpBkC,EAAYlC,EAAwB,MAAS,EAE7C,CAAE,eAAAmC,EAAgB,WAAAC,EAAY,WAAAC,GAAeR,EAAc,EAGjErC,EACEsC,EACCzB,GAAY,CACL,MAAAC,EAAQD,EAAQ,CAAC,EACRN,EAAA,MAAQO,GAAO,gBAAkB,EAClD,EACA,CACE,WAAUgC,EAAA,WACV,UAAW,EACb,CAAA,EAIF,MAAMC,EAAaC,EAAS,IAAMzC,EAAe,KAAK,EAEtDS,EACE+B,EACA,MAAOE,GAAkB,CACnB,GAAAA,GAAiBH,EAAA,KAAO,CAACJ,EAAU,OAAS,CAACD,EAAS,MACpD,GAAA,CACF,MAAMS,EAAc,MAAMP,EAAeG,EAAG,GAAA,EAC5C,GAAII,EAAY,MACdT,EAAS,MAAQ,WACRS,EAAY,UAAW,CAC1B,MAAAC,EAAcP,EAAWE,EAAG,GAAA,EACxBJ,EAAA,MAAQS,GAAeD,EAAY,SAAA,MAE7CR,EAAU,MAAQI,EAAA,UAEbd,EAAO,CACN,QAAA,KAAK,+BAAgCA,CAAK,EAClDU,EAAU,MAAQI,EAAA,GACpB,MACUG,IACNP,EAAU,OAAO,WAAW,OAAO,GACrCG,EAAWC,EAAG,GAAA,EAGhBN,EAAc,MAAQ,GACtBE,EAAU,MAAQ,OAClBD,EAAS,MAAQ,GAErB,EACA,CAAE,UAAW,EAAK,CAAA,EAGpB,MAAMW,EAAczC,EAAA,IAAM,CACxB6B,EAAc,MAAQ,GACtBC,EAAS,MAAQ,EAAA,EAFC,eAKdY,EAAe1C,EAAA,IAAM,CACzB8B,EAAS,MAAQ,GACjBD,EAAc,MAAQ,EAAA,EAFH,gBAKrB,OAAAc,EAAY,IAAM,CACZZ,EAAU,OAAO,WAAW,OAAO,GACrCG,EAAWC,EAAG,GAAA,CAChB,CACD"}