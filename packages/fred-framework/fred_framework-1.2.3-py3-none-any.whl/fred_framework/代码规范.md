# 代码规范文档

## 目录

1. [项目结构规范](#1-项目结构规范)
2. [后端代码规范](#2-后端代码规范)
3. [前端代码规范](#3-前端代码规范)
4. [命名规范](#4-命名规范)
5. [国际化规范](#5-国际化规范)
6. [最佳实践](#6-最佳实践)
7. [Git 提交流程规范](#7-git-提交流程规范)

---

## 1. 项目结构规范

### 1.1 目录结构

Fred Framework 项目通过 `fred-init` 命令自动创建标准目录结构：

```
项目根目录/
├─ model/                    # 数据模型目录（由 fred-init 自动创建）
│   ├─ __init__.py
│   └─ model.py             # 数据库模型文件（系统自动生成，不要修改）
├─ config/                   # 配置文件目录（由 fred-init 自动创建）
│   ├─ __init__.py
│   └─ Config.py            # 项目配置文件（从框架复制，可自定义）
├─ translations/             # 国际化翻译文件目录（由 fred-init 自动创建）
│   ├─ zh/                   # 中文翻译文件
│   └─ en/                   # 英文翻译文件
├─ scheduler/                # 定时任务目录（由 fred-init 自动创建）
│   ├─ __init__.py
│   └─ tasks.py              # 定时任务定义（可选）
├─ docs/                     # 文档目录（由 fred-init 自动创建）
│   ├─ FRED_COMMANDS.md      # 命令使用文档
│   └─ 代码规范.md           # 代码规范文档（本文档）
├─ frontend/                 # 前端目录（由 fred-init 从 demo/frontend 复制）
│   ├─ src/                  # 前端源代码
│   ├─ public/               # 静态资源
│   └─ package.json          # 前端依赖配置
├─ {模块名}/                  # 业务模块目录（由 fred-create 创建）
│   ├─ __init__.py           # Blueprint 定义
│   ├─ controller/           # 控制器目录
│   │   ├─ __init__.py       # 路由控制和用户验证
│   │   └─ {ModuleName}Controller.py
│   ├─ service/              # 服务层目录
│   │   ├─ __init__.py
│   │   └─ {ModuleName}Service.py
│   ├─ schema/               # Schema 定义目录
│   │   ├─ __init__.py
│   │   └─ {ModuleName}Schema.py
│   └─ model/                # 模块数据模型（可选）
│       └─ {ModuleName}Model.py
├─ run.py                    # 项目运行文件（由 fred-init 自动创建）
├─ requirements.txt          # Python 依赖文件（由 fred-init 自动创建）
└─ .gitignore                # Git 忽略文件（由 fred-init 自动创建）
```

### 1.2 各目录职责说明

#### 1.2.1 框架自动创建的目录

- **model/**: 数据库模型目录
  - 存放 SQLAlchemy 模型定义
  - 存放数据模型相关的业务逻辑
  - 存放模型验证和序列化相关代码
  - **注意**：`model/model.py` 由系统自动生成，禁止手动修改

- **config/**: 配置文件目录
  - 存放自定义配置类（继承自 `fred_framework.config.Config`）
  - 存放环境相关的配置文件
  - 存放敏感信息配置文件（建议加入 `.gitignore`）
  - `Config.py` 从框架复制而来，可自定义配置项

- **translations/**: 国际化翻译文件目录
  - 存放 Babel 翻译文件（.po, .mo）
  - 支持多语言切换
  - 配合 `flask_babelplus` 使用

- **scheduler/**: 定时任务目录
  - 存放 APScheduler 定时任务函数
  - 存放任务调度相关配置
  - 存放任务执行逻辑

- **docs/**: 文档目录
  - 存放所有项目文档（Markdown 格式）
  - 包含项目说明、命令使用、代码规范等文档

- **frontend/**: 前端目录
  - 前端源代码目录（从 `demo/frontend` 复制）
  - 包含 Vue 3 + TypeScript 前端项目
  - 前端打包后的静态文件可放在模块的 `templates/` 目录

#### 1.2.2 业务模块目录（由 fred-create 创建）

- **controller/**: 控制器目录
  - 只负责路由控制和参数传递，不包含业务逻辑
  - 使用 `MethodView` 实现 RESTful 接口

- **service/**: 服务层目录
  - 实现所有业务逻辑和数据库操作
  - 使用实例方法，不使用静态方法装饰器

- **schema/**: Schema 定义目录
  - 使用 marshmallow 进行请求参数验证和响应数据格式化
  - 定义输入参数验证（Query Schema）和输出参数验证（Response Schema）

- **model/**: 模块数据模型目录（可选）
  - 存放模块特定的数据模型
  - 与根目录的 `model/` 目录配合使用

### 1.3 新建项目流程

#### 1.3.1 初始化项目

使用 `fred-init` 命令初始化项目：

```bash
# 1. 安装框架
pip install fred_framework

# 2. 创建项目目录
mkdir my_project
cd my_project

# 3. 初始化项目（自动创建目录结构和配置文件）
fred-init
```

`fred-init` 命令会自动创建以下内容：
- 项目目录结构（`model/`, `config/`, `translations/`, `scheduler/`, `docs/`）
- `run.py` 应用启动文件
- `config/Config.py` 配置文件（从框架复制）
- `requirements.txt` 依赖文件
- `.gitignore` Git 忽略文件
- `frontend/` 前端目录（从 `demo/frontend` 复制）
- `docs/` 目录下的文档文件

#### 1.3.2 创建业务模块

使用 `fred-create` 命令创建新的业务模块：

```bash
# 创建名为 user 的模块
fred-create user

# 创建名为 user_management 的模块（支持下划线）
fred-create user_management
```

`fred-create` 命令会自动创建模块的完整目录结构和基础文件：
- `__init__.py` - Blueprint 定义
- `controller/` - 控制器目录和文件
- `service/` - 服务层目录和文件
- `schema/` - Schema 定义目录和文件
- `model/` - 数据模型目录和文件（可选）

#### 1.3.3 配置项目

**后端配置：**
- 修改 `config/Config.py` 中的配置项（如数据库连接、项目根目录等）
- 修改模块 `__init__.py` 文件中的蓝图变量名和路由地址，使其与目录名一致

**前端配置：**
- 修改 `frontend/src/api/config/servicePort.ts` 中的 `PORT1`（后端接口统一前缀）
- 修改 `frontend/src/.env.development` 文件中的 `VITE_PROXY` 为 `http://127.0.0.1:5000`
- 修改 `frontend/src/.env` 文件中的 `VITE_GLOB_APP_TITLE` 为项目中文名字
- 修改 `frontend/src/vite.config.ts` 文件中的 `outDir` 配置（如需要）
- 修改 `frontend/src/views/login/index.vue` 文件中的项目名称显示

#### 1.3.4 启动项目

```bash
# 启动开发服务器
python run.py
```

**详细命令说明请参考：** `docs/FRED_COMMANDS.md`

---

## 2. 后端代码规范

### 2.1 Controller层规范

#### 2.1.1 基本结构

Controller层只负责路由控制和参数传递，不包含业务逻辑。

**文件头部引入规范：**
```python
# python3.11
# -*- coding: utf-8 -*-
"""
 @author: 作者名
 @date: 日期
 @desc: 描述
"""
from flask.views import MethodView
from flask_babelplus import gettext

from {模块名} import {模块名}  # 导入对应的蓝图（模块名由 fred-create 创建时确定）
from {模块名}.controller import {模块名}_required  # 权限装饰器
from {模块名}.schema.{ModuleName}Schema import {ModuleName}Query, {ModuleName}Response  # Schema导入
from {模块名}.service.{ModuleName}Service import {ModuleName}Service  # Service导入
from fred_framework.common.PageSchema import PageSchemaFactory  # 分页Schema（如需要）
```

**注意**：
- `{模块名}` 为实际模块目录名（如：`user`, `admin` 等）
- `{ModuleName}` 为模块名的首字母大写格式（如：`User`, `Admin` 等）
- 实际使用时请替换为具体的模块名和类名

#### 2.1.2 路由定义

使用 `@{模块名}.route()` 装饰器定义路由，使用 `MethodView` 类实现RESTful接口：

```python
@{模块名}.route("/resource/path")
class ResourceController(MethodView):
    @{模块名}_required
    @{模块名}.arguments(QuerySchema, location='query')  # GET请求使用location='query'
    @{模块名}.response(200, PageSchemaFactory(ResponseSchema))  # 分页响应
    def get(self, args):
        """
        查询资源列表
        """
        return ResourceService().get_list(args)

    @{模块名}_required
    @{模块名}.arguments(SaveSchema)  # POST/PUT请求不需要location参数
    @{模块名}.response(200)
    def post(self, args):
        """
        新增资源
        """
        ResourceService().save(args)
        return {'message':gettext("保存成功")}

    @{模块名}_required
    @{模块名}.arguments(SaveSchema)
    @{模块名}.response(200)
    def put(self, args):
        """
        更新资源
        """
        ResourceService().save(args)
        return {'message':gettext("保存成功")}

    @{模块名}_required
    @{模块名}.arguments(DeleteSchema, location='query')  # DELETE请求使用location='query'
    @{模块名}.response(200)
    def delete(self, args):
        """
        删除资源
        """
        ResourceService().delete(args)
        return {'message':gettext("保存成功")}
```

**注意**：`{模块名}` 为实际模块目录名，实际使用时请替换为具体的模块名（如：`admin`, `user` 等）

#### 2.1.3 请求方法使用规范

- **GET**: 查询数据，使用 `location='query'` 传递查询参数
- **POST**: 新增数据，参数在请求体中
- **PUT**: 更新数据，参数在请求体中
- **DELETE**: 删除数据，使用 `location='query'` 传递删除参数
- **PATCH**: 部分更新或特殊操作（如恢复），参数在请求体中

#### 2.1.4 权限验证

所有接口必须使用 `@{模块名}_required` 装饰器进行权限验证（如：`@admin_required`, `@user_required` 等）。

#### 2.1.5 返回数据格式

- Controller直接返回数据，框架会自动封装为 `{"code": 200, "data": 返回的数据, "message": "提示信息"}`
- 成功消息使用 `gettext()` 进行国际化处理
- 分页数据返回格式：
```python
return {
    "total": pagination.total,
    "records": records,
    "pageNum": pagination.page,
    "pageSize": pagination.per_page
}
```

#### 2.1.6 异常处理

Controller层不进行异常处理，异常由Service层抛出，全局异常处理器统一处理。

**参考文件：** `{模块名}/controller/{ModuleName}Controller.py`（示例路径，实际项目中模块名可能不同）

### 2.2 Service层规范

#### 2.2.1 基本结构

Service层实现所有业务逻辑和数据库操作。

**文件头部引入规范：**
```python
# python3.11
# -*- coding: utf-8 -*-
"""
 @author: 作者名
 @date: 日期
 @desc: 描述
"""
from datetime import datetime
from flask import abort, current_app
from flask_babelplus import gettext

from model.model import XXXModel, db  # 导入数据库模型
from fred_framework.common.Utils import Utils  # 工具类
```

#### 2.2.2 类定义

使用类定义Service，**不要使用静态方法装饰器（`@staticmethod`）**：

```python
class ResourceService:
    """
    Resource业务逻辑服务
    """

    def get_list(self, args):
        """
        获取资源列表
        """
        # 业务逻辑实现
        pass

    def save(self, args):
        """
        保存资源（新增或更新）
        """
        # 业务逻辑实现
        pass
```

**注意：** Service中的方法应该定义为实例方法，通过 `self` 访问。虽然现有代码中可能还有使用 `@staticmethod` 的情况，但新代码必须遵循不使用静态方法装饰器的规范。

#### 2.2.3 数据库操作

- 使用 `model` 目录中的模型进行数据库操作
- 禁止直接修改 `model` 目录中的文件
- 使用 SQLAlchemy ORM 进行数据库操作

**示例：**
```python
from model.model import ResourceModel, db

# 查询
query = ResourceModel.query
if name:
    query = query.filter(ResourceModel.name.like(f"%{name}%"))
data = query.paginate(page=page, per_page=per_page)

# 新增
new_resource = ResourceModel(**args)
db.session.add(new_resource)
db.session.commit()

# 更新
resource = ResourceModel.query.get(id)
if resource:
    for key, value in args.items():
        setattr(resource, key, value)
    db.session.commit()

# 删除（逻辑删除）
resource = ResourceModel.query.get(id)
if resource:
    resource.deleted = 1
    resource.modified = datetime.now()
    db.session.commit()
```

#### 2.2.4 异常处理

Service层使用 `abort()` 抛出异常，不使用 `try-except`：

```python
# 正确示例
if not resource:
    abort(400, gettext("资源不存在"))

if ResourceModel.query.filter(ResourceModel.name == name, ResourceModel.id != id).first():
    abort(500, gettext("资源名称已存在"))

# 错误示例（不要使用）
try:
    # 业务逻辑
except Exception as e:
    # 异常处理
```

**异常格式：**
- 使用 `abort(500, '错误消息')` 格式
- 错误码始终使用 500（框架会自动处理）
- 错误消息使用 `gettext()` 进行国际化处理

#### 2.2.5 函数拆分原则

- 每个函数不超过100行
- 根据业务逻辑独立成函数
- 函数职责单一，避免函数过大

**示例：**
```python
def save_resource(self, args):
    """
    保存资源
    """
    # 参数验证
    self._validate_args(args)

    # 检查重复
    self._check_duplicate(args)

    # 保存数据
    return self._do_save(args)

def _validate_args(self, args):
    """
    验证参数
    """
    if not args.get('name'):
        abort(500, gettext("名称不能为空"))

def _check_duplicate(self, args):
    """
    检查重复
    """
    # 检查逻辑
    pass

def _do_save(self, args):
    """
    执行保存
    """
    # 保存逻辑
    pass
```

#### 2.2.6 返回数据格式

Service层直接返回数据，不需要封装：

```python
# 返回单个对象
return Utils.query_to_dict(resource)

# 返回列表
return Utils.query_to_dict_list(resources)

# 返回分页数据
return {
    "total": pagination.total,
    "records": records,
    "pageNum": pagination.page,
    "pageSize": pagination.per_page
}

# 返回成功消息
return gettext("操作成功")
```

**参考文件：** `{模块名}/service/{ModuleName}Service.py`（示例路径，实际项目中模块名可能不同）

### 2.3 Schema层规范

#### 2.3.1 基本结构

Schema层使用marshmallow 4.0+进行参数验证。

**文件头部规范：**
```python
# coding: utf-8
from marshmallow import Schema, fields

"""
 * @Author：作者名
 * @Package：Schema包名
 * @Project：项目名
 * @name：Schema名称
 * @Date：日期
 * @Filename：文件名
"""
```

#### 2.3.2 输入参数验证（Query Schema）

用于验证请求参数：

```python
class ResourceListQuery(Schema):
    """
    查询参数及验证
    """
    name = fields.String(metadata={'description': '资源名称'})
    status = fields.Int(metadata={'description': '状态'})
    pageSize = fields.Int(load_default=10, metadata={'description': '每页数量'})
    pageNum = fields.Int(required=False, load_default=1, metadata={'description': '页码'})


class ResourceSaveQuery(Schema):
    """
    保存参数及验证
    """
    id = fields.Integer(load_default=0)
    name = fields.String(required=True, metadata={'description': '资源名称'})
    desc = fields.String(required=True, metadata={'description': '描述'})
    status = fields.Integer(required=True, metadata={'description': '状态'})


class ResourceDeleteQuery(Schema):
    """
    删除参数及验证
    """
    id = fields.Integer(required=True)
    deleted = fields.Integer(required=True)
```

#### 2.3.3 输出参数验证（Response Schema）

用于格式化响应数据：

```python
class ResourceListResponse(Schema):
    """
    输出参数
    """
    id = fields.Int()
    name = fields.Str(metadata={'description': '资源名称'})
    desc = fields.Str(metadata={'description': '描述'})
    status = fields.Int(metadata={'description': '状态'})
    created = fields.DateTime(format='%Y-%m-%d %H:%M:%S', metadata={'description': '创建时间'})
    modified = fields.DateTime(format='%Y-%m-%d %H:%M:%S', metadata={'description': '修改时间'})
```

#### 2.3.4 嵌套Schema

对于复杂数据结构，使用嵌套Schema：

```python
class FieldResponseSchema(Schema):
    """
    字段参数
    """
    id = fields.Int()
    field_name = fields.Str(required=True, metadata={'description': '字段名'})
    field_type = fields.Int(required=True, metadata={'description': '字段类型'})


class ResourceListResponse(Schema):
    """
    输出参数
    """
    id = fields.Int()
    name = fields.Str(metadata={'description': '资源名称'})
    field = fields.List(fields.Nested(FieldResponseSchema, metadata={'description': '字段列表'}))
```

#### 2.3.5 字段类型说明

- `fields.String`: 字符串类型
- `fields.Integer` / `fields.Int`: 整数类型
- `fields.Float`: 浮点数类型
- `fields.Boolean`: 布尔类型
- `fields.DateTime`: 日期时间类型（需要指定format）
- `fields.List`: 列表类型
- `fields.Nested`: 嵌套Schema类型

**参考文件：** `{模块名}/schema/{ModuleName}Schema.py`（示例路径，实际项目中模块名可能不同）

### 2.4 通用规范

#### 2.4.1 文件编码

- 所有Python文件使用UTF-8编码
- 文件头部添加编码声明：`# -*- coding: utf-8 -*-`

#### 2.4.2 引入文件位置

所有引入语句写在文件头部位置，按以下顺序组织：
1. 标准库导入
2. 第三方库导入
3. 项目内部导入

#### 2.4.3 注释规范

- 类和方法必须添加文档字符串
- 复杂逻辑添加行内注释
- 使用中文注释

#### 2.4.4 代码风格

- 使用4个空格缩进（不使用Tab）
- 行长度不超过120字符
- 函数和类之间空2行
- 方法之间空1行

---

## 3. 前端代码规范

### 3.1 组件化要求

前端代码必须使用组件模式，将接口和CSS单独存放，避免文件过大。

**参考文件：** `frontend/src/views/system/menuManage`（示例路径，实际项目中路径可能不同）

#### 3.1.1 目录结构

```
views/
  └─ resource/
      ├─ index.vue          # 主组件
      └─ components/        # 子组件目录
          ├─ ResourceDrawer.vue
          └─ ResourceForm.vue
```

#### 3.1.2 主组件结构

主组件负责页面布局和主要逻辑：

```vue
<template>
  <div class="table-box">
    <ProTable
      ref="proTable"
      :columns="columns"
      :request-api="getResourceList"
    >
      <!-- 表格内容 -->
    </ProTable>
    <ResourceDrawer ref="drawerRef" />
  </div>
</template>

<script setup lang="ts">
import { ref } from "vue";
import { getResourceList } from "@/api/modules/resource";
import ResourceDrawer from "./components/ResourceDrawer.vue";

// 业务逻辑
</script>

<style scoped lang="scss">
// 样式
</style>
```

#### 3.1.3 子组件结构

子组件负责特定功能模块：

```vue
<template>
  <el-drawer v-model="drawerVisible" :title="drawerProps.title">
    <!-- 表单内容 -->
  </el-drawer>
</template>

<script setup lang="ts">
import { ref, reactive } from "vue";
// 组件逻辑
</script>

<style scoped lang="scss">
// 样式
</style>
```

### 3.2 接口调用规范

#### 3.2.1 API文件组织

接口调用统一放在 `frontend/src/api/modules` 目录下：

```typescript
// frontend/src/api/modules/resource.ts
import { ResPage } from "@/api/interface";
import { PORT1 } from "@/api/config/servicePort";
import http from "@/api";
import type { ResourceInfo, ResourceQuery } from "@/api/model/resourceModel";

/**
 * 资源管理相关接口
 */

export const getResourceList = (params?: ResourceQuery) => {
  return http.get<ResPage<ResourceInfo>>(PORT1 + `/resource/list`, params || {});
};

export const addResource = (params: ResourceInfo) => {
  return http.post(PORT1 + `/resource/save`, params);
};

export const editResource = (params: ResourceInfo) => {
  return http.put(PORT1 + `/resource/save`, params);
};

export const deleteResource = (params: { id: string }) => {
  return http.delete(PORT1 + `/resource/delete`, params);
};
```

#### 3.2.2 接口调用方式

在组件中使用接口：

```typescript
import { getResourceList, addResource } from "@/api/modules/resource";
// 注意：@/ 别名指向 frontend/src 目录

// 查询列表
const getTableList = async (params: any) => {
  const { data } = await getResourceList(params);
  return data;
};

// 新增
const handleAdd = async (params: ResourceInfo) => {
  await addResource(params);
  ElMessage.success("保存成功");
};
```

### 3.3 代码检查与格式化

#### 3.3.1 代码检查

修改代码后必须执行代码检查：

```bash
cd frontend
pnpm lint:eslint
```

#### 3.3.2 代码格式化

无论代码检查是否有错误，都必须执行格式化：

```bash
cd frontend
pnpm lint:prettier
```

### 3.4 TypeScript规范

#### 3.4.1 类型定义

所有接口参数和返回值必须定义类型：

```typescript
// frontend/src/api/model/resourceModel.ts
export interface ResourceInfo {
  id?: number;
  name: string;
  desc: string;
  status: number;
  created?: string;
  modified?: string;
}

export interface ResourceQuery {
  name?: string;
  status?: number;
  pageNum?: number;
  pageSize?: number;
}
```

#### 3.4.2 组件类型

使用TypeScript定义组件props和emits：

```typescript
interface DrawerProps {
  title: string;
  row: ResourceInfo;
  isView?: boolean;
}

const drawerProps = ref<DrawerProps>({
  title: "",
  row: {} as ResourceInfo,
  isView: false
});
```

### 3.5 Vue 3 Composition API规范

#### 3.5.1 使用setup语法

优先使用 `<script setup lang="ts">` 语法：

```vue
<script setup lang="ts">
import { ref, reactive, computed, onMounted } from "vue";

const count = ref(0);
const form = reactive({
  name: "",
  desc: ""
});

const handleSubmit = () => {
  // 提交逻辑
};
</script>
```

#### 3.5.2 响应式数据

- 使用 `ref` 定义基本类型响应式数据
- 使用 `reactive` 定义对象类型响应式数据
- 使用 `computed` 定义计算属性

### 3.6 样式规范

#### 3.6.1 样式文件组织

- 使用 `scoped` 作用域样式
- 复杂样式可以提取到单独的 `.scss` 文件
- 使用 `lang="scss"` 支持SCSS语法

#### 3.6.2 样式命名

使用BEM命名规范或语义化命名：

```scss
.table-box {
  padding: 20px;

  .table-header {
    margin-bottom: 20px;
  }
}
```

---

## 4. 命名规范

### 4.1 文件命名

#### 4.1.1 Python文件

- 使用大驼峰命名（PascalCase）：`ResourceController.py`, `ResourceService.py`, `ResourceSchema.py`
- Controller文件：`XXXController.py`
- Service文件：`XXXService.py`
- Schema文件：`XXXSchema.py`

#### 4.1.2 前端文件

- Vue组件文件：使用大驼峰命名：`ResourceManage.vue`
- TypeScript文件：使用小驼峰命名：`resourceModel.ts`
- 目录名：使用小写字母和连字符：`resource-manage`

### 4.2 类命名

- 使用大驼峰命名（PascalCase）
- Controller类：`ResourceController`
- Service类：`ResourceService`
- Schema类：`ResourceListQuery`, `ResourceSaveQuery`, `ResourceListResponse`

### 4.3 函数命名

#### 4.3.1 后端函数

- 使用小写字母和下划线：`get_resource_list`, `save_resource`, `delete_resource`
- 私有方法使用单下划线前缀：`_validate_args`, `_check_duplicate`

#### 4.3.2 前端函数

- 使用小驼峰命名：`getResourceList`, `handleSubmit`, `openDrawer`
- 事件处理函数使用 `handle` 前缀：`handleAdd`, `handleEdit`, `handleDelete`
- 工具函数使用动词开头：`formatDate`, `validateForm`

### 4.4 变量命名

#### 4.4.1 后端变量

- 使用小写字母和下划线：`resource_id`, `resource_name`, `page_num`

#### 4.4.2 前端变量

- 使用小驼峰命名：`resourceList`, `drawerVisible`, `formData`
- 常量使用大写下划线：`API_BASE_URL`, `MAX_PAGE_SIZE`

### 4.5 路由命名

- 使用小写字母和下划线（snake_case）：`/resource_list`, `/resource_save`, `/resource_delete`
- 建议使用 RESTful 风格结合 snake_case：如 `/resource`（GET列表, POST新增），`/resource_detail`（GET详情, PUT更新, DELETE删除）

---

## 5. 国际化规范

### 5.1 后端国际化

#### 5.1.1 使用gettext

所有用户可见的文本必须使用 `gettext()` 进行国际化处理：

```python
from flask_babelplus import gettext

# 正确示例
return gettext("保存成功")
abort(500, gettext("资源不存在"))

# 错误示例（不要使用）
return "保存成功"
abort(500, "资源不存在")
```

#### 5.1.2 国际化文件位置

- 翻译文件位置：`translations/zh/` 和 `translations/en/`
- 翻译文件格式：`.po` 和 `.mo` 文件

### 5.2 前端国际化

#### 5.2.1 使用vue-i18n

前端使用 `vue-i18n` 进行国际化：

```typescript
import { useI18n } from "vue-i18n";

const { t } = useI18n();

// 使用
ElMessage.success(t("resource.saveSuccess"));
```

#### 5.2.2 国际化文件位置

- 翻译文件位置：`frontend/src/languages/modules/`
- 翻译文件格式：TypeScript文件，导出翻译对象

#### 5.2.3 翻译键命名

使用模块前缀和语义化命名：

```typescript
// languages/modules/zh.ts
export default {
  resource: {
    title: "资源管理",
    name: "资源名称",
    saveSuccess: "保存成功",
    deleteSuccess: "删除成功"
  }
};
```

---

## 6. 最佳实践

### 6.1 代码组织建议

#### 6.1.1 后端代码组织

1. **Controller层**：保持简洁，只做路由控制和参数传递
2. **Service层**：实现所有业务逻辑，按功能拆分函数
3. **Schema层**：清晰定义输入输出参数，添加必要的验证规则

#### 6.1.2 前端代码组织

1. **组件拆分**：大组件拆分为小组件，每个组件职责单一
2. **接口分离**：接口调用统一放在 `frontend/src/api/modules` 目录
3. **样式分离**：复杂样式提取到单独的样式文件

### 6.2 常见问题避免

#### 6.2.1 后端常见问题

1. **不要在Controller中写业务逻辑**
   - ❌ 错误：在Controller中直接操作数据库
   - ✅ 正确：调用Service层方法

2. **不要使用try-except处理异常**
   - ❌ 错误：使用try-except捕获异常
   - ✅ 正确：使用abort(500, '错误消息')

3. **不要直接返回封装的数据**
   - ❌ 错误：返回 `{"code": 200, "data": data}`
   - ✅ 正确：直接返回 `data`，框架会自动封装

4. **不要修改model目录中的文件**
   - ❌ 错误：手动修改model文件
   - ✅ 正确：使用系统自动生成的model文件

#### 6.2.2 前端常见问题

1. **不要在组件中直接写接口URL**
   - ❌ 错误：`http.get('/{模块名}/resource/list')`
   - ✅ 正确：使用 `frontend/src/api/modules` 中的接口函数

2. **不要忽略代码检查和格式化**
   - ❌ 错误：提交代码前不执行lint和format
   - ✅ 正确：每次修改后执行 `cd frontend && pnpm lint:eslint` 和 `cd frontend && pnpm lint:prettier`

3. **不要创建过大的组件文件**
   - ❌ 错误：单个组件文件超过500行
   - ✅ 正确：拆分为多个子组件

### 6.3 开发流程建议

#### 6.3.1 新建功能开发流程

1. **后端开发**
   - 创建Schema文件，定义输入输出参数
   - 创建Service文件，实现业务逻辑
   - 创建Controller文件，定义路由
   - 测试接口功能

2. **前端开发**
   - 创建API接口文件
   - 创建TypeScript类型定义
   - 创建Vue组件
   - 执行代码检查和格式化
   - 测试功能

#### 6.3.2 代码提交前检查

1. **后端检查**
   - 确保没有使用try-except
   - 确保使用abort抛出异常
   - 确保所有用户可见文本使用gettext
   - 确保函数不超过100行

2. **前端检查**
   - 执行 `cd frontend && pnpm lint:eslint` 检查代码
   - 执行 `cd frontend && pnpm lint:prettier` 格式化代码
   - 确保组件文件不会过大
   - 确保接口调用使用统一的前缀

### 6.4 性能优化建议

#### 6.4.1 后端优化

1. **数据库查询优化**
   - 使用索引优化查询
   - 避免N+1查询问题
   - 使用分页查询大数据量

2. **函数拆分**
   - 保持函数简洁，不超过100行
   - 按功能拆分函数，提高可维护性

#### 6.4.2 前端优化

1. **组件懒加载**
   - 使用路由懒加载
   - 大组件按需加载

2. **接口调用优化**
   - 避免重复请求
   - 使用防抖和节流
   - 合理使用缓存

### 6.5 安全建议

1. **参数验证**
   - 所有输入参数必须通过Schema验证
   - 对用户输入进行必要的过滤和转义

2. **权限控制**
   - 所有接口必须使用 `@admin_required` 装饰器
   - 前端根据权限控制按钮显示

3. **SQL注入防护**
   - 使用ORM进行数据库操作
   - 避免直接拼接SQL语句

---

## 7. Git 提交流程规范

### 7.1 允许的 Git 操作范围（供 AI/工具使用）

- **允许的命令（需人工在终端确认执行）**：
  - `git status`：查看当前变更
  - `git diff`：查看具体改动内容
  - `git add <file>` 或 `git add .`：将本次修改或新建的文件加入暂存区
  - `git commit -m "<message>"`：提交到本地仓库
- **禁止由 AI/工具自动执行的命令（需人工完成）**：
  - `git push` / `git pull` / `git rebase` / `git reset` / `git checkout` 等会影响远程仓库或历史记录的命令

### 7.2 提交粒度与时机

- **一次提交只包含一类逻辑变更**，例如：
  - `feat: 新增场景列表分页接口`
  - `fix: 修复 AnnotationService 标注统计错误`
- 在提交前应确保：
  - 代码能通过基础检查（如：`pnpm lint:eslint`、`pnpm lint:prettier` 等）
  - 仅 `git add` 本次任务相关的文件，避免提交临时文件或无关改动

### 7.3 提交信息规范（commit message）

- 使用 `<type>: <简要说明>` 格式，常用 `type` 如下：
  - `feat`：新增功能
  - `fix`：修复 bug
  - `refactor`：重构（不改变功能）
  - `style`：仅样式/格式修改（如 Prettier 调整）
  - `chore`：脚本、配置等杂项
- 示例：
  - `feat: 新增场景列表分页接口`
  - `fix: 修复 AnnotationService 标注统计错误`
  - `chore: 更新前端 lint 配置`

### 7.4 提交前自检

- **后端**：
  - 确保没有使用 `try-except` 捕获业务异常
  - 异常统一使用 `abort(500, gettext("错误消息"))`
  - 所有用户可见文本使用 `gettext()` 进行国际化
  - 单个函数不超过100行
- **前端**：
  - 执行 `pnpm lint:eslint` 检查代码
  - 执行 `pnpm lint:prettier` 格式化代码
  - 确保组件不会过大（建议小于500行）
  - 接口调用统一使用 `api/modules` 中的封装方法

---

## 附录

### A. 参考文件清单

#### 后端参考文件
- Controller示例：`{模块名}/controller/{ModuleName}Controller.py`
- Service示例：`{模块名}/service/{ModuleName}Service.py`
- Schema示例：`{模块名}/schema/{ModuleName}Schema.py`
- 蓝图注册：`{模块名}/__init__.py`
- **注意**：实际项目中模块名可能不同，请根据 `fred-create` 创建的模块名称查找

#### 前端参考文件
- 组件示例：`frontend/src/views/system/menuManage`（示例路径）
- API调用示例：`frontend/src/api/modules/system.ts`（示例路径）
- 类型定义示例：`frontend/src/api/model/systemModel.ts`（示例路径）

#### 新建项目参考
- 项目模板：`src/fred_framework/demo/`（框架内置示例）
- 蓝图注册示例：`demo/__init__.py`（框架内置示例）
- 使用 `fred-create` 命令创建新模块时，会自动参考 demo 模块的结构

### B. 常用命令

#### 后端命令
```bash
# 运行项目
python -m flask run

# 生成模型文件（系统自动执行）
flask-sqlacodegen <database_uri> --outfile model/model.py --flask
```

#### 前端命令
```bash
# 进入前端目录
cd frontend

# 安装依赖
pnpm install

# 代码检查
pnpm lint:eslint

# 代码格式化
pnpm lint:prettier

# 开发模式运行
pnpm dev

# 生产构建
pnpm build
```

### C. 常见错误处理

#### 后端错误

1. **abort参数错误**
   - 错误：`abort(400, "错误消息")`
   - 正确：`abort(500, gettext("错误消息"))`

2. **返回数据格式错误**
   - 错误：返回 `{"code": 200, "data": data}`
   - 正确：直接返回 `data`

#### 前端错误

1. **接口调用错误**
   - 错误：直接使用URL字符串
   - 正确：使用 `api/modules` 中的接口函数

2. **类型定义错误**
   - 错误：使用 `any` 类型
   - 正确：定义具体的接口类型

---

## 更新日志

- 2025-01-XX: 初始版本，基于框架代码分析编写
- 2025-01-XX: 根据 `install_hook.py` 优化项目结构说明，更新为使用 `fred-init` 和 `fred-create` 命令的标准流程

---

**注意：本文档基于 Fred Framework 的实际实现编写，与 `install_hook.py` 自动创建的项目结构保持一致。如有更新请及时同步文档内容。**

