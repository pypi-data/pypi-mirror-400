from __future__ import annotations

import os
from typing import Dict, List, Optional

from pentestai.ai.multi_router import MultiAIRouter
from pentestai.ai.providers.base import AIProvider
from pentestai.ai.providers.openai_provider import OpenAIProvider
from pentestai.ai.providers.anthropic_provider import AnthropicProvider
from pentestai.ai.providers.gemini_provider import GeminiProvider
from pentestai.ai.providers.deepseek_provider import DeepSeekProvider


def _maybe_api_key(env_name: str) -> Optional[str]:
    """
    Return API key from env if present, else None.
    Avoids crashing when optional providers are configured but not enabled.
    """
    v = os.getenv(env_name, "")
    v = v.strip() if v else ""
    return v or None


class AIRouter:
    """
    Compatibility wrapper used by cli.py and tasks.py.
    Internally uses MultiAIRouter with providers loaded from config.yaml + .env.

    IMPORTANT:
    - Providers are only "enabled" if their api_key_env is actually set in the environment.
    - This prevents crashing on missing ANTHROPIC/GEMINI/DEEPSEEK keys when you only want OpenAI.
    """

    def __init__(self, cfg):
        self.cfg = cfg

        ai_cfg = getattr(cfg, "ai", None)
        if ai_cfg is None:
            raise RuntimeError("Missing ai config section")

        providers_cfg = getattr(ai_cfg, "providers", {}) or {}
        default_provider: str = getattr(ai_cfg, "default_provider", "openai")
        fallbacks: List[str] = getattr(ai_cfg, "fallback_providers", []) or []

        routing = getattr(ai_cfg, "routing", None) or {
            "surface": [default_provider] + fallbacks,
            "triage": [default_provider] + fallbacks,
            "report": [default_provider] + fallbacks,
        }

        providers: Dict[str, AIProvider] = {}

        # openai
        if "openai" in providers_cfg:
            p = providers_cfg["openai"]
            key = _maybe_api_key(p.api_key_env)
            if key:
                providers["openai"] = OpenAIProvider(
                    api_key=key,
                    base_url=p.base_url,
                    model=p.model,
                )

        # anthropic (Claude)
        if "anthropic" in providers_cfg:
            p = providers_cfg["anthropic"]
            key = _maybe_api_key(p.api_key_env)
            if key:
                providers["anthropic"] = AnthropicProvider(
                    api_key=key,
                    base_url=p.base_url,
                    model=p.model,
                )

        # gemini
        if "gemini" in providers_cfg:
            p = providers_cfg["gemini"]
            key = _maybe_api_key(p.api_key_env)
            if key:
                providers["gemini"] = GeminiProvider(
                    api_key=key,
                    base_url=p.base_url,
                    model=p.model,
                )

        # deepseek
        if "deepseek" in providers_cfg:
            p = providers_cfg["deepseek"]
            key = _maybe_api_key(p.api_key_env)
            if key:
                providers["deepseek"] = DeepSeekProvider(
                    api_key=key,
                    base_url=p.base_url,
                    model=p.model,
                )

        if not providers:
            # Only providers with keys are enabled now, so this message is more accurate:
            raise RuntimeError(
                "No AI providers enabled. Set at least one API key env (e.g. OPENAI_API_KEY)."
            )

        self._router = MultiAIRouter(
            providers=providers,
            routing=routing,
            fallbacks=fallbacks,
            default_provider=default_provider,
        )

    async def run(
        self,
        task: str,
        system: str,
        user: str,
        temperature: float = 0.2,
        max_tokens: int = 1400,
    ) -> str:
        return await self._router.run(
            task, system, user, temperature=temperature, max_tokens=max_tokens
        )
