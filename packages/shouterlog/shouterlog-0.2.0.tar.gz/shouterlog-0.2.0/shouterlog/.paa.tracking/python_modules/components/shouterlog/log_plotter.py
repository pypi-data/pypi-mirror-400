"""
Simple module to plot logs generated by shouterlog.
"""

from datetime import datetime
from typing import Any, Dict, List, Tuple, Optional

import attrs
import attrsx
import matplotlib.pyplot as plt


@attrsx.define(slots=True)
class LogPlotter:

    # labels
    label_mode: str = "method"  # "method" | "full" | "none"

    # show/hide
    show_leaf_only_events: bool = True   # show events that don't cause inter-class movement
    show_self_calls: bool = True
    show_intra_class_proc_path: bool = True 
    show_record_label: bool = True
    show_idx: bool = True
    show_right_labels: bool = True
    show_only_leaf_fn_in_proc_path: bool = True
    show_count_suffix: bool = True
    
    # proc rendering / grouping
    proc_group_window_seconds: float = 0.35   # time-window for burst grouping

    # plotting defaults
    figsize: Optional[Tuple[float, float]] = None  # None => autosize
    title: str = "Sequence diagram"

    # autosize tuning knobs (used when figsize is None)
    autosize_inches_per_row: float = 0.4
    autosize_inches_per_lane: float = 2.6
    autosize_min_w: float = 10.0
    autosize_max_w: float = 28.0
    autosize_min_h: float = 6.0
    autosize_max_h: float = 30.0

    # ---------------- internal message model ----------------

    @attrs.define(frozen=True, slots=True)
    class _Msg:
        kind: str  # "call" | "event" | "proc_group"
        src: str
        dst: str
        label: str
        is_proc: bool
        invocation_key: tuple
        count: int = 1
        rec_label: str = ""
        idxs: Tuple[int, ...] = (),

    def __attrs_post_init__(self) -> None:
        self._validate(label_mode=self.label_mode)

    # ---------------- helpers ----------------

    @staticmethod
    def _validate(*, label_mode: str) -> None:
        if label_mode not in ("method", "full", "none"):
            raise ValueError("label_mode must be 'method', 'full', or 'none'")

    @staticmethod
    def _parse_ts(s: str, fmt: str) -> datetime:
        try:
            return datetime.strptime(s, fmt)
        except ValueError:
            if "%f" not in fmt:
                return datetime.strptime(s, fmt + ".%f")
            raise

    @staticmethod
    def _split_fn(fn: str) -> Tuple[str, str]:
        if not fn:
            return "<unknown>", "<unknown>"
        if "." not in fn:
            return fn, fn
        cls, meth = fn.split(".", 1)
        return cls, meth

    def _chain_origin_to_leaf(self, tb_list: List[str]) -> List[Tuple[str, str]]:
        # tb format: [leaf, ..., origin]  -> we want [origin, ..., leaf]
        return [self._split_fn(x) for x in reversed(tb_list or [])]

    @staticmethod
    def _lca_prefix_len(a: List[Tuple[str, str]], b: List[Tuple[str, str]]) -> int:
        n = min(len(a), len(b))
        i = 0
        while i < n and a[i] == b[i]:
            i += 1
        return i

    @staticmethod
    def _mk_label(cls: str, meth: str, label_mode: str) -> str:
        if label_mode == "none":
            return ""
        if label_mode == "full":
            return f"{cls}.{meth}"
        return meth

    def _auto_figsize(self, n_rows: int, n_lanes: int) -> Tuple[float, float]:
        width = n_lanes * self.autosize_inches_per_lane
        height = n_rows * self.autosize_inches_per_row
        width = max(self.autosize_min_w, min(self.autosize_max_w, width))
        height = max(self.autosize_min_h, min(self.autosize_max_h, height))
        return float(width), float(height)

    @staticmethod
    def _resolve(value, default):
        return default if value is None else value

    @staticmethod
    def _format_idxs(idxs: Tuple[int, ...]) -> str:
        if not idxs:
            return ""
        xs = sorted(set(int(x) for x in idxs))
        if len(xs) == 1:
            return str(xs[0])

        # build contiguous ranges
        ranges = []
        start = prev = xs[0]
        for x in xs[1:]:
            if x == prev + 1:
                prev = x
                continue
            ranges.append((start, prev))
            start = prev = x
        ranges.append((start, prev))

        # if everything is a single contiguous block, show "a-b"
        if len(ranges) == 1:
            a, b = ranges[0]
            return f"{a}-{b}"

        # otherwise: show list for small sets, else show ranges
        if len(xs) <= 6:
            return ",".join(str(x) for x in xs)

        parts = [f"{a}-{b}" if a != b else str(a) for a, b in ranges]
        return ", ".join(parts)


    # ---------------- public API ----------------

    def plot_sequence_diagram_from_tracebacks(
        self,
        log_records: List[Dict[str, Any]],
        *,
        label_mode: Optional[str] = None,
        show_count_suffix: Optional[bool] = None,
        show_leaf_only_events: Optional[bool] = None,
        show_self_calls: Optional[bool] = None,
        show_record_label: Optional[bool] = None,
        show_right_labels: Optional[bool] = None,
        show_idx: Optional[bool] = None,
        proc_group_window_seconds: Optional[float] = None,
        show_intra_class_proc_path: Optional[bool] = None,
        show_only_leaf_fn_in_proc_path: Optional[bool] = None,
        figsize: Optional[Tuple[float, float]] = None,
        title: Optional[str] = None,
    ):
        if not log_records:
            raise ValueError("log_records is empty")

        # ---------------- resolve config ----------------

        label_mode = self._resolve(label_mode, self.label_mode)
        show_count_suffix = self._resolve(show_count_suffix, self.show_count_suffix)

        show_leaf_only_events = self._resolve(show_leaf_only_events, self.show_leaf_only_events)
        show_self_calls = self._resolve(show_self_calls, self.show_self_calls)
        show_record_label = self._resolve(show_record_label, self.show_record_label)
        show_right_labels = self._resolve(show_right_labels, self.show_right_labels)
        show_idx = self._resolve(show_idx, self.show_idx)

        proc_group_window_seconds = self._resolve(proc_group_window_seconds, self.proc_group_window_seconds)
        show_intra_class_proc_path = self._resolve(show_intra_class_proc_path, self.show_intra_class_proc_path)
        show_only_leaf_fn_in_proc_path = self._resolve(show_only_leaf_fn_in_proc_path, self.show_only_leaf_fn_in_proc_path)

        figsize = self._resolve(figsize, self.figsize)
        title = self._resolve(title, self.title)

        self._validate(label_mode=label_mode)

        # ============================================================
        # 1) NORMALIZE INPUT: sort, parse chains, build lane order
        # ============================================================

        indexed: List[Tuple[datetime, int, Dict[str, Any]]] = []
        for i, rec in enumerate(log_records):
            ts = self._parse_ts(rec["datetime"], "%Y-%m-%d %H:%M:%S") if "datetime" in rec else datetime.min
            indexed.append((ts, i, rec))
        indexed.sort(key=lambda x: (x[0], x[1]))

        lane_order: List[str] = []
        lane_seen = set()

        stream = []  # list of dicts with normalized info per record
        for ts, _, rec in indexed:
            tb_list = rec.get("traceback") or []
            chain = self._chain_origin_to_leaf(tb_list)  # [(cls,meth)] origin->leaf
            if not chain:
                continue

            is_proc = bool(rec.get("is_proc", False))
            rec_label = str(rec.get("label") or "").strip()

            idx_val = rec.get("idx", None)
            idxs = (int(idx_val),) if idx_val is not None else ()

            tb_tuple = tuple(tb_list)
            proc_name = rec.get("proc_name", None)
            call_id = rec.get("call_id", None)

            if call_id is None:
                # IMPORTANT: must be stable across all logs of the same invocation
                call_id = proc_name if is_proc else tb_tuple



            # call_id is NOT unique in your logs (it gets reused), so include tb_tuple to avoid collisions.
            invocation_key = (
                ("proc", proc_name, call_id, tb_tuple) if is_proc
                else ("non_proc", call_id, tb_tuple)
            )


            stream.append({
                "ts": ts,
                "rec": rec,
                "chain": chain,
                "is_proc": is_proc,
                "leaf_cls": chain[-1][0],
                "leaf_m": chain[-1][1],
                "rec_label": rec_label,
                "idxs": idxs,
                "tb_tuple": tb_tuple,
                "proc_name": proc_name,
                "call_id": call_id,
                "invocation_key": invocation_key,
            })

            for cls, _ in chain:
                if cls not in lane_seen:
                    lane_seen.add(cls)
                    lane_order.append(cls)

        if not lane_order:
            raise ValueError("No lanes discovered (empty tracebacks?)")

        # ============================================================
        # 2) BUILD RAW MESSAGES using active-stack + proc burst buffer
        # ============================================================

        msgs: List[LogPlotter._Msg] = []

        active_stack: List[Tuple[str, str]] = []  # origin->...->current owner
        current_owner_cls: Optional[str] = None

        # proc buffer groups repeated proc logs into bursts
        # key groups *visual arrow*, but we count invocations separately later
        proc_buf: Dict[Tuple[Any, ...], Dict[str, Any]] = {}
        proc_key_order: List[Tuple[Any, ...]] = []

        def flush_proc_buffers():
            nonlocal proc_buf, proc_key_order
            for k in proc_key_order:
                info = proc_buf.get(k)
                if not info:
                    continue

                labels = sorted(x for x in (info.get("rec_labels") or set()) if x)
                rec_label_out = "|".join(labels)  # or ", ".join(labels)

                msgs.append(
                    LogPlotter._Msg(
                        kind="proc_group",
                        src=info["src"],
                        dst=info["dst"],
                        label=info["label"],
                        is_proc=True,
                        invocation_key=frozenset(info.get("invocations") or ()),
                        count=len(info.get("invocations") or ()),
                        rec_label=rec_label_out,  # proc groups don't carry a single record label
                        idxs=tuple(info.get("idxs") or ()),
                    )
                )
            proc_buf = {}
            proc_key_order = []

        for item in stream:
            ts = item["ts"]
            chain = item["chain"]
            is_proc = item["is_proc"]
            leaf_cls = item["leaf_cls"]
            leaf_m = item["leaf_m"]
            rec_label = item["rec_label"]
            idxs = item["idxs"]
            invocation_key = item["invocation_key"]
            tb_tuple = item["tb_tuple"]
            proc_name = item["proc_name"]

            # initialize stack
            if not active_stack:
                active_stack = chain[:1]
                current_owner_cls = active_stack[-1][0]

            # ------------------------------------------------------------
            # IMPORTANT: only NON-PROC records are allowed to mutate stack
            # ------------------------------------------------------------
            if not is_proc:
                # LCA pop
                lca = self._lca_prefix_len(active_stack, chain)
                if lca < len(active_stack):
                    if proc_buf:
                        flush_proc_buffers()
                    active_stack = active_stack[:lca]

                # push (calls) compressed by class
                pushed = chain[lca:]
                if pushed:
                    prev_cls = active_stack[-1][0] if active_stack else pushed[0][0]
                    for cls, meth in pushed:
                        if cls != prev_cls:
                            if proc_buf:
                                flush_proc_buffers()
                            msgs.append(
                                LogPlotter._Msg(
                                    kind="call",
                                    src=prev_cls,
                                    dst=cls,
                                    label=self._mk_label(cls, meth, label_mode),
                                    is_proc=False,
                                    invocation_key=invocation_key,
                                    count=1,
                                    rec_label=rec_label,
                                    idxs=idxs,
                                )
                            )
                            prev_cls = cls
                        active_stack.append((cls, meth))

                current_owner_cls = active_stack[-1][0] if active_stack else None

            # -------- proc log: add to burst buffer, don't emit normal event --------
            if is_proc and current_owner_cls:
                src_lane = current_owner_cls
                dst_lane = leaf_cls

                if show_only_leaf_fn_in_proc_path:
                    path_label = self._mk_label(leaf_cls, leaf_m, label_mode)
                else:
                    if show_intra_class_proc_path:
                        inside = [m for (c, m) in chain if c == src_lane]
                        path_label = " -> ".join(inside + [leaf_m]) if inside else self._mk_label(leaf_cls, leaf_m, label_mode)
                    else:
                        path_label = self._mk_label(leaf_cls, leaf_m, label_mode)

                visual_key = (src_lane, dst_lane, leaf_m, path_label)

                info = proc_buf.get(visual_key)
                if info is None:
                    proc_buf[visual_key] = {
                        "src": src_lane,
                        "dst": dst_lane,
                        "label": path_label,
                        "count": 1,
                        "last_ts": ts,
                        "idxs": list(idxs),
                        "invocations": {invocation_key},
                        "rec_labels": set([rec_label]) if rec_label else set(),
                    }

                    proc_key_order.append(visual_key)
                else:
                    gap = (ts - info["last_ts"]).total_seconds()
                    if gap <= proc_group_window_seconds:
                        info["count"] += 1
                        info["last_ts"] = ts
                        info["idxs"].extend(idxs)
                        info["invocations"].add(invocation_key)
                        if rec_label:
                            info["rec_labels"].add(rec_label)
                    else:
                        flush_proc_buffers()
                        proc_buf[visual_key] = {
                            "src": src_lane,
                            "dst": dst_lane,
                            "label": path_label,
                            "count": 1,
                            "last_ts": ts,
                            "idxs": list(idxs),
                            "invocations": {invocation_key},
                            "rec_labels": set([rec_label]) if rec_label else set(),
                        }

                        proc_key_order.append(visual_key)

                continue

            # non-proc record: flush proc bursts before emitting events
            if proc_buf:
                flush_proc_buffers()

            # "event" on owner lane (optional)
            if show_leaf_only_events and current_owner_cls:
                meths = [m for (c, m) in chain if c == current_owner_cls]
                lbl_m = meths[-1] if meths else leaf_m
                msgs.append(
                    LogPlotter._Msg(
                        kind="event",
                        src=current_owner_cls,
                        dst=current_owner_cls,
                        label=self._mk_label(current_owner_cls, lbl_m, label_mode),
                        is_proc=False,
                        invocation_key=invocation_key,
                        count=1,
                        rec_label=rec_label,
                        idxs=idxs,
                    )
                )

        if proc_buf:
            flush_proc_buffers()

        # ============================================================
        # 3) COLLAPSE: merge identical visuals, count invocations properly
        # ============================================================

        collapsed: List[LogPlotter._Msg] = []
        inv_sets: List[set] = []  # per collapsed item: set of invocation keys counted
        proc_inv_sets: List[set] = []  # only used for proc_group (optional)

        def same_visual(a: LogPlotter._Msg, b: LogPlotter._Msg) -> bool:
            return (
                a.kind == b.kind and
                a.src == b.src and
                a.dst == b.dst and
                a.label == b.label and
                a.is_proc == b.is_proc and
                a.rec_label == b.rec_label
            )

        for m in msgs:
            if not collapsed:
                collapsed.append(m)
                inv_sets.append({m.invocation_key})
                continue

            last = collapsed[-1]

            if same_visual(last, m):
                merged_idxs = tuple(last.idxs) + tuple(m.idxs)

                if last.kind == "proc_group":
                    merged_inv = set(last.invocation_key) | set(m.invocation_key)
                    collapsed[-1] = LogPlotter._Msg(
                        kind=last.kind,
                        src=last.src,
                        dst=last.dst,
                        label=last.label,
                        is_proc=last.is_proc,
                        invocation_key=frozenset(merged_inv),
                        count=len(merged_inv),
                        rec_label=last.rec_label,
                        idxs=merged_idxs,
                    )
                else:
                    inv_sets[-1].add(m.invocation_key)
                    new_count = len(inv_sets[-1])

                    collapsed[-1] = LogPlotter._Msg(
                        kind=last.kind,
                        src=last.src,
                        dst=last.dst,
                        label=last.label,
                        is_proc=last.is_proc,
                        invocation_key=last.invocation_key,
                        count=new_count,
                        rec_label=last.rec_label,
                        idxs=merged_idxs,
                    )

            else:
                collapsed.append(m)
                inv_sets.append({m.invocation_key})


        # ============================================================
        # 4) PLOT: unchanged logic, just uses collapsed
        # ============================================================

        if figsize is None:
            figsize = self._auto_figsize(n_rows=len(collapsed), n_lanes=len(lane_order))

        x = {c: i for i, c in enumerate(lane_order)}
        fig, ax = plt.subplots(figsize=figsize)

        y_top = 0
        y_bottom = len(collapsed) + 1

        for c in lane_order:
            xc = x[c]
            ax.plot([xc, xc], [y_top, y_bottom], linestyle="--", linewidth=1, alpha=0.35)
            ax.text(xc, y_top - 0.65, c, ha="center", va="bottom", fontsize=10)

        y = 1
        right_label_x_pad = 0.2
        for m in collapsed:
            xs, xd = x[m.src], x[m.dst]

            lbl = (m.label or "").strip()
            if show_record_label and m.rec_label and not show_right_labels:
                lbl = (lbl + f" [{m.rec_label}]").strip()

            if show_count_suffix and m.count > 1:
                lbl = (lbl + f" Ã—{m.count}").strip()
            if m.is_proc and lbl:
                lbl = (lbl + " (proc)").strip()

            if show_idx:
                idx_txt = self._format_idxs(m.idxs)
                if idx_txt:
                    ax.text(-0.6, y, idx_txt, fontsize=8, ha="right", va="center", alpha=0.85)
                if show_right_labels and m.rec_label:
                    # put record labels in a right-side "gutter", similar to idx on the left
                    x_right = (len(lane_order) - 0.3) + right_label_x_pad
                    ax.text(x_right, y, str(m.rec_label), fontsize=8, ha="left", va="center", alpha=0.85)

            arrowprops = dict(arrowstyle="->", linewidth=1)
            if m.is_proc:
                arrowprops["linestyle"] = "--"
                arrowprops["alpha"] = 0.75

            y_label_offset = -0.2

            if m.src == m.dst:
                if show_self_calls:
                    loop_w = 0.35
                    ax.plot(
                        [xs, xs + loop_w, xs + loop_w, xs],
                        [y, y, y + 0.25, y + 0.25],
                        linewidth=1,
                        linestyle="--" if m.is_proc else "-",
                        alpha=0.75 if m.is_proc else 1.0,
                    )
                    ax.annotate("", xy=(xs, y + 0.25), xytext=(xs + loop_w, y + 0.25), arrowprops=arrowprops)
                    if lbl:
                        ax.text(xs + loop_w + 0.05, y + y_label_offset, lbl, fontsize=9)
            else:
                ax.annotate("", xy=(xd, y), xytext=(xs, y), arrowprops=arrowprops)
                if lbl:
                    ax.text((xs + xd) / 2, y + y_label_offset, lbl, fontsize=9, ha="center")

            y += 1

        ax.set_title(title)
        
        x_left = -0.6
        x_right = (len(lane_order) - 0.3) + (right_label_x_pad if show_right_labels else 0.0) + 0.2
        ax.set_xlim(x_left, x_right)

        ax.set_ylim(y_bottom + 0.5, -1.2)
        ax.axis("off")
        plt.show()
        return fig, ax

