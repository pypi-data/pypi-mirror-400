import typing, abc
from System import Array_1, Progress_1
from System.Collections.Generic import List_1
from System.Threading.Tasks import Task_1
from PalmSens.Plottables import EISData
from MathNet.Numerics.LinearAlgebra import Matrix_1, Vector_1
from PalmSens.Fitting.Models.Circuits import ElementGroup
from PalmSens.Fitting.Models.Circuits.Elements import ElementTypes

class Algorithm(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...

    # Values:
    LevenbergMarquardt : Algorithm # 0
    NelderMead : Algorithm # 1


class BVModel(IModelBase):
    def __init__(self) -> None: ...
    Begin : int
    End : int
    @property
    def Name(self) -> str: ...
    @property
    def NParameters(self) -> int: ...
    def GetResidualValues(self, parameters: Array_1[float], x: Array_1[float], y: Array_1[float]) -> Array_1[float]: ...
    def GetValues(self, parameters: Array_1[float], x: Array_1[float]) -> Array_1[float]: ...
    # Skipped EvaluatePointError due to it being static, abstract and generic.

    EvaluatePointError : EvaluatePointError_MethodGroup
    class EvaluatePointError_MethodGroup:
        @typing.overload
        def __call__(self, parameters: Array_1[float]) -> float:...
        @typing.overload
        def __call__(self, parameters: Array_1[float], fitOptionsCircuit: FitOptionsCircuit) -> float:...



class BVModelICorr(IModelBase):
    def __init__(self, eCorr: float, bA: float, bC: float) -> None: ...
    Begin : int
    End : int
    @property
    def Name(self) -> str: ...
    @property
    def NParameters(self) -> int: ...
    def GetResidualValues(self, parameters: Array_1[float], x: Array_1[float], y: Array_1[float]) -> Array_1[float]: ...
    def GetValues(self, parameters: Array_1[float], x: Array_1[float]) -> Array_1[float]: ...
    # Skipped EvaluatePointError due to it being static, abstract and generic.

    EvaluatePointError : EvaluatePointError_MethodGroup
    class EvaluatePointError_MethodGroup:
        @typing.overload
        def __call__(self, parameters: Array_1[float]) -> float:...
        @typing.overload
        def __call__(self, parameters: Array_1[float], fitOptionsCircuit: FitOptionsCircuit) -> float:...



class BVModelICorrSimplex(IModelBase):
    def __init__(self, eCorr: float, ba: float, bc: float, x: Array_1[float], y: Array_1[float]) -> None: ...
    Begin : int
    End : int
    @property
    def Name(self) -> str: ...
    @property
    def NParameters(self) -> int: ...
    def GetResidualValues(self, parameters: Array_1[float], x: Array_1[float], y: Array_1[float]) -> Array_1[float]: ...
    def GetValues(self, parameters: Array_1[float], x: Array_1[float]) -> Array_1[float]: ...
    # Skipped EvaluatePointError due to it being static, abstract and generic.

    EvaluatePointError : EvaluatePointError_MethodGroup
    class EvaluatePointError_MethodGroup:
        @typing.overload
        def __call__(self, parameters: Array_1[float]) -> float:...
        @typing.overload
        def __call__(self, parameters: Array_1[float], fitOptionsCircuit: FitOptionsCircuit) -> float:...



class BVModelSimplex(IModelBase):
    def __init__(self, x: Array_1[float], y: Array_1[float], eCorr: float) -> None: ...
    Begin : int
    End : int
    @property
    def Name(self) -> str: ...
    @property
    def NParameters(self) -> int: ...
    def GetResidualValues(self, parameters: Array_1[float], x: Array_1[float], y: Array_1[float]) -> Array_1[float]: ...
    def GetValues(self, parameters: Array_1[float], x: Array_1[float]) -> Array_1[float]: ...
    # Skipped EvaluatePointError due to it being static, abstract and generic.

    EvaluatePointError : EvaluatePointError_MethodGroup
    class EvaluatePointError_MethodGroup:
        @typing.overload
        def __call__(self, parameters: Array_1[float]) -> float:...
        @typing.overload
        def __call__(self, parameters: Array_1[float], fitOptionsCircuit: FitOptionsCircuit) -> float:...



class BVModelSlopeAn(IModelBase):
    def __init__(self, eCorr: float, bC: float) -> None: ...
    Begin : int
    End : int
    @property
    def Name(self) -> str: ...
    @property
    def NParameters(self) -> int: ...
    def GetResidualValues(self, parameters: Array_1[float], x: Array_1[float], y: Array_1[float]) -> Array_1[float]: ...
    def GetValues(self, parameters: Array_1[float], x: Array_1[float]) -> Array_1[float]: ...
    # Skipped EvaluatePointError due to it being static, abstract and generic.

    EvaluatePointError : EvaluatePointError_MethodGroup
    class EvaluatePointError_MethodGroup:
        @typing.overload
        def __call__(self, parameters: Array_1[float]) -> float:...
        @typing.overload
        def __call__(self, parameters: Array_1[float], fitOptionsCircuit: FitOptionsCircuit) -> float:...



class BVModelSlopeCath(IModelBase):
    def __init__(self, eCorr: float, bA: float) -> None: ...
    Begin : int
    End : int
    @property
    def Name(self) -> str: ...
    @property
    def NParameters(self) -> int: ...
    def GetResidualValues(self, parameters: Array_1[float], x: Array_1[float], y: Array_1[float]) -> Array_1[float]: ...
    def GetValues(self, parameters: Array_1[float], x: Array_1[float]) -> Array_1[float]: ...
    # Skipped EvaluatePointError due to it being static, abstract and generic.

    EvaluatePointError : EvaluatePointError_MethodGroup
    class EvaluatePointError_MethodGroup:
        @typing.overload
        def __call__(self, parameters: Array_1[float]) -> float:...
        @typing.overload
        def __call__(self, parameters: Array_1[float], fitOptionsCircuit: FitOptionsCircuit) -> float:...



class BVModelSlopesSimplex(IModelBase):
    def __init__(self, eCorr: float, iCorr: float, x: Array_1[float], y: Array_1[float]) -> None: ...
    Begin : int
    End : int
    @property
    def Name(self) -> str: ...
    @property
    def NParameters(self) -> int: ...
    def GetResidualValues(self, parameters: Array_1[float], x: Array_1[float], y: Array_1[float]) -> Array_1[float]: ...
    def GetValues(self, parameters: Array_1[float], x: Array_1[float]) -> Array_1[float]: ...
    # Skipped EvaluatePointError due to it being static, abstract and generic.

    EvaluatePointError : EvaluatePointError_MethodGroup
    class EvaluatePointError_MethodGroup:
        @typing.overload
        def __call__(self, parameters: Array_1[float]) -> float:...
        @typing.overload
        def __call__(self, parameters: Array_1[float], fitOptionsCircuit: FitOptionsCircuit) -> float:...



class EnumFitProgress(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...

    # Values:
    Started : EnumFitProgress # 0
    FitIterated : EnumFitProgress # 1
    Cancelled : EnumFitProgress # 2
    Finished : EnumFitProgress # 3


class ExitCodes(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...

    # Values:
    MinimumDeltaErrorTerm : ExitCodes # 1
    MinimumDeltaParameters : ExitCodes # 2
    MaxIterations : ExitCodes # 3
    HessianNonPositive : ExitCodes # 4


class ExitCondition(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...

    # Values:
    None_ : ExitCondition # 0
    RelativeGradient : ExitCondition # 1
    LackOfProgress : ExitCondition # 2
    AbsoluteGradient : ExitCondition # 3
    WeakWolfeCriteria : ExitCondition # 4
    BoundTolerance : ExitCondition # 5
    StrongWolfeCriteria : ExitCondition # 6
    Converged : ExitCondition # 7


class FitAlgorithm(abc.ABC):
    @typing.overload
    def __init__(self, fitOptions: FitOptionsCircuit) -> None: ...
    @typing.overload
    def __init__(self, fitOptions: FitOptions) -> None: ...
    @property
    def FitResult(self) -> FitResult: ...
    @FitResult.setter
    def FitResult(self, value: FitResult) -> FitResult: ...
    @property
    def Iterations(self) -> List_1[Array_1[float]]: ...
    @abc.abstractmethod
    def ApplyFit(self) -> FitResult: ...
    def ApplyFitCircuitAsync(self, fitProgress: FitProgress = ...) -> Task_1[FitResult]: ...
    @staticmethod
    def FromAlgorithm(fitOptions: FitOptionsCircuit) -> FitAlgorithm: ...
    # Skipped ApplyFitCircuit due to it being static, abstract and generic.

    ApplyFitCircuit : ApplyFitCircuit_MethodGroup
    class ApplyFitCircuit_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, fitProgress: FitProgress) -> None:...



class FitOptions:
    def __init__(self, xData: Array_1[float], yData: Array_1[float], model: IModelBase, initialParameters: Array_1[float]) -> None: ...
    @property
    def ConvergenceTolerance(self) -> float: ...
    @ConvergenceTolerance.setter
    def ConvergenceTolerance(self, value: float) -> float: ...
    @property
    def EnableMinimunDeltaErrorTerm(self) -> bool: ...
    @EnableMinimunDeltaErrorTerm.setter
    def EnableMinimunDeltaErrorTerm(self, value: bool) -> bool: ...
    @property
    def EnableMinimunDeltaParameters(self) -> bool: ...
    @EnableMinimunDeltaParameters.setter
    def EnableMinimunDeltaParameters(self, value: bool) -> bool: ...
    @property
    def InitialParameters(self) -> Array_1[float]: ...
    @InitialParameters.setter
    def InitialParameters(self, value: Array_1[float]) -> Array_1[float]: ...
    @property
    def Lambda(self) -> float: ...
    @Lambda.setter
    def Lambda(self, value: float) -> float: ...
    @property
    def LambdaFactor(self) -> float: ...
    @LambdaFactor.setter
    def LambdaFactor(self, value: float) -> float: ...
    @property
    def MaxIterations(self) -> int: ...
    @MaxIterations.setter
    def MaxIterations(self, value: int) -> int: ...
    @property
    def MinimumDeltaErrorTerm(self) -> float: ...
    @MinimumDeltaErrorTerm.setter
    def MinimumDeltaErrorTerm(self, value: float) -> float: ...
    @property
    def MinimumDeltaParameters(self) -> float: ...
    @MinimumDeltaParameters.setter
    def MinimumDeltaParameters(self, value: float) -> float: ...
    @property
    def Model(self) -> IModelBase: ...
    @Model.setter
    def Model(self, value: IModelBase) -> IModelBase: ...
    @property
    def SelectedAlgorithm(self) -> Algorithm: ...
    @SelectedAlgorithm.setter
    def SelectedAlgorithm(self, value: Algorithm) -> Algorithm: ...
    @property
    def XData(self) -> Array_1[float]: ...
    @property
    def YData(self) -> Array_1[float]: ...


class FitOptionsCircuit(FitOptions):
    def __init__(self) -> None: ...

    class FitTypes(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...

        # Values:
        Real : FitOptionsCircuit.FitTypes # 0
        Imaginary : FitOptionsCircuit.FitTypes # 1
        Complex : FitOptionsCircuit.FitTypes # 2


    class Weighting(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...

        # Values:
        Unit : FitOptionsCircuit.Weighting # 0
        Modulus : FitOptionsCircuit.Weighting # 1
        Proportional : FitOptionsCircuit.Weighting # 2

    @property
    def AllDataPoints(self) -> bool: ...
    @AllDataPoints.setter
    def AllDataPoints(self, value: bool) -> bool: ...
    @property
    def ConvergenceTolerance(self) -> float: ...
    @ConvergenceTolerance.setter
    def ConvergenceTolerance(self, value: float) -> float: ...
    @property
    def EnableMinimunDeltaErrorTerm(self) -> bool: ...
    @EnableMinimunDeltaErrorTerm.setter
    def EnableMinimunDeltaErrorTerm(self, value: bool) -> bool: ...
    @property
    def EnableMinimunDeltaParameters(self) -> bool: ...
    @EnableMinimunDeltaParameters.setter
    def EnableMinimunDeltaParameters(self, value: bool) -> bool: ...
    @property
    def FitType(self) -> FitTypes: ...
    @FitType.setter
    def FitType(self, value: FitTypes) -> FitTypes: ...
    @property
    def InitialParameters(self) -> Array_1[float]: ...
    @InitialParameters.setter
    def InitialParameters(self, value: Array_1[float]) -> Array_1[float]: ...
    @property
    def Lambda(self) -> float: ...
    @Lambda.setter
    def Lambda(self, value: float) -> float: ...
    @property
    def LambdaFactor(self) -> float: ...
    @LambdaFactor.setter
    def LambdaFactor(self, value: float) -> float: ...
    @property
    def MaxIterations(self) -> int: ...
    @MaxIterations.setter
    def MaxIterations(self, value: int) -> int: ...
    @property
    def MinimumDeltaErrorTerm(self) -> float: ...
    @MinimumDeltaErrorTerm.setter
    def MinimumDeltaErrorTerm(self, value: float) -> float: ...
    @property
    def MinimumDeltaParameters(self) -> float: ...
    @MinimumDeltaParameters.setter
    def MinimumDeltaParameters(self, value: float) -> float: ...
    @property
    def Model(self) -> IModelBase: ...
    @Model.setter
    def Model(self, value: IModelBase) -> IModelBase: ...
    @property
    def RawData(self) -> EISData: ...
    @RawData.setter
    def RawData(self, value: EISData) -> EISData: ...
    @property
    def SelectedAlgorithm(self) -> Algorithm: ...
    @SelectedAlgorithm.setter
    def SelectedAlgorithm(self, value: Algorithm) -> Algorithm: ...
    @property
    def SelectedDataPoints(self) -> Array_1[bool]: ...
    @SelectedDataPoints.setter
    def SelectedDataPoints(self, value: Array_1[bool]) -> Array_1[bool]: ...
    @property
    def Weight(self) -> Weighting: ...
    @Weight.setter
    def Weight(self, value: Weighting) -> Weighting: ...
    @property
    def XData(self) -> Array_1[float]: ...
    @property
    def YData(self) -> Array_1[float]: ...


class FitProgress(Progress_1[FitProgressUpdate]):
    def __init__(self) -> None: ...
    FitAlgorithm : FitAlgorithm
    FitOptions : FitOptionsCircuit
    def Cancel(self) -> None: ...


class FitProgressUpdate:
    NIterations : int
    Progress : EnumFitProgress
    Result : FitResult


class FitResult:
    @typing.overload
    def __init__(self, iterations: List_1[Array_1[float]], alphaCNLS: Matrix_1[float], residualSS: float, nSamples: int, exitCode: int) -> None: ...
    @typing.overload
    def __init__(self, iterations: List_1[Array_1[float]], residualSS: float, nSamples: int, exitCode: int) -> None: ...
    @typing.overload
    def __init__(self, parameters: Parameters, iterations: List_1[Array_1[float]], alphaCNLS: Matrix_1[float], residualSS: float, nSamples: int, exitCode: int) -> None: ...
    @property
    def ChiSq(self) -> float: ...
    @property
    def ExitCode(self) -> ExitCodes: ...
    @property
    def FinalParameters(self) -> Array_1[float]: ...
    @property
    def Iterations(self) -> List_1[Array_1[float]]: ...
    @property
    def NIterations(self) -> int: ...
    @property
    def ParameterSDs(self) -> Array_1[float]: ...


class IModelBase(typing.Protocol):
    @property
    def Name(self) -> str: ...
    @property
    def NParameters(self) -> int: ...
    @abc.abstractmethod
    def GetResidualValues(self, parameters: Array_1[float], x: Array_1[float], y: Array_1[float]) -> Array_1[float]: ...
    @abc.abstractmethod
    def GetValues(self, parameters: Array_1[float], x: Array_1[float]) -> Array_1[float]: ...
    # Skipped EvaluatePointError due to it being static, abstract and generic.

    EvaluatePointError : EvaluatePointError_MethodGroup
    class EvaluatePointError_MethodGroup:
        @typing.overload
        def __call__(self, parameters: Array_1[float]) -> float:...
        @typing.overload
        def __call__(self, parameters: Array_1[float], fitOptionsCircuit: FitOptionsCircuit) -> float:...



class LevenbergMarquardt(FitAlgorithm):
    def __init__(self, fitOptions: FitOptions) -> None: ...
    @property
    def FitResult(self) -> FitResult: ...
    @FitResult.setter
    def FitResult(self, value: FitResult) -> FitResult: ...
    @property
    def Iterations(self) -> List_1[Array_1[float]]: ...
    def ApplyFit(self) -> FitResult: ...
    def ApplyFitCircuit(self) -> None: ...


class NelderMead(FitAlgorithm):
    @typing.overload
    def __init__(self, fitOptions: FitOptions) -> None: ...
    @typing.overload
    def __init__(self, fitOptions: FitOptionsCircuit) -> None: ...
    @property
    def FitResult(self) -> FitResult: ...
    @FitResult.setter
    def FitResult(self, value: FitResult) -> FitResult: ...
    @property
    def Iterations(self) -> List_1[Array_1[float]]: ...
    def ApplyFit(self) -> FitResult: ...
    def ApplyFitCircuit(self) -> None: ...
    # Skipped FindMinimum due to it being static, abstract and generic.

    FindMinimum : FindMinimum_MethodGroup
    class FindMinimum_MethodGroup:
        @typing.overload
        def __call__(self, initialGuess: Vector_1[float]) -> FitResult:...
        @typing.overload
        def __call__(self, initialGuess: Vector_1[float], initalPertubation: Vector_1[float]) -> FitResult:...

    # Skipped Minimum due to it being static, abstract and generic.

    Minimum : Minimum_MethodGroup
    class Minimum_MethodGroup:
        @typing.overload
        def __call__(self, initialGuess: Vector_1[float], convergenceTolerance: float = ..., maximumIterations: int = ...) -> FitResult:...
        @typing.overload
        def __call__(self, initialGuess: Vector_1[float], initalPertubation: Vector_1[float], convergenceTolerance: float = ..., maximumIterations: int = ...) -> FitResult:...



class Parameter:
    @typing.overload
    def __init__(self, _grp: ElementGroup) -> None: ...
    @typing.overload
    def __init__(self, _grp: ElementGroup, _npar: int) -> None: ...
    Fixed : bool
    @property
    def MaxValue(self) -> float: ...
    @MaxValue.setter
    def MaxValue(self, value: float) -> float: ...
    @property
    def MinValue(self) -> float: ...
    @MinValue.setter
    def MinValue(self, value: float) -> float: ...
    @property
    def Name(self) -> str: ...
    @Name.setter
    def Name(self, value: str) -> str: ...
    @property
    def ParameterNumber(self) -> int: ...
    @ParameterNumber.setter
    def ParameterNumber(self, value: int) -> int: ...
    @property
    def Symbol(self) -> str: ...
    @Symbol.setter
    def Symbol(self, value: str) -> str: ...
    @property
    def Type(self) -> ElementTypes: ...
    @Type.setter
    def Type(self, value: ElementTypes) -> ElementTypes: ...
    @property
    def Value(self) -> float: ...
    @Value.setter
    def Value(self, value: float) -> float: ...


class Parameters(List_1[Parameter]):
    def __init__(self) -> None: ...
    FixedParameterCount : int
    @property
    def Capacity(self) -> int: ...
    @Capacity.setter
    def Capacity(self, value: int) -> int: ...
    @property
    def Count(self) -> int: ...
    @property
    def CurrentFitValues(self) -> Array_1[float]: ...
    @CurrentFitValues.setter
    def CurrentFitValues(self, value: Array_1[float]) -> Array_1[float]: ...
    @property
    def CurrentValues(self) -> Array_1[float]: ...
    @property
    def Item(self) -> Parameter: ...
    @Item.setter
    def Item(self, value: Parameter) -> Parameter: ...
    @property
    def NextFitValues(self) -> Array_1[float]: ...
    @NextFitValues.setter
    def NextFitValues(self, value: Array_1[float]) -> Array_1[float]: ...
    @property
    def NextValues(self) -> Array_1[float]: ...
    def AddStep(self, step: Array_1[float]) -> None: ...
    def InitCurrentFitValues(self) -> None: ...
    def SetNewFitValuesAsCurrent(self) -> None: ...
