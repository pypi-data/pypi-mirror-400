
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union, Optional as _Optional


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "vm"

@_ods_cext.register_operation(_Dialect)
class AbsF32Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.abs.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def abs_f32(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return AbsF32Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AbsF64Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.abs.f64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def abs_f64(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return AbsF64Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AbsI32Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.abs.i32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def abs_i32(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return AbsI32Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AbsI64Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.abs.i64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def abs_i64(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return AbsI64Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AddF32Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.add.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def add_f32(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return AddF32Op(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AddF64Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.add.f64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def add_f64(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return AddF64Op(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AddI32Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.add.i32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def add_i32(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return AddI32Op(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AddI64Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.add.i64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def add_i64(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return AddI64Op(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AndI32Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.and.i32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def and_i32(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return AndI32Op(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AndI64Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.and.i64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def and_i64(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return AndI64Op(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AssignRefOp(_ods_ir.OpView):
  r"""
  Assigns a reference value from one register to another. This is a runtime
  operation that performs retain/move semantics based on the MOVE bit.
  
  This operation exists to support efficient ref-to-ref assignments where
  the source and destination may have the same or different registers. When
  the source and destination registers are the same, this operation becomes
  a no-op and is elided during bytecode encoding.
  """

  OPERATION_NAME = "vm.assign.ref"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, source, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(source)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def assign_ref(result, source, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return AssignRefOp(result=result, source=source, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Atan2F32Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.atan2.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def atan2_f32(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return Atan2F32Op(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Atan2F64Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.atan2.f64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def atan2_f64(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return Atan2F64Op(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtanF32Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.atan.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def atan_f32(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return AtanF32Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtanF64Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.atan.f64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def atan_f64(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return AtanF64Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BitcastF32I32Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.bitcast.f32.i32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def bitcast_f32_i32(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return BitcastF32I32Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BitcastF64I64Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.bitcast.f64.i64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def bitcast_f64_i64(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return BitcastF64I64Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BitcastI32F32Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.bitcast.i32.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def bitcast_i32_f32(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return BitcastI32F32Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BitcastI64F64Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.bitcast.i64.f64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def bitcast_i64_f64(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return BitcastI64F64Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BranchOp(_ods_ir.OpView):
  r"""
   Represents an unconditional branch operation that branches to a target block
   with the given set of arguments.
  
   ```
   ^bb0(...):
     vm.br ^bb1(%a)
   ^bb1(%blockArg1):
     ...
  ```
  """

  OPERATION_NAME = "vm.br"

  _ODS_REGIONS = (0, True)

  def __init__(self, destOperands, dest, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(destOperands))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = []
    _ods_successors.append(dest)
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def destOperands(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def br(dest_operands, dest, *, loc=None, ip=None) -> BranchOp:
  return BranchOp(destOperands=dest_operands, dest=dest, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class BranchTableOp(_ods_ir.OpView):
  r"""
   Represents a branch table instructing execution to branch to the block with
   the specified index. If the index is out of bounds then execution will
   branch to the default block.
  
   ```
   vm.br_table %index {
     default: ^bb1(%a : i64),
     0: ^bb2,
     1: ^bb3(%c : i64)
   }
  ```
  """

  OPERATION_NAME = "vm.br_table"

  _ODS_OPERAND_SEGMENTS = [1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, index, defaultOperands, caseOperands, case_operand_segments, defaultDestination, caseDestinations, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(index)
    operands.append(_get_op_results_or_values(defaultOperands))
    operands.append(_get_op_results_or_values(caseOperands))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["case_operand_segments"] = (case_operand_segments if (
    isinstance(case_operand_segments, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DenseI32ArrayAttr')) else
      _ods_ir.AttrBuilder.get('DenseI32ArrayAttr')(case_operand_segments, context=_ods_context))
    results = []
    _ods_successors = []
    _ods_successors.append(defaultDestination)
    _ods_successors.extend(caseDestinations)
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def index(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def defaultOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def caseOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def case_operand_segments(self) -> _ods_ir.DenseI32ArrayAttr:
    return self.operation.attributes["case_operand_segments"]

  @case_operand_segments.setter
  def case_operand_segments(self, value: _ods_ir.DenseI32ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["case_operand_segments"] = value

def br_table(index, default_operands, case_operands, case_operand_segments, default_destination, case_destinations, *, loc=None, ip=None) -> BranchTableOp:
  return BranchTableOp(index=index, defaultOperands=default_operands, caseOperands=case_operands, case_operand_segments=case_operand_segments, defaultDestination=default_destination, caseDestinations=case_destinations, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class BreakOp(_ods_ir.OpView):
  r"""
  Breaks into the attached debugger or asks for attaching a debugger. After
  resuming (or if a debugger is not attached) execution will continue at the
  target block.
  """

  OPERATION_NAME = "vm.break"

  _ODS_REGIONS = (0, True)

  def __init__(self, destOperands, dest, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(destOperands))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = []
    _ods_successors.append(dest)
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def destOperands(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def break_(dest_operands, dest, *, loc=None, ip=None) -> BreakOp:
  return BreakOp(destOperands=dest_operands, dest=dest, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class BufferAllocOp(_ods_ir.OpView):
  r"""
  Allocates a new zero-initialized buffer with the given size in bytes.
  """

  OPERATION_NAME = "vm.buffer.alloc"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, length, alignment, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(length)
    operands.append(alignment)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def length(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def alignment(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def buffer_alloc(result, length, alignment, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return BufferAllocOp(result=result, length=length, alignment=alignment, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferCloneOp(_ods_ir.OpView):
  r"""
  Clones a range of the source buffer to produce a mutable buffer with the
  same contents.
  """

  OPERATION_NAME = "vm.buffer.clone"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, source_buffer, source_offset, length, alignment, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(source_buffer)
    operands.append(source_offset)
    operands.append(length)
    operands.append(alignment)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source_buffer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def source_offset(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def length(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[2]

  @builtins.property
  def alignment(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[3]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def buffer_clone(result, source_buffer, source_offset, length, alignment, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return BufferCloneOp(result=result, source_buffer=source_buffer, source_offset=source_offset, length=length, alignment=alignment, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferCompareOp(_ods_ir.OpView):
  r"""
  Returns 1 if the two ranges are bitwise equivalent, somewhat like memcmp.
  """

  OPERATION_NAME = "vm.buffer.compare"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs_buffer, lhs_offset, rhs_buffer, rhs_offset, length, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs_buffer)
    operands.append(lhs_offset)
    operands.append(rhs_buffer)
    operands.append(rhs_offset)
    operands.append(length)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs_buffer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def lhs_offset(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def rhs_buffer(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def rhs_offset(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[3]

  @builtins.property
  def length(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[4]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def buffer_compare(result, lhs_buffer, lhs_offset, rhs_buffer, rhs_offset, length, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return BufferCompareOp(result=result, lhs_buffer=lhs_buffer, lhs_offset=lhs_offset, rhs_buffer=rhs_buffer, rhs_offset=rhs_offset, length=length, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferCopyOp(_ods_ir.OpView):
  r"""
  Copies a range of one buffer to another, like memcpy.
  """

  OPERATION_NAME = "vm.buffer.copy"

  _ODS_REGIONS = (0, True)

  def __init__(self, source_buffer, source_offset, target_buffer, target_offset, length, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(source_buffer)
    operands.append(source_offset)
    operands.append(target_buffer)
    operands.append(target_offset)
    operands.append(length)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source_buffer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def source_offset(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def target_buffer(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def target_offset(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[3]

  @builtins.property
  def length(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[4]

def buffer_copy(source_buffer, source_offset, target_buffer, target_offset, length, *, loc=None, ip=None) -> BufferCopyOp:
  return BufferCopyOp(source_buffer=source_buffer, source_offset=source_offset, target_buffer=target_buffer, target_offset=target_offset, length=length, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class BufferFillF32Op(_ods_ir.OpView):
  r"""
  Fills an element range of the buffer with the given value, like memset.
  """

  OPERATION_NAME = "vm.buffer.fill.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, target_buffer, target_offset, length, value, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(target_buffer)
    operands.append(target_offset)
    operands.append(length)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target_buffer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def target_offset(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def length(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[2]

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[3]

def buffer_fill_f32(target_buffer, target_offset, length, value, *, loc=None, ip=None) -> BufferFillF32Op:
  return BufferFillF32Op(target_buffer=target_buffer, target_offset=target_offset, length=length, value=value, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class BufferFillF64Op(_ods_ir.OpView):
  r"""
  Fills an element range of the buffer with the given value, like memset.
  """

  OPERATION_NAME = "vm.buffer.fill.f64"

  _ODS_REGIONS = (0, True)

  def __init__(self, target_buffer, target_offset, length, value, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(target_buffer)
    operands.append(target_offset)
    operands.append(length)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target_buffer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def target_offset(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def length(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[2]

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[3]

def buffer_fill_f64(target_buffer, target_offset, length, value, *, loc=None, ip=None) -> BufferFillF64Op:
  return BufferFillF64Op(target_buffer=target_buffer, target_offset=target_offset, length=length, value=value, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class BufferFillI8Op(_ods_ir.OpView):
  r"""
  Fills an element range of the buffer with the given value, like memset.
  """

  OPERATION_NAME = "vm.buffer.fill.i8"

  _ODS_REGIONS = (0, True)

  def __init__(self, target_buffer, target_offset, length, value, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(target_buffer)
    operands.append(target_offset)
    operands.append(length)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target_buffer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def target_offset(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def length(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[2]

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[3]

def buffer_fill_i8(target_buffer, target_offset, length, value, *, loc=None, ip=None) -> BufferFillI8Op:
  return BufferFillI8Op(target_buffer=target_buffer, target_offset=target_offset, length=length, value=value, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class BufferFillI16Op(_ods_ir.OpView):
  r"""
  Fills an element range of the buffer with the given value, like memset.
  """

  OPERATION_NAME = "vm.buffer.fill.i16"

  _ODS_REGIONS = (0, True)

  def __init__(self, target_buffer, target_offset, length, value, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(target_buffer)
    operands.append(target_offset)
    operands.append(length)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target_buffer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def target_offset(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def length(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[2]

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[3]

def buffer_fill_i16(target_buffer, target_offset, length, value, *, loc=None, ip=None) -> BufferFillI16Op:
  return BufferFillI16Op(target_buffer=target_buffer, target_offset=target_offset, length=length, value=value, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class BufferFillI32Op(_ods_ir.OpView):
  r"""
  Fills an element range of the buffer with the given value, like memset.
  """

  OPERATION_NAME = "vm.buffer.fill.i32"

  _ODS_REGIONS = (0, True)

  def __init__(self, target_buffer, target_offset, length, value, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(target_buffer)
    operands.append(target_offset)
    operands.append(length)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target_buffer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def target_offset(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def length(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[2]

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[3]

def buffer_fill_i32(target_buffer, target_offset, length, value, *, loc=None, ip=None) -> BufferFillI32Op:
  return BufferFillI32Op(target_buffer=target_buffer, target_offset=target_offset, length=length, value=value, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class BufferFillI64Op(_ods_ir.OpView):
  r"""
  Fills an element range of the buffer with the given value, like memset.
  """

  OPERATION_NAME = "vm.buffer.fill.i64"

  _ODS_REGIONS = (0, True)

  def __init__(self, target_buffer, target_offset, length, value, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(target_buffer)
    operands.append(target_offset)
    operands.append(length)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target_buffer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def target_offset(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def length(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[2]

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[3]

def buffer_fill_i64(target_buffer, target_offset, length, value, *, loc=None, ip=None) -> BufferFillI64Op:
  return BufferFillI64Op(target_buffer=target_buffer, target_offset=target_offset, length=length, value=value, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class BufferHashOp(_ods_ir.OpView):
  r"""
  Computes the SipHash-2-4 of the source buffer at the given offset for
  |length| bytes using seed `0x0001020304...0e0f`.
  """

  OPERATION_NAME = "vm.buffer.hash"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, source_buffer, source_offset, length, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(source_buffer)
    operands.append(source_offset)
    operands.append(length)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source_buffer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def source_offset(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def length(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[2]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def buffer_hash(result, source_buffer, source_offset, length, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return BufferHashOp(result=result, source_buffer=source_buffer, source_offset=source_offset, length=length, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferLengthOp(_ods_ir.OpView):
  r"""
  Returns the total byte length of the given buffer. This is the exact value
  as specified during buffer allocation though the underlying system buffer
  may have additional padding.
  """

  OPERATION_NAME = "vm.buffer.length"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, buffer, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(buffer)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def buffer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def buffer_length(result, buffer, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return BufferLengthOp(result=result, buffer=buffer, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferLoadF32Op(_ods_ir.OpView):
  r"""
  Loads a value from the buffer at the given element offset.
  """

  OPERATION_NAME = "vm.buffer.load.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, source_buffer, source_offset, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(source_buffer)
    operands.append(source_offset)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source_buffer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def source_offset(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def buffer_load_f32(result, source_buffer, source_offset, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return BufferLoadF32Op(result=result, source_buffer=source_buffer, source_offset=source_offset, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferLoadF64Op(_ods_ir.OpView):
  r"""
  Loads a value from the buffer at the given element offset.
  """

  OPERATION_NAME = "vm.buffer.load.f64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, source_buffer, source_offset, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(source_buffer)
    operands.append(source_offset)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source_buffer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def source_offset(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def buffer_load_f64(result, source_buffer, source_offset, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return BufferLoadF64Op(result=result, source_buffer=source_buffer, source_offset=source_offset, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferLoadI8SOp(_ods_ir.OpView):
  r"""
  Loads a value from the buffer at the given element offset.
  """

  OPERATION_NAME = "vm.buffer.load.i8.s"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, source_buffer, source_offset, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(source_buffer)
    operands.append(source_offset)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source_buffer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def source_offset(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def buffer_load_i8_s(result, source_buffer, source_offset, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return BufferLoadI8SOp(result=result, source_buffer=source_buffer, source_offset=source_offset, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferLoadI8UOp(_ods_ir.OpView):
  r"""
  Loads a value from the buffer at the given element offset.
  """

  OPERATION_NAME = "vm.buffer.load.i8.u"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, source_buffer, source_offset, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(source_buffer)
    operands.append(source_offset)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source_buffer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def source_offset(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def buffer_load_i8_u(result, source_buffer, source_offset, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return BufferLoadI8UOp(result=result, source_buffer=source_buffer, source_offset=source_offset, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferLoadI16SOp(_ods_ir.OpView):
  r"""
  Loads a value from the buffer at the given element offset.
  """

  OPERATION_NAME = "vm.buffer.load.i16.s"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, source_buffer, source_offset, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(source_buffer)
    operands.append(source_offset)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source_buffer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def source_offset(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def buffer_load_i16_s(result, source_buffer, source_offset, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return BufferLoadI16SOp(result=result, source_buffer=source_buffer, source_offset=source_offset, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferLoadI16UOp(_ods_ir.OpView):
  r"""
  Loads a value from the buffer at the given element offset.
  """

  OPERATION_NAME = "vm.buffer.load.i16.u"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, source_buffer, source_offset, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(source_buffer)
    operands.append(source_offset)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source_buffer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def source_offset(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def buffer_load_i16_u(result, source_buffer, source_offset, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return BufferLoadI16UOp(result=result, source_buffer=source_buffer, source_offset=source_offset, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferLoadI32Op(_ods_ir.OpView):
  r"""
  Loads a value from the buffer at the given element offset.
  """

  OPERATION_NAME = "vm.buffer.load.i32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, source_buffer, source_offset, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(source_buffer)
    operands.append(source_offset)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source_buffer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def source_offset(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def buffer_load_i32(result, source_buffer, source_offset, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return BufferLoadI32Op(result=result, source_buffer=source_buffer, source_offset=source_offset, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferLoadI64Op(_ods_ir.OpView):
  r"""
  Loads a value from the buffer at the given element offset.
  """

  OPERATION_NAME = "vm.buffer.load.i64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, source_buffer, source_offset, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(source_buffer)
    operands.append(source_offset)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source_buffer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def source_offset(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def buffer_load_i64(result, source_buffer, source_offset, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return BufferLoadI64Op(result=result, source_buffer=source_buffer, source_offset=source_offset, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferStoreF32Op(_ods_ir.OpView):
  r"""
  Stores a value to the buffer at the given element offset.
  """

  OPERATION_NAME = "vm.buffer.store.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, target_buffer, target_offset, value, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(target_buffer)
    operands.append(target_offset)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target_buffer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def target_offset(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[2]

def buffer_store_f32(target_buffer, target_offset, value, *, loc=None, ip=None) -> BufferStoreF32Op:
  return BufferStoreF32Op(target_buffer=target_buffer, target_offset=target_offset, value=value, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class BufferStoreF64Op(_ods_ir.OpView):
  r"""
  Stores a value to the buffer at the given element offset.
  """

  OPERATION_NAME = "vm.buffer.store.f64"

  _ODS_REGIONS = (0, True)

  def __init__(self, target_buffer, target_offset, value, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(target_buffer)
    operands.append(target_offset)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target_buffer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def target_offset(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[2]

def buffer_store_f64(target_buffer, target_offset, value, *, loc=None, ip=None) -> BufferStoreF64Op:
  return BufferStoreF64Op(target_buffer=target_buffer, target_offset=target_offset, value=value, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class BufferStoreI8Op(_ods_ir.OpView):
  r"""
  Stores a value to the buffer at the given element offset.
  """

  OPERATION_NAME = "vm.buffer.store.i8"

  _ODS_REGIONS = (0, True)

  def __init__(self, target_buffer, target_offset, value, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(target_buffer)
    operands.append(target_offset)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target_buffer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def target_offset(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[2]

def buffer_store_i8(target_buffer, target_offset, value, *, loc=None, ip=None) -> BufferStoreI8Op:
  return BufferStoreI8Op(target_buffer=target_buffer, target_offset=target_offset, value=value, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class BufferStoreI16Op(_ods_ir.OpView):
  r"""
  Stores a value to the buffer at the given element offset.
  """

  OPERATION_NAME = "vm.buffer.store.i16"

  _ODS_REGIONS = (0, True)

  def __init__(self, target_buffer, target_offset, value, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(target_buffer)
    operands.append(target_offset)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target_buffer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def target_offset(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[2]

def buffer_store_i16(target_buffer, target_offset, value, *, loc=None, ip=None) -> BufferStoreI16Op:
  return BufferStoreI16Op(target_buffer=target_buffer, target_offset=target_offset, value=value, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class BufferStoreI32Op(_ods_ir.OpView):
  r"""
  Stores a value to the buffer at the given element offset.
  """

  OPERATION_NAME = "vm.buffer.store.i32"

  _ODS_REGIONS = (0, True)

  def __init__(self, target_buffer, target_offset, value, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(target_buffer)
    operands.append(target_offset)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target_buffer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def target_offset(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[2]

def buffer_store_i32(target_buffer, target_offset, value, *, loc=None, ip=None) -> BufferStoreI32Op:
  return BufferStoreI32Op(target_buffer=target_buffer, target_offset=target_offset, value=value, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class BufferStoreI64Op(_ods_ir.OpView):
  r"""
  Stores a value to the buffer at the given element offset.
  """

  OPERATION_NAME = "vm.buffer.store.i64"

  _ODS_REGIONS = (0, True)

  def __init__(self, target_buffer, target_offset, value, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(target_buffer)
    operands.append(target_offset)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target_buffer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def target_offset(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[2]

def buffer_store_i64(target_buffer, target_offset, value, *, loc=None, ip=None) -> BufferStoreI64Op:
  return BufferStoreI64Op(target_buffer=target_buffer, target_offset=target_offset, value=value, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CallOp(_ods_ir.OpView):
  r"""
  Calls an internal VM function with the given arguments.
  """

  OPERATION_NAME = "vm.call"

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, callee, operands_, *, arg_attrs=None, res_attrs=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["callee"] = (callee if (
    isinstance(callee, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('VM_FuncRefAttr')) else
      _ods_ir.AttrBuilder.get('VM_FuncRefAttr')(callee, context=_ods_context))
    if arg_attrs is not None: attributes["arg_attrs"] = (arg_attrs if (
        isinstance(arg_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(arg_attrs, context=_ods_context))
    if res_attrs is not None: attributes["res_attrs"] = (res_attrs if (
        isinstance(res_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(res_attrs, context=_ods_context))
    results = []
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def callee(self) -> _ods_ir.Attribute:
    return self.operation.attributes["callee"]

  @callee.setter
  def callee(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["callee"] = value

  @builtins.property
  def arg_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "arg_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["arg_attrs"]

  @arg_attrs.setter
  def arg_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["arg_attrs"] = value
    elif "arg_attrs" in self.operation.attributes:
      del self.operation.attributes["arg_attrs"]

  @arg_attrs.deleter
  def arg_attrs(self):
    del self.operation.attributes["arg_attrs"]

  @builtins.property
  def res_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "res_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["res_attrs"]

  @res_attrs.setter
  def res_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["res_attrs"] = value
    elif "res_attrs" in self.operation.attributes:
      del self.operation.attributes["res_attrs"]

  @res_attrs.deleter
  def res_attrs(self):
    del self.operation.attributes["res_attrs"]

  @builtins.property
  def results_(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def call(results_, callee, operands_, *, arg_attrs=None, res_attrs=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, CallOp]:
  op = CallOp(results_=results_, callee=callee, operands_=operands_, arg_attrs=arg_attrs, res_attrs=res_attrs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class CallVariadicOp(_ods_ir.OpView):
  r"""
  Calls an internal VM function with the given arguments. One or more of the
  arguments may be variadic, encoded as segmented sized operand lists.
  
  Variadic arguments must be specified with a total count in the segment_sizes
  attribute.
  """

  OPERATION_NAME = "vm.call.variadic"

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, callee, segment_sizes, segment_types, operands_, *, arg_attrs=None, res_attrs=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["callee"] = (callee if (
    isinstance(callee, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('VM_FuncRefAttr')) else
      _ods_ir.AttrBuilder.get('VM_FuncRefAttr')(callee, context=_ods_context))
    attributes["segment_sizes"] = (segment_sizes if (
    isinstance(segment_sizes, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_1204')) else
      _ods_ir.AttrBuilder.get('anonymous_1204')(segment_sizes, context=_ods_context))
    attributes["segment_types"] = (segment_types if (
    isinstance(segment_types, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeArrayAttr')) else
      _ods_ir.AttrBuilder.get('TypeArrayAttr')(segment_types, context=_ods_context))
    if arg_attrs is not None: attributes["arg_attrs"] = (arg_attrs if (
        isinstance(arg_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(arg_attrs, context=_ods_context))
    if res_attrs is not None: attributes["res_attrs"] = (res_attrs if (
        isinstance(res_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(res_attrs, context=_ods_context))
    results = []
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def callee(self) -> _ods_ir.Attribute:
    return self.operation.attributes["callee"]

  @callee.setter
  def callee(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["callee"] = value

  @builtins.property
  def segment_sizes(self) -> _ods_ir.DenseIntElementsAttr:
    return self.operation.attributes["segment_sizes"]

  @segment_sizes.setter
  def segment_sizes(self, value: _ods_ir.DenseIntElementsAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["segment_sizes"] = value

  @builtins.property
  def segment_types(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["segment_types"]

  @segment_types.setter
  def segment_types(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["segment_types"] = value

  @builtins.property
  def arg_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "arg_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["arg_attrs"]

  @arg_attrs.setter
  def arg_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["arg_attrs"] = value
    elif "arg_attrs" in self.operation.attributes:
      del self.operation.attributes["arg_attrs"]

  @arg_attrs.deleter
  def arg_attrs(self):
    del self.operation.attributes["arg_attrs"]

  @builtins.property
  def res_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "res_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["res_attrs"]

  @res_attrs.setter
  def res_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["res_attrs"] = value
    elif "res_attrs" in self.operation.attributes:
      del self.operation.attributes["res_attrs"]

  @res_attrs.deleter
  def res_attrs(self):
    del self.operation.attributes["res_attrs"]

  @builtins.property
  def results_(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def call_variadic(results_, callee, segment_sizes, segment_types, operands_, *, arg_attrs=None, res_attrs=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, CallVariadicOp]:
  op = CallVariadicOp(results_=results_, callee=callee, segment_sizes=segment_sizes, segment_types=segment_types, operands_=operands_, arg_attrs=arg_attrs, res_attrs=res_attrs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class CastAnyRefOp(_ods_ir.OpView):
  r"""
  Performs a runtime cast of an opaque `!vm.ref<?>` to a specific `!vm.ref<T>`
  and raises an error if the operand does not match the expected type.
  Null refs can always be cast between types.
  """

  OPERATION_NAME = "vm.cast.any.ref"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cast_any_ref(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CastAnyRefOp(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CastF32SI32Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.cast.f32.si32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cast_f32_si32(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CastF32SI32Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CastF32SI64Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.cast.f32.si64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cast_f32_si64(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CastF32SI64Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CastF32UI32Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.cast.f32.ui32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cast_f32_ui32(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CastF32UI32Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CastF32UI64Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.cast.f32.ui64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cast_f32_ui64(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CastF32UI64Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CastF64SI64Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.cast.f64.si64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cast_f64_si64(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CastF64SI64Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CastF64UI64Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.cast.f64.ui64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cast_f64_ui64(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CastF64UI64Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CastRefAnyOp(_ods_ir.OpView):
  r"""
  Performs a compile-time widening cast of a specific `!vm.ref<T>` to an
  opaque `!vm.ref<?>`. At runtime this is equivalent to a ref assignment
  since all refs have the same representation. Uses the same encoding as
  vm.assign.ref.
  """

  OPERATION_NAME = "vm.cast.ref.any"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cast_ref_any(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CastRefAnyOp(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CastSI32F32Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.cast.si32.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def cast_si32_f32(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CastSI32F32Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CastSI64F32Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.cast.si64.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def cast_si64_f32(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CastSI64F32Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CastSI64F64Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.cast.si64.f64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def cast_si64_f64(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CastSI64F64Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CastUI32F32Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.cast.ui32.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def cast_ui32_f32(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CastUI32F32Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CastUI64F32Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.cast.ui64.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def cast_ui64_f32(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CastUI64F32Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CastUI64F64Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.cast.ui64.f64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def cast_ui64_f64(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CastUI64F64Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CeilF32Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.ceil.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def ceil_f32(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CeilF32Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CeilF64Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.ceil.f64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def ceil_f64(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CeilF64Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CheckEQOp(_ods_ir.OpView):
  r"""
  When the condition is true this signals a runtime failure that causes the
  entire active invocation - and possibly *all* in-flight and pending
  invocations - to fail. The status will be propagated back via the available
  runtime error handling mechanisms such as semaphores or synchronous
  invocation results.
  
  This is implemented as a pseudo-op that transforms into a vm.cond_fail
  operation.
  
  ```
  vm.check.eq %a, %b, "a == b" : i32
  vm.check.nz %ref, "!null" : !vm.ref<?>
  ```
  """

  OPERATION_NAME = "vm.check.eq"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, message=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    if message is not None: attributes["message"] = (message if (
        isinstance(message, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(message, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def message(self) -> _Optional[_ods_ir.StringAttr]:
    if "message" not in self.operation.attributes:
      return None
    return self.operation.attributes["message"]

  @message.setter
  def message(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["message"] = value
    elif "message" in self.operation.attributes:
      del self.operation.attributes["message"]

  @message.deleter
  def message(self):
    del self.operation.attributes["message"]

def check_eq(lhs, rhs, *, message=None, loc=None, ip=None) -> CheckEQOp:
  return CheckEQOp(lhs=lhs, rhs=rhs, message=message, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CheckNEOp(_ods_ir.OpView):
  r"""
  When the condition is true this signals a runtime failure that causes the
  entire active invocation - and possibly *all* in-flight and pending
  invocations - to fail. The status will be propagated back via the available
  runtime error handling mechanisms such as semaphores or synchronous
  invocation results.
  
  This is implemented as a pseudo-op that transforms into a vm.cond_fail
  operation.
  
  ```
  vm.check.eq %a, %b, "a == b" : i32
  vm.check.nz %ref, "!null" : !vm.ref<?>
  ```
  """

  OPERATION_NAME = "vm.check.ne"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, message=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    if message is not None: attributes["message"] = (message if (
        isinstance(message, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(message, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def message(self) -> _Optional[_ods_ir.StringAttr]:
    if "message" not in self.operation.attributes:
      return None
    return self.operation.attributes["message"]

  @message.setter
  def message(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["message"] = value
    elif "message" in self.operation.attributes:
      del self.operation.attributes["message"]

  @message.deleter
  def message(self):
    del self.operation.attributes["message"]

def check_ne(lhs, rhs, *, message=None, loc=None, ip=None) -> CheckNEOp:
  return CheckNEOp(lhs=lhs, rhs=rhs, message=message, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CheckNZOp(_ods_ir.OpView):
  r"""
  When the condition is true this signals a runtime failure that causes the
  entire active invocation - and possibly *all* in-flight and pending
  invocations - to fail. The status will be propagated back via the available
  runtime error handling mechanisms such as semaphores or synchronous
  invocation results.
  
  This is implemented as a pseudo-op that transforms into a vm.cond_fail
  operation.
  
  ```
  vm.check.eq %a, %b, "a == b" : i32
  vm.check.nz %ref, "!null" : !vm.ref<?>
  ```
  """

  OPERATION_NAME = "vm.check.nz"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, *, message=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    if message is not None: attributes["message"] = (message if (
        isinstance(message, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(message, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def message(self) -> _Optional[_ods_ir.StringAttr]:
    if "message" not in self.operation.attributes:
      return None
    return self.operation.attributes["message"]

  @message.setter
  def message(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["message"] = value
    elif "message" in self.operation.attributes:
      del self.operation.attributes["message"]

  @message.deleter
  def message(self):
    del self.operation.attributes["message"]

def check_nz(value, *, message=None, loc=None, ip=None) -> CheckNZOp:
  return CheckNZOp(value=value, message=message, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CheckNearlyEQOp(_ods_ir.OpView):
  r"""
  When the condition is true this signals a runtime failure that causes the
  entire active invocation - and possibly *all* in-flight and pending
  invocations - to fail. The status will be propagated back via the available
  runtime error handling mechanisms such as semaphores or synchronous
  invocation results.
  
  This is implemented as a pseudo-op that transforms into a vm.cond_fail
  operation.
  
  ```
  vm.check.eq %a, %b, "a == b" : i32
  vm.check.nz %ref, "!null" : !vm.ref<?>
  ```
  """

  OPERATION_NAME = "vm.check.nearly_eq"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, message=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    if message is not None: attributes["message"] = (message if (
        isinstance(message, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(message, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def message(self) -> _Optional[_ods_ir.StringAttr]:
    if "message" not in self.operation.attributes:
      return None
    return self.operation.attributes["message"]

  @message.setter
  def message(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["message"] = value
    elif "message" in self.operation.attributes:
      del self.operation.attributes["message"]

  @message.deleter
  def message(self):
    del self.operation.attributes["message"]

def check_nearly_eq(lhs, rhs, *, message=None, loc=None, ip=None) -> CheckNearlyEQOp:
  return CheckNearlyEQOp(lhs=lhs, rhs=rhs, message=message, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CmpEQF32NearOp(_ods_ir.OpView):
  r"""
  Compares two operands with the specified predicate.
  """

  OPERATION_NAME = "vm.cmp.eq.f32.near"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_eq_f32_near(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpEQF32NearOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpEQF32OOp(_ods_ir.OpView):
  r"""
  Compares two operands with the specified predicate.
  """

  OPERATION_NAME = "vm.cmp.eq.f32.o"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_eq_f32_o(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpEQF32OOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpEQF32UOp(_ods_ir.OpView):
  r"""
  Compares two operands with the specified predicate.
  """

  OPERATION_NAME = "vm.cmp.eq.f32.u"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_eq_f32_u(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpEQF32UOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpEQF64NearOp(_ods_ir.OpView):
  r"""
  Compares two operands with the specified predicate.
  """

  OPERATION_NAME = "vm.cmp.eq.f64.near"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_eq_f64_near(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpEQF64NearOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpEQF64OOp(_ods_ir.OpView):
  r"""
  Compares two operands with the specified predicate.
  """

  OPERATION_NAME = "vm.cmp.eq.f64.o"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_eq_f64_o(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpEQF64OOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpEQF64UOp(_ods_ir.OpView):
  r"""
  Compares two operands with the specified predicate.
  """

  OPERATION_NAME = "vm.cmp.eq.f64.u"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_eq_f64_u(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpEQF64UOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpEQI32Op(_ods_ir.OpView):
  r"""
  Compares two operands with the specified predicate.
  """

  OPERATION_NAME = "vm.cmp.eq.i32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_eq_i32(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpEQI32Op(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpEQI64Op(_ods_ir.OpView):
  r"""
  Compares two operands with the specified predicate.
  """

  OPERATION_NAME = "vm.cmp.eq.i64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_eq_i64(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpEQI64Op(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpEQRefOp(_ods_ir.OpView):
  r"""
  Compares two operands with the specified predicate.
  """

  OPERATION_NAME = "vm.cmp.eq.ref"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_eq_ref(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpEQRefOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpGTEF32OOp(_ods_ir.OpView):
  r"""
  Compares two operands with the specified predicate.
  """

  OPERATION_NAME = "vm.cmp.gte.f32.o"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_gte_f32_o(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpGTEF32OOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpGTEF32UOp(_ods_ir.OpView):
  r"""
  Compares two operands with the specified predicate.
  """

  OPERATION_NAME = "vm.cmp.gte.f32.u"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_gte_f32_u(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpGTEF32UOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpGTEF64OOp(_ods_ir.OpView):
  r"""
  Compares two operands with the specified predicate.
  """

  OPERATION_NAME = "vm.cmp.gte.f64.o"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_gte_f64_o(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpGTEF64OOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpGTEF64UOp(_ods_ir.OpView):
  r"""
  Compares two operands with the specified predicate.
  """

  OPERATION_NAME = "vm.cmp.gte.f64.u"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_gte_f64_u(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpGTEF64UOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpGTEI32SOp(_ods_ir.OpView):
  r"""
  Compares two operands with the specified predicate.
  """

  OPERATION_NAME = "vm.cmp.gte.i32.s"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_gte_i32_s(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpGTEI32SOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpGTEI32UOp(_ods_ir.OpView):
  r"""
  Compares two operands with the specified predicate.
  """

  OPERATION_NAME = "vm.cmp.gte.i32.u"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_gte_i32_u(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpGTEI32UOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpGTEI64SOp(_ods_ir.OpView):
  r"""
  Compares two operands with the specified predicate.
  """

  OPERATION_NAME = "vm.cmp.gte.i64.s"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_gte_i64_s(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpGTEI64SOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpGTEI64UOp(_ods_ir.OpView):
  r"""
  Compares two operands with the specified predicate.
  """

  OPERATION_NAME = "vm.cmp.gte.i64.u"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_gte_i64_u(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpGTEI64UOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpGTF32OOp(_ods_ir.OpView):
  r"""
  Compares two operands with the specified predicate.
  """

  OPERATION_NAME = "vm.cmp.gt.f32.o"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_gt_f32_o(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpGTF32OOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpGTF32UOp(_ods_ir.OpView):
  r"""
  Compares two operands with the specified predicate.
  """

  OPERATION_NAME = "vm.cmp.gt.f32.u"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_gt_f32_u(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpGTF32UOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpGTF64OOp(_ods_ir.OpView):
  r"""
  Compares two operands with the specified predicate.
  """

  OPERATION_NAME = "vm.cmp.gt.f64.o"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_gt_f64_o(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpGTF64OOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpGTF64UOp(_ods_ir.OpView):
  r"""
  Compares two operands with the specified predicate.
  """

  OPERATION_NAME = "vm.cmp.gt.f64.u"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_gt_f64_u(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpGTF64UOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpGTI32SOp(_ods_ir.OpView):
  r"""
  Compares two operands with the specified predicate.
  """

  OPERATION_NAME = "vm.cmp.gt.i32.s"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_gt_i32_s(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpGTI32SOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpGTI32UOp(_ods_ir.OpView):
  r"""
  Compares two operands with the specified predicate.
  """

  OPERATION_NAME = "vm.cmp.gt.i32.u"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_gt_i32_u(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpGTI32UOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpGTI64SOp(_ods_ir.OpView):
  r"""
  Compares two operands with the specified predicate.
  """

  OPERATION_NAME = "vm.cmp.gt.i64.s"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_gt_i64_s(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpGTI64SOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpGTI64UOp(_ods_ir.OpView):
  r"""
  Compares two operands with the specified predicate.
  """

  OPERATION_NAME = "vm.cmp.gt.i64.u"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_gt_i64_u(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpGTI64UOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpLTEF32OOp(_ods_ir.OpView):
  r"""
  Compares two operands with the specified predicate.
  """

  OPERATION_NAME = "vm.cmp.lte.f32.o"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_lte_f32_o(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpLTEF32OOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpLTEF32UOp(_ods_ir.OpView):
  r"""
  Compares two operands with the specified predicate.
  """

  OPERATION_NAME = "vm.cmp.lte.f32.u"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_lte_f32_u(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpLTEF32UOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpLTEF64OOp(_ods_ir.OpView):
  r"""
  Compares two operands with the specified predicate.
  """

  OPERATION_NAME = "vm.cmp.lte.f64.o"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_lte_f64_o(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpLTEF64OOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpLTEF64UOp(_ods_ir.OpView):
  r"""
  Compares two operands with the specified predicate.
  """

  OPERATION_NAME = "vm.cmp.lte.f64.u"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_lte_f64_u(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpLTEF64UOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpLTEI32SOp(_ods_ir.OpView):
  r"""
  Compares two operands with the specified predicate.
  """

  OPERATION_NAME = "vm.cmp.lte.i32.s"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_lte_i32_s(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpLTEI32SOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpLTEI32UOp(_ods_ir.OpView):
  r"""
  Compares two operands with the specified predicate.
  """

  OPERATION_NAME = "vm.cmp.lte.i32.u"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_lte_i32_u(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpLTEI32UOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpLTEI64SOp(_ods_ir.OpView):
  r"""
  Compares two operands with the specified predicate.
  """

  OPERATION_NAME = "vm.cmp.lte.i64.s"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_lte_i64_s(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpLTEI64SOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpLTEI64UOp(_ods_ir.OpView):
  r"""
  Compares two operands with the specified predicate.
  """

  OPERATION_NAME = "vm.cmp.lte.i64.u"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_lte_i64_u(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpLTEI64UOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpLTF32OOp(_ods_ir.OpView):
  r"""
  Compares two operands with the specified predicate.
  """

  OPERATION_NAME = "vm.cmp.lt.f32.o"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_lt_f32_o(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpLTF32OOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpLTF32UOp(_ods_ir.OpView):
  r"""
  Compares two operands with the specified predicate.
  """

  OPERATION_NAME = "vm.cmp.lt.f32.u"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_lt_f32_u(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpLTF32UOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpLTF64OOp(_ods_ir.OpView):
  r"""
  Compares two operands with the specified predicate.
  """

  OPERATION_NAME = "vm.cmp.lt.f64.o"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_lt_f64_o(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpLTF64OOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpLTF64UOp(_ods_ir.OpView):
  r"""
  Compares two operands with the specified predicate.
  """

  OPERATION_NAME = "vm.cmp.lt.f64.u"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_lt_f64_u(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpLTF64UOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpLTI32SOp(_ods_ir.OpView):
  r"""
  Compares two operands with the specified predicate.
  """

  OPERATION_NAME = "vm.cmp.lt.i32.s"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_lt_i32_s(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpLTI32SOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpLTI32UOp(_ods_ir.OpView):
  r"""
  Compares two operands with the specified predicate.
  """

  OPERATION_NAME = "vm.cmp.lt.i32.u"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_lt_i32_u(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpLTI32UOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpLTI64SOp(_ods_ir.OpView):
  r"""
  Compares two operands with the specified predicate.
  """

  OPERATION_NAME = "vm.cmp.lt.i64.s"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_lt_i64_s(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpLTI64SOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpLTI64UOp(_ods_ir.OpView):
  r"""
  Compares two operands with the specified predicate.
  """

  OPERATION_NAME = "vm.cmp.lt.i64.u"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_lt_i64_u(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpLTI64UOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpNEF32OOp(_ods_ir.OpView):
  r"""
  Compares two operands with the specified predicate.
  """

  OPERATION_NAME = "vm.cmp.ne.f32.o"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_ne_f32_o(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpNEF32OOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpNEF32UOp(_ods_ir.OpView):
  r"""
  Compares two operands with the specified predicate.
  """

  OPERATION_NAME = "vm.cmp.ne.f32.u"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_ne_f32_u(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpNEF32UOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpNEF64OOp(_ods_ir.OpView):
  r"""
  Compares two operands with the specified predicate.
  """

  OPERATION_NAME = "vm.cmp.ne.f64.o"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_ne_f64_o(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpNEF64OOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpNEF64UOp(_ods_ir.OpView):
  r"""
  Compares two operands with the specified predicate.
  """

  OPERATION_NAME = "vm.cmp.ne.f64.u"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_ne_f64_u(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpNEF64UOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpNEI32Op(_ods_ir.OpView):
  r"""
  Compares two operands with the specified predicate.
  """

  OPERATION_NAME = "vm.cmp.ne.i32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_ne_i32(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpNEI32Op(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpNEI64Op(_ods_ir.OpView):
  r"""
  Compares two operands with the specified predicate.
  """

  OPERATION_NAME = "vm.cmp.ne.i64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_ne_i64(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpNEI64Op(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpNERefOp(_ods_ir.OpView):
  r"""
  Compares two operands with the specified predicate.
  """

  OPERATION_NAME = "vm.cmp.ne.ref"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_ne_ref(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpNERefOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpNZF32OOp(_ods_ir.OpView):
  r"""
  Compares the given floating-point operand for a non-zero value.
  """

  OPERATION_NAME = "vm.cmp.nz.f32.o"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_nz_f32_o(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpNZF32OOp(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpNZF32UOp(_ods_ir.OpView):
  r"""
  Compares the given floating-point operand for a non-zero value.
  """

  OPERATION_NAME = "vm.cmp.nz.f32.u"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_nz_f32_u(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpNZF32UOp(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpNZF64OOp(_ods_ir.OpView):
  r"""
  Compares the given floating-point operand for a non-zero value.
  """

  OPERATION_NAME = "vm.cmp.nz.f64.o"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_nz_f64_o(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpNZF64OOp(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpNZF64UOp(_ods_ir.OpView):
  r"""
  Compares the given floating-point operand for a non-zero value.
  """

  OPERATION_NAME = "vm.cmp.nz.f64.u"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_nz_f64_u(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpNZF64UOp(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpNZI32Op(_ods_ir.OpView):
  r"""
  Compares the given integer operand for a non-zero value.
  """

  OPERATION_NAME = "vm.cmp.nz.i32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_nz_i32(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpNZI32Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpNZI64Op(_ods_ir.OpView):
  r"""
  Compares the given integer operand for a non-zero value.
  """

  OPERATION_NAME = "vm.cmp.nz.i64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_nz_i64(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpNZI64Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpNZRefOp(_ods_ir.OpView):
  r"""
  Compares the given ref operand for a non-zero/null value.
  """

  OPERATION_NAME = "vm.cmp.nz.ref"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_nz_ref(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpNZRefOp(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpNaNF32Op(_ods_ir.OpView):
  r"""
  Returns 1 if the value is NaN.
  """

  OPERATION_NAME = "vm.cmp.nan.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_nan_f32(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpNaNF32Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpNaNF64Op(_ods_ir.OpView):
  r"""
  Returns 1 if the value is NaN.
  """

  OPERATION_NAME = "vm.cmp.nan.f64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp_nan_f64(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpNaNF64Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CondBranchOp(_ods_ir.OpView):
  r"""
   Represents a conditional branch operation that branches to one of the two
   target blocks with the given set of arguments.
  
   ```
   ^bb0(...):
     vm.cond_br %condition, ^bb1(%a), ^bb2(%b)
   ^bb1(%blockArg1):
     ...
   ^bb2(%blockArg2):
     ...
  ```
  """

  OPERATION_NAME = "vm.cond_br"

  _ODS_OPERAND_SEGMENTS = [1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, condition, trueDestOperands, falseDestOperands, trueDest, falseDest, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(condition)
    operands.append(_get_op_results_or_values(trueDestOperands))
    operands.append(_get_op_results_or_values(falseDestOperands))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = []
    _ods_successors.append(trueDest)
    _ods_successors.append(falseDest)
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def condition(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def trueDestOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def falseDestOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

def cond_br(condition, true_dest_operands, false_dest_operands, true_dest, false_dest, *, loc=None, ip=None) -> CondBranchOp:
  return CondBranchOp(condition=condition, trueDestOperands=true_dest_operands, falseDestOperands=false_dest_operands, trueDest=true_dest, falseDest=false_dest, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CondBreakOp(_ods_ir.OpView):
  r"""
  Breaks into the attached debugger or asks for attaching a debugger if the
  provided condition is true. After resuming (or if a debugger is not
  attached) execution will continue at the target block.
  """

  OPERATION_NAME = "vm.cond_break"

  _ODS_REGIONS = (0, True)

  def __init__(self, condition, destOperands, dest, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(condition)
    operands.extend(_get_op_results_or_values(destOperands))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = []
    _ods_successors.append(dest)
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def condition(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def destOperands(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

def cond_break(condition, dest_operands, dest, *, loc=None, ip=None) -> CondBreakOp:
  return CondBreakOp(condition=condition, destOperands=dest_operands, dest=dest, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CondFailOp(_ods_ir.OpView):
  r"""
  When the condition is true this signals a runtime failure that causes the
  entire active invocation - and possibly *all* in-flight and pending
  invocations - to fail with the given status. The status will be propagated
  back via the available runtime error handling mechanisms such as semaphores
  or synchronous invocation results.
  
  As the IREE execution model is deeply pipelined it's possible that failures
  have a latency between when they are emitted and when the application can
  observe the failure. It's also possible that other work that is in-flight
  or pending when the failure occurs will complete.
  
  This is implemented as a pseudo-op that transforms into a vm.fail operation
  guarded by the condition.
  
  ```
  %nz = vm.cmp.nz.i32 %value : i32
  %statusCode = vm.const.i32 9
  vm.cond_fail %nz, %statusCode, "expected non-zero"
  ```
  """

  OPERATION_NAME = "vm.cond_fail"

  _ODS_REGIONS = (0, True)

  def __init__(self, condition, status, *, message=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(condition)
    operands.append(status)
    _ods_context = _ods_get_default_loc_context(loc)
    if message is not None: attributes["message"] = (message if (
        isinstance(message, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(message, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def condition(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def status(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def message(self) -> _Optional[_ods_ir.StringAttr]:
    if "message" not in self.operation.attributes:
      return None
    return self.operation.attributes["message"]

  @message.setter
  def message(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["message"] = value
    elif "message" in self.operation.attributes:
      del self.operation.attributes["message"]

  @message.deleter
  def message(self):
    del self.operation.attributes["message"]

def cond_fail(condition, status, *, message=None, loc=None, ip=None) -> CondFailOp:
  return CondFailOp(condition=condition, status=status, message=message, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ConstF32Op(_ods_ir.OpView):
  r"""
  Defines a constant value that is treated as a scalar literal at runtime.
  """

  OPERATION_NAME = "vm.const.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, value, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_794')) else
      _ods_ir.AttrBuilder.get('anonymous_794')(value, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Attribute:
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def const_f32(result, value, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ConstF32Op(result=result, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConstF32ZeroOp(_ods_ir.OpView):
  r"""
  Defines a constant zero primitive.
  """

  OPERATION_NAME = "vm.const.f32.zero"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def const_f32_zero(result, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ConstF32ZeroOp(result=result, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConstF64Op(_ods_ir.OpView):
  r"""
  Defines a constant value that is treated as a scalar literal at runtime.
  """

  OPERATION_NAME = "vm.const.f64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, value, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_796')) else
      _ods_ir.AttrBuilder.get('anonymous_796')(value, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Attribute:
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def const_f64(result, value, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ConstF64Op(result=result, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConstF64ZeroOp(_ods_ir.OpView):
  r"""
  Defines a constant zero primitive.
  """

  OPERATION_NAME = "vm.const.f64.zero"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def const_f64_zero(result, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ConstF64ZeroOp(result=result, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConstI32Op(_ods_ir.OpView):
  r"""
  Defines a constant value that is treated as a scalar literal at runtime.
  """

  OPERATION_NAME = "vm.const.i32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, value, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_790')) else
      _ods_ir.AttrBuilder.get('anonymous_790')(value, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Attribute:
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def const_i32(result, value, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ConstI32Op(result=result, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConstI32ZeroOp(_ods_ir.OpView):
  r"""
  Defines a constant zero primitive.
  """

  OPERATION_NAME = "vm.const.i32.zero"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def const_i32_zero(result, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ConstI32ZeroOp(result=result, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConstI64Op(_ods_ir.OpView):
  r"""
  Defines a constant value that is treated as a scalar literal at runtime.
  """

  OPERATION_NAME = "vm.const.i64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, value, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_792')) else
      _ods_ir.AttrBuilder.get('anonymous_792')(value, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Attribute:
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def const_i64(result, value, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ConstI64Op(result=result, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConstI64ZeroOp(_ods_ir.OpView):
  r"""
  Defines a constant zero primitive.
  """

  OPERATION_NAME = "vm.const.i64.zero"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def const_i64_zero(result, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ConstI64ZeroOp(result=result, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConstRefRodataOp(_ods_ir.OpView):
  r"""
  Returns a reference to a read-only buffer.
  """

  OPERATION_NAME = "vm.const.ref.rodata"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, rodata, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["rodata"] = (rodata if (
    isinstance(rodata, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(rodata, context=_ods_context))
    results = []
    results.append(value)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def rodata(self) -> _ods_ir.FlatSymbolRefAttr:
    return self.operation.attributes["rodata"]

  @rodata.setter
  def rodata(self, value: _ods_ir.FlatSymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["rodata"] = value

  @builtins.property
  def value(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def const_ref_rodata(value, rodata, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ConstRefRodataOp(value=value, rodata=rodata, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConstRefZeroOp(_ods_ir.OpView):
  r"""
  Defines a constant null ref that can be used in comparisons and
  initialization.
  """

  OPERATION_NAME = "vm.const.ref.zero"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def const_ref_zero(result, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ConstRefZeroOp(result=result, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CosF32Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.cos.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def cos_f32(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CosF32Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CosF64Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.cos.f64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def cos_f64(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CosF64Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CtlzI32Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.ctlz.i32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def ctlz_i32(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CtlzI32Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CtlzI64Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.ctlz.i64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def ctlz_i64(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CtlzI64Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DiscardRefsOp(_ods_ir.OpView):
  r"""
  Explicitly releases reference values. This is used by the compiler to insert
  early releases at ref death points, enabling functions to be marked as
  "refs clean" so the runtime can skip cleanup on the success path.
  
  The encode method is implemented manually in C++ to support per-operand
  elision based on register allocation analysis. Operands that have already
  been released via a MOVE bit on a preceding use are elided from encoding.
  """

  OPERATION_NAME = "vm.discard.refs"

  _ODS_REGIONS = (0, True)

  def __init__(self, refs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(refs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def refs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def discard_refs(refs, *, loc=None, ip=None) -> DiscardRefsOp:
  return DiscardRefsOp(refs=refs, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class DivF32Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.div.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def div_f32(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return DivF32Op(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DivF64Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.div.f64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def div_f64(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return DivF64Op(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DivI32SOp(_ods_ir.OpView):
  OPERATION_NAME = "vm.div.i32.s"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def div_i32_s(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return DivI32SOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DivI32UOp(_ods_ir.OpView):
  OPERATION_NAME = "vm.div.i32.u"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def div_i32_u(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return DivI32UOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DivI64SOp(_ods_ir.OpView):
  OPERATION_NAME = "vm.div.i64.s"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def div_i64_s(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return DivI64SOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DivI64UOp(_ods_ir.OpView):
  OPERATION_NAME = "vm.div.i64.u"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def div_i64_u(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return DivI64UOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ErfF32Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.erf.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def erf_f32(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ErfF32Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ErfF64Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.erf.f64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def erf_f64(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ErfF64Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Exp2F32Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.exp2.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def exp2_f32(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return Exp2F32Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Exp2F64Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.exp2.f64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def exp2_f64(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return Exp2F64Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ExpF32Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.exp.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def exp_f32(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ExpF32Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ExpF64Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.exp.f64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def exp_f64(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ExpF64Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ExpM1F32Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.expm1.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def expm1_f32(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ExpM1F32Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ExpM1F64Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.expm1.f64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def expm1_f64(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ExpM1F64Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ExportOp(_ods_ir.OpView):
  r"""
  Specifies an exported function with an externally-visible alias. Multiple
  exports can reference the same internal functions.
  """

  OPERATION_NAME = "vm.export"

  _ODS_REGIONS = (0, True)

  def __init__(self, function_ref, export_name, *, ordinal=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["function_ref"] = (function_ref if (
    isinstance(function_ref, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(function_ref, context=_ods_context))
    attributes["export_name"] = (export_name if (
    isinstance(export_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(export_name, context=_ods_context))
    if ordinal is not None: attributes["ordinal"] = (ordinal if (
        isinstance(ordinal, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('VM_Ordinal')) else
          _ods_ir.AttrBuilder.get('VM_Ordinal')(ordinal, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def function_ref(self) -> _ods_ir.FlatSymbolRefAttr:
    return self.operation.attributes["function_ref"]

  @function_ref.setter
  def function_ref(self, value: _ods_ir.FlatSymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["function_ref"] = value

  @builtins.property
  def export_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["export_name"]

  @export_name.setter
  def export_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["export_name"] = value

  @builtins.property
  def ordinal(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "ordinal" not in self.operation.attributes:
      return None
    return self.operation.attributes["ordinal"]

  @ordinal.setter
  def ordinal(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["ordinal"] = value
    elif "ordinal" in self.operation.attributes:
      del self.operation.attributes["ordinal"]

  @ordinal.deleter
  def ordinal(self):
    del self.operation.attributes["ordinal"]

def export(function_ref, export_name, *, ordinal=None, loc=None, ip=None) -> ExportOp:
  return ExportOp(function_ref=function_ref, export_name=export_name, ordinal=ordinal, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ExtF32F64Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.ext.f32.f64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def ext_f32_f64(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ExtF32F64Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ExtI8I32SOp(_ods_ir.OpView):
  OPERATION_NAME = "vm.ext.i8.i32.s"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def ext_i8_i32_s(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ExtI8I32SOp(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ExtI8I32UOp(_ods_ir.OpView):
  OPERATION_NAME = "vm.ext.i8.i32.u"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def ext_i8_i32_u(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ExtI8I32UOp(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ExtI8I64SOp(_ods_ir.OpView):
  OPERATION_NAME = "vm.ext.i8.i64.s"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def ext_i8_i64_s(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ExtI8I64SOp(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ExtI8I64UOp(_ods_ir.OpView):
  OPERATION_NAME = "vm.ext.i8.i64.u"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def ext_i8_i64_u(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ExtI8I64UOp(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ExtI16I32SOp(_ods_ir.OpView):
  OPERATION_NAME = "vm.ext.i16.i32.s"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def ext_i16_i32_s(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ExtI16I32SOp(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ExtI16I32UOp(_ods_ir.OpView):
  OPERATION_NAME = "vm.ext.i16.i32.u"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def ext_i16_i32_u(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ExtI16I32UOp(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ExtI16I64SOp(_ods_ir.OpView):
  OPERATION_NAME = "vm.ext.i16.i64.s"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def ext_i16_i64_s(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ExtI16I64SOp(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ExtI16I64UOp(_ods_ir.OpView):
  OPERATION_NAME = "vm.ext.i16.i64.u"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def ext_i16_i64_u(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ExtI16I64UOp(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ExtI32I64SOp(_ods_ir.OpView):
  OPERATION_NAME = "vm.ext.i32.i64.s"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def ext_i32_i64_s(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ExtI32I64SOp(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ExtI32I64UOp(_ods_ir.OpView):
  OPERATION_NAME = "vm.ext.i32.i64.u"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def ext_i32_i64_u(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ExtI32I64UOp(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FMAF32Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.fma.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, a, b, c, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    operands.append(c)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def b(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def c(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[2]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def fma_f32(result, a, b, c, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return FMAF32Op(result=result, a=a, b=b, c=c, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FMAF64Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.fma.f64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, a, b, c, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    operands.append(c)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def b(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def c(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[2]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def fma_f64(result, a, b, c, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return FMAF64Op(result=result, a=a, b=b, c=c, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FMAI32Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.fma.i32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, a, b, c, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    operands.append(c)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def b(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def c(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[2]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def fma_i32(result, a, b, c, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return FMAI32Op(result=result, a=a, b=b, c=c, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FMAI64Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.fma.i64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, a, b, c, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    operands.append(c)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def b(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def c(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[2]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def fma_i64(result, a, b, c, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return FMAI64Op(result=result, a=a, b=b, c=c, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FailOp(_ods_ir.OpView):
  r"""
  Signals a runtime failure that causes the entire active invocation - and
  possibly *all* in-flight and pending invocations - to fail with the given
  status. The status will be propagated back via the available runtime error
  handling mechanisms such as semaphores or synchronous invocation results.
  
  As the IREE execution model is deeply pipelined it's possible that failures
  have a latency between when they are emitted and when the application can
  observe the failure. It's also possible that other work that is in-flight
  or pending when the failure occurs will complete.
  
  ```
  %statusCode = vm.const.i32 9
  vm.fail %statusCode, "oh no!"
  ```
  """

  OPERATION_NAME = "vm.fail"

  _ODS_REGIONS = (0, True)

  def __init__(self, status, *, message=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(status)
    _ods_context = _ods_get_default_loc_context(loc)
    if message is not None: attributes["message"] = (message if (
        isinstance(message, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(message, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def status(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def message(self) -> _Optional[_ods_ir.StringAttr]:
    if "message" not in self.operation.attributes:
      return None
    return self.operation.attributes["message"]

  @message.setter
  def message(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["message"] = value
    elif "message" in self.operation.attributes:
      del self.operation.attributes["message"]

  @message.deleter
  def message(self):
    del self.operation.attributes["message"]

def fail(status, *, message=None, loc=None, ip=None) -> FailOp:
  return FailOp(status=status, message=message, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class FloorF32Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.floor.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def floor_f32(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return FloorF32Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FloorF64Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.floor.f64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def floor_f64(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return FloorF64Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FuncOp(_ods_ir.OpView):
  r"""
  Represents a function containing VM ops and those of compatible dialects.
  All flow control is performed by VM ops.
  """

  OPERATION_NAME = "vm.func"

  _ODS_REGIONS = (1, True)

  def __init__(self, function_type, *, ordinal=None, inlining_policy=None, arg_attrs=None, res_attrs=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["function_type"] = (function_type if (
    isinstance(function_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_771')) else
      _ods_ir.AttrBuilder.get('anonymous_771')(function_type, context=_ods_context))
    if ordinal is not None: attributes["ordinal"] = (ordinal if (
        isinstance(ordinal, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('VM_Ordinal')) else
          _ods_ir.AttrBuilder.get('VM_Ordinal')(ordinal, context=_ods_context))
    if inlining_policy is not None: attributes["inlining_policy"] = (inlining_policy if (
        isinstance(inlining_policy, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Util_InliningPolicyAttrInterface')) else
          _ods_ir.AttrBuilder.get('Util_InliningPolicyAttrInterface')(inlining_policy, context=_ods_context))
    if arg_attrs is not None: attributes["arg_attrs"] = (arg_attrs if (
        isinstance(arg_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(arg_attrs, context=_ods_context))
    if res_attrs is not None: attributes["res_attrs"] = (res_attrs if (
        isinstance(res_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(res_attrs, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def function_type(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["function_type"]

  @function_type.setter
  def function_type(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["function_type"] = value

  @builtins.property
  def ordinal(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "ordinal" not in self.operation.attributes:
      return None
    return self.operation.attributes["ordinal"]

  @ordinal.setter
  def ordinal(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["ordinal"] = value
    elif "ordinal" in self.operation.attributes:
      del self.operation.attributes["ordinal"]

  @ordinal.deleter
  def ordinal(self):
    del self.operation.attributes["ordinal"]

  @builtins.property
  def inlining_policy(self) -> _Optional[_ods_ir.Attribute]:
    if "inlining_policy" not in self.operation.attributes:
      return None
    return self.operation.attributes["inlining_policy"]

  @inlining_policy.setter
  def inlining_policy(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["inlining_policy"] = value
    elif "inlining_policy" in self.operation.attributes:
      del self.operation.attributes["inlining_policy"]

  @inlining_policy.deleter
  def inlining_policy(self):
    del self.operation.attributes["inlining_policy"]

  @builtins.property
  def arg_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "arg_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["arg_attrs"]

  @arg_attrs.setter
  def arg_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["arg_attrs"] = value
    elif "arg_attrs" in self.operation.attributes:
      del self.operation.attributes["arg_attrs"]

  @arg_attrs.deleter
  def arg_attrs(self):
    del self.operation.attributes["arg_attrs"]

  @builtins.property
  def res_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "res_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["res_attrs"]

  @res_attrs.setter
  def res_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["res_attrs"] = value
    elif "res_attrs" in self.operation.attributes:
      del self.operation.attributes["res_attrs"]

  @res_attrs.deleter
  def res_attrs(self):
    del self.operation.attributes["res_attrs"]

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def func(function_type, *, ordinal=None, inlining_policy=None, arg_attrs=None, res_attrs=None, loc=None, ip=None) -> FuncOp:
  return FuncOp(function_type=function_type, ordinal=ordinal, inlining_policy=inlining_policy, arg_attrs=arg_attrs, res_attrs=res_attrs, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GlobalAddressOp(_ods_ir.OpView):
  r"""
  Returns an indirect address reference to the given global. During export the
  address will be converted to the natural format of the global table (for
  example, ordinals for refs and byte offsets for primitive types).
  """

  OPERATION_NAME = "vm.global.address"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, global_, *, is_immutable=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["global"] = (global_ if (
    isinstance(global_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('VM_GlobalRefAttr')) else
      _ods_ir.AttrBuilder.get('VM_GlobalRefAttr')(global_, context=_ods_context))
    if bool(is_immutable): attributes["is_immutable"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def global_(self) -> _ods_ir.Attribute:
    return self.operation.attributes["global"]

  @global_.setter
  def global_(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["global"] = value

  @builtins.property
  def is_immutable(self) -> bool:
    return "is_immutable" in self.operation.attributes

  @is_immutable.setter
  def is_immutable(self, value):
    if bool(value):
      self.operation.attributes["is_immutable"] = _ods_ir.UnitAttr.get()
    elif "is_immutable" in self.operation.attributes:
      del self.operation.attributes["is_immutable"]

  @is_immutable.deleter
  def is_immutable(self):
    del self.operation.attributes["is_immutable"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def global_address(result, global_, *, is_immutable=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GlobalAddressOp(result=result, global_=global_, is_immutable=is_immutable, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GlobalF32Op(_ods_ir.OpView):
  r"""
  Defines a global value that is treated as a scalar literal at runtime.
  Initialized to zero unless an initial value is specified.
  """

  OPERATION_NAME = "vm.global.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, sym_name, type_, *, sym_visibility=None, is_mutable=None, initial_value=None, inlining_policy=None, ordinal=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if sym_visibility is not None: attributes["sym_visibility"] = (sym_visibility if (
        isinstance(sym_visibility, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(sym_visibility, context=_ods_context))
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["type"] = (type_ if (
    isinstance(type_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(type_, context=_ods_context))
    if bool(is_mutable): attributes["is_mutable"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if initial_value is not None: attributes["initial_value"] = (initial_value if (
        isinstance(initial_value, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_794')) else
          _ods_ir.AttrBuilder.get('anonymous_794')(initial_value, context=_ods_context))
    if inlining_policy is not None: attributes["inlining_policy"] = (inlining_policy if (
        isinstance(inlining_policy, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Util_InliningPolicyAttrInterface')) else
          _ods_ir.AttrBuilder.get('Util_InliningPolicyAttrInterface')(inlining_policy, context=_ods_context))
    if ordinal is not None: attributes["ordinal"] = (ordinal if (
        isinstance(ordinal, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('VM_Ordinal')) else
          _ods_ir.AttrBuilder.get('VM_Ordinal')(ordinal, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_visibility(self) -> _Optional[_ods_ir.StringAttr]:
    if "sym_visibility" not in self.operation.attributes:
      return None
    return self.operation.attributes["sym_visibility"]

  @sym_visibility.setter
  def sym_visibility(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["sym_visibility"] = value
    elif "sym_visibility" in self.operation.attributes:
      del self.operation.attributes["sym_visibility"]

  @sym_visibility.deleter
  def sym_visibility(self):
    del self.operation.attributes["sym_visibility"]

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def type_(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["type"]

  @type_.setter
  def type_(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["type"] = value

  @builtins.property
  def is_mutable(self) -> bool:
    return "is_mutable" in self.operation.attributes

  @is_mutable.setter
  def is_mutable(self, value):
    if bool(value):
      self.operation.attributes["is_mutable"] = _ods_ir.UnitAttr.get()
    elif "is_mutable" in self.operation.attributes:
      del self.operation.attributes["is_mutable"]

  @is_mutable.deleter
  def is_mutable(self):
    del self.operation.attributes["is_mutable"]

  @builtins.property
  def initial_value(self) -> _Optional[_ods_ir.Attribute]:
    if "initial_value" not in self.operation.attributes:
      return None
    return self.operation.attributes["initial_value"]

  @initial_value.setter
  def initial_value(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["initial_value"] = value
    elif "initial_value" in self.operation.attributes:
      del self.operation.attributes["initial_value"]

  @initial_value.deleter
  def initial_value(self):
    del self.operation.attributes["initial_value"]

  @builtins.property
  def inlining_policy(self) -> _Optional[_ods_ir.Attribute]:
    if "inlining_policy" not in self.operation.attributes:
      return None
    return self.operation.attributes["inlining_policy"]

  @inlining_policy.setter
  def inlining_policy(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["inlining_policy"] = value
    elif "inlining_policy" in self.operation.attributes:
      del self.operation.attributes["inlining_policy"]

  @inlining_policy.deleter
  def inlining_policy(self):
    del self.operation.attributes["inlining_policy"]

  @builtins.property
  def ordinal(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "ordinal" not in self.operation.attributes:
      return None
    return self.operation.attributes["ordinal"]

  @ordinal.setter
  def ordinal(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["ordinal"] = value
    elif "ordinal" in self.operation.attributes:
      del self.operation.attributes["ordinal"]

  @ordinal.deleter
  def ordinal(self):
    del self.operation.attributes["ordinal"]

def global_f32(sym_name, type_, *, sym_visibility=None, is_mutable=None, initial_value=None, inlining_policy=None, ordinal=None, loc=None, ip=None) -> GlobalF32Op:
  return GlobalF32Op(sym_name=sym_name, type_=type_, sym_visibility=sym_visibility, is_mutable=is_mutable, initial_value=initial_value, inlining_policy=inlining_policy, ordinal=ordinal, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GlobalF64Op(_ods_ir.OpView):
  r"""
  Defines a global value that is treated as a scalar literal at runtime.
  Initialized to zero unless an initial value is specified.
  """

  OPERATION_NAME = "vm.global.f64"

  _ODS_REGIONS = (0, True)

  def __init__(self, sym_name, type_, *, sym_visibility=None, is_mutable=None, initial_value=None, inlining_policy=None, ordinal=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if sym_visibility is not None: attributes["sym_visibility"] = (sym_visibility if (
        isinstance(sym_visibility, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(sym_visibility, context=_ods_context))
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["type"] = (type_ if (
    isinstance(type_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(type_, context=_ods_context))
    if bool(is_mutable): attributes["is_mutable"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if initial_value is not None: attributes["initial_value"] = (initial_value if (
        isinstance(initial_value, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_796')) else
          _ods_ir.AttrBuilder.get('anonymous_796')(initial_value, context=_ods_context))
    if inlining_policy is not None: attributes["inlining_policy"] = (inlining_policy if (
        isinstance(inlining_policy, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Util_InliningPolicyAttrInterface')) else
          _ods_ir.AttrBuilder.get('Util_InliningPolicyAttrInterface')(inlining_policy, context=_ods_context))
    if ordinal is not None: attributes["ordinal"] = (ordinal if (
        isinstance(ordinal, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('VM_Ordinal')) else
          _ods_ir.AttrBuilder.get('VM_Ordinal')(ordinal, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_visibility(self) -> _Optional[_ods_ir.StringAttr]:
    if "sym_visibility" not in self.operation.attributes:
      return None
    return self.operation.attributes["sym_visibility"]

  @sym_visibility.setter
  def sym_visibility(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["sym_visibility"] = value
    elif "sym_visibility" in self.operation.attributes:
      del self.operation.attributes["sym_visibility"]

  @sym_visibility.deleter
  def sym_visibility(self):
    del self.operation.attributes["sym_visibility"]

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def type_(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["type"]

  @type_.setter
  def type_(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["type"] = value

  @builtins.property
  def is_mutable(self) -> bool:
    return "is_mutable" in self.operation.attributes

  @is_mutable.setter
  def is_mutable(self, value):
    if bool(value):
      self.operation.attributes["is_mutable"] = _ods_ir.UnitAttr.get()
    elif "is_mutable" in self.operation.attributes:
      del self.operation.attributes["is_mutable"]

  @is_mutable.deleter
  def is_mutable(self):
    del self.operation.attributes["is_mutable"]

  @builtins.property
  def initial_value(self) -> _Optional[_ods_ir.Attribute]:
    if "initial_value" not in self.operation.attributes:
      return None
    return self.operation.attributes["initial_value"]

  @initial_value.setter
  def initial_value(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["initial_value"] = value
    elif "initial_value" in self.operation.attributes:
      del self.operation.attributes["initial_value"]

  @initial_value.deleter
  def initial_value(self):
    del self.operation.attributes["initial_value"]

  @builtins.property
  def inlining_policy(self) -> _Optional[_ods_ir.Attribute]:
    if "inlining_policy" not in self.operation.attributes:
      return None
    return self.operation.attributes["inlining_policy"]

  @inlining_policy.setter
  def inlining_policy(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["inlining_policy"] = value
    elif "inlining_policy" in self.operation.attributes:
      del self.operation.attributes["inlining_policy"]

  @inlining_policy.deleter
  def inlining_policy(self):
    del self.operation.attributes["inlining_policy"]

  @builtins.property
  def ordinal(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "ordinal" not in self.operation.attributes:
      return None
    return self.operation.attributes["ordinal"]

  @ordinal.setter
  def ordinal(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["ordinal"] = value
    elif "ordinal" in self.operation.attributes:
      del self.operation.attributes["ordinal"]

  @ordinal.deleter
  def ordinal(self):
    del self.operation.attributes["ordinal"]

def global_f64(sym_name, type_, *, sym_visibility=None, is_mutable=None, initial_value=None, inlining_policy=None, ordinal=None, loc=None, ip=None) -> GlobalF64Op:
  return GlobalF64Op(sym_name=sym_name, type_=type_, sym_visibility=sym_visibility, is_mutable=is_mutable, initial_value=initial_value, inlining_policy=inlining_policy, ordinal=ordinal, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GlobalI32Op(_ods_ir.OpView):
  r"""
  Defines a global value that is treated as a scalar literal at runtime.
  Initialized to zero unless an initial value is specified.
  """

  OPERATION_NAME = "vm.global.i32"

  _ODS_REGIONS = (0, True)

  def __init__(self, sym_name, type_, *, sym_visibility=None, is_mutable=None, initial_value=None, inlining_policy=None, ordinal=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if sym_visibility is not None: attributes["sym_visibility"] = (sym_visibility if (
        isinstance(sym_visibility, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(sym_visibility, context=_ods_context))
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["type"] = (type_ if (
    isinstance(type_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(type_, context=_ods_context))
    if bool(is_mutable): attributes["is_mutable"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if initial_value is not None: attributes["initial_value"] = (initial_value if (
        isinstance(initial_value, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_790')) else
          _ods_ir.AttrBuilder.get('anonymous_790')(initial_value, context=_ods_context))
    if inlining_policy is not None: attributes["inlining_policy"] = (inlining_policy if (
        isinstance(inlining_policy, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Util_InliningPolicyAttrInterface')) else
          _ods_ir.AttrBuilder.get('Util_InliningPolicyAttrInterface')(inlining_policy, context=_ods_context))
    if ordinal is not None: attributes["ordinal"] = (ordinal if (
        isinstance(ordinal, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('VM_Ordinal')) else
          _ods_ir.AttrBuilder.get('VM_Ordinal')(ordinal, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_visibility(self) -> _Optional[_ods_ir.StringAttr]:
    if "sym_visibility" not in self.operation.attributes:
      return None
    return self.operation.attributes["sym_visibility"]

  @sym_visibility.setter
  def sym_visibility(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["sym_visibility"] = value
    elif "sym_visibility" in self.operation.attributes:
      del self.operation.attributes["sym_visibility"]

  @sym_visibility.deleter
  def sym_visibility(self):
    del self.operation.attributes["sym_visibility"]

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def type_(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["type"]

  @type_.setter
  def type_(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["type"] = value

  @builtins.property
  def is_mutable(self) -> bool:
    return "is_mutable" in self.operation.attributes

  @is_mutable.setter
  def is_mutable(self, value):
    if bool(value):
      self.operation.attributes["is_mutable"] = _ods_ir.UnitAttr.get()
    elif "is_mutable" in self.operation.attributes:
      del self.operation.attributes["is_mutable"]

  @is_mutable.deleter
  def is_mutable(self):
    del self.operation.attributes["is_mutable"]

  @builtins.property
  def initial_value(self) -> _Optional[_ods_ir.Attribute]:
    if "initial_value" not in self.operation.attributes:
      return None
    return self.operation.attributes["initial_value"]

  @initial_value.setter
  def initial_value(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["initial_value"] = value
    elif "initial_value" in self.operation.attributes:
      del self.operation.attributes["initial_value"]

  @initial_value.deleter
  def initial_value(self):
    del self.operation.attributes["initial_value"]

  @builtins.property
  def inlining_policy(self) -> _Optional[_ods_ir.Attribute]:
    if "inlining_policy" not in self.operation.attributes:
      return None
    return self.operation.attributes["inlining_policy"]

  @inlining_policy.setter
  def inlining_policy(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["inlining_policy"] = value
    elif "inlining_policy" in self.operation.attributes:
      del self.operation.attributes["inlining_policy"]

  @inlining_policy.deleter
  def inlining_policy(self):
    del self.operation.attributes["inlining_policy"]

  @builtins.property
  def ordinal(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "ordinal" not in self.operation.attributes:
      return None
    return self.operation.attributes["ordinal"]

  @ordinal.setter
  def ordinal(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["ordinal"] = value
    elif "ordinal" in self.operation.attributes:
      del self.operation.attributes["ordinal"]

  @ordinal.deleter
  def ordinal(self):
    del self.operation.attributes["ordinal"]

def global_i32(sym_name, type_, *, sym_visibility=None, is_mutable=None, initial_value=None, inlining_policy=None, ordinal=None, loc=None, ip=None) -> GlobalI32Op:
  return GlobalI32Op(sym_name=sym_name, type_=type_, sym_visibility=sym_visibility, is_mutable=is_mutable, initial_value=initial_value, inlining_policy=inlining_policy, ordinal=ordinal, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GlobalI64Op(_ods_ir.OpView):
  r"""
  Defines a global value that is treated as a scalar literal at runtime.
  Initialized to zero unless an initial value is specified.
  """

  OPERATION_NAME = "vm.global.i64"

  _ODS_REGIONS = (0, True)

  def __init__(self, sym_name, type_, *, sym_visibility=None, is_mutable=None, initial_value=None, inlining_policy=None, ordinal=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if sym_visibility is not None: attributes["sym_visibility"] = (sym_visibility if (
        isinstance(sym_visibility, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(sym_visibility, context=_ods_context))
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["type"] = (type_ if (
    isinstance(type_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(type_, context=_ods_context))
    if bool(is_mutable): attributes["is_mutable"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if initial_value is not None: attributes["initial_value"] = (initial_value if (
        isinstance(initial_value, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_792')) else
          _ods_ir.AttrBuilder.get('anonymous_792')(initial_value, context=_ods_context))
    if inlining_policy is not None: attributes["inlining_policy"] = (inlining_policy if (
        isinstance(inlining_policy, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Util_InliningPolicyAttrInterface')) else
          _ods_ir.AttrBuilder.get('Util_InliningPolicyAttrInterface')(inlining_policy, context=_ods_context))
    if ordinal is not None: attributes["ordinal"] = (ordinal if (
        isinstance(ordinal, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('VM_Ordinal')) else
          _ods_ir.AttrBuilder.get('VM_Ordinal')(ordinal, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_visibility(self) -> _Optional[_ods_ir.StringAttr]:
    if "sym_visibility" not in self.operation.attributes:
      return None
    return self.operation.attributes["sym_visibility"]

  @sym_visibility.setter
  def sym_visibility(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["sym_visibility"] = value
    elif "sym_visibility" in self.operation.attributes:
      del self.operation.attributes["sym_visibility"]

  @sym_visibility.deleter
  def sym_visibility(self):
    del self.operation.attributes["sym_visibility"]

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def type_(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["type"]

  @type_.setter
  def type_(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["type"] = value

  @builtins.property
  def is_mutable(self) -> bool:
    return "is_mutable" in self.operation.attributes

  @is_mutable.setter
  def is_mutable(self, value):
    if bool(value):
      self.operation.attributes["is_mutable"] = _ods_ir.UnitAttr.get()
    elif "is_mutable" in self.operation.attributes:
      del self.operation.attributes["is_mutable"]

  @is_mutable.deleter
  def is_mutable(self):
    del self.operation.attributes["is_mutable"]

  @builtins.property
  def initial_value(self) -> _Optional[_ods_ir.Attribute]:
    if "initial_value" not in self.operation.attributes:
      return None
    return self.operation.attributes["initial_value"]

  @initial_value.setter
  def initial_value(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["initial_value"] = value
    elif "initial_value" in self.operation.attributes:
      del self.operation.attributes["initial_value"]

  @initial_value.deleter
  def initial_value(self):
    del self.operation.attributes["initial_value"]

  @builtins.property
  def inlining_policy(self) -> _Optional[_ods_ir.Attribute]:
    if "inlining_policy" not in self.operation.attributes:
      return None
    return self.operation.attributes["inlining_policy"]

  @inlining_policy.setter
  def inlining_policy(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["inlining_policy"] = value
    elif "inlining_policy" in self.operation.attributes:
      del self.operation.attributes["inlining_policy"]

  @inlining_policy.deleter
  def inlining_policy(self):
    del self.operation.attributes["inlining_policy"]

  @builtins.property
  def ordinal(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "ordinal" not in self.operation.attributes:
      return None
    return self.operation.attributes["ordinal"]

  @ordinal.setter
  def ordinal(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["ordinal"] = value
    elif "ordinal" in self.operation.attributes:
      del self.operation.attributes["ordinal"]

  @ordinal.deleter
  def ordinal(self):
    del self.operation.attributes["ordinal"]

def global_i64(sym_name, type_, *, sym_visibility=None, is_mutable=None, initial_value=None, inlining_policy=None, ordinal=None, loc=None, ip=None) -> GlobalI64Op:
  return GlobalI64Op(sym_name=sym_name, type_=type_, sym_visibility=sym_visibility, is_mutable=is_mutable, initial_value=initial_value, inlining_policy=inlining_policy, ordinal=ordinal, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GlobalLoadF32Op(_ods_ir.OpView):
  r"""
  Loads the value of a global containing an primitive value.
  """

  OPERATION_NAME = "vm.global.load.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, global_, *, is_immutable=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["global"] = (global_ if (
    isinstance(global_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('VM_GlobalRefAttr')) else
      _ods_ir.AttrBuilder.get('VM_GlobalRefAttr')(global_, context=_ods_context))
    if bool(is_immutable): attributes["is_immutable"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results = []
    results.append(value)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def global_(self) -> _ods_ir.Attribute:
    return self.operation.attributes["global"]

  @global_.setter
  def global_(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["global"] = value

  @builtins.property
  def is_immutable(self) -> bool:
    return "is_immutable" in self.operation.attributes

  @is_immutable.setter
  def is_immutable(self, value):
    if bool(value):
      self.operation.attributes["is_immutable"] = _ods_ir.UnitAttr.get()
    elif "is_immutable" in self.operation.attributes:
      del self.operation.attributes["is_immutable"]

  @is_immutable.deleter
  def is_immutable(self):
    del self.operation.attributes["is_immutable"]

  @builtins.property
  def value(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def global_load_f32(value, global_, *, is_immutable=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GlobalLoadF32Op(value=value, global_=global_, is_immutable=is_immutable, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GlobalLoadF64Op(_ods_ir.OpView):
  r"""
  Loads the value of a global containing an primitive value.
  """

  OPERATION_NAME = "vm.global.load.f64"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, global_, *, is_immutable=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["global"] = (global_ if (
    isinstance(global_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('VM_GlobalRefAttr')) else
      _ods_ir.AttrBuilder.get('VM_GlobalRefAttr')(global_, context=_ods_context))
    if bool(is_immutable): attributes["is_immutable"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results = []
    results.append(value)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def global_(self) -> _ods_ir.Attribute:
    return self.operation.attributes["global"]

  @global_.setter
  def global_(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["global"] = value

  @builtins.property
  def is_immutable(self) -> bool:
    return "is_immutable" in self.operation.attributes

  @is_immutable.setter
  def is_immutable(self, value):
    if bool(value):
      self.operation.attributes["is_immutable"] = _ods_ir.UnitAttr.get()
    elif "is_immutable" in self.operation.attributes:
      del self.operation.attributes["is_immutable"]

  @is_immutable.deleter
  def is_immutable(self):
    del self.operation.attributes["is_immutable"]

  @builtins.property
  def value(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def global_load_f64(value, global_, *, is_immutable=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GlobalLoadF64Op(value=value, global_=global_, is_immutable=is_immutable, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GlobalLoadI32Op(_ods_ir.OpView):
  r"""
  Loads the value of a global containing an primitive value.
  """

  OPERATION_NAME = "vm.global.load.i32"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, global_, *, is_immutable=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["global"] = (global_ if (
    isinstance(global_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('VM_GlobalRefAttr')) else
      _ods_ir.AttrBuilder.get('VM_GlobalRefAttr')(global_, context=_ods_context))
    if bool(is_immutable): attributes["is_immutable"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results = []
    results.append(value)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def global_(self) -> _ods_ir.Attribute:
    return self.operation.attributes["global"]

  @global_.setter
  def global_(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["global"] = value

  @builtins.property
  def is_immutable(self) -> bool:
    return "is_immutable" in self.operation.attributes

  @is_immutable.setter
  def is_immutable(self, value):
    if bool(value):
      self.operation.attributes["is_immutable"] = _ods_ir.UnitAttr.get()
    elif "is_immutable" in self.operation.attributes:
      del self.operation.attributes["is_immutable"]

  @is_immutable.deleter
  def is_immutable(self):
    del self.operation.attributes["is_immutable"]

  @builtins.property
  def value(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def global_load_i32(value, global_, *, is_immutable=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GlobalLoadI32Op(value=value, global_=global_, is_immutable=is_immutable, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GlobalLoadI64Op(_ods_ir.OpView):
  r"""
  Loads the value of a global containing an primitive value.
  """

  OPERATION_NAME = "vm.global.load.i64"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, global_, *, is_immutable=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["global"] = (global_ if (
    isinstance(global_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('VM_GlobalRefAttr')) else
      _ods_ir.AttrBuilder.get('VM_GlobalRefAttr')(global_, context=_ods_context))
    if bool(is_immutable): attributes["is_immutable"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results = []
    results.append(value)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def global_(self) -> _ods_ir.Attribute:
    return self.operation.attributes["global"]

  @global_.setter
  def global_(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["global"] = value

  @builtins.property
  def is_immutable(self) -> bool:
    return "is_immutable" in self.operation.attributes

  @is_immutable.setter
  def is_immutable(self, value):
    if bool(value):
      self.operation.attributes["is_immutable"] = _ods_ir.UnitAttr.get()
    elif "is_immutable" in self.operation.attributes:
      del self.operation.attributes["is_immutable"]

  @is_immutable.deleter
  def is_immutable(self):
    del self.operation.attributes["is_immutable"]

  @builtins.property
  def value(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def global_load_i64(value, global_, *, is_immutable=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GlobalLoadI64Op(value=value, global_=global_, is_immutable=is_immutable, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GlobalLoadIndirectF32Op(_ods_ir.OpView):
  r"""
  Loads the value of a global containing a primitive value.
  """

  OPERATION_NAME = "vm.global.load.indirect.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, global_, *, is_immutable=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(global_)
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(is_immutable): attributes["is_immutable"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results = []
    results.append(value)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def global_(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def is_immutable(self) -> bool:
    return "is_immutable" in self.operation.attributes

  @is_immutable.setter
  def is_immutable(self, value):
    if bool(value):
      self.operation.attributes["is_immutable"] = _ods_ir.UnitAttr.get()
    elif "is_immutable" in self.operation.attributes:
      del self.operation.attributes["is_immutable"]

  @is_immutable.deleter
  def is_immutable(self):
    del self.operation.attributes["is_immutable"]

  @builtins.property
  def value(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def global_load_indirect_f32(value, global_, *, is_immutable=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GlobalLoadIndirectF32Op(value=value, global_=global_, is_immutable=is_immutable, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GlobalLoadIndirectF64Op(_ods_ir.OpView):
  r"""
  Loads the value of a global containing a primitive value.
  """

  OPERATION_NAME = "vm.global.load.indirect.f64"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, global_, *, is_immutable=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(global_)
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(is_immutable): attributes["is_immutable"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results = []
    results.append(value)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def global_(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def is_immutable(self) -> bool:
    return "is_immutable" in self.operation.attributes

  @is_immutable.setter
  def is_immutable(self, value):
    if bool(value):
      self.operation.attributes["is_immutable"] = _ods_ir.UnitAttr.get()
    elif "is_immutable" in self.operation.attributes:
      del self.operation.attributes["is_immutable"]

  @is_immutable.deleter
  def is_immutable(self):
    del self.operation.attributes["is_immutable"]

  @builtins.property
  def value(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def global_load_indirect_f64(value, global_, *, is_immutable=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GlobalLoadIndirectF64Op(value=value, global_=global_, is_immutable=is_immutable, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GlobalLoadIndirectI32Op(_ods_ir.OpView):
  r"""
  Loads the value of a global containing a primitive value.
  """

  OPERATION_NAME = "vm.global.load.indirect.i32"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, global_, *, is_immutable=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(global_)
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(is_immutable): attributes["is_immutable"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results = []
    results.append(value)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def global_(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def is_immutable(self) -> bool:
    return "is_immutable" in self.operation.attributes

  @is_immutable.setter
  def is_immutable(self, value):
    if bool(value):
      self.operation.attributes["is_immutable"] = _ods_ir.UnitAttr.get()
    elif "is_immutable" in self.operation.attributes:
      del self.operation.attributes["is_immutable"]

  @is_immutable.deleter
  def is_immutable(self):
    del self.operation.attributes["is_immutable"]

  @builtins.property
  def value(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def global_load_indirect_i32(value, global_, *, is_immutable=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GlobalLoadIndirectI32Op(value=value, global_=global_, is_immutable=is_immutable, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GlobalLoadIndirectI64Op(_ods_ir.OpView):
  r"""
  Loads the value of a global containing a primitive value.
  """

  OPERATION_NAME = "vm.global.load.indirect.i64"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, global_, *, is_immutable=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(global_)
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(is_immutable): attributes["is_immutable"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results = []
    results.append(value)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def global_(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def is_immutable(self) -> bool:
    return "is_immutable" in self.operation.attributes

  @is_immutable.setter
  def is_immutable(self, value):
    if bool(value):
      self.operation.attributes["is_immutable"] = _ods_ir.UnitAttr.get()
    elif "is_immutable" in self.operation.attributes:
      del self.operation.attributes["is_immutable"]

  @is_immutable.deleter
  def is_immutable(self):
    del self.operation.attributes["is_immutable"]

  @builtins.property
  def value(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def global_load_indirect_i64(value, global_, *, is_immutable=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GlobalLoadIndirectI64Op(value=value, global_=global_, is_immutable=is_immutable, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GlobalLoadIndirectRefOp(_ods_ir.OpView):
  r"""
  Loads the value of a global containing a ref of the given type.
  """

  OPERATION_NAME = "vm.global.load.indirect.ref"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, global_, *, is_immutable=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(global_)
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(is_immutable): attributes["is_immutable"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results = []
    results.append(value)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def global_(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def is_immutable(self) -> bool:
    return "is_immutable" in self.operation.attributes

  @is_immutable.setter
  def is_immutable(self, value):
    if bool(value):
      self.operation.attributes["is_immutable"] = _ods_ir.UnitAttr.get()
    elif "is_immutable" in self.operation.attributes:
      del self.operation.attributes["is_immutable"]

  @is_immutable.deleter
  def is_immutable(self):
    del self.operation.attributes["is_immutable"]

  @builtins.property
  def value(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def global_load_indirect_ref(value, global_, *, is_immutable=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GlobalLoadIndirectRefOp(value=value, global_=global_, is_immutable=is_immutable, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GlobalLoadRefOp(_ods_ir.OpView):
  r"""
  Loads the value of a global containing a ref of the given type.
  """

  OPERATION_NAME = "vm.global.load.ref"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, global_, *, is_immutable=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["global"] = (global_ if (
    isinstance(global_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('VM_GlobalRefAttr')) else
      _ods_ir.AttrBuilder.get('VM_GlobalRefAttr')(global_, context=_ods_context))
    if bool(is_immutable): attributes["is_immutable"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results = []
    results.append(value)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def global_(self) -> _ods_ir.Attribute:
    return self.operation.attributes["global"]

  @global_.setter
  def global_(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["global"] = value

  @builtins.property
  def is_immutable(self) -> bool:
    return "is_immutable" in self.operation.attributes

  @is_immutable.setter
  def is_immutable(self, value):
    if bool(value):
      self.operation.attributes["is_immutable"] = _ods_ir.UnitAttr.get()
    elif "is_immutable" in self.operation.attributes:
      del self.operation.attributes["is_immutable"]

  @is_immutable.deleter
  def is_immutable(self):
    del self.operation.attributes["is_immutable"]

  @builtins.property
  def value(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def global_load_ref(value, global_, *, is_immutable=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GlobalLoadRefOp(value=value, global_=global_, is_immutable=is_immutable, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GlobalRefOp(_ods_ir.OpView):
  r"""
  Defines a global value that is a ref of a specific type. The global will
  retain the ref object for the lifetime of the context or until the value is
  replaced with a store or reset.
  Initialized to null unless an initial value is specified.
  """

  OPERATION_NAME = "vm.global.ref"

  _ODS_REGIONS = (0, True)

  def __init__(self, sym_name, type_, *, sym_visibility=None, is_mutable=None, inlining_policy=None, ordinal=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if sym_visibility is not None: attributes["sym_visibility"] = (sym_visibility if (
        isinstance(sym_visibility, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(sym_visibility, context=_ods_context))
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["type"] = (type_ if (
    isinstance(type_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(type_, context=_ods_context))
    if bool(is_mutable): attributes["is_mutable"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if inlining_policy is not None: attributes["inlining_policy"] = (inlining_policy if (
        isinstance(inlining_policy, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Util_InliningPolicyAttrInterface')) else
          _ods_ir.AttrBuilder.get('Util_InliningPolicyAttrInterface')(inlining_policy, context=_ods_context))
    if ordinal is not None: attributes["ordinal"] = (ordinal if (
        isinstance(ordinal, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('VM_Ordinal')) else
          _ods_ir.AttrBuilder.get('VM_Ordinal')(ordinal, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_visibility(self) -> _Optional[_ods_ir.StringAttr]:
    if "sym_visibility" not in self.operation.attributes:
      return None
    return self.operation.attributes["sym_visibility"]

  @sym_visibility.setter
  def sym_visibility(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["sym_visibility"] = value
    elif "sym_visibility" in self.operation.attributes:
      del self.operation.attributes["sym_visibility"]

  @sym_visibility.deleter
  def sym_visibility(self):
    del self.operation.attributes["sym_visibility"]

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def type_(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["type"]

  @type_.setter
  def type_(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["type"] = value

  @builtins.property
  def is_mutable(self) -> bool:
    return "is_mutable" in self.operation.attributes

  @is_mutable.setter
  def is_mutable(self, value):
    if bool(value):
      self.operation.attributes["is_mutable"] = _ods_ir.UnitAttr.get()
    elif "is_mutable" in self.operation.attributes:
      del self.operation.attributes["is_mutable"]

  @is_mutable.deleter
  def is_mutable(self):
    del self.operation.attributes["is_mutable"]

  @builtins.property
  def inlining_policy(self) -> _Optional[_ods_ir.Attribute]:
    if "inlining_policy" not in self.operation.attributes:
      return None
    return self.operation.attributes["inlining_policy"]

  @inlining_policy.setter
  def inlining_policy(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["inlining_policy"] = value
    elif "inlining_policy" in self.operation.attributes:
      del self.operation.attributes["inlining_policy"]

  @inlining_policy.deleter
  def inlining_policy(self):
    del self.operation.attributes["inlining_policy"]

  @builtins.property
  def ordinal(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "ordinal" not in self.operation.attributes:
      return None
    return self.operation.attributes["ordinal"]

  @ordinal.setter
  def ordinal(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["ordinal"] = value
    elif "ordinal" in self.operation.attributes:
      del self.operation.attributes["ordinal"]

  @ordinal.deleter
  def ordinal(self):
    del self.operation.attributes["ordinal"]

def global_ref(sym_name, type_, *, sym_visibility=None, is_mutable=None, inlining_policy=None, ordinal=None, loc=None, ip=None) -> GlobalRefOp:
  return GlobalRefOp(sym_name=sym_name, type_=type_, sym_visibility=sym_visibility, is_mutable=is_mutable, inlining_policy=inlining_policy, ordinal=ordinal, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GlobalStoreF32Op(_ods_ir.OpView):
  r"""
  Stores a primitive value value to a global.
  """

  OPERATION_NAME = "vm.global.store.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, global_, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["global"] = (global_ if (
    isinstance(global_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('VM_GlobalRefAttr')) else
      _ods_ir.AttrBuilder.get('VM_GlobalRefAttr')(global_, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def global_(self) -> _ods_ir.Attribute:
    return self.operation.attributes["global"]

  @global_.setter
  def global_(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["global"] = value

def global_store_f32(value, global_, *, loc=None, ip=None) -> GlobalStoreF32Op:
  return GlobalStoreF32Op(value=value, global_=global_, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GlobalStoreF64Op(_ods_ir.OpView):
  r"""
  Stores a primitive value value to a global.
  """

  OPERATION_NAME = "vm.global.store.f64"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, global_, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["global"] = (global_ if (
    isinstance(global_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('VM_GlobalRefAttr')) else
      _ods_ir.AttrBuilder.get('VM_GlobalRefAttr')(global_, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def global_(self) -> _ods_ir.Attribute:
    return self.operation.attributes["global"]

  @global_.setter
  def global_(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["global"] = value

def global_store_f64(value, global_, *, loc=None, ip=None) -> GlobalStoreF64Op:
  return GlobalStoreF64Op(value=value, global_=global_, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GlobalStoreI32Op(_ods_ir.OpView):
  r"""
  Stores a primitive value value to a global.
  """

  OPERATION_NAME = "vm.global.store.i32"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, global_, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["global"] = (global_ if (
    isinstance(global_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('VM_GlobalRefAttr')) else
      _ods_ir.AttrBuilder.get('VM_GlobalRefAttr')(global_, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def global_(self) -> _ods_ir.Attribute:
    return self.operation.attributes["global"]

  @global_.setter
  def global_(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["global"] = value

def global_store_i32(value, global_, *, loc=None, ip=None) -> GlobalStoreI32Op:
  return GlobalStoreI32Op(value=value, global_=global_, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GlobalStoreI64Op(_ods_ir.OpView):
  r"""
  Stores a primitive value value to a global.
  """

  OPERATION_NAME = "vm.global.store.i64"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, global_, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["global"] = (global_ if (
    isinstance(global_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('VM_GlobalRefAttr')) else
      _ods_ir.AttrBuilder.get('VM_GlobalRefAttr')(global_, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def global_(self) -> _ods_ir.Attribute:
    return self.operation.attributes["global"]

  @global_.setter
  def global_(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["global"] = value

def global_store_i64(value, global_, *, loc=None, ip=None) -> GlobalStoreI64Op:
  return GlobalStoreI64Op(value=value, global_=global_, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GlobalStoreIndirectF32Op(_ods_ir.OpView):
  r"""
  Stores a primitive value to a global.
  """

  OPERATION_NAME = "vm.global.store.indirect.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, global_, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    operands.append(global_)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def global_(self) -> _ods_ir.Value:
    return self.operation.operands[1]

def global_store_indirect_f32(value, global_, *, loc=None, ip=None) -> GlobalStoreIndirectF32Op:
  return GlobalStoreIndirectF32Op(value=value, global_=global_, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GlobalStoreIndirectF64Op(_ods_ir.OpView):
  r"""
  Stores a primitive value to a global.
  """

  OPERATION_NAME = "vm.global.store.indirect.f64"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, global_, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    operands.append(global_)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def global_(self) -> _ods_ir.Value:
    return self.operation.operands[1]

def global_store_indirect_f64(value, global_, *, loc=None, ip=None) -> GlobalStoreIndirectF64Op:
  return GlobalStoreIndirectF64Op(value=value, global_=global_, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GlobalStoreIndirectI32Op(_ods_ir.OpView):
  r"""
  Stores a primitive value to a global.
  """

  OPERATION_NAME = "vm.global.store.indirect.i32"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, global_, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    operands.append(global_)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def global_(self) -> _ods_ir.Value:
    return self.operation.operands[1]

def global_store_indirect_i32(value, global_, *, loc=None, ip=None) -> GlobalStoreIndirectI32Op:
  return GlobalStoreIndirectI32Op(value=value, global_=global_, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GlobalStoreIndirectI64Op(_ods_ir.OpView):
  r"""
  Stores a primitive value to a global.
  """

  OPERATION_NAME = "vm.global.store.indirect.i64"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, global_, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    operands.append(global_)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def global_(self) -> _ods_ir.Value:
    return self.operation.operands[1]

def global_store_indirect_i64(value, global_, *, loc=None, ip=None) -> GlobalStoreIndirectI64Op:
  return GlobalStoreIndirectI64Op(value=value, global_=global_, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GlobalStoreIndirectRefOp(_ods_ir.OpView):
  r"""
  Stores a ref<T> to a global, retaining it until the global is reset.
  """

  OPERATION_NAME = "vm.global.store.indirect.ref"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, global_, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    operands.append(global_)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def global_(self) -> _ods_ir.Value:
    return self.operation.operands[1]

def global_store_indirect_ref(value, global_, *, loc=None, ip=None) -> GlobalStoreIndirectRefOp:
  return GlobalStoreIndirectRefOp(value=value, global_=global_, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GlobalStoreRefOp(_ods_ir.OpView):
  r"""
  Stores a ref<T> to a global, retaining it until the global is reset.
  """

  OPERATION_NAME = "vm.global.store.ref"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, global_, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["global"] = (global_ if (
    isinstance(global_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('VM_GlobalRefAttr')) else
      _ods_ir.AttrBuilder.get('VM_GlobalRefAttr')(global_, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def global_(self) -> _ods_ir.Attribute:
    return self.operation.attributes["global"]

  @global_.setter
  def global_(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["global"] = value

def global_store_ref(value, global_, *, loc=None, ip=None) -> GlobalStoreRefOp:
  return GlobalStoreRefOp(value=value, global_=global_, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ImportOp(_ods_ir.OpView):
  r"""
  Specifies a function that should be imported from either the runtime or
  an external VM module.
  
  Required imports can be declared with a minimum version of the module that
  contains the import. The maximum declared minimum version of all required
  imports from the module will become the required minimum version at runtime.
  
  Optional imports not present at runtime will be invalid to call and whether
  they were resolved can be queried with `vm.import.resolved`.
  """

  OPERATION_NAME = "vm.import"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, function_type, *, arg_attrs=None, res_attrs=None, sym_visibility=None, ordinal=None, is_optional=None, minimum_version=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["function_type"] = (function_type if (
    isinstance(function_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_771')) else
      _ods_ir.AttrBuilder.get('anonymous_771')(function_type, context=_ods_context))
    if arg_attrs is not None: attributes["arg_attrs"] = (arg_attrs if (
        isinstance(arg_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(arg_attrs, context=_ods_context))
    if res_attrs is not None: attributes["res_attrs"] = (res_attrs if (
        isinstance(res_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(res_attrs, context=_ods_context))
    if sym_visibility is not None: attributes["sym_visibility"] = (sym_visibility if (
        isinstance(sym_visibility, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(sym_visibility, context=_ods_context))
    if ordinal is not None: attributes["ordinal"] = (ordinal if (
        isinstance(ordinal, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('VM_Ordinal')) else
          _ods_ir.AttrBuilder.get('VM_Ordinal')(ordinal, context=_ods_context))
    if bool(is_optional): attributes["is_optional"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if minimum_version is not None: attributes["minimum_version"] = (minimum_version if (
        isinstance(minimum_version, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(minimum_version, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def function_type(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["function_type"]

  @function_type.setter
  def function_type(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["function_type"] = value

  @builtins.property
  def arg_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "arg_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["arg_attrs"]

  @arg_attrs.setter
  def arg_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["arg_attrs"] = value
    elif "arg_attrs" in self.operation.attributes:
      del self.operation.attributes["arg_attrs"]

  @arg_attrs.deleter
  def arg_attrs(self):
    del self.operation.attributes["arg_attrs"]

  @builtins.property
  def res_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "res_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["res_attrs"]

  @res_attrs.setter
  def res_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["res_attrs"] = value
    elif "res_attrs" in self.operation.attributes:
      del self.operation.attributes["res_attrs"]

  @res_attrs.deleter
  def res_attrs(self):
    del self.operation.attributes["res_attrs"]

  @builtins.property
  def sym_visibility(self) -> _Optional[_ods_ir.StringAttr]:
    if "sym_visibility" not in self.operation.attributes:
      return None
    return self.operation.attributes["sym_visibility"]

  @sym_visibility.setter
  def sym_visibility(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["sym_visibility"] = value
    elif "sym_visibility" in self.operation.attributes:
      del self.operation.attributes["sym_visibility"]

  @sym_visibility.deleter
  def sym_visibility(self):
    del self.operation.attributes["sym_visibility"]

  @builtins.property
  def ordinal(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "ordinal" not in self.operation.attributes:
      return None
    return self.operation.attributes["ordinal"]

  @ordinal.setter
  def ordinal(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["ordinal"] = value
    elif "ordinal" in self.operation.attributes:
      del self.operation.attributes["ordinal"]

  @ordinal.deleter
  def ordinal(self):
    del self.operation.attributes["ordinal"]

  @builtins.property
  def is_optional(self) -> bool:
    return "is_optional" in self.operation.attributes

  @is_optional.setter
  def is_optional(self, value):
    if bool(value):
      self.operation.attributes["is_optional"] = _ods_ir.UnitAttr.get()
    elif "is_optional" in self.operation.attributes:
      del self.operation.attributes["is_optional"]

  @is_optional.deleter
  def is_optional(self):
    del self.operation.attributes["is_optional"]

  @builtins.property
  def minimum_version(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "minimum_version" not in self.operation.attributes:
      return None
    return self.operation.attributes["minimum_version"]

  @minimum_version.setter
  def minimum_version(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["minimum_version"] = value
    elif "minimum_version" in self.operation.attributes:
      del self.operation.attributes["minimum_version"]

  @minimum_version.deleter
  def minimum_version(self):
    del self.operation.attributes["minimum_version"]

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def import_(sym_name, function_type, *, arg_attrs=None, res_attrs=None, sym_visibility=None, ordinal=None, is_optional=None, minimum_version=None, loc=None, ip=None) -> ImportOp:
  return ImportOp(sym_name=sym_name, function_type=function_type, arg_attrs=arg_attrs, res_attrs=res_attrs, sym_visibility=sym_visibility, ordinal=ordinal, is_optional=is_optional, minimum_version=minimum_version, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ImportResolvedOp(_ods_ir.OpView):
  r"""
  Allows for checking whether a optional import was resolved at runtime. If
  this returns false then attempting to call the imported function will result
  in a failure at runtime.
  """

  OPERATION_NAME = "vm.import.resolved"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, import_, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["import"] = (import_ if (
    isinstance(import_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('VM_FuncRefAttr')) else
      _ods_ir.AttrBuilder.get('VM_FuncRefAttr')(import_, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def import_(self) -> _ods_ir.Attribute:
    return self.operation.attributes["import"]

  @import_.setter
  def import_(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["import"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def import_resolved(result, import_, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ImportResolvedOp(result=result, import_=import_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class InitializerOp(_ods_ir.OpView):
  r"""
  A function that is called in definition order upon module initialization.
  Must not load any globals that are defined or initialized after it in the
  module.
  """

  OPERATION_NAME = "vm.initializer"

  _ODS_REGIONS = (1, True)

  def __init__(self, function_type, *, arg_attrs=None, res_attrs=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["function_type"] = (function_type if (
    isinstance(function_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_771')) else
      _ods_ir.AttrBuilder.get('anonymous_771')(function_type, context=_ods_context))
    if arg_attrs is not None: attributes["arg_attrs"] = (arg_attrs if (
        isinstance(arg_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(arg_attrs, context=_ods_context))
    if res_attrs is not None: attributes["res_attrs"] = (res_attrs if (
        isinstance(res_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(res_attrs, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def function_type(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["function_type"]

  @function_type.setter
  def function_type(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["function_type"] = value

  @builtins.property
  def arg_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "arg_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["arg_attrs"]

  @arg_attrs.setter
  def arg_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["arg_attrs"] = value
    elif "arg_attrs" in self.operation.attributes:
      del self.operation.attributes["arg_attrs"]

  @arg_attrs.deleter
  def arg_attrs(self):
    del self.operation.attributes["arg_attrs"]

  @builtins.property
  def res_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "res_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["res_attrs"]

  @res_attrs.setter
  def res_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["res_attrs"] = value
    elif "res_attrs" in self.operation.attributes:
      del self.operation.attributes["res_attrs"]

  @res_attrs.deleter
  def res_attrs(self):
    del self.operation.attributes["res_attrs"]

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def initializer(function_type, *, arg_attrs=None, res_attrs=None, loc=None, ip=None) -> InitializerOp:
  return InitializerOp(function_type=function_type, arg_attrs=arg_attrs, res_attrs=res_attrs, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ListAllocOp(_ods_ir.OpView):
  r"""
  Allocates a new typed list with a minimum initial_capacity.
  """

  OPERATION_NAME = "vm.list.alloc"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, initial_capacity, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(initial_capacity)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def initial_capacity(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def list_alloc(result, initial_capacity, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ListAllocOp(result=result, initial_capacity=initial_capacity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ListGetF32Op(_ods_ir.OpView):
  r"""
  Returns the value of the element at the given index.
  """

  OPERATION_NAME = "vm.list.get.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, list, index, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(list)
    operands.append(index)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def list(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def index(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def list_get_f32(result, list, index, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ListGetF32Op(result=result, list=list, index=index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ListGetF64Op(_ods_ir.OpView):
  r"""
  Returns the value of the element at the given index.
  """

  OPERATION_NAME = "vm.list.get.f64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, list, index, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(list)
    operands.append(index)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def list(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def index(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def list_get_f64(result, list, index, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ListGetF64Op(result=result, list=list, index=index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ListGetI32Op(_ods_ir.OpView):
  r"""
  Returns the value of the element at the given index.
  """

  OPERATION_NAME = "vm.list.get.i32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, list, index, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(list)
    operands.append(index)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def list(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def index(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def list_get_i32(result, list, index, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ListGetI32Op(result=result, list=list, index=index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ListGetI64Op(_ods_ir.OpView):
  r"""
  Returns the value of the element at the given index.
  """

  OPERATION_NAME = "vm.list.get.i64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, list, index, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(list)
    operands.append(index)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def list(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def index(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def list_get_i64(result, list, index, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ListGetI64Op(result=result, list=list, index=index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ListGetRefOp(_ods_ir.OpView):
  r"""
  Returns the ref value of the element at the given index. Note that the value
  may be null if the element is null or the type does not match.
  """

  OPERATION_NAME = "vm.list.get.ref"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, list, index, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(list)
    operands.append(index)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def list(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def index(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def list_get_ref(result, list, index, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ListGetRefOp(result=result, list=list, index=index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ListReserveOp(_ods_ir.OpView):
  r"""
  Reserves storage for at least minimum_capacity elements. If the list already
  has at least the specified capacity the operation is ignored.
  """

  OPERATION_NAME = "vm.list.reserve"

  _ODS_REGIONS = (0, True)

  def __init__(self, list, minimum_capacity, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(list)
    operands.append(minimum_capacity)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def list(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def minimum_capacity(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

def list_reserve(list, minimum_capacity, *, loc=None, ip=None) -> ListReserveOp:
  return ListReserveOp(list=list, minimum_capacity=minimum_capacity, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ListResizeOp(_ods_ir.OpView):
  r"""
  Resizes the list to contain new_size elements. This will either truncate
  the list if the existing size is greater than new_size or extend the list
  with the default list value of 0 if storing primitives and null if refs.
  """

  OPERATION_NAME = "vm.list.resize"

  _ODS_REGIONS = (0, True)

  def __init__(self, list, new_size, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(list)
    operands.append(new_size)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def list(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def new_size(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

def list_resize(list, new_size, *, loc=None, ip=None) -> ListResizeOp:
  return ListResizeOp(list=list, new_size=new_size, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ListSetF32Op(_ods_ir.OpView):
  r"""
  Sets the element at the given index to the new value.
  """

  OPERATION_NAME = "vm.list.set.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, list, index, value, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(list)
    operands.append(index)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def list(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def index(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def value(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[2]

def list_set_f32(list, index, value, *, loc=None, ip=None) -> ListSetF32Op:
  return ListSetF32Op(list=list, index=index, value=value, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ListSetF64Op(_ods_ir.OpView):
  r"""
  Sets the element at the given index to the new value.
  """

  OPERATION_NAME = "vm.list.set.f64"

  _ODS_REGIONS = (0, True)

  def __init__(self, list, index, value, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(list)
    operands.append(index)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def list(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def index(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def value(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[2]

def list_set_f64(list, index, value, *, loc=None, ip=None) -> ListSetF64Op:
  return ListSetF64Op(list=list, index=index, value=value, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ListSetI32Op(_ods_ir.OpView):
  r"""
  Sets the element at the given index to the new value.
  """

  OPERATION_NAME = "vm.list.set.i32"

  _ODS_REGIONS = (0, True)

  def __init__(self, list, index, value, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(list)
    operands.append(index)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def list(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def index(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def value(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[2]

def list_set_i32(list, index, value, *, loc=None, ip=None) -> ListSetI32Op:
  return ListSetI32Op(list=list, index=index, value=value, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ListSetI64Op(_ods_ir.OpView):
  r"""
  Sets the element at the given index to the new value.
  """

  OPERATION_NAME = "vm.list.set.i64"

  _ODS_REGIONS = (0, True)

  def __init__(self, list, index, value, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(list)
    operands.append(index)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def list(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def index(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def value(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[2]

def list_set_i64(list, index, value, *, loc=None, ip=None) -> ListSetI64Op:
  return ListSetI64Op(list=list, index=index, value=value, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ListSetRefOp(_ods_ir.OpView):
  r"""
  Sets the element at the given index to the new ref value (possibly null).
  """

  OPERATION_NAME = "vm.list.set.ref"

  _ODS_REGIONS = (0, True)

  def __init__(self, list, index, value, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(list)
    operands.append(index)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def list(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def index(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[2]

def list_set_ref(list, index, value, *, loc=None, ip=None) -> ListSetRefOp:
  return ListSetRefOp(list=list, index=index, value=value, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ListSizeOp(_ods_ir.OpView):
  r"""
  Returns the current size of the list in elements.
  """

  OPERATION_NAME = "vm.list.size"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, list, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(list)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def list(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def list_size(result, list, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ListSizeOp(result=result, list=list, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Log1pF32Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.log1p.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def log1p_f32(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return Log1pF32Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Log1pF64Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.log1p.f64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def log1p_f64(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return Log1pF64Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Log2F32Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.log2.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def log2_f32(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return Log2F32Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Log2F64Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.log2.f64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def log2_f64(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return Log2F64Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Log10F32Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.log10.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def log10_f32(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return Log10F32Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Log10F64Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.log10.f64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def log10_f64(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return Log10F64Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class LogF32Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.log.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def log_f32(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return LogF32Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class LogF64Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.log.f64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def log_f64(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return LogF64Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MaxF32Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.max.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def max_f32(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return MaxF32Op(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MaxF64Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.max.f64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def max_f64(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return MaxF64Op(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MaxI32SOp(_ods_ir.OpView):
  OPERATION_NAME = "vm.max.i32.s"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def max_i32_s(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return MaxI32SOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MaxI32UOp(_ods_ir.OpView):
  OPERATION_NAME = "vm.max.i32.u"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def max_i32_u(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return MaxI32UOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MaxI64SOp(_ods_ir.OpView):
  OPERATION_NAME = "vm.max.i64.s"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def max_i64_s(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return MaxI64SOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MaxI64UOp(_ods_ir.OpView):
  OPERATION_NAME = "vm.max.i64.u"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def max_i64_u(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return MaxI64UOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MinF32Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.min.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def min_f32(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return MinF32Op(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MinF64Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.min.f64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def min_f64(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return MinF64Op(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MinI32SOp(_ods_ir.OpView):
  OPERATION_NAME = "vm.min.i32.s"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def min_i32_s(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return MinI32SOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MinI32UOp(_ods_ir.OpView):
  OPERATION_NAME = "vm.min.i32.u"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def min_i32_u(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return MinI32UOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MinI64SOp(_ods_ir.OpView):
  OPERATION_NAME = "vm.min.i64.s"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def min_i64_s(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return MinI64SOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MinI64UOp(_ods_ir.OpView):
  OPERATION_NAME = "vm.min.i64.u"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def min_i64_u(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return MinI64UOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ModuleOp(_ods_ir.OpView):
  r"""
  Top-level container for VM functions.
  """

  OPERATION_NAME = "vm.module"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, *, sym_visibility=None, ordinal_counts=None, version=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if sym_visibility is not None: attributes["sym_visibility"] = (sym_visibility if (
        isinstance(sym_visibility, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(sym_visibility, context=_ods_context))
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    if ordinal_counts is not None: attributes["ordinal_counts"] = (ordinal_counts if (
        isinstance(ordinal_counts, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('VM_OrdinalCountsAttr')) else
          _ods_ir.AttrBuilder.get('VM_OrdinalCountsAttr')(ordinal_counts, context=_ods_context))
    if version is not None: attributes["version"] = (version if (
        isinstance(version, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(version, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_visibility(self) -> _Optional[_ods_ir.StringAttr]:
    if "sym_visibility" not in self.operation.attributes:
      return None
    return self.operation.attributes["sym_visibility"]

  @sym_visibility.setter
  def sym_visibility(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["sym_visibility"] = value
    elif "sym_visibility" in self.operation.attributes:
      del self.operation.attributes["sym_visibility"]

  @sym_visibility.deleter
  def sym_visibility(self):
    del self.operation.attributes["sym_visibility"]

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def ordinal_counts(self) -> _Optional[_ods_ir.Attribute]:
    if "ordinal_counts" not in self.operation.attributes:
      return None
    return self.operation.attributes["ordinal_counts"]

  @ordinal_counts.setter
  def ordinal_counts(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["ordinal_counts"] = value
    elif "ordinal_counts" in self.operation.attributes:
      del self.operation.attributes["ordinal_counts"]

  @ordinal_counts.deleter
  def ordinal_counts(self):
    del self.operation.attributes["ordinal_counts"]

  @builtins.property
  def version(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "version" not in self.operation.attributes:
      return None
    return self.operation.attributes["version"]

  @version.setter
  def version(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["version"] = value
    elif "version" in self.operation.attributes:
      del self.operation.attributes["version"]

  @version.deleter
  def version(self):
    del self.operation.attributes["version"]

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def module(sym_name, *, sym_visibility=None, ordinal_counts=None, version=None, loc=None, ip=None) -> ModuleOp:
  return ModuleOp(sym_name=sym_name, sym_visibility=sym_visibility, ordinal_counts=ordinal_counts, version=version, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ModuleTerminatorOp(_ods_ir.OpView):
  OPERATION_NAME = "vm.module_terminator"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def module_terminator(*, loc=None, ip=None) -> ModuleTerminatorOp:
  return ModuleTerminatorOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class MulF32Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.mul.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def mul_f32(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return MulF32Op(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MulF64Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.mul.f64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def mul_f64(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return MulF64Op(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MulI32Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.mul.i32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def mul_i32(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return MulI32Op(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MulI64Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.mul.i64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def mul_i64(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return MulI64Op(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class NegF32Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.neg.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def neg_f32(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return NegF32Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class NegF64Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.neg.f64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def neg_f64(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return NegF64Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class NotI32Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.not.i32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def not_i32(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return NotI32Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class NotI64Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.not.i64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def not_i64(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return NotI64Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class OrI32Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.or.i32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def or_i32(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return OrI32Op(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class OrI64Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.or.i64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def or_i64(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return OrI64Op(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PowF32Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.pow.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def pow_f32(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return PowF32Op(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PowF64Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.pow.f64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def pow_f64(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return PowF64Op(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PrintOp(_ods_ir.OpView):
  r"""
  Prints the given string message and zero or more values.
  """

  OPERATION_NAME = "vm.print"

  _ODS_REGIONS = (0, True)

  def __init__(self, message, operands_, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["message"] = (message if (
    isinstance(message, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(message, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def message(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["message"]

  @message.setter
  def message(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["message"] = value

def print_(message, operands_, *, loc=None, ip=None) -> PrintOp:
  return PrintOp(message=message, operands_=operands_, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class RemF32Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.rem.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def rem_f32(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return RemF32Op(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RemF64Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.rem.f64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def rem_f64(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return RemF64Op(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RemI32SOp(_ods_ir.OpView):
  OPERATION_NAME = "vm.rem.i32.s"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def rem_i32_s(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return RemI32SOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RemI32UOp(_ods_ir.OpView):
  OPERATION_NAME = "vm.rem.i32.u"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def rem_i32_u(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return RemI32UOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RemI64SOp(_ods_ir.OpView):
  OPERATION_NAME = "vm.rem.i64.s"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def rem_i64_s(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return RemI64SOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RemI64UOp(_ods_ir.OpView):
  OPERATION_NAME = "vm.rem.i64.u"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def rem_i64_u(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return RemI64UOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ReturnOp(_ods_ir.OpView):
  r"""
  Represents a return operation within a function.
  
  ```
  vm.func @foo(%0: i32, %1: f8) -> (i32, f8) {
    vm.return %0, %1 : i32, f8
  }
  ```
  """

  OPERATION_NAME = "vm.return"

  _ODS_REGIONS = (0, True)

  def __init__(self, operands_, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def return_(operands_, *, loc=None, ip=None) -> ReturnOp:
  return ReturnOp(operands_=operands_, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class RodataInlineOp(_ods_ir.OpView):
  r"""
  vm.rodata that can be embedded inline in functions. See vm.rodata for more
  information.
  """

  OPERATION_NAME = "vm.rodata.inline"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, value, *, name=None, alignment=None, mime_type=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if name is not None: attributes["name"] = (name if (
        isinstance(name, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Util_AnySerializableAttr')) else
      _ods_ir.AttrBuilder.get('Util_AnySerializableAttr')(value, context=_ods_context))
    if alignment is not None: attributes["alignment"] = (alignment if (
        isinstance(alignment, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(alignment, context=_ods_context))
    if mime_type is not None: attributes["mime_type"] = (mime_type if (
        isinstance(mime_type, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(mime_type, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def name(self) -> _Optional[_ods_ir.StringAttr]:
    if "name" not in self.operation.attributes:
      return None
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["name"] = value
    elif "name" in self.operation.attributes:
      del self.operation.attributes["name"]

  @name.deleter
  def name(self):
    del self.operation.attributes["name"]

  @builtins.property
  def value(self) -> _ods_ir.Attribute:
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def alignment(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "alignment" not in self.operation.attributes:
      return None
    return self.operation.attributes["alignment"]

  @alignment.setter
  def alignment(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["alignment"] = value
    elif "alignment" in self.operation.attributes:
      del self.operation.attributes["alignment"]

  @alignment.deleter
  def alignment(self):
    del self.operation.attributes["alignment"]

  @builtins.property
  def mime_type(self) -> _Optional[_ods_ir.StringAttr]:
    if "mime_type" not in self.operation.attributes:
      return None
    return self.operation.attributes["mime_type"]

  @mime_type.setter
  def mime_type(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["mime_type"] = value
    elif "mime_type" in self.operation.attributes:
      del self.operation.attributes["mime_type"]

  @mime_type.deleter
  def mime_type(self):
    del self.operation.attributes["mime_type"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def rodata_inline(result, value, *, name=None, alignment=None, mime_type=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return RodataInlineOp(result=result, value=value, name=name, alignment=alignment, mime_type=mime_type, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RodataOp(_ods_ir.OpView):
  r"""
  Defines a blob of read-only constant data that can be represented as a
  ref. This can be used to store arbitrary data within modules such as
  large constant buffers and other file contents.
  
  Note that the data is reference counted as a way to track its usage once the
  value leaves the module. For example, returning rodata from an exported
  function must keep the data (possibly backed by mmap) valid for its entire
  lifetime.
  
  By default all rodata will be aligned in the final module output at a
  16-byte granularity. An optional alignment can be specified to override the
  default for cases where larger or smaller alignments are needed.
  """

  OPERATION_NAME = "vm.rodata"

  _ODS_REGIONS = (0, True)

  def __init__(self, sym_name, value, *, sym_visibility=None, alignment=None, ordinal=None, mime_type=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if sym_visibility is not None: attributes["sym_visibility"] = (sym_visibility if (
        isinstance(sym_visibility, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(sym_visibility, context=_ods_context))
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Util_AnySerializableAttr')) else
      _ods_ir.AttrBuilder.get('Util_AnySerializableAttr')(value, context=_ods_context))
    if alignment is not None: attributes["alignment"] = (alignment if (
        isinstance(alignment, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(alignment, context=_ods_context))
    if ordinal is not None: attributes["ordinal"] = (ordinal if (
        isinstance(ordinal, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('VM_Ordinal')) else
          _ods_ir.AttrBuilder.get('VM_Ordinal')(ordinal, context=_ods_context))
    if mime_type is not None: attributes["mime_type"] = (mime_type if (
        isinstance(mime_type, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(mime_type, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_visibility(self) -> _Optional[_ods_ir.StringAttr]:
    if "sym_visibility" not in self.operation.attributes:
      return None
    return self.operation.attributes["sym_visibility"]

  @sym_visibility.setter
  def sym_visibility(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["sym_visibility"] = value
    elif "sym_visibility" in self.operation.attributes:
      del self.operation.attributes["sym_visibility"]

  @sym_visibility.deleter
  def sym_visibility(self):
    del self.operation.attributes["sym_visibility"]

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def value(self) -> _ods_ir.Attribute:
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def alignment(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "alignment" not in self.operation.attributes:
      return None
    return self.operation.attributes["alignment"]

  @alignment.setter
  def alignment(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["alignment"] = value
    elif "alignment" in self.operation.attributes:
      del self.operation.attributes["alignment"]

  @alignment.deleter
  def alignment(self):
    del self.operation.attributes["alignment"]

  @builtins.property
  def ordinal(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "ordinal" not in self.operation.attributes:
      return None
    return self.operation.attributes["ordinal"]

  @ordinal.setter
  def ordinal(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["ordinal"] = value
    elif "ordinal" in self.operation.attributes:
      del self.operation.attributes["ordinal"]

  @ordinal.deleter
  def ordinal(self):
    del self.operation.attributes["ordinal"]

  @builtins.property
  def mime_type(self) -> _Optional[_ods_ir.StringAttr]:
    if "mime_type" not in self.operation.attributes:
      return None
    return self.operation.attributes["mime_type"]

  @mime_type.setter
  def mime_type(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["mime_type"] = value
    elif "mime_type" in self.operation.attributes:
      del self.operation.attributes["mime_type"]

  @mime_type.deleter
  def mime_type(self):
    del self.operation.attributes["mime_type"]

def rodata(sym_name, value, *, sym_visibility=None, alignment=None, ordinal=None, mime_type=None, loc=None, ip=None) -> RodataOp:
  return RodataOp(sym_name=sym_name, value=value, sym_visibility=sym_visibility, alignment=alignment, ordinal=ordinal, mime_type=mime_type, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class RodataTableInlineOp(_ods_ir.OpView):
  r"""
  vm.rodata with another associated vm.rodata table specifying byte offsets
  and sizes as a subview into the flattened data. The table is a flat array
  of 32 or 64-bit integers storing (offset, size) in element order.
  
  The optional alignment attribute applies to both the table and data rodata.
  The data_alignment attribute can be used to specify an alignment for the
  elements of the table, padding to the data alignment with zeros. The element
  sizes reflect the unpadded attribute storage sizes.
  
  See vm.rodata for more information.
  """

  OPERATION_NAME = "vm.rodata.table.inline"

  _ODS_REGIONS = (0, True)

  def __init__(self, table_result, data_result, table_type, data_array, *, table_name=None, data_name=None, alignment=None, data_alignment=None, mime_type=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if table_name is not None: attributes["table_name"] = (table_name if (
        isinstance(table_name, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(table_name, context=_ods_context))
    if data_name is not None: attributes["data_name"] = (data_name if (
        isinstance(data_name, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(data_name, context=_ods_context))
    attributes["table_type"] = (table_type if (
    isinstance(table_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_888')) else
      _ods_ir.AttrBuilder.get('anonymous_888')(table_type, context=_ods_context))
    attributes["data_array"] = (data_array if (
    isinstance(data_array, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Util_AnySerializableArrayAttr')) else
      _ods_ir.AttrBuilder.get('Util_AnySerializableArrayAttr')(data_array, context=_ods_context))
    if alignment is not None: attributes["alignment"] = (alignment if (
        isinstance(alignment, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(alignment, context=_ods_context))
    if data_alignment is not None: attributes["data_alignment"] = (data_alignment if (
        isinstance(data_alignment, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(data_alignment, context=_ods_context))
    if mime_type is not None: attributes["mime_type"] = (mime_type if (
        isinstance(mime_type, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(mime_type, context=_ods_context))
    results = []
    results.append(table_result)
    results.append(data_result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def table_name(self) -> _Optional[_ods_ir.StringAttr]:
    if "table_name" not in self.operation.attributes:
      return None
    return self.operation.attributes["table_name"]

  @table_name.setter
  def table_name(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["table_name"] = value
    elif "table_name" in self.operation.attributes:
      del self.operation.attributes["table_name"]

  @table_name.deleter
  def table_name(self):
    del self.operation.attributes["table_name"]

  @builtins.property
  def data_name(self) -> _Optional[_ods_ir.StringAttr]:
    if "data_name" not in self.operation.attributes:
      return None
    return self.operation.attributes["data_name"]

  @data_name.setter
  def data_name(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["data_name"] = value
    elif "data_name" in self.operation.attributes:
      del self.operation.attributes["data_name"]

  @data_name.deleter
  def data_name(self):
    del self.operation.attributes["data_name"]

  @builtins.property
  def table_type(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["table_type"]

  @table_type.setter
  def table_type(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["table_type"] = value

  @builtins.property
  def data_array(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["data_array"]

  @data_array.setter
  def data_array(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["data_array"] = value

  @builtins.property
  def alignment(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "alignment" not in self.operation.attributes:
      return None
    return self.operation.attributes["alignment"]

  @alignment.setter
  def alignment(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["alignment"] = value
    elif "alignment" in self.operation.attributes:
      del self.operation.attributes["alignment"]

  @alignment.deleter
  def alignment(self):
    del self.operation.attributes["alignment"]

  @builtins.property
  def data_alignment(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "data_alignment" not in self.operation.attributes:
      return None
    return self.operation.attributes["data_alignment"]

  @data_alignment.setter
  def data_alignment(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["data_alignment"] = value
    elif "data_alignment" in self.operation.attributes:
      del self.operation.attributes["data_alignment"]

  @data_alignment.deleter
  def data_alignment(self):
    del self.operation.attributes["data_alignment"]

  @builtins.property
  def mime_type(self) -> _Optional[_ods_ir.StringAttr]:
    if "mime_type" not in self.operation.attributes:
      return None
    return self.operation.attributes["mime_type"]

  @mime_type.setter
  def mime_type(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["mime_type"] = value
    elif "mime_type" in self.operation.attributes:
      del self.operation.attributes["mime_type"]

  @mime_type.deleter
  def mime_type(self):
    del self.operation.attributes["mime_type"]

  @builtins.property
  def table_result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

  @builtins.property
  def data_result(self) -> _ods_ir.OpResult:
    return self.operation.results[1]

def rodata_table_inline(table_result, data_result, table_type, data_array, *, table_name=None, data_name=None, alignment=None, data_alignment=None, mime_type=None, loc=None, ip=None) -> _ods_ir.OpResultList:
  return RodataTableInlineOp(table_result=table_result, data_result=data_result, table_type=table_type, data_array=data_array, table_name=table_name, data_name=data_name, alignment=alignment, data_alignment=data_alignment, mime_type=mime_type, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class RoundF32EvenOp(_ods_ir.OpView):
  OPERATION_NAME = "vm.round.f32.even"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def round_f32_even(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return RoundF32EvenOp(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RoundF32Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.round.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def round_f32(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return RoundF32Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RoundF64EvenOp(_ods_ir.OpView):
  OPERATION_NAME = "vm.round.f64.even"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def round_f64_even(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return RoundF64EvenOp(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RoundF64Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.round.f64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def round_f64(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return RoundF64Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RsqrtF32Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.rsqrt.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def rsqrt_f32(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return RsqrtF32Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RsqrtF64Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.rsqrt.f64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def rsqrt_f64(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return RsqrtF64Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SelectF32Op(_ods_ir.OpView):
  r"""
  Chooses one value based on a binary condition supplied as its first operand.
  If the value of the condition is true the `true_value` operand is chosen,
  otherwise the `false_value` operand is chosen. The true and false values
  must have the same types. For example, the maximum operation is obtained by
  combining "select" with "cmpi" as follows:
  
  ```
  %2 = vm.cmp.gt.i32.s %0, %1 : i32
  %3 = vm.select.i32 %2, %0, %1 : i32
  ```
  """

  OPERATION_NAME = "vm.select.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, condition, true_value, false_value, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(condition)
    operands.append(true_value)
    operands.append(false_value)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def condition(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def true_value(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def false_value(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[2]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def select_f32(result, condition, true_value, false_value, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return SelectF32Op(result=result, condition=condition, true_value=true_value, false_value=false_value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SelectF64Op(_ods_ir.OpView):
  r"""
  Chooses one value based on a binary condition supplied as its first operand.
  If the value of the condition is true the `true_value` operand is chosen,
  otherwise the `false_value` operand is chosen. The true and false values
  must have the same types. For example, the maximum operation is obtained by
  combining "select" with "cmpi" as follows:
  
  ```
  %2 = vm.cmp.gt.i32.s %0, %1 : i32
  %3 = vm.select.i32 %2, %0, %1 : i32
  ```
  """

  OPERATION_NAME = "vm.select.f64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, condition, true_value, false_value, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(condition)
    operands.append(true_value)
    operands.append(false_value)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def condition(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def true_value(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def false_value(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[2]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def select_f64(result, condition, true_value, false_value, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return SelectF64Op(result=result, condition=condition, true_value=true_value, false_value=false_value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SelectI32Op(_ods_ir.OpView):
  r"""
  Chooses one value based on a binary condition supplied as its first operand.
  If the value of the condition is true the `true_value` operand is chosen,
  otherwise the `false_value` operand is chosen. The true and false values
  must have the same types. For example, the maximum operation is obtained by
  combining "select" with "cmpi" as follows:
  
  ```
  %2 = vm.cmp.gt.i32.s %0, %1 : i32
  %3 = vm.select.i32 %2, %0, %1 : i32
  ```
  """

  OPERATION_NAME = "vm.select.i32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, condition, true_value, false_value, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(condition)
    operands.append(true_value)
    operands.append(false_value)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def condition(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def true_value(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def false_value(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[2]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def select_i32(result, condition, true_value, false_value, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return SelectI32Op(result=result, condition=condition, true_value=true_value, false_value=false_value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SelectI64Op(_ods_ir.OpView):
  r"""
  Chooses one value based on a binary condition supplied as its first operand.
  If the value of the condition is true the `true_value` operand is chosen,
  otherwise the `false_value` operand is chosen. The true and false values
  must have the same types. For example, the maximum operation is obtained by
  combining "select" with "cmpi" as follows:
  
  ```
  %2 = vm.cmp.gt.i32.s %0, %1 : i32
  %3 = vm.select.i32 %2, %0, %1 : i32
  ```
  """

  OPERATION_NAME = "vm.select.i64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, condition, true_value, false_value, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(condition)
    operands.append(true_value)
    operands.append(false_value)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def condition(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def true_value(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def false_value(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[2]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def select_i64(result, condition, true_value, false_value, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return SelectI64Op(result=result, condition=condition, true_value=true_value, false_value=false_value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SelectRefOp(_ods_ir.OpView):
  r"""
  Chooses one value based on a binary condition supplied as its first operand.
  If the value of the condition is true the `true_value` operand is chosen,
  otherwise the `false_value` operand is chosen.
  """

  OPERATION_NAME = "vm.select.ref"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, condition, true_value, false_value, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(condition)
    operands.append(true_value)
    operands.append(false_value)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def condition(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def true_value(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def false_value(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def select_ref(result, condition, true_value, false_value, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return SelectRefOp(result=result, condition=condition, true_value=true_value, false_value=false_value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ShlI32Op(_ods_ir.OpView):
  r"""
  Shifts the operand in a direction by the number of bits specified.
  """

  OPERATION_NAME = "vm.shl.i32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, amount, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    operands.append(amount)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def amount(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def shl_i32(result, operand, amount, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ShlI32Op(result=result, operand=operand, amount=amount, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ShlI64Op(_ods_ir.OpView):
  r"""
  Shifts the operand in a direction by the number of bits specified.
  """

  OPERATION_NAME = "vm.shl.i64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, amount, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    operands.append(amount)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def amount(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def shl_i64(result, operand, amount, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ShlI64Op(result=result, operand=operand, amount=amount, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ShrI32SOp(_ods_ir.OpView):
  r"""
  Shifts the operand in a direction by the number of bits specified.
  """

  OPERATION_NAME = "vm.shr.i32.s"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, amount, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    operands.append(amount)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def amount(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def shr_i32_s(result, operand, amount, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ShrI32SOp(result=result, operand=operand, amount=amount, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ShrI32UOp(_ods_ir.OpView):
  r"""
  Shifts the operand in a direction by the number of bits specified.
  """

  OPERATION_NAME = "vm.shr.i32.u"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, amount, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    operands.append(amount)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def amount(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def shr_i32_u(result, operand, amount, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ShrI32UOp(result=result, operand=operand, amount=amount, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ShrI64SOp(_ods_ir.OpView):
  r"""
  Shifts the operand in a direction by the number of bits specified.
  """

  OPERATION_NAME = "vm.shr.i64.s"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, amount, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    operands.append(amount)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def amount(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def shr_i64_s(result, operand, amount, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ShrI64SOp(result=result, operand=operand, amount=amount, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ShrI64UOp(_ods_ir.OpView):
  r"""
  Shifts the operand in a direction by the number of bits specified.
  """

  OPERATION_NAME = "vm.shr.i64.u"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, amount, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    operands.append(amount)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def amount(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def shr_i64_u(result, operand, amount, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ShrI64UOp(result=result, operand=operand, amount=amount, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SinF32Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.sin.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def sin_f32(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return SinF32Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SinF64Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.sin.f64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def sin_f64(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return SinF64Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SqrtF32Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.sqrt.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def sqrt_f32(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return SqrtF32Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SqrtF64Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.sqrt.f64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def sqrt_f64(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return SqrtF64Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SubF32Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.sub.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def sub_f32(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return SubF32Op(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SubF64Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.sub.f64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def sub_f64(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return SubF64Op(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SubI32Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.sub.i32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def sub_i32(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return SubI32Op(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SubI64Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.sub.i64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def sub_i64(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return SubI64Op(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SwitchF32Op(_ods_ir.OpView):
  r"""
  Returns the value with the given `index` in `values` or `default_value` if
  the index is out of bounds.
  
  ```mlir
  // Switch %index to cases of %c100/%c200/%c300 if index==0, ==1, ==2.
  // If %index is out of range (<0 or >2) then default to %c5.
  %0 = vm.switch.f32 %index[%c100, %c200, %c300] else %c5 : f32
  ```
  """

  OPERATION_NAME = "vm.switch.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, index, default_value, values, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(index)
    operands.append(default_value)
    operands.extend(_get_op_results_or_values(values))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def index(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def default_value(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def values(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[2:2 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def switch_f32(result, index, default_value, values, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return SwitchF32Op(result=result, index=index, default_value=default_value, values=values, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SwitchF64Op(_ods_ir.OpView):
  r"""
  Returns the value with the given `index` in `values` or `default_value` if
  the index is out of bounds.
  
  ```mlir
  // Switch %index to cases of %c100/%c200/%c300 if index==0, ==1, ==2.
  // If %index is out of range (<0 or >2) then default to %c5.
  %0 = vm.switch.f32 %index[%c100, %c200, %c300] else %c5 : f32
  ```
  """

  OPERATION_NAME = "vm.switch.f64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, index, default_value, values, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(index)
    operands.append(default_value)
    operands.extend(_get_op_results_or_values(values))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def index(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def default_value(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[1]

  @builtins.property
  def values(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[2:2 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def switch_f64(result, index, default_value, values, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return SwitchF64Op(result=result, index=index, default_value=default_value, values=values, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SwitchI32Op(_ods_ir.OpView):
  r"""
  Returns the value with the given `index` in `values` or `default_value` if
  the index is out of bounds.
  
  ```mlir
  // Switch %index to cases of %c100/%c200/%c300 if index==0, ==1, ==2.
  // If %index is out of range (<0 or >2) then default to %c5.
  %0 = vm.switch.i32 %index[%c100, %c200, %c300] else %c5 : i32
  ```
  """

  OPERATION_NAME = "vm.switch.i32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, index, default_value, values, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(index)
    operands.append(default_value)
    operands.extend(_get_op_results_or_values(values))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def index(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def default_value(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def values(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[2:2 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def switch_i32(result, index, default_value, values, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return SwitchI32Op(result=result, index=index, default_value=default_value, values=values, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SwitchI64Op(_ods_ir.OpView):
  r"""
  Returns the value with the given `index` in `values` or `default_value` if
  the index is out of bounds.
  
  ```mlir
  // Switch %index to cases of %c100/%c200/%c300 if index==0, ==1, ==2.
  // If %index is out of range (<0 or >2) then default to %c5.
  %0 = vm.switch.i32 %index[%c100, %c200, %c300] else %c5 : i32
  ```
  """

  OPERATION_NAME = "vm.switch.i64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, index, default_value, values, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(index)
    operands.append(default_value)
    operands.extend(_get_op_results_or_values(values))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def index(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def default_value(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def values(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[2:2 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def switch_i64(result, index, default_value, values, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return SwitchI64Op(result=result, index=index, default_value=default_value, values=values, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SwitchRefOp(_ods_ir.OpView):
  r"""
  Returns the value with the given `index` in `values` or `default_value` if
  the index is out of bounds.
  
  ```mlir
  // Switch %arg0 to cases of %r0/%r1/%r2 if arg0==0, ==1, ==2.
  // If %arg0 is out of range (<0 or >2) then default to %null.
  %0 = vm.switch.ref %index[%r0, %r1, %r2] else %null : vm.ref<!foo>
  ```
  """

  OPERATION_NAME = "vm.switch.ref"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, index, default_value, values, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(index)
    operands.append(default_value)
    operands.extend(_get_op_results_or_values(values))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def index(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def default_value(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def values(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[2:2 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def switch_ref(result, index, default_value, values, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return SwitchRefOp(result=result, index=index, default_value=default_value, values=values, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TanhF32Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.tanh.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def tanh_f32(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TanhF32Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TanhF64Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.tanh.f64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def tanh_f64(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TanhF64Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TraceOp(_ods_ir.OpView):
  r"""
  Traces one or more values at the time the operation is executed.
  These values will be encoded into the active trace depending on the active
  trace verbosity setting.
  """

  OPERATION_NAME = "vm.trace"

  _ODS_REGIONS = (0, True)

  def __init__(self, event_name, operands_, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["event_name"] = (event_name if (
    isinstance(event_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(event_name, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def event_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["event_name"]

  @event_name.setter
  def event_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["event_name"] = value

def trace(event_name, operands_, *, loc=None, ip=None) -> TraceOp:
  return TraceOp(event_name=event_name, operands_=operands_, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class TruncF64F32Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.trunc.f64.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.FloatType]:
    return self.operation.results[0]

def trunc_f64_f32(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TruncF64F32Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TruncI16I8Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.trunc.i16.i8"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def trunc_i16_i8(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TruncI16I8Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TruncI32I8Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.trunc.i32.i8"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def trunc_i32_i8(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TruncI32I8Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TruncI32I16Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.trunc.i32.i16"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def trunc_i32_i16(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TruncI32I16Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TruncI64I8Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.trunc.i64.i8"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def trunc_i64_i8(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TruncI64I8Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TruncI64I16Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.trunc.i64.i16"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def trunc_i64_i16(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TruncI64I16Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TruncI64I32Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.trunc.i64.i32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def trunc_i64_i32(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TruncI64I32Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class XorI32Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.xor.i32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def xor_i32(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return XorI32Op(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class XorI64Op(_ods_ir.OpView):
  OPERATION_NAME = "vm.xor.i64"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def xor_i64(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return XorI64Op(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class YieldOp(_ods_ir.OpView):
  r"""
   Yields the fiber for some (likely short) amount of time. This can be used to
   perform cooperative scheduling and ensure fair (enough) execution. Execution
   resumes at the specified target branch.
  
   ```
   ^bb0:
     vm.yield ^on_resume
   ^on_resume:
     ...
  ```
  """

  OPERATION_NAME = "vm.yield"

  _ODS_REGIONS = (0, True)

  def __init__(self, destOperands, dest, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(destOperands))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = []
    _ods_successors.append(dest)
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def destOperands(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def yield_(dest_operands, dest, *, loc=None, ip=None) -> YieldOp:
  return YieldOp(destOperands=dest_operands, dest=dest, loc=loc, ip=ip)
