# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pydantic_utilities import parse_obj_as
from ..core.request_options import RequestOptions
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..types.available_categories_response import AvailableCategoriesResponse
from ..types.available_models_response import AvailableModelsResponse
from ..types.benchmark_quantile import BenchmarkQuantile
from ..types.categories_metadata_response import CategoriesMetadataResponse
from ..types.columns_metadata_response import ColumnsMetadataResponse
from ..types.deal_combined_metrics_response import DealCombinedMetricsResponse
from ..types.http_validation_error import HttpValidationError
from ..types.models_metadata_response import ModelsMetadataResponse
from ..types.scale_models_response import ScaleModelsResponse
from ..types.tradeoff_models_response import TradeoffModelsResponse
from ..types.user_type import UserType


class RawBenchmarkClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def get_quantiles(
        self, group_id: int, category: str, *, revenue: float, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.List[BenchmarkQuantile]]:
        """
        Get benchmark quantiles for a specific category at a given revenue scale.

        This endpoint returns quantile-based benchmarks for key SaaS metrics, allowing comparison
        of performance against similar companies at comparable revenue scales. Each quantile
        represents a percentile of the benchmark distribution (e.g., 0.25 = 25th percentile).

        **Key Metrics Included:**
        - Revenue metrics (annualized revenue, rolling averages, concentration)
        - Growth metrics (CMGR, YoY growth)
        - Financial efficiency (margins, magic number, rule of 40)
        - Retention and cohort metrics (logo/revenue retention, LTV/CAC ratios)
        - Employee metrics (headcount, retention, efficiency)

        **Parameters:**
        - `category`: The business category for benchmarking (e.g., "saas", "ai", "consumer")
        - `revenue`: The annualized revenue scale for which to obtain benchmarks

        Parameters
        ----------
        group_id : int

        category : str

        revenue : float
            Annualized revenue scale for which to obtain benchmarks

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[BenchmarkQuantile]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/data/benchmark/quantiles/{jsonable_encoder(category)}",
            method="GET",
            params={
                "revenue": revenue,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[BenchmarkQuantile],
                    parse_obj_as(
                        type_=typing.List[BenchmarkQuantile],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_scaling(
        self,
        group_id: int,
        category: str,
        *,
        model: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ScaleModelsResponse]:
        """
        Get scaling models for a specific category.

        Scaling models show how metrics change as companies grow (e.g., how growth rates
        change with revenue scale). Each model contains raw data points, predicted trends,
        and confidence bands.

        **Parameters:**
        - `category`: The business category (e.g., "saas", "ai", "consumer")
        - `model`: Optional list of specific models to return (e.g., ["12m_growth_vs_scale"])

        Parameters
        ----------
        group_id : int

        category : str

        model : typing.Optional[typing.Union[str, typing.Sequence[str]]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ScaleModelsResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/data/benchmark/scaling/{jsonable_encoder(category)}",
            method="GET",
            params={
                "model": model,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ScaleModelsResponse,
                    parse_obj_as(
                        type_=ScaleModelsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_available_models(
        self, group_id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[AvailableModelsResponse]:
        """
        Get the list of available benchmark models.

        Returns lists of available scaling models (e.g., how metrics evolve with scale)
        and tradeoff models (e.g., growth vs. efficiency tradeoffs) for the account.

        Parameters
        ----------
        group_id : int

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[AvailableModelsResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/data/benchmark/available-models",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AvailableModelsResponse,
                    parse_obj_as(
                        type_=AvailableModelsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_tradeoff_at_scale(
        self,
        group_id: int,
        category: str,
        *,
        revenue: float,
        model: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[TradeoffModelsResponse]:
        """
        Get tradeoff models for a specific category at a given revenue scale.

        Tradeoff models show the relationship between two metrics (e.g., growth vs. margin)
        for companies at a similar revenue scale. This helps understand typical tradeoffs
        companies make at different stages.

        **Parameters:**
        - `category`: The business category (e.g., "saas", "ai", "consumer")
        - `revenue`: The annualized revenue scale
        - `model`: Optional list of specific models to return (e.g., ["12m_growth_vs_margin"])

        Parameters
        ----------
        group_id : int

        category : str

        revenue : float
            Annualized revenue scale for which to obtain benchmarks

        model : typing.Optional[typing.Union[str, typing.Sequence[str]]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[TradeoffModelsResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/data/benchmark/tradeoff-at-scale/{jsonable_encoder(category)}",
            method="GET",
            params={
                "revenue": revenue,
                "model": model,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    TradeoffModelsResponse,
                    parse_obj_as(
                        type_=TradeoffModelsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_available_company_categories(
        self, group_id: int, deal_id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[AvailableCategoriesResponse]:
        """
        Get the categories with benchmark models available for the company associated with the deal.

        Parameters
        ----------
        group_id : int

        deal_id : int

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[AvailableCategoriesResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/{jsonable_encoder(deal_id)}/data/benchmark/available-categories",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AvailableCategoriesResponse,
                    parse_obj_as(
                        type_=AvailableCategoriesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_combined_time_series(
        self,
        group_id: int,
        deal_id: int,
        user_type: UserType,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[DealCombinedMetricsResponse]]:
        """
        Get the combined time series data for the deal.

        Parameters
        ----------
        group_id : int

        deal_id : int

        user_type : UserType

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[DealCombinedMetricsResponse]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/{jsonable_encoder(deal_id)}/data/benchmark/combined-time-series/{jsonable_encoder(user_type)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[DealCombinedMetricsResponse],
                    parse_obj_as(
                        type_=typing.List[DealCombinedMetricsResponse],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_time_series_endpoint(
        self,
        group_id: int,
        deal_id: int,
        user_type: UserType,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[DealCombinedMetricsResponse]:
        """
        Get the time series data endpoint for the deal.

        Parameters
        ----------
        group_id : int

        deal_id : int

        user_type : UserType

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DealCombinedMetricsResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/{jsonable_encoder(deal_id)}/data/benchmark/time-series-endpoint/{jsonable_encoder(user_type)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DealCombinedMetricsResponse,
                    parse_obj_as(
                        type_=DealCombinedMetricsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_deal_benchmark_quantiles(
        self, group_id: int, deal_id: int, category: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.List[BenchmarkQuantile]]:
        """
        Get benchmark quantiles for a specific deal and category.

        This endpoint returns quantile-based benchmarks for key SaaS metrics, allowing you to compare
        a deal's performance against similar companies at comparable revenue scales. Each quantile
        represents a percentile of the benchmark distribution (e.g., 0.25 = 25th percentile).

        **Key Metrics Included:**
        - Revenue metrics (annualized revenue, rolling averages, concentration)
        - Growth metrics (CMGR, YoY growth)
        - Financial efficiency (margins, magic number, rule of 40)
        - Retention and cohort metrics (logo/revenue retention, LTV/CAC ratios)
        - Employee metrics (headcount, retention, efficiency)

        **Parameters:**
        - `category`: The business category for benchmarking (e.g., "saas", "ai", "consumer")
        - `column`: Optional list of specific metric columns to return (reduces response size)
        - Revenue is automatically resolved from the deal's time series data

        Parameters
        ----------
        group_id : int

        deal_id : int

        category : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[BenchmarkQuantile]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/{jsonable_encoder(deal_id)}/data/benchmark/quantiles/{jsonable_encoder(category)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[BenchmarkQuantile],
                    parse_obj_as(
                        type_=typing.List[BenchmarkQuantile],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_deal_benchmark_tradeoff_at_scale(
        self,
        group_id: int,
        deal_id: int,
        category: str,
        *,
        model: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[TradeoffModelsResponse]:
        """
        Get the tradeoff models for a given category.

        Parameters
        ----------
        group_id : int

        deal_id : int

        category : str

        model : typing.Optional[typing.Union[str, typing.Sequence[str]]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[TradeoffModelsResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/{jsonable_encoder(deal_id)}/data/benchmark/tradeoff-at-scale/{jsonable_encoder(category)}",
            method="GET",
            params={
                "model": model,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    TradeoffModelsResponse,
                    parse_obj_as(
                        type_=TradeoffModelsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_columns_metadata(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[ColumnsMetadataResponse]:
        """
        Get metadata for all benchmark metrics/columns.

        Returns comprehensive information about each metric including:
        - Friendly display names
        - Units (percent, ratio, scalar, dollar)
        - Scaling type (geometric or arithmetic)
        - Performance direction (reverse = lower is better)
        - Suggested cutoff values

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ColumnsMetadataResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/data/benchmark/metadata/columns",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ColumnsMetadataResponse,
                    parse_obj_as(
                        type_=ColumnsMetadataResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_models_metadata(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.List[ModelsMetadataResponse]]:
        """
        Get metadata for benchmark model types.

        Returns information about model classes (scaling and tradeoff), including:
        - Model class names and descriptions
        - Available model implementations
        - Metrics used in each model

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[ModelsMetadataResponse]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/data/benchmark/metadata/models",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[ModelsMetadataResponse],
                    parse_obj_as(
                        type_=typing.List[ModelsMetadataResponse],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_categories_metadata(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[CategoriesMetadataResponse]:
        """
        Get metadata for benchmark categories.

        Returns information about all enabled benchmark categories including:
        - Category names and friendly display names
        - Default user type for each category (business or consumer)

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CategoriesMetadataResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/data/benchmark/metadata/categories",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CategoriesMetadataResponse,
                    parse_obj_as(
                        type_=CategoriesMetadataResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawBenchmarkClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def get_quantiles(
        self, group_id: int, category: str, *, revenue: float, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.List[BenchmarkQuantile]]:
        """
        Get benchmark quantiles for a specific category at a given revenue scale.

        This endpoint returns quantile-based benchmarks for key SaaS metrics, allowing comparison
        of performance against similar companies at comparable revenue scales. Each quantile
        represents a percentile of the benchmark distribution (e.g., 0.25 = 25th percentile).

        **Key Metrics Included:**
        - Revenue metrics (annualized revenue, rolling averages, concentration)
        - Growth metrics (CMGR, YoY growth)
        - Financial efficiency (margins, magic number, rule of 40)
        - Retention and cohort metrics (logo/revenue retention, LTV/CAC ratios)
        - Employee metrics (headcount, retention, efficiency)

        **Parameters:**
        - `category`: The business category for benchmarking (e.g., "saas", "ai", "consumer")
        - `revenue`: The annualized revenue scale for which to obtain benchmarks

        Parameters
        ----------
        group_id : int

        category : str

        revenue : float
            Annualized revenue scale for which to obtain benchmarks

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[BenchmarkQuantile]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/data/benchmark/quantiles/{jsonable_encoder(category)}",
            method="GET",
            params={
                "revenue": revenue,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[BenchmarkQuantile],
                    parse_obj_as(
                        type_=typing.List[BenchmarkQuantile],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_scaling(
        self,
        group_id: int,
        category: str,
        *,
        model: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ScaleModelsResponse]:
        """
        Get scaling models for a specific category.

        Scaling models show how metrics change as companies grow (e.g., how growth rates
        change with revenue scale). Each model contains raw data points, predicted trends,
        and confidence bands.

        **Parameters:**
        - `category`: The business category (e.g., "saas", "ai", "consumer")
        - `model`: Optional list of specific models to return (e.g., ["12m_growth_vs_scale"])

        Parameters
        ----------
        group_id : int

        category : str

        model : typing.Optional[typing.Union[str, typing.Sequence[str]]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ScaleModelsResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/data/benchmark/scaling/{jsonable_encoder(category)}",
            method="GET",
            params={
                "model": model,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ScaleModelsResponse,
                    parse_obj_as(
                        type_=ScaleModelsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_available_models(
        self, group_id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[AvailableModelsResponse]:
        """
        Get the list of available benchmark models.

        Returns lists of available scaling models (e.g., how metrics evolve with scale)
        and tradeoff models (e.g., growth vs. efficiency tradeoffs) for the account.

        Parameters
        ----------
        group_id : int

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[AvailableModelsResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/data/benchmark/available-models",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AvailableModelsResponse,
                    parse_obj_as(
                        type_=AvailableModelsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_tradeoff_at_scale(
        self,
        group_id: int,
        category: str,
        *,
        revenue: float,
        model: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[TradeoffModelsResponse]:
        """
        Get tradeoff models for a specific category at a given revenue scale.

        Tradeoff models show the relationship between two metrics (e.g., growth vs. margin)
        for companies at a similar revenue scale. This helps understand typical tradeoffs
        companies make at different stages.

        **Parameters:**
        - `category`: The business category (e.g., "saas", "ai", "consumer")
        - `revenue`: The annualized revenue scale
        - `model`: Optional list of specific models to return (e.g., ["12m_growth_vs_margin"])

        Parameters
        ----------
        group_id : int

        category : str

        revenue : float
            Annualized revenue scale for which to obtain benchmarks

        model : typing.Optional[typing.Union[str, typing.Sequence[str]]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[TradeoffModelsResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/data/benchmark/tradeoff-at-scale/{jsonable_encoder(category)}",
            method="GET",
            params={
                "revenue": revenue,
                "model": model,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    TradeoffModelsResponse,
                    parse_obj_as(
                        type_=TradeoffModelsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_available_company_categories(
        self, group_id: int, deal_id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[AvailableCategoriesResponse]:
        """
        Get the categories with benchmark models available for the company associated with the deal.

        Parameters
        ----------
        group_id : int

        deal_id : int

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[AvailableCategoriesResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/{jsonable_encoder(deal_id)}/data/benchmark/available-categories",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AvailableCategoriesResponse,
                    parse_obj_as(
                        type_=AvailableCategoriesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_combined_time_series(
        self,
        group_id: int,
        deal_id: int,
        user_type: UserType,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[DealCombinedMetricsResponse]]:
        """
        Get the combined time series data for the deal.

        Parameters
        ----------
        group_id : int

        deal_id : int

        user_type : UserType

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[DealCombinedMetricsResponse]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/{jsonable_encoder(deal_id)}/data/benchmark/combined-time-series/{jsonable_encoder(user_type)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[DealCombinedMetricsResponse],
                    parse_obj_as(
                        type_=typing.List[DealCombinedMetricsResponse],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_time_series_endpoint(
        self,
        group_id: int,
        deal_id: int,
        user_type: UserType,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[DealCombinedMetricsResponse]:
        """
        Get the time series data endpoint for the deal.

        Parameters
        ----------
        group_id : int

        deal_id : int

        user_type : UserType

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DealCombinedMetricsResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/{jsonable_encoder(deal_id)}/data/benchmark/time-series-endpoint/{jsonable_encoder(user_type)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DealCombinedMetricsResponse,
                    parse_obj_as(
                        type_=DealCombinedMetricsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_deal_benchmark_quantiles(
        self, group_id: int, deal_id: int, category: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.List[BenchmarkQuantile]]:
        """
        Get benchmark quantiles for a specific deal and category.

        This endpoint returns quantile-based benchmarks for key SaaS metrics, allowing you to compare
        a deal's performance against similar companies at comparable revenue scales. Each quantile
        represents a percentile of the benchmark distribution (e.g., 0.25 = 25th percentile).

        **Key Metrics Included:**
        - Revenue metrics (annualized revenue, rolling averages, concentration)
        - Growth metrics (CMGR, YoY growth)
        - Financial efficiency (margins, magic number, rule of 40)
        - Retention and cohort metrics (logo/revenue retention, LTV/CAC ratios)
        - Employee metrics (headcount, retention, efficiency)

        **Parameters:**
        - `category`: The business category for benchmarking (e.g., "saas", "ai", "consumer")
        - `column`: Optional list of specific metric columns to return (reduces response size)
        - Revenue is automatically resolved from the deal's time series data

        Parameters
        ----------
        group_id : int

        deal_id : int

        category : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[BenchmarkQuantile]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/{jsonable_encoder(deal_id)}/data/benchmark/quantiles/{jsonable_encoder(category)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[BenchmarkQuantile],
                    parse_obj_as(
                        type_=typing.List[BenchmarkQuantile],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_deal_benchmark_tradeoff_at_scale(
        self,
        group_id: int,
        deal_id: int,
        category: str,
        *,
        model: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[TradeoffModelsResponse]:
        """
        Get the tradeoff models for a given category.

        Parameters
        ----------
        group_id : int

        deal_id : int

        category : str

        model : typing.Optional[typing.Union[str, typing.Sequence[str]]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[TradeoffModelsResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/{jsonable_encoder(deal_id)}/data/benchmark/tradeoff-at-scale/{jsonable_encoder(category)}",
            method="GET",
            params={
                "model": model,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    TradeoffModelsResponse,
                    parse_obj_as(
                        type_=TradeoffModelsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_columns_metadata(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[ColumnsMetadataResponse]:
        """
        Get metadata for all benchmark metrics/columns.

        Returns comprehensive information about each metric including:
        - Friendly display names
        - Units (percent, ratio, scalar, dollar)
        - Scaling type (geometric or arithmetic)
        - Performance direction (reverse = lower is better)
        - Suggested cutoff values

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ColumnsMetadataResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/data/benchmark/metadata/columns",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ColumnsMetadataResponse,
                    parse_obj_as(
                        type_=ColumnsMetadataResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_models_metadata(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.List[ModelsMetadataResponse]]:
        """
        Get metadata for benchmark model types.

        Returns information about model classes (scaling and tradeoff), including:
        - Model class names and descriptions
        - Available model implementations
        - Metrics used in each model

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[ModelsMetadataResponse]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/data/benchmark/metadata/models",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[ModelsMetadataResponse],
                    parse_obj_as(
                        type_=typing.List[ModelsMetadataResponse],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_categories_metadata(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[CategoriesMetadataResponse]:
        """
        Get metadata for benchmark categories.

        Returns information about all enabled benchmark categories including:
        - Category names and friendly display names
        - Default user type for each category (business or consumer)

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CategoriesMetadataResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/data/benchmark/metadata/categories",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CategoriesMetadataResponse,
                    parse_obj_as(
                        type_=CategoriesMetadataResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
