# coding: utf-8

"""
    Trackside Software TeamDB API v2.0

    This API enables you to access TeamDB data  # noqa: E501

    OpenAPI spec version: 2.0
    Contact: support@trackside.fr
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from teamdbapi.api_client import ApiClient


class AssemblyApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def add_revisions_to_assembly(self, assembly_id, revision_ids, **kwargs):  # noqa: E501
        """[Command] Add a list of revisions to an assembly.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_revisions_to_assembly(assembly_id, revision_ids, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str assembly_id: The assembly id to which you want to add the revisions (required)
        :param list[str] revision_ids: A list of unique revision ids you want to add to the assembly (required)
        :return: Assembly
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_revisions_to_assembly_with_http_info(assembly_id, revision_ids, **kwargs)  # noqa: E501
        else:
            (data) = self.add_revisions_to_assembly_with_http_info(assembly_id, revision_ids, **kwargs)  # noqa: E501
            return data

    def add_revisions_to_assembly_with_http_info(self, assembly_id, revision_ids, **kwargs):  # noqa: E501
        """[Command] Add a list of revisions to an assembly.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_revisions_to_assembly_with_http_info(assembly_id, revision_ids, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str assembly_id: The assembly id to which you want to add the revisions (required)
        :param list[str] revision_ids: A list of unique revision ids you want to add to the assembly (required)
        :return: Assembly
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['assembly_id', 'revision_ids']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_revisions_to_assembly" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'assembly_id' is set
        if self.api_client.client_side_validation and ('assembly_id' not in params or
                                                       params['assembly_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `assembly_id` when calling `add_revisions_to_assembly`")  # noqa: E501
        # verify the required parameter 'revision_ids' is set
        if self.api_client.client_side_validation and ('revision_ids' not in params or
                                                       params['revision_ids'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `revision_ids` when calling `add_revisions_to_assembly`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'assembly_id' in params:
            path_params['assemblyId'] = params['assembly_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'revision_ids' in params:
            body_params = params['revision_ids']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json-patch+json', 'application/json', 'text/json', 'application/*+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TdbApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/teamdbapi/v2.0/assembly/{assemblyId}/addrevisions', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Assembly',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_tag(self, assembly_id, tag, **kwargs):  # noqa: E501
        """[Command] Add a search tag to an existing assembly  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_tag(assembly_id, tag, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str assembly_id: The assembly unique id (required)
        :param str tag: The tag to add to the assembly (required)
        :return: Assembly
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_tag_with_http_info(assembly_id, tag, **kwargs)  # noqa: E501
        else:
            (data) = self.add_tag_with_http_info(assembly_id, tag, **kwargs)  # noqa: E501
            return data

    def add_tag_with_http_info(self, assembly_id, tag, **kwargs):  # noqa: E501
        """[Command] Add a search tag to an existing assembly  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_tag_with_http_info(assembly_id, tag, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str assembly_id: The assembly unique id (required)
        :param str tag: The tag to add to the assembly (required)
        :return: Assembly
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['assembly_id', 'tag']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_tag" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'assembly_id' is set
        if self.api_client.client_side_validation and ('assembly_id' not in params or
                                                       params['assembly_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `assembly_id` when calling `add_tag`")  # noqa: E501
        # verify the required parameter 'tag' is set
        if self.api_client.client_side_validation and ('tag' not in params or
                                                       params['tag'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `tag` when calling `add_tag`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'assembly_id' in params:
            path_params['assemblyId'] = params['assembly_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'tag' in params:
            body_params = params['tag']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json-patch+json', 'application/json', 'text/json', 'application/*+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TdbApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/teamdbapi/v2.0/assembly/{assemblyId}/addtag', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Assembly',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def assemblies_link_to_run(self, run_id, **kwargs):  # noqa: E501
        """Get all the assemblies link to a run  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.assemblies_link_to_run(run_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str run_id: The run id you want the assemblies linked to (required)
        :return: list[Assembly]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.assemblies_link_to_run_with_http_info(run_id, **kwargs)  # noqa: E501
        else:
            (data) = self.assemblies_link_to_run_with_http_info(run_id, **kwargs)  # noqa: E501
            return data

    def assemblies_link_to_run_with_http_info(self, run_id, **kwargs):  # noqa: E501
        """Get all the assemblies link to a run  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.assemblies_link_to_run_with_http_info(run_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str run_id: The run id you want the assemblies linked to (required)
        :return: list[Assembly]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['run_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method assemblies_link_to_run" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'run_id' is set
        if self.api_client.client_side_validation and ('run_id' not in params or
                                                       params['run_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `run_id` when calling `assemblies_link_to_run`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'run_id' in params:
            path_params['runId'] = params['run_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TdbApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/teamdbapi/v2.0/run/{runId}/assemblies', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Assembly]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def compare_assemblies(self, assembly_a_id, assembly_b_id, **kwargs):  # noqa: E501
        """[Command] Compare 2 assemblies  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.compare_assemblies(assembly_a_id, assembly_b_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str assembly_a_id: Assembly A unique Id (required)
        :param str assembly_b_id: Assembly B unique Id (required)
        :param CompareOptions compare_options: The import options. You can leave options empty.              By defaut, there will be no filter and no file export.              To apply a filter you have to fill ParametersSelectionFilters and ExcludeParametersInSelection.              To export a file you must fill OutPathFilePath. The file extension will be automatically replaced by the good one.              DiffGroup allows you to select the content of the diff file generated. You can choose A or B. By default B is selected.
        :return: list[CompareResultDetail]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.compare_assemblies_with_http_info(assembly_a_id, assembly_b_id, **kwargs)  # noqa: E501
        else:
            (data) = self.compare_assemblies_with_http_info(assembly_a_id, assembly_b_id, **kwargs)  # noqa: E501
            return data

    def compare_assemblies_with_http_info(self, assembly_a_id, assembly_b_id, **kwargs):  # noqa: E501
        """[Command] Compare 2 assemblies  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.compare_assemblies_with_http_info(assembly_a_id, assembly_b_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str assembly_a_id: Assembly A unique Id (required)
        :param str assembly_b_id: Assembly B unique Id (required)
        :param CompareOptions compare_options: The import options. You can leave options empty.              By defaut, there will be no filter and no file export.              To apply a filter you have to fill ParametersSelectionFilters and ExcludeParametersInSelection.              To export a file you must fill OutPathFilePath. The file extension will be automatically replaced by the good one.              DiffGroup allows you to select the content of the diff file generated. You can choose A or B. By default B is selected.
        :return: list[CompareResultDetail]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['assembly_a_id', 'assembly_b_id', 'compare_options']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method compare_assemblies" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'assembly_a_id' is set
        if self.api_client.client_side_validation and ('assembly_a_id' not in params or
                                                       params['assembly_a_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `assembly_a_id` when calling `compare_assemblies`")  # noqa: E501
        # verify the required parameter 'assembly_b_id' is set
        if self.api_client.client_side_validation and ('assembly_b_id' not in params or
                                                       params['assembly_b_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `assembly_b_id` when calling `compare_assemblies`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'assembly_a_id' in params:
            query_params.append(('assemblyAId', params['assembly_a_id']))  # noqa: E501
        if 'assembly_b_id' in params:
            query_params.append(('assemblyBId', params['assembly_b_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'compare_options' in params:
            body_params = params['compare_options']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json-patch+json', 'application/json', 'text/json', 'application/*+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TdbApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/teamdbapi/v2.0/assembly/compare', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[CompareResultDetail]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_assembly(self, assembly, **kwargs):  # noqa: E501
        """Create an assembly. The revisions list content will be ignored. You have to call AddRevisionsToAssembly to add revisions to an assembly.  # noqa: E501

        Set Assembly.Id empty (00000000-0000-0000-0000-000000000000) in order to create a new assembly.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_assembly(assembly, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Assembly assembly: The assembly to create. (required)
        :return: Assembly
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_assembly_with_http_info(assembly, **kwargs)  # noqa: E501
        else:
            (data) = self.create_assembly_with_http_info(assembly, **kwargs)  # noqa: E501
            return data

    def create_assembly_with_http_info(self, assembly, **kwargs):  # noqa: E501
        """Create an assembly. The revisions list content will be ignored. You have to call AddRevisionsToAssembly to add revisions to an assembly.  # noqa: E501

        Set Assembly.Id empty (00000000-0000-0000-0000-000000000000) in order to create a new assembly.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_assembly_with_http_info(assembly, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Assembly assembly: The assembly to create. (required)
        :return: Assembly
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['assembly']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_assembly" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'assembly' is set
        if self.api_client.client_side_validation and ('assembly' not in params or
                                                       params['assembly'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `assembly` when calling `create_assembly`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'assembly' in params:
            body_params = params['assembly']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json-patch+json', 'application/json', 'text/json', 'application/*+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TdbApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/teamdbapi/v2.0/assembly', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Assembly',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_assembly(self, assembly_id, **kwargs):  # noqa: E501
        """Delete an assembly or group revision corresponding to a given id.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_assembly(assembly_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str assembly_id: The assembly id or group revision you want to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_assembly_with_http_info(assembly_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_assembly_with_http_info(assembly_id, **kwargs)  # noqa: E501
            return data

    def delete_assembly_with_http_info(self, assembly_id, **kwargs):  # noqa: E501
        """Delete an assembly or group revision corresponding to a given id.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_assembly_with_http_info(assembly_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str assembly_id: The assembly id or group revision you want to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['assembly_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_assembly" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'assembly_id' is set
        if self.api_client.client_side_validation and ('assembly_id' not in params or
                                                       params['assembly_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `assembly_id` when calling `delete_assembly`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'assembly_id' in params:
            path_params['assemblyId'] = params['assembly_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TdbApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/teamdbapi/v2.0/assembly/{assemblyId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def duplicate_assembly(self, assembly_id, **kwargs):  # noqa: E501
        """Duplicate an existing assembly. Set the flag \"withLogs\" to True to duplicate Logs as well.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.duplicate_assembly(assembly_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str assembly_id: The assembly id to copy. (required)
        :param bool with_logs: Flag indicating if the logs should also be duplicated.
        :return: Assembly
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.duplicate_assembly_with_http_info(assembly_id, **kwargs)  # noqa: E501
        else:
            (data) = self.duplicate_assembly_with_http_info(assembly_id, **kwargs)  # noqa: E501
            return data

    def duplicate_assembly_with_http_info(self, assembly_id, **kwargs):  # noqa: E501
        """Duplicate an existing assembly. Set the flag \"withLogs\" to True to duplicate Logs as well.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.duplicate_assembly_with_http_info(assembly_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str assembly_id: The assembly id to copy. (required)
        :param bool with_logs: Flag indicating if the logs should also be duplicated.
        :return: Assembly
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['assembly_id', 'with_logs']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method duplicate_assembly" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'assembly_id' is set
        if self.api_client.client_side_validation and ('assembly_id' not in params or
                                                       params['assembly_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `assembly_id` when calling `duplicate_assembly`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'assembly_id' in params:
            path_params['assemblyId'] = params['assembly_id']  # noqa: E501

        query_params = []
        if 'with_logs' in params:
            query_params.append(('withLogs', params['with_logs']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TdbApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/teamdbapi/v2.0/assembly/{assemblyId}/duplicate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Assembly',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def export_assembly(self, assembly_id, output_file_path, **kwargs):  # noqa: E501
        """[Command] Export an assembly into a file  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.export_assembly(assembly_id, output_file_path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str assembly_id: The unique assembly id corresponding to the assembly to export. (required)
        :param str output_file_path: The path to the file to create. You have to provide the file extension for example : C:/path/MyFile.m (required)
        :return: bool
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.export_assembly_with_http_info(assembly_id, output_file_path, **kwargs)  # noqa: E501
        else:
            (data) = self.export_assembly_with_http_info(assembly_id, output_file_path, **kwargs)  # noqa: E501
            return data

    def export_assembly_with_http_info(self, assembly_id, output_file_path, **kwargs):  # noqa: E501
        """[Command] Export an assembly into a file  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.export_assembly_with_http_info(assembly_id, output_file_path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str assembly_id: The unique assembly id corresponding to the assembly to export. (required)
        :param str output_file_path: The path to the file to create. You have to provide the file extension for example : C:/path/MyFile.m (required)
        :return: bool
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['assembly_id', 'output_file_path']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method export_assembly" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'assembly_id' is set
        if self.api_client.client_side_validation and ('assembly_id' not in params or
                                                       params['assembly_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `assembly_id` when calling `export_assembly`")  # noqa: E501
        # verify the required parameter 'output_file_path' is set
        if self.api_client.client_side_validation and ('output_file_path' not in params or
                                                       params['output_file_path'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `output_file_path` when calling `export_assembly`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'assembly_id' in params:
            path_params['assemblyId'] = params['assembly_id']  # noqa: E501

        query_params = []
        if 'output_file_path' in params:
            query_params.append(('outputFilePath', params['output_file_path']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TdbApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/teamdbapi/v2.0/assembly/{assemblyId}/export', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='bool',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_assemblies(self, version_id, **kwargs):  # noqa: E501
        """Get all assemblies for a given version  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_assemblies(version_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str version_id: the version id to wich you want the assemblies. (required)
        :return: list[Assembly]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_assemblies_with_http_info(version_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_assemblies_with_http_info(version_id, **kwargs)  # noqa: E501
            return data

    def get_assemblies_with_http_info(self, version_id, **kwargs):  # noqa: E501
        """Get all assemblies for a given version  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_assemblies_with_http_info(version_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str version_id: the version id to wich you want the assemblies. (required)
        :return: list[Assembly]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['version_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_assemblies" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'version_id' is set
        if self.api_client.client_side_validation and ('version_id' not in params or
                                                       params['version_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `version_id` when calling `get_assemblies`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'version_id' in params:
            path_params['versionId'] = params['version_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TdbApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/teamdbapi/v2.0/version/{versionId}/assemblies', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Assembly]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_assembly(self, assembly_id, **kwargs):  # noqa: E501
        """Get an assembly for a given id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_assembly(assembly_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str assembly_id: the unique id of the assembly. (required)
        :return: Assembly
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_assembly_with_http_info(assembly_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_assembly_with_http_info(assembly_id, **kwargs)  # noqa: E501
            return data

    def get_assembly_with_http_info(self, assembly_id, **kwargs):  # noqa: E501
        """Get an assembly for a given id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_assembly_with_http_info(assembly_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str assembly_id: the unique id of the assembly. (required)
        :return: Assembly
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['assembly_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_assembly" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'assembly_id' is set
        if self.api_client.client_side_validation and ('assembly_id' not in params or
                                                       params['assembly_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `assembly_id` when calling `get_assembly`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'assembly_id' in params:
            path_params['assemblyId'] = params['assembly_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TdbApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/teamdbapi/v2.0/assembly/{assemblyId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Assembly',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_current_assembly(self, **kwargs):  # noqa: E501
        """Get the current selected assembly  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_current_assembly(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: Assembly
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_current_assembly_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_current_assembly_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_current_assembly_with_http_info(self, **kwargs):  # noqa: E501
        """Get the current selected assembly  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_current_assembly_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: Assembly
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_current_assembly" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TdbApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/teamdbapi/v2.0/assembly/current', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Assembly',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_group_revisions(self, assembly_id, **kwargs):  # noqa: E501
        """Get a list of group revisions (sub assemblies linked to a group) that are setted to a given assembly  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_group_revisions(assembly_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str assembly_id: The unique assembly id to which you search the linked group revisions (required)
        :return: list[Assembly]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_group_revisions_with_http_info(assembly_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_group_revisions_with_http_info(assembly_id, **kwargs)  # noqa: E501
            return data

    def get_group_revisions_with_http_info(self, assembly_id, **kwargs):  # noqa: E501
        """Get a list of group revisions (sub assemblies linked to a group) that are setted to a given assembly  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_group_revisions_with_http_info(assembly_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str assembly_id: The unique assembly id to which you search the linked group revisions (required)
        :return: list[Assembly]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['assembly_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_group_revisions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'assembly_id' is set
        if self.api_client.client_side_validation and ('assembly_id' not in params or
                                                       params['assembly_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `assembly_id` when calling `get_group_revisions`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'assembly_id' in params:
            path_params['assemblyId'] = params['assembly_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TdbApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/teamdbapi/v2.0/assembly/{assemblyId}/grouprevisions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Assembly]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_group_revisions_in_assembly_and_group(self, assembly_id, group_id, **kwargs):  # noqa: E501
        """Get a list of group revisions (sub assemblies linked to a group) setted to a given assembly and group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_group_revisions_in_assembly_and_group(assembly_id, group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str assembly_id: The unique assembly id to which you search the linked group revisions (required)
        :param str group_id: The unique group id where the group revision are linked (required)
        :return: list[Assembly]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_group_revisions_in_assembly_and_group_with_http_info(assembly_id, group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_group_revisions_in_assembly_and_group_with_http_info(assembly_id, group_id, **kwargs)  # noqa: E501
            return data

    def get_group_revisions_in_assembly_and_group_with_http_info(self, assembly_id, group_id, **kwargs):  # noqa: E501
        """Get a list of group revisions (sub assemblies linked to a group) setted to a given assembly and group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_group_revisions_in_assembly_and_group_with_http_info(assembly_id, group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str assembly_id: The unique assembly id to which you search the linked group revisions (required)
        :param str group_id: The unique group id where the group revision are linked (required)
        :return: list[Assembly]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['assembly_id', 'group_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_group_revisions_in_assembly_and_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'assembly_id' is set
        if self.api_client.client_side_validation and ('assembly_id' not in params or
                                                       params['assembly_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `assembly_id` when calling `get_group_revisions_in_assembly_and_group`")  # noqa: E501
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in params or
                                                       params['group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group_id` when calling `get_group_revisions_in_assembly_and_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'assembly_id' in params:
            path_params['assemblyId'] = params['assembly_id']  # noqa: E501
        if 'group_id' in params:
            path_params['groupId'] = params['group_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TdbApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/teamdbapi/v2.0/assembly/{assemblyId}/group/{groupId}/revisions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Assembly]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def import_assembly(self, **kwargs):  # noqa: E501
        """Create a new assembly by importing a definition file. This will also create the new revisions.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_assembly(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str version_id: The version id to which the new assembly will belong
        :param str assembly_name: The assembly name to create
        :param str revision_name: The default revision name used to create the new revisions
        :param str file_path: The file path containing the parameters. Example: C:/path/myFile.m
        :return: Assembly
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.import_assembly_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.import_assembly_with_http_info(**kwargs)  # noqa: E501
            return data

    def import_assembly_with_http_info(self, **kwargs):  # noqa: E501
        """Create a new assembly by importing a definition file. This will also create the new revisions.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_assembly_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str version_id: The version id to which the new assembly will belong
        :param str assembly_name: The assembly name to create
        :param str revision_name: The default revision name used to create the new revisions
        :param str file_path: The file path containing the parameters. Example: C:/path/myFile.m
        :return: Assembly
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['version_id', 'assembly_name', 'revision_name', 'file_path']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method import_assembly" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'version_id' in params:
            query_params.append(('versionId', params['version_id']))  # noqa: E501
        if 'assembly_name' in params:
            query_params.append(('assemblyName', params['assembly_name']))  # noqa: E501
        if 'revision_name' in params:
            query_params.append(('revisionName', params['revision_name']))  # noqa: E501
        if 'file_path' in params:
            query_params.append(('filePath', params['file_path']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TdbApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/teamdbapi/v2.0/assembly/import', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Assembly',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def link_run_to_assembly(self, run_id, assembly_id, **kwargs):  # noqa: E501
        """[Command] Link a run to an assembly  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.link_run_to_assembly(run_id, assembly_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str run_id: The Id of the Run to link (required)
        :param str assembly_id: The Id of the Assembly to link (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.link_run_to_assembly_with_http_info(run_id, assembly_id, **kwargs)  # noqa: E501
        else:
            (data) = self.link_run_to_assembly_with_http_info(run_id, assembly_id, **kwargs)  # noqa: E501
            return data

    def link_run_to_assembly_with_http_info(self, run_id, assembly_id, **kwargs):  # noqa: E501
        """[Command] Link a run to an assembly  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.link_run_to_assembly_with_http_info(run_id, assembly_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str run_id: The Id of the Run to link (required)
        :param str assembly_id: The Id of the Assembly to link (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['run_id', 'assembly_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method link_run_to_assembly" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'run_id' is set
        if self.api_client.client_side_validation and ('run_id' not in params or
                                                       params['run_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `run_id` when calling `link_run_to_assembly`")  # noqa: E501
        # verify the required parameter 'assembly_id' is set
        if self.api_client.client_side_validation and ('assembly_id' not in params or
                                                       params['assembly_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `assembly_id` when calling `link_run_to_assembly`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'run_id' in params:
            path_params['runId'] = params['run_id']  # noqa: E501

        query_params = []
        if 'assembly_id' in params:
            query_params.append(('assemblyId', params['assembly_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TdbApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/teamdbapi/v2.0/run/{runId}/linkassembly', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def lock_assembly(self, assembly_id, locked, **kwargs):  # noqa: E501
        """[Command] Lock an assembly.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.lock_assembly(assembly_id, locked, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str assembly_id: The assembly id to edit. (required)
        :param bool locked: True to lock the assembly, False to unlock (required)
        :return: Assembly
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.lock_assembly_with_http_info(assembly_id, locked, **kwargs)  # noqa: E501
        else:
            (data) = self.lock_assembly_with_http_info(assembly_id, locked, **kwargs)  # noqa: E501
            return data

    def lock_assembly_with_http_info(self, assembly_id, locked, **kwargs):  # noqa: E501
        """[Command] Lock an assembly.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.lock_assembly_with_http_info(assembly_id, locked, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str assembly_id: The assembly id to edit. (required)
        :param bool locked: True to lock the assembly, False to unlock (required)
        :return: Assembly
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['assembly_id', 'locked']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method lock_assembly" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'assembly_id' is set
        if self.api_client.client_side_validation and ('assembly_id' not in params or
                                                       params['assembly_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `assembly_id` when calling `lock_assembly`")  # noqa: E501
        # verify the required parameter 'locked' is set
        if self.api_client.client_side_validation and ('locked' not in params or
                                                       params['locked'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `locked` when calling `lock_assembly`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'assembly_id' in params:
            path_params['assemblyId'] = params['assembly_id']  # noqa: E501

        query_params = []
        if 'locked' in params:
            query_params.append(('locked', params['locked']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TdbApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/teamdbapi/v2.0/assembly/{assemblyId}/lock', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Assembly',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_revisions_from_assembly(self, assembly_id, revision_ids, **kwargs):  # noqa: E501
        """[Command] Remove a list of revisions from an assembly.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_revisions_from_assembly(assembly_id, revision_ids, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str assembly_id: The assembly id to which you want to remove the revisions (required)
        :param list[str] revision_ids: A list of unique revision ids to remove from the assembly (required)
        :return: Assembly
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.remove_revisions_from_assembly_with_http_info(assembly_id, revision_ids, **kwargs)  # noqa: E501
        else:
            (data) = self.remove_revisions_from_assembly_with_http_info(assembly_id, revision_ids, **kwargs)  # noqa: E501
            return data

    def remove_revisions_from_assembly_with_http_info(self, assembly_id, revision_ids, **kwargs):  # noqa: E501
        """[Command] Remove a list of revisions from an assembly.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_revisions_from_assembly_with_http_info(assembly_id, revision_ids, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str assembly_id: The assembly id to which you want to remove the revisions (required)
        :param list[str] revision_ids: A list of unique revision ids to remove from the assembly (required)
        :return: Assembly
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['assembly_id', 'revision_ids']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_revisions_from_assembly" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'assembly_id' is set
        if self.api_client.client_side_validation and ('assembly_id' not in params or
                                                       params['assembly_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `assembly_id` when calling `remove_revisions_from_assembly`")  # noqa: E501
        # verify the required parameter 'revision_ids' is set
        if self.api_client.client_side_validation and ('revision_ids' not in params or
                                                       params['revision_ids'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `revision_ids` when calling `remove_revisions_from_assembly`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'assembly_id' in params:
            path_params['assemblyId'] = params['assembly_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'revision_ids' in params:
            body_params = params['revision_ids']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json-patch+json', 'application/json', 'text/json', 'application/*+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TdbApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/teamdbapi/v2.0/assembly/{assemblyId}/removerevisions', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Assembly',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_tag(self, assembly_id, tag, **kwargs):  # noqa: E501
        """[Command] Remove a search tag from an existing assembly  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_tag(assembly_id, tag, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str assembly_id: The assembly unique id (required)
        :param str tag: The tag to remove from the assembly (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.remove_tag_with_http_info(assembly_id, tag, **kwargs)  # noqa: E501
        else:
            (data) = self.remove_tag_with_http_info(assembly_id, tag, **kwargs)  # noqa: E501
            return data

    def remove_tag_with_http_info(self, assembly_id, tag, **kwargs):  # noqa: E501
        """[Command] Remove a search tag from an existing assembly  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_tag_with_http_info(assembly_id, tag, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str assembly_id: The assembly unique id (required)
        :param str tag: The tag to remove from the assembly (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['assembly_id', 'tag']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_tag" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'assembly_id' is set
        if self.api_client.client_side_validation and ('assembly_id' not in params or
                                                       params['assembly_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `assembly_id` when calling `remove_tag`")  # noqa: E501
        # verify the required parameter 'tag' is set
        if self.api_client.client_side_validation and ('tag' not in params or
                                                       params['tag'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `tag` when calling `remove_tag`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'assembly_id' in params:
            path_params['assemblyId'] = params['assembly_id']  # noqa: E501

        query_params = []
        if 'tag' in params:
            query_params.append(('tag', params['tag']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TdbApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/teamdbapi/v2.0/assembly/{assemblyId}/removetag', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def select_current_assembly(self, assembly_id, **kwargs):  # noqa: E501
        """[Command] Set the current selected assembly  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.select_current_assembly(assembly_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str assembly_id: The assembly id to select (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.select_current_assembly_with_http_info(assembly_id, **kwargs)  # noqa: E501
        else:
            (data) = self.select_current_assembly_with_http_info(assembly_id, **kwargs)  # noqa: E501
            return data

    def select_current_assembly_with_http_info(self, assembly_id, **kwargs):  # noqa: E501
        """[Command] Set the current selected assembly  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.select_current_assembly_with_http_info(assembly_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str assembly_id: The assembly id to select (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['assembly_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method select_current_assembly" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'assembly_id' is set
        if self.api_client.client_side_validation and ('assembly_id' not in params or
                                                       params['assembly_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `assembly_id` when calling `select_current_assembly`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'assembly_id' in params:
            query_params.append(('assemblyId', params['assembly_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TdbApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/teamdbapi/v2.0/assembly/current', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def unlink_assembly(self, run_id, assembly_id, **kwargs):  # noqa: E501
        """[Command] Remove an assembly from a run  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unlink_assembly(run_id, assembly_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str run_id: The Id of the Run to unlink (required)
        :param str assembly_id: The Id of the Assembly to unlink (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.unlink_assembly_with_http_info(run_id, assembly_id, **kwargs)  # noqa: E501
        else:
            (data) = self.unlink_assembly_with_http_info(run_id, assembly_id, **kwargs)  # noqa: E501
            return data

    def unlink_assembly_with_http_info(self, run_id, assembly_id, **kwargs):  # noqa: E501
        """[Command] Remove an assembly from a run  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unlink_assembly_with_http_info(run_id, assembly_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str run_id: The Id of the Run to unlink (required)
        :param str assembly_id: The Id of the Assembly to unlink (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['run_id', 'assembly_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method unlink_assembly" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'run_id' is set
        if self.api_client.client_side_validation and ('run_id' not in params or
                                                       params['run_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `run_id` when calling `unlink_assembly`")  # noqa: E501
        # verify the required parameter 'assembly_id' is set
        if self.api_client.client_side_validation and ('assembly_id' not in params or
                                                       params['assembly_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `assembly_id` when calling `unlink_assembly`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'run_id' in params:
            path_params['runId'] = params['run_id']  # noqa: E501

        query_params = []
        if 'assembly_id' in params:
            query_params.append(('assemblyId', params['assembly_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TdbApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/teamdbapi/v2.0/run/{runId}/unlinkassembly', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_assembly(self, assembly_id, assembly, **kwargs):  # noqa: E501
        """Update an assembly. The revisions list content will be ignored. You have to call AddRevisionsToAssembly to add revisions to an assembly.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_assembly(assembly_id, assembly, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str assembly_id: The assembly id corresponding to the assembly you want to update. (required)
        :param Assembly assembly: The assembly to update. (required)
        :return: Assembly
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_assembly_with_http_info(assembly_id, assembly, **kwargs)  # noqa: E501
        else:
            (data) = self.update_assembly_with_http_info(assembly_id, assembly, **kwargs)  # noqa: E501
            return data

    def update_assembly_with_http_info(self, assembly_id, assembly, **kwargs):  # noqa: E501
        """Update an assembly. The revisions list content will be ignored. You have to call AddRevisionsToAssembly to add revisions to an assembly.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_assembly_with_http_info(assembly_id, assembly, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str assembly_id: The assembly id corresponding to the assembly you want to update. (required)
        :param Assembly assembly: The assembly to update. (required)
        :return: Assembly
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['assembly_id', 'assembly']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_assembly" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'assembly_id' is set
        if self.api_client.client_side_validation and ('assembly_id' not in params or
                                                       params['assembly_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `assembly_id` when calling `update_assembly`")  # noqa: E501
        # verify the required parameter 'assembly' is set
        if self.api_client.client_side_validation and ('assembly' not in params or
                                                       params['assembly'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `assembly` when calling `update_assembly`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'assembly_id' in params:
            path_params['assemblyId'] = params['assembly_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'assembly' in params:
            body_params = params['assembly']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json-patch+json', 'application/json', 'text/json', 'application/*+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TdbApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/teamdbapi/v2.0/assembly/{assemblyId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Assembly',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
