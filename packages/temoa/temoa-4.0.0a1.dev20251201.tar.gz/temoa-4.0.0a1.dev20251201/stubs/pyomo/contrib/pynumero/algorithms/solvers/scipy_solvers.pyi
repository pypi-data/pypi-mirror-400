import types
from collections import namedtuple as namedtuple

from _typeshed import Incomplete
from pyomo.common.config import ConfigBlock as ConfigBlock
from pyomo.common.config import ConfigValue as ConfigValue
from pyomo.common.config import In as In
from pyomo.common.dependencies import attempt_import as attempt_import
from pyomo.common.dependencies import numpy_available as numpy_available
from pyomo.common.dependencies import scipy_available as scipy_available
from pyomo.common.modeling import unique_component_name as unique_component_name
from pyomo.common.timing import HierarchicalTimer as HierarchicalTimer
from pyomo.contrib.pynumero.algorithms.solvers.square_solver_base import (
    DenseSquareNlpSolver as DenseSquareNlpSolver,
)
from pyomo.contrib.pynumero.algorithms.solvers.square_solver_base import (
    ScalarDenseSquareNlpSolver as ScalarDenseSquareNlpSolver,
)
from pyomo.core.base.objective import Objective as Objective
from pyomo.opt import SolverResults as SolverResults
from pyomo.opt import TerminationCondition as TerminationCondition

pyomo_nlp: Incomplete
_: Incomplete

class FsolveNlpSolver(DenseSquareNlpSolver):
    OPTIONS: Incomplete
    def solve(self, x0=None): ...

class RootNlpSolver(DenseSquareNlpSolver):
    OPTIONS: Incomplete
    def solve(self, x0=None): ...

class NewtonNlpSolver(ScalarDenseSquareNlpSolver):
    OPTIONS: Incomplete
    def solve(self, x0=None): ...

class SecantNewtonNlpSolver(NewtonNlpSolver):
    OPTIONS: Incomplete
    converged_with_secant: Incomplete
    def __init__(self, nlp, timer=None, options=None) -> None: ...
    def solve(self, x0=None): ...

class PyomoScipySolver:
    options: Incomplete
    def __init__(self, options=None) -> None: ...
    def available(self, exception_flag: bool = False): ...
    def license_is_valid(self): ...
    def version(self): ...
    def set_options(self, options) -> None: ...
    def solve(self, model, timer=None, tee: bool = False): ...
    def get_nlp(self): ...
    def create_nlp_solver(self, **kwds) -> None: ...
    def get_pyomo_results(self, model, scipy_results) -> None: ...
    def __enter__(self): ...
    def __exit__(
        self,
        t: type[BaseException] | None,
        v: BaseException | None,
        traceback: types.TracebackType | None,
    ) -> None: ...

class PyomoFsolveSolver(PyomoScipySolver):
    def create_nlp_solver(self, **kwds): ...
    def get_pyomo_results(self, model, scipy_results): ...

class PyomoRootSolver(PyomoScipySolver):
    def create_nlp_solver(self, **kwds): ...
    def get_pyomo_results(self, model, scipy_results): ...

class PyomoNewtonSolver(PyomoScipySolver):
    def create_nlp_solver(self, **kwds): ...
    def get_pyomo_results(self, model, scipy_results): ...

class PyomoSecantNewtonSolver(PyomoNewtonSolver):
    def converged_with_secant(self): ...
    def create_nlp_solver(self, **kwds): ...
