# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.pydantic_utilities import parse_obj_as
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..errors.bad_request_error import BadRequestError
from ..errors.internal_server_error import InternalServerError
from ..types.add_cost_line_batch_response import AddCostLineBatchResponse
from ..types.bind_cost_line_response import BindCostLineResponse
from ..types.cost_line_cadence import CostLineCadence
from ..types.cost_line_type import CostLineType
from ..types.create_cost_line_request import CreateCostLineRequest
from ..types.delete_cost_line_response import DeleteCostLineResponse
from ..types.error_schema import ErrorSchema
from ..types.generic_id import GenericId
from ..types.list_costs_normalized_response import ListCostsNormalizedResponse
from ..types.unbind_cost_line_response import UnbindCostLineResponse
from ..types.update_cost_line_response import UpdateCostLineResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawCostsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def add_cost_line_batch(
        self,
        *,
        requests: typing.Sequence[CreateCostLineRequest],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[AddCostLineBatchResponse]:
        """
        Parameters
        ----------
        requests : typing.Sequence[CreateCostLineRequest]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[AddCostLineBatchResponse]
            Batch cost lines added successfully
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v2/costs/batch",
            method="POST",
            json={
                "requests": convert_and_respect_annotation_metadata(
                    object_=requests, annotation=typing.Sequence[CreateCostLineRequest], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AddCostLineBatchResponse,
                    parse_obj_as(
                        type_=AddCostLineBatchResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorSchema,
                        parse_obj_as(
                            type_=ErrorSchema,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorSchema,
                        parse_obj_as(
                            type_=ErrorSchema,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_costs(
        self,
        *,
        period_start_at: str,
        period_end_at: str,
        from_asset_ids: typing.Optional[str] = None,
        max_depth: typing.Optional[str] = None,
        category_path: typing.Optional[str] = None,
        cadence: typing.Optional[CostLineCadence] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ListCostsNormalizedResponse]:
        """
        Parameters
        ----------
        period_start_at : str

        period_end_at : str

        from_asset_ids : typing.Optional[str]

        max_depth : typing.Optional[str]

        category_path : typing.Optional[str]

        cadence : typing.Optional[CostLineCadence]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ListCostsNormalizedResponse]
            Normalized costs returned successfully
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v2/costs/normalized",
            method="GET",
            params={
                "fromAssetIds": from_asset_ids,
                "maxDepth": max_depth,
                "periodStartAt": period_start_at,
                "periodEndAt": period_end_at,
                "categoryPath": category_path,
                "cadence": cadence,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListCostsNormalizedResponse,
                    parse_obj_as(
                        type_=ListCostsNormalizedResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorSchema,
                        parse_obj_as(
                            type_=ErrorSchema,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorSchema,
                        parse_obj_as(
                            type_=ErrorSchema,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete_cost_line(
        self, *, id: GenericId, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[DeleteCostLineResponse]:
        """
        Parameters
        ----------
        id : GenericId
            A unique identifier for an asset. Can be an AssetId or an ExternalId. ExternalIds are denoted by the "eid:" prefix.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DeleteCostLineResponse]
            Costs line deleted successfully
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v2/costs/line/:id",
            method="DELETE",
            params={
                "id": id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeleteCostLineResponse,
                    parse_obj_as(
                        type_=DeleteCostLineResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorSchema,
                        parse_obj_as(
                            type_=ErrorSchema,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorSchema,
                        parse_obj_as(
                            type_=ErrorSchema,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def update_cost_line(
        self,
        *,
        id: GenericId,
        name: typing.Optional[str] = OMIT,
        cadence: typing.Optional[CostLineCadence] = OMIT,
        type: typing.Optional[CostLineType] = OMIT,
        period_start_at: typing.Optional[float] = OMIT,
        period_end_at: typing.Optional[float] = OMIT,
        value: typing.Optional[float] = OMIT,
        notes: typing.Optional[str] = OMIT,
        currency: typing.Optional[str] = OMIT,
        category: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[UpdateCostLineResponse]:
        """
        Parameters
        ----------
        id : GenericId
            A unique identifier for an asset. Can be an AssetId or an ExternalId. ExternalIds are denoted by the "eid:" prefix.

        name : typing.Optional[str]

        cadence : typing.Optional[CostLineCadence]

        type : typing.Optional[CostLineType]

        period_start_at : typing.Optional[float]

        period_end_at : typing.Optional[float]

        value : typing.Optional[float]

        notes : typing.Optional[str]

        currency : typing.Optional[str]

        category : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[UpdateCostLineResponse]
            Cost line updated successfully
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v2/costs/line/:id",
            method="PATCH",
            params={
                "id": id,
            },
            json={
                "name": name,
                "cadence": cadence,
                "type": type,
                "periodStartAt": period_start_at,
                "periodEndAt": period_end_at,
                "value": value,
                "notes": notes,
                "currency": currency,
                "category": category,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    UpdateCostLineResponse,
                    parse_obj_as(
                        type_=UpdateCostLineResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorSchema,
                        parse_obj_as(
                            type_=ErrorSchema,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorSchema,
                        parse_obj_as(
                            type_=ErrorSchema,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def bind_cost_line(
        self, *, id: str, asset_ids: typing.Sequence[str], request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[BindCostLineResponse]:
        """
        Parameters
        ----------
        id : str

        asset_ids : typing.Sequence[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[BindCostLineResponse]
            Cost line bound successfully
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v2/costs/line/:id/bind",
            method="POST",
            params={
                "id": id,
            },
            json={
                "assetIds": asset_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BindCostLineResponse,
                    parse_obj_as(
                        type_=BindCostLineResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorSchema,
                        parse_obj_as(
                            type_=ErrorSchema,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorSchema,
                        parse_obj_as(
                            type_=ErrorSchema,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def unbind_cost_line(
        self, *, id: str, asset_ids: typing.Sequence[str], request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[UnbindCostLineResponse]:
        """
        Parameters
        ----------
        id : str

        asset_ids : typing.Sequence[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[UnbindCostLineResponse]
            Cost line bound successfully
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v2/costs/line/:id/unbind",
            method="POST",
            params={
                "id": id,
            },
            json={
                "assetIds": asset_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    UnbindCostLineResponse,
                    parse_obj_as(
                        type_=UnbindCostLineResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorSchema,
                        parse_obj_as(
                            type_=ErrorSchema,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorSchema,
                        parse_obj_as(
                            type_=ErrorSchema,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawCostsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def add_cost_line_batch(
        self,
        *,
        requests: typing.Sequence[CreateCostLineRequest],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[AddCostLineBatchResponse]:
        """
        Parameters
        ----------
        requests : typing.Sequence[CreateCostLineRequest]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[AddCostLineBatchResponse]
            Batch cost lines added successfully
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v2/costs/batch",
            method="POST",
            json={
                "requests": convert_and_respect_annotation_metadata(
                    object_=requests, annotation=typing.Sequence[CreateCostLineRequest], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AddCostLineBatchResponse,
                    parse_obj_as(
                        type_=AddCostLineBatchResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorSchema,
                        parse_obj_as(
                            type_=ErrorSchema,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorSchema,
                        parse_obj_as(
                            type_=ErrorSchema,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_costs(
        self,
        *,
        period_start_at: str,
        period_end_at: str,
        from_asset_ids: typing.Optional[str] = None,
        max_depth: typing.Optional[str] = None,
        category_path: typing.Optional[str] = None,
        cadence: typing.Optional[CostLineCadence] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ListCostsNormalizedResponse]:
        """
        Parameters
        ----------
        period_start_at : str

        period_end_at : str

        from_asset_ids : typing.Optional[str]

        max_depth : typing.Optional[str]

        category_path : typing.Optional[str]

        cadence : typing.Optional[CostLineCadence]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ListCostsNormalizedResponse]
            Normalized costs returned successfully
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v2/costs/normalized",
            method="GET",
            params={
                "fromAssetIds": from_asset_ids,
                "maxDepth": max_depth,
                "periodStartAt": period_start_at,
                "periodEndAt": period_end_at,
                "categoryPath": category_path,
                "cadence": cadence,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListCostsNormalizedResponse,
                    parse_obj_as(
                        type_=ListCostsNormalizedResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorSchema,
                        parse_obj_as(
                            type_=ErrorSchema,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorSchema,
                        parse_obj_as(
                            type_=ErrorSchema,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete_cost_line(
        self, *, id: GenericId, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[DeleteCostLineResponse]:
        """
        Parameters
        ----------
        id : GenericId
            A unique identifier for an asset. Can be an AssetId or an ExternalId. ExternalIds are denoted by the "eid:" prefix.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DeleteCostLineResponse]
            Costs line deleted successfully
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v2/costs/line/:id",
            method="DELETE",
            params={
                "id": id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeleteCostLineResponse,
                    parse_obj_as(
                        type_=DeleteCostLineResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorSchema,
                        parse_obj_as(
                            type_=ErrorSchema,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorSchema,
                        parse_obj_as(
                            type_=ErrorSchema,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def update_cost_line(
        self,
        *,
        id: GenericId,
        name: typing.Optional[str] = OMIT,
        cadence: typing.Optional[CostLineCadence] = OMIT,
        type: typing.Optional[CostLineType] = OMIT,
        period_start_at: typing.Optional[float] = OMIT,
        period_end_at: typing.Optional[float] = OMIT,
        value: typing.Optional[float] = OMIT,
        notes: typing.Optional[str] = OMIT,
        currency: typing.Optional[str] = OMIT,
        category: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[UpdateCostLineResponse]:
        """
        Parameters
        ----------
        id : GenericId
            A unique identifier for an asset. Can be an AssetId or an ExternalId. ExternalIds are denoted by the "eid:" prefix.

        name : typing.Optional[str]

        cadence : typing.Optional[CostLineCadence]

        type : typing.Optional[CostLineType]

        period_start_at : typing.Optional[float]

        period_end_at : typing.Optional[float]

        value : typing.Optional[float]

        notes : typing.Optional[str]

        currency : typing.Optional[str]

        category : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[UpdateCostLineResponse]
            Cost line updated successfully
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v2/costs/line/:id",
            method="PATCH",
            params={
                "id": id,
            },
            json={
                "name": name,
                "cadence": cadence,
                "type": type,
                "periodStartAt": period_start_at,
                "periodEndAt": period_end_at,
                "value": value,
                "notes": notes,
                "currency": currency,
                "category": category,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    UpdateCostLineResponse,
                    parse_obj_as(
                        type_=UpdateCostLineResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorSchema,
                        parse_obj_as(
                            type_=ErrorSchema,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorSchema,
                        parse_obj_as(
                            type_=ErrorSchema,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def bind_cost_line(
        self, *, id: str, asset_ids: typing.Sequence[str], request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[BindCostLineResponse]:
        """
        Parameters
        ----------
        id : str

        asset_ids : typing.Sequence[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[BindCostLineResponse]
            Cost line bound successfully
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v2/costs/line/:id/bind",
            method="POST",
            params={
                "id": id,
            },
            json={
                "assetIds": asset_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BindCostLineResponse,
                    parse_obj_as(
                        type_=BindCostLineResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorSchema,
                        parse_obj_as(
                            type_=ErrorSchema,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorSchema,
                        parse_obj_as(
                            type_=ErrorSchema,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def unbind_cost_line(
        self, *, id: str, asset_ids: typing.Sequence[str], request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[UnbindCostLineResponse]:
        """
        Parameters
        ----------
        id : str

        asset_ids : typing.Sequence[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[UnbindCostLineResponse]
            Cost line bound successfully
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v2/costs/line/:id/unbind",
            method="POST",
            params={
                "id": id,
            },
            json={
                "assetIds": asset_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    UnbindCostLineResponse,
                    parse_obj_as(
                        type_=UnbindCostLineResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorSchema,
                        parse_obj_as(
                            type_=ErrorSchema,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorSchema,
                        parse_obj_as(
                            type_=ErrorSchema,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
