# This file was auto-generated by Fern from our API Definition.

import typing

from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.request_options import RequestOptions
from ...types.context_detail import ContextDetail
from ...types.context_list_response import ContextListResponse
from ...types.create_context_response import CreateContextResponse
from ...types.delete_context_response import DeleteContextResponse
from ...types.update_context_response import UpdateContextResponse
from .raw_client import AsyncRawObjectsClient, RawObjectsClient
from .types.create_context_request_on_schema_mismatch import CreateContextRequestOnSchemaMismatch
from .types.create_context_request_schema_item import CreateContextRequestSchemaItem
from .types.update_context_request_on_schema_mismatch import UpdateContextRequestOnSchemaMismatch
from .types.update_context_request_schema_item import UpdateContextRequestSchemaItem

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class ObjectsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._raw_client = RawObjectsClient(client_wrapper=client_wrapper)

    @property
    def with_raw_response(self) -> RawObjectsClient:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        RawObjectsClient
        """
        return self._raw_client

    def list(self, *, request_options: typing.Optional[RequestOptions] = None) -> ContextListResponse:
        """
        Retrieve all contexts for the authenticated user.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ContextListResponse
            Success

        Examples
        --------
        from rulebricks import Rulebricks

        client = Rulebricks(
            api_key="YOUR_API_KEY",
        )
        client.contexts.objects.list()
        """
        _response = self._raw_client.list(request_options=request_options)
        return _response.data

    def create(
        self,
        *,
        name: str,
        schema: typing.Sequence[CreateContextRequestSchemaItem],
        identity_fact: str,
        slug: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        auto_execute_decisions: typing.Optional[bool] = OMIT,
        ttl_seconds: typing.Optional[int] = OMIT,
        history_limit: typing.Optional[int] = OMIT,
        on_schema_mismatch: typing.Optional[CreateContextRequestOnSchemaMismatch] = OMIT,
        webhook_on_solve: typing.Optional[str] = OMIT,
        webhook_on_expire: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CreateContextResponse:
        """
        Create a new context for the authenticated user.

        Parameters
        ----------
        name : str
            The name of the context.

        schema : typing.Sequence[CreateContextRequestSchemaItem]
            Initial schema fields for the context. At least one field must be defined.

        identity_fact : str
            The field key to use as the unique identifier for instances. Must be a key from the schema.

        slug : typing.Optional[str]
            Optional custom slug. Auto-generated if not provided.

        description : typing.Optional[str]
            The description of the context.

        auto_execute_decisions : typing.Optional[bool]
            When true (default), bound rules and flows automatically execute when their inputs are satisfied.

        ttl_seconds : typing.Optional[int]
            Time-to-live in seconds for live context instances. Instances expire after this duration.

        history_limit : typing.Optional[int]
            Maximum number of history entries to retain per field.

        on_schema_mismatch : typing.Optional[CreateContextRequestOnSchemaMismatch]
            How to handle fields that don't match the schema.

        webhook_on_solve : typing.Optional[str]
            Webhook URL called when a rule or flow successfully solves.

        webhook_on_expire : typing.Optional[str]
            Webhook URL called when a live context expires due to TTL.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CreateContextResponse
            Context created successfully

        Examples
        --------
        from rulebricks import Rulebricks
        from rulebricks.contexts.objects import CreateContextRequestSchemaItem

        client = Rulebricks(
            api_key="YOUR_API_KEY",
        )
        client.contexts.objects.create(
            name="Customer",
            description="Represents a customer in the system",
            schema=[
                CreateContextRequestSchemaItem(
                    key="email",
                    name="Email",
                    type="string",
                ),
                CreateContextRequestSchemaItem(
                    key="age",
                    name="Age",
                    type="number",
                ),
            ],
            identity_fact="email",
        )
        """
        _response = self._raw_client.create(
            name=name,
            schema=schema,
            identity_fact=identity_fact,
            slug=slug,
            description=description,
            auto_execute_decisions=auto_execute_decisions,
            ttl_seconds=ttl_seconds,
            history_limit=history_limit,
            on_schema_mismatch=on_schema_mismatch,
            webhook_on_solve=webhook_on_solve,
            webhook_on_expire=webhook_on_expire,
            request_options=request_options,
        )
        return _response.data

    def get(self, id: str, *, request_options: typing.Optional[RequestOptions] = None) -> ContextDetail:
        """
        Retrieve a specific context by its ID.

        Parameters
        ----------
        id : str
            The unique identifier for the context.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ContextDetail
            Success

        Examples
        --------
        from rulebricks import Rulebricks

        client = Rulebricks(
            api_key="YOUR_API_KEY",
        )
        client.contexts.objects.get(
            id="a1b2c3d4-e5f6-7890-abcd-ef1234567890",
        )
        """
        _response = self._raw_client.get(id, request_options=request_options)
        return _response.data

    def update(
        self,
        id: str,
        *,
        name: typing.Optional[str] = OMIT,
        slug: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        schema: typing.Optional[typing.Sequence[UpdateContextRequestSchemaItem]] = OMIT,
        auto_execute_decisions: typing.Optional[bool] = OMIT,
        ttl_seconds: typing.Optional[int] = OMIT,
        history_limit: typing.Optional[int] = OMIT,
        on_schema_mismatch: typing.Optional[UpdateContextRequestOnSchemaMismatch] = OMIT,
        webhook_on_solve: typing.Optional[str] = OMIT,
        webhook_on_expire: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> UpdateContextResponse:
        """
        Update an existing context's properties and schema.

        Parameters
        ----------
        id : str
            The unique identifier for the context.

        name : typing.Optional[str]
            The name of the context.

        slug : typing.Optional[str]
            The slug of the context.

        description : typing.Optional[str]
            The description of the context.

        schema : typing.Optional[typing.Sequence[UpdateContextRequestSchemaItem]]
            Updated schema fields for the context.

        auto_execute_decisions : typing.Optional[bool]
            When true, bound rules and flows automatically execute when their inputs are satisfied.

        ttl_seconds : typing.Optional[int]
            Time-to-live in seconds for live context instances. Instances expire after this duration.

        history_limit : typing.Optional[int]
            Maximum number of history entries to retain per field.

        on_schema_mismatch : typing.Optional[UpdateContextRequestOnSchemaMismatch]
            How to handle fields that don't match the schema.

        webhook_on_solve : typing.Optional[str]
            Webhook URL called when a rule or flow successfully solves.

        webhook_on_expire : typing.Optional[str]
            Webhook URL called when a live context expires due to TTL.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UpdateContextResponse
            Context updated successfully

        Examples
        --------
        from rulebricks import Rulebricks

        client = Rulebricks(
            api_key="YOUR_API_KEY",
        )
        client.contexts.objects.update(
            id="a1b2c3d4-e5f6-7890-abcd-ef1234567890",
            name="Updated Customer",
            description="Updated description for premium customers",
        )
        """
        _response = self._raw_client.update(
            id,
            name=name,
            slug=slug,
            description=description,
            schema=schema,
            auto_execute_decisions=auto_execute_decisions,
            ttl_seconds=ttl_seconds,
            history_limit=history_limit,
            on_schema_mismatch=on_schema_mismatch,
            webhook_on_solve=webhook_on_solve,
            webhook_on_expire=webhook_on_expire,
            request_options=request_options,
        )
        return _response.data

    def delete(self, id: str, *, request_options: typing.Optional[RequestOptions] = None) -> DeleteContextResponse:
        """
        Delete a specific context and all its instances.

        Parameters
        ----------
        id : str
            The unique identifier for the context.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        DeleteContextResponse
            Context deleted successfully

        Examples
        --------
        from rulebricks import Rulebricks

        client = Rulebricks(
            api_key="YOUR_API_KEY",
        )
        client.contexts.objects.delete(
            id="a1b2c3d4-e5f6-7890-abcd-ef1234567890",
        )
        """
        _response = self._raw_client.delete(id, request_options=request_options)
        return _response.data


class AsyncObjectsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._raw_client = AsyncRawObjectsClient(client_wrapper=client_wrapper)

    @property
    def with_raw_response(self) -> AsyncRawObjectsClient:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        AsyncRawObjectsClient
        """
        return self._raw_client

    async def list(self, *, request_options: typing.Optional[RequestOptions] = None) -> ContextListResponse:
        """
        Retrieve all contexts for the authenticated user.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ContextListResponse
            Success

        Examples
        --------
        import asyncio

        from rulebricks import AsyncRulebricks

        client = AsyncRulebricks(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.contexts.objects.list()


        asyncio.run(main())
        """
        _response = await self._raw_client.list(request_options=request_options)
        return _response.data

    async def create(
        self,
        *,
        name: str,
        schema: typing.Sequence[CreateContextRequestSchemaItem],
        identity_fact: str,
        slug: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        auto_execute_decisions: typing.Optional[bool] = OMIT,
        ttl_seconds: typing.Optional[int] = OMIT,
        history_limit: typing.Optional[int] = OMIT,
        on_schema_mismatch: typing.Optional[CreateContextRequestOnSchemaMismatch] = OMIT,
        webhook_on_solve: typing.Optional[str] = OMIT,
        webhook_on_expire: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CreateContextResponse:
        """
        Create a new context for the authenticated user.

        Parameters
        ----------
        name : str
            The name of the context.

        schema : typing.Sequence[CreateContextRequestSchemaItem]
            Initial schema fields for the context. At least one field must be defined.

        identity_fact : str
            The field key to use as the unique identifier for instances. Must be a key from the schema.

        slug : typing.Optional[str]
            Optional custom slug. Auto-generated if not provided.

        description : typing.Optional[str]
            The description of the context.

        auto_execute_decisions : typing.Optional[bool]
            When true (default), bound rules and flows automatically execute when their inputs are satisfied.

        ttl_seconds : typing.Optional[int]
            Time-to-live in seconds for live context instances. Instances expire after this duration.

        history_limit : typing.Optional[int]
            Maximum number of history entries to retain per field.

        on_schema_mismatch : typing.Optional[CreateContextRequestOnSchemaMismatch]
            How to handle fields that don't match the schema.

        webhook_on_solve : typing.Optional[str]
            Webhook URL called when a rule or flow successfully solves.

        webhook_on_expire : typing.Optional[str]
            Webhook URL called when a live context expires due to TTL.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CreateContextResponse
            Context created successfully

        Examples
        --------
        import asyncio

        from rulebricks import AsyncRulebricks
        from rulebricks.contexts.objects import CreateContextRequestSchemaItem

        client = AsyncRulebricks(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.contexts.objects.create(
                name="Customer",
                description="Represents a customer in the system",
                schema=[
                    CreateContextRequestSchemaItem(
                        key="email",
                        name="Email",
                        type="string",
                    ),
                    CreateContextRequestSchemaItem(
                        key="age",
                        name="Age",
                        type="number",
                    ),
                ],
                identity_fact="email",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.create(
            name=name,
            schema=schema,
            identity_fact=identity_fact,
            slug=slug,
            description=description,
            auto_execute_decisions=auto_execute_decisions,
            ttl_seconds=ttl_seconds,
            history_limit=history_limit,
            on_schema_mismatch=on_schema_mismatch,
            webhook_on_solve=webhook_on_solve,
            webhook_on_expire=webhook_on_expire,
            request_options=request_options,
        )
        return _response.data

    async def get(self, id: str, *, request_options: typing.Optional[RequestOptions] = None) -> ContextDetail:
        """
        Retrieve a specific context by its ID.

        Parameters
        ----------
        id : str
            The unique identifier for the context.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ContextDetail
            Success

        Examples
        --------
        import asyncio

        from rulebricks import AsyncRulebricks

        client = AsyncRulebricks(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.contexts.objects.get(
                id="a1b2c3d4-e5f6-7890-abcd-ef1234567890",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.get(id, request_options=request_options)
        return _response.data

    async def update(
        self,
        id: str,
        *,
        name: typing.Optional[str] = OMIT,
        slug: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        schema: typing.Optional[typing.Sequence[UpdateContextRequestSchemaItem]] = OMIT,
        auto_execute_decisions: typing.Optional[bool] = OMIT,
        ttl_seconds: typing.Optional[int] = OMIT,
        history_limit: typing.Optional[int] = OMIT,
        on_schema_mismatch: typing.Optional[UpdateContextRequestOnSchemaMismatch] = OMIT,
        webhook_on_solve: typing.Optional[str] = OMIT,
        webhook_on_expire: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> UpdateContextResponse:
        """
        Update an existing context's properties and schema.

        Parameters
        ----------
        id : str
            The unique identifier for the context.

        name : typing.Optional[str]
            The name of the context.

        slug : typing.Optional[str]
            The slug of the context.

        description : typing.Optional[str]
            The description of the context.

        schema : typing.Optional[typing.Sequence[UpdateContextRequestSchemaItem]]
            Updated schema fields for the context.

        auto_execute_decisions : typing.Optional[bool]
            When true, bound rules and flows automatically execute when their inputs are satisfied.

        ttl_seconds : typing.Optional[int]
            Time-to-live in seconds for live context instances. Instances expire after this duration.

        history_limit : typing.Optional[int]
            Maximum number of history entries to retain per field.

        on_schema_mismatch : typing.Optional[UpdateContextRequestOnSchemaMismatch]
            How to handle fields that don't match the schema.

        webhook_on_solve : typing.Optional[str]
            Webhook URL called when a rule or flow successfully solves.

        webhook_on_expire : typing.Optional[str]
            Webhook URL called when a live context expires due to TTL.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UpdateContextResponse
            Context updated successfully

        Examples
        --------
        import asyncio

        from rulebricks import AsyncRulebricks

        client = AsyncRulebricks(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.contexts.objects.update(
                id="a1b2c3d4-e5f6-7890-abcd-ef1234567890",
                name="Updated Customer",
                description="Updated description for premium customers",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.update(
            id,
            name=name,
            slug=slug,
            description=description,
            schema=schema,
            auto_execute_decisions=auto_execute_decisions,
            ttl_seconds=ttl_seconds,
            history_limit=history_limit,
            on_schema_mismatch=on_schema_mismatch,
            webhook_on_solve=webhook_on_solve,
            webhook_on_expire=webhook_on_expire,
            request_options=request_options,
        )
        return _response.data

    async def delete(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> DeleteContextResponse:
        """
        Delete a specific context and all its instances.

        Parameters
        ----------
        id : str
            The unique identifier for the context.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        DeleteContextResponse
            Context deleted successfully

        Examples
        --------
        import asyncio

        from rulebricks import AsyncRulebricks

        client = AsyncRulebricks(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.contexts.objects.delete(
                id="a1b2c3d4-e5f6-7890-abcd-ef1234567890",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.delete(id, request_options=request_options)
        return _response.data
