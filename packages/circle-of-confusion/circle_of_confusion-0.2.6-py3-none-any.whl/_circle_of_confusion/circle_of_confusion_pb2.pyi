"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""

import builtins
import google.protobuf.descriptor
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _WorldUnit:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _WorldUnitEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_WorldUnit.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    M: _WorldUnit.ValueType  # 3
    """Meters"""
    MM: _WorldUnit.ValueType  # 0
    """Millimeters"""
    CM: _WorldUnit.ValueType  # 1
    """Centimeters"""
    DM: _WorldUnit.ValueType  # 2
    """Decimeters"""
    IN: _WorldUnit.ValueType  # 4
    """Inches"""
    FT: _WorldUnit.ValueType  # 5
    """Feet"""

class WorldUnit(_WorldUnit, metaclass=_WorldUnitEnumTypeWrapper): ...

M: WorldUnit.ValueType  # 3
"""Meters"""
MM: WorldUnit.ValueType  # 0
"""Millimeters"""
CM: WorldUnit.ValueType  # 1
"""Centimeters"""
DM: WorldUnit.ValueType  # 2
"""Decimeters"""
IN: WorldUnit.ValueType  # 4
"""Inches"""
FT: WorldUnit.ValueType  # 5
"""Feet"""
Global___WorldUnit: typing_extensions.TypeAlias = WorldUnit

class _Math:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _MathEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Math.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    ONE_DIVIDED_BY_Z: _Math.ValueType  # 1
    """One divided by Z (inverse depth)"""
    REAL: _Math.ValueType  # 0
    """Real depth values"""

class Math(_Math, metaclass=_MathEnumTypeWrapper):
    """Math mode of provided depth channel

    This enum defines how the depth channel's mathematical representation
    should be interpreted. The mode is specified by the render engine that
    generates the depth information.
    """

ONE_DIVIDED_BY_Z: Math.ValueType  # 1
"""One divided by Z (inverse depth)"""
REAL: Math.ValueType  # 0
"""Real depth values"""
Global___Math: typing_extensions.TypeAlias = Math

class _FFIError:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _FFIErrorEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_FFIError.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    PROTO_ENCODE: _FFIError.ValueType  # 1
    """Data could not be encoded to protobuf"""
    PROTO_DECODE: _FFIError.ValueType  # 2
    """Protobuf could not be decoded from input buffer"""
    INITIALIZE_FAILED: _FFIError.ValueType  # 3
    """Initialization failed"""

class FFIError(_FFIError, metaclass=_FFIErrorEnumTypeWrapper): ...

PROTO_ENCODE: FFIError.ValueType  # 1
"""Data could not be encoded to protobuf"""
PROTO_DECODE: FFIError.ValueType  # 2
"""Protobuf could not be decoded from input buffer"""
INITIALIZE_FAILED: FFIError.ValueType  # 3
"""Initialization failed"""
Global___FFIError: typing_extensions.TypeAlias = FFIError

@typing.final
class Filmback(google.protobuf.message.Message):
    """Size of sensor"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    WIDTH_FIELD_NUMBER: builtins.int
    HEIGHT_FIELD_NUMBER: builtins.int
    width: builtins.float
    """Width of sensor"""
    height: builtins.float
    """Height of sensor"""
    def __init__(
        self,
        *,
        width: builtins.float | None = ...,
        height: builtins.float | None = ...,
    ) -> None: ...
    _HasFieldArgType: typing_extensions.TypeAlias = typing.Literal["height", b"height", "width", b"width"]
    def HasField(self, field_name: _HasFieldArgType) -> builtins.bool: ...
    _ClearFieldArgType: typing_extensions.TypeAlias = typing.Literal["height", b"height", "width", b"width"]
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___Filmback: typing_extensions.TypeAlias = Filmback

@typing.final
class Resolution(google.protobuf.message.Message):
    """Resolution of recording"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    WIDTH_FIELD_NUMBER: builtins.int
    HEIGHT_FIELD_NUMBER: builtins.int
    width: builtins.int
    """Width of plate"""
    height: builtins.int
    """Height of plate"""
    def __init__(
        self,
        *,
        width: builtins.int | None = ...,
        height: builtins.int | None = ...,
    ) -> None: ...
    _HasFieldArgType: typing_extensions.TypeAlias = typing.Literal["height", b"height", "width", b"width"]
    def HasField(self, field_name: _HasFieldArgType) -> builtins.bool: ...
    _ClearFieldArgType: typing_extensions.TypeAlias = typing.Literal["height", b"height", "width", b"width"]
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___Resolution: typing_extensions.TypeAlias = Resolution

@typing.final
class CameraData(google.protobuf.message.Message):
    """Camera parameters that are used when using the camera-based circle of
    confusion

    This struct contains camera-specific parameters that are used to calculate
    circle of confusion.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    FOCAL_LENGTH_FIELD_NUMBER: builtins.int
    F_STOP_FIELD_NUMBER: builtins.int
    FILMBACK_FIELD_NUMBER: builtins.int
    NEAR_FIELD_FIELD_NUMBER: builtins.int
    FAR_FIELD_FIELD_NUMBER: builtins.int
    WORLD_UNIT_FIELD_NUMBER: builtins.int
    RESOLUTION_FIELD_NUMBER: builtins.int
    focal_length: builtins.float
    """Focal length of the camera lens"""
    f_stop: builtins.float
    """F-stop (aperture) of the camera"""
    near_field: builtins.float
    """Near field distance for depth of field"""
    far_field: builtins.float
    """Far field distance for depth of field"""
    world_unit: Global___WorldUnit.ValueType
    """World unit for depth measurements"""
    @property
    def filmback(self) -> Global___Filmback:
        """Filmback size (width and height)"""

    @property
    def resolution(self) -> Global___Resolution:
        """Resolution camera is recording at"""

    def __init__(
        self,
        *,
        focal_length: builtins.float | None = ...,
        f_stop: builtins.float | None = ...,
        filmback: Global___Filmback | None = ...,
        near_field: builtins.float | None = ...,
        far_field: builtins.float | None = ...,
        world_unit: Global___WorldUnit.ValueType | None = ...,
        resolution: Global___Resolution | None = ...,
    ) -> None: ...
    _HasFieldArgType: typing_extensions.TypeAlias = typing.Literal["f_stop", b"f_stop", "far_field", b"far_field", "filmback", b"filmback", "focal_length", b"focal_length", "near_field", b"near_field", "resolution", b"resolution", "world_unit", b"world_unit"]
    def HasField(self, field_name: _HasFieldArgType) -> builtins.bool: ...
    _ClearFieldArgType: typing_extensions.TypeAlias = typing.Literal["f_stop", b"f_stop", "far_field", b"far_field", "filmback", b"filmback", "focal_length", b"focal_length", "near_field", b"near_field", "resolution", b"resolution", "world_unit", b"world_unit"]
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___CameraData: typing_extensions.TypeAlias = CameraData

@typing.final
class Settings(google.protobuf.message.Message):
    """Settings for the circle of confusion calculation.

    This struct contains all the parameters needed to calculate the circle of
    confusion.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SIZE_FIELD_NUMBER: builtins.int
    MAX_SIZE_FIELD_NUMBER: builtins.int
    MATH_FIELD_NUMBER: builtins.int
    FOCAL_PLANE_FIELD_NUMBER: builtins.int
    PROTECT_FIELD_NUMBER: builtins.int
    PIXEL_ASPECT_FIELD_NUMBER: builtins.int
    CAMERA_DATA_FIELD_NUMBER: builtins.int
    size: builtins.float
    """Base size for circle of confusion"""
    max_size: builtins.float
    """Maximum size for circle of confusion (clamped)"""
    math: Global___Math.ValueType
    """Mathematical interpretation of depth"""
    focal_plane: builtins.float
    """Focal plane position"""
    protect: builtins.float
    """Protection value for circle of confusion, this adds a region that has a CoC
    of zero.
    """
    pixel_aspect: builtins.float
    """Pixel aspect ratio"""
    @property
    def camera_data(self) -> Global___CameraData:
        """Camera parameters"""

    def __init__(
        self,
        *,
        size: builtins.float | None = ...,
        max_size: builtins.float | None = ...,
        math: Global___Math.ValueType | None = ...,
        focal_plane: builtins.float | None = ...,
        protect: builtins.float | None = ...,
        pixel_aspect: builtins.float | None = ...,
        camera_data: Global___CameraData | None = ...,
    ) -> None: ...
    _HasFieldArgType: typing_extensions.TypeAlias = typing.Literal["camera_data", b"camera_data", "focal_plane", b"focal_plane", "math", b"math", "max_size", b"max_size", "pixel_aspect", b"pixel_aspect", "protect", b"protect", "size", b"size"]
    def HasField(self, field_name: _HasFieldArgType) -> builtins.bool: ...
    _ClearFieldArgType: typing_extensions.TypeAlias = typing.Literal["camera_data", b"camera_data", "focal_plane", b"focal_plane", "math", b"math", "max_size", b"max_size", "pixel_aspect", b"pixel_aspect", "protect", b"protect", "size", b"size"]
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___Settings: typing_extensions.TypeAlias = Settings

@typing.final
class DepthOfField(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    X_FIELD_NUMBER: builtins.int
    Y_FIELD_NUMBER: builtins.int
    x: builtins.float
    """x"""
    y: builtins.float
    """y"""
    def __init__(
        self,
        *,
        x: builtins.float | None = ...,
        y: builtins.float | None = ...,
    ) -> None: ...
    _HasFieldArgType: typing_extensions.TypeAlias = typing.Literal["x", b"x", "y", b"y"]
    def HasField(self, field_name: _HasFieldArgType) -> builtins.bool: ...
    _ClearFieldArgType: typing_extensions.TypeAlias = typing.Literal["x", b"x", "y", b"y"]
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___DepthOfField: typing_extensions.TypeAlias = DepthOfField

@typing.final
class Calculator(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SETTINGS_FIELD_NUMBER: builtins.int
    INTERNAL_FOCUS_FIELD_NUMBER: builtins.int
    WORLD_UNIT_MULTIPLIER_FIELD_NUMBER: builtins.int
    DEPTH_OF_FIELD_FIELD_NUMBER: builtins.int
    HYPERFOCAL_DISTANCE_FIELD_NUMBER: builtins.int
    internal_focus: builtins.float
    """Focus point used for calculations"""
    world_unit_multiplier: builtins.float
    """Multiplier unit to use for world unit conversion"""
    hyperfocal_distance: builtins.float
    """Hyperfocal distance calculated value"""
    @property
    def settings(self) -> Global___Settings:
        """CoC settings"""

    @property
    def depth_of_field(self) -> Global___DepthOfField:
        """Start and end value of DoF"""

    def __init__(
        self,
        *,
        settings: Global___Settings | None = ...,
        internal_focus: builtins.float | None = ...,
        world_unit_multiplier: builtins.float | None = ...,
        depth_of_field: Global___DepthOfField | None = ...,
        hyperfocal_distance: builtins.float | None = ...,
    ) -> None: ...
    _HasFieldArgType: typing_extensions.TypeAlias = typing.Literal["depth_of_field", b"depth_of_field", "hyperfocal_distance", b"hyperfocal_distance", "internal_focus", b"internal_focus", "settings", b"settings", "world_unit_multiplier", b"world_unit_multiplier"]
    def HasField(self, field_name: _HasFieldArgType) -> builtins.bool: ...
    _ClearFieldArgType: typing_extensions.TypeAlias = typing.Literal["depth_of_field", b"depth_of_field", "hyperfocal_distance", b"hyperfocal_distance", "internal_focus", b"internal_focus", "settings", b"settings", "world_unit_multiplier", b"world_unit_multiplier"]
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___Calculator: typing_extensions.TypeAlias = Calculator

@typing.final
class FFIResult(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    FLOAT_VALUE_FIELD_NUMBER: builtins.int
    UINT_VALUE_FIELD_NUMBER: builtins.int
    INT_VALUE_FIELD_NUMBER: builtins.int
    ERROR_FIELD_NUMBER: builtins.int
    float_value: builtins.float
    """Float value is returned"""
    uint_value: builtins.int
    """An uint is returned"""
    int_value: builtins.int
    """An int is returned"""
    error: Global___FFIError.ValueType
    """Call failed and error is returned"""
    def __init__(
        self,
        *,
        float_value: builtins.float | None = ...,
        uint_value: builtins.int | None = ...,
        int_value: builtins.int | None = ...,
        error: Global___FFIError.ValueType | None = ...,
    ) -> None: ...
    _HasFieldArgType: typing_extensions.TypeAlias = typing.Literal["ResultValue", b"ResultValue", "error", b"error", "float_value", b"float_value", "int_value", b"int_value", "uint_value", b"uint_value"]
    def HasField(self, field_name: _HasFieldArgType) -> builtins.bool: ...
    _ClearFieldArgType: typing_extensions.TypeAlias = typing.Literal["ResultValue", b"ResultValue", "error", b"error", "float_value", b"float_value", "int_value", b"int_value", "uint_value", b"uint_value"]
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType_ResultValue: typing_extensions.TypeAlias = typing.Literal["float_value", "uint_value", "int_value", "error"]
    _WhichOneofArgType_ResultValue: typing_extensions.TypeAlias = typing.Literal["ResultValue", b"ResultValue"]
    def WhichOneof(self, oneof_group: _WhichOneofArgType_ResultValue) -> _WhichOneofReturnType_ResultValue | None: ...

Global___FFIResult: typing_extensions.TypeAlias = FFIResult
