#!/usr/bin/env python3
"""MCP Server for security analysis."""

import json
import os
import sys
from typing import Any, Callable

from mcp.server import Server
from mcp.server.stdio import stdio_server
from mcp.types import Tool, TextContent

from .audit import run_audit


app = Server("mcp-server-security")


# Helper functions to reduce code repetition
def _get_log_dir() -> str:
    """Auto-detect appropriate log directory based on user privileges."""
    if os.geteuid() == 0:
        return "/var/log/mcp-watchdog"
    return f"/tmp/mcp-watchdog-{os.getuid()}"


def _get_monitoring_manager():
    """Get MonitoringManager instance with auto-detected log directory."""
    from .monitoring.manager import MonitoringManager

    return MonitoringManager(_get_log_dir())


def _handle_monitoring_operation(
    operation: Callable, error_message: str, **kwargs
) -> list[TextContent]:
    """Generic handler for monitoring operations with consistent error handling."""
    try:
        manager = _get_monitoring_manager()
        result = operation(manager, **kwargs)
        return [TextContent(type="text", text=json.dumps(result, indent=2))]
    except Exception as e:
        return [
            TextContent(
                type="text",
                text=json.dumps({"error": str(e), "message": error_message}, indent=2),
            )
        ]


@app.list_tools()
async def list_tools() -> list[Tool]:
    """List available security audit tools."""
    return [
        Tool(
            name="security_audit",
            description="Run comprehensive cybersecurity audit of the Linux server. "
            "Analyzes: firewall (ufw/iptables/firewalld), SSH configuration, "
            "threat patterns, fail2ban, network services/open ports, Docker security, "
            "security updates, MAC (AppArmor/SELinux), and kernel hardening. "
            "Returns detailed JSON report with security score and actionable recommendations.",
            inputSchema={
                "type": "object",
                "properties": {
                    "mask_data": {
                        "type": "boolean",
                        "description": "Mask sensitive data like IPs and hostname (default: true)",
                        "default": True,
                    }
                },
            },
        ),
        Tool(
            name="analyze_anomaly",
            description="Analyze security anomaly with AI-powered insights. "
            "Use this when the monitoring system detects anomalies (firewall changes, "
            "new open ports, SSH config changes, attack spikes, etc.). "
            "Provides deep analysis of what changed, why it's concerning, and recommended actions. "
            "This tool should ONLY be called when anomalies are detected - don't waste tokens on normal state.",
            inputSchema={
                "type": "object",
                "properties": {
                    "anomaly_file": {
                        "type": "string",
                        "description": "Path to anomaly report JSON file (generated by monitor)",
                    }
                },
                "required": ["anomaly_file"],
            },
        ),
        Tool(
            name="monitoring_status",
            description="Get current status of security monitoring daemon. "
            "Shows if monitoring is running, how many logs collected, disk usage, etc. "
            "Use this to check monitoring state before starting/stopping it.",
            inputSchema={"type": "object", "properties": {}},
        ),
        Tool(
            name="start_monitoring",
            description="Start continuous security monitoring in background. "
            "The daemon will check security state periodically and alert on anomalies. "
            "IMPORTANT: Ask user for confirmation before starting! This runs a background process.",
            inputSchema={
                "type": "object",
                "properties": {
                    "interval_seconds": {
                        "type": "number",
                        "description": "Check interval in seconds (default: 3600 = 1 hour, min: 300 = 5 min)",
                        "default": 3600,
                    }
                },
            },
        ),
        Tool(
            name="stop_monitoring",
            description="Stop security monitoring daemon. "
            "IMPORTANT: Ask user for confirmation before stopping!",
            inputSchema={"type": "object", "properties": {}},
        ),
        Tool(
            name="cleanup_old_logs",
            description="Remove old monitoring logs to free disk space. "
            "Keeps most recent 50 bulletins and 20 anomaly reports, deletes older ones. "
            "Safe to run periodically to prevent disk fill.",
            inputSchema={"type": "object", "properties": {}},
        ),
    ]


@app.call_tool()
async def call_tool(name: str, arguments: Any) -> list[TextContent]:
    """Execute security audit tool."""
    if name == "security_audit":
        mask_data = arguments.get("mask_data", True)

        try:
            report = run_audit(mask_data=mask_data)
            return [TextContent(type="text", text=json.dumps(report, indent=2))]

        except Exception as e:
            return [
                TextContent(
                    type="text",
                    text=json.dumps(
                        {"error": str(e), "message": "Failed to run security audit"}, indent=2
                    ),
                )
            ]

    elif name == "analyze_anomaly":
        anomaly_file = arguments.get("anomaly_file")

        if not anomaly_file:
            return [
                TextContent(
                    type="text",
                    text=json.dumps({"error": "anomaly_file parameter required"}, indent=2),
                )
            ]

        try:
            from pathlib import Path

            # Read anomaly report
            path = Path(anomaly_file).resolve()

            # Security: Only allow reading from expected log directories
            allowed_dirs = [
                Path("/var/log/mcp-watchdog").resolve(),
                Path(f"/tmp/mcp-watchdog-{os.getuid()}").resolve(),
            ]

            # Check if path is within allowed directories using secure path comparison
            is_allowed = False
            for allowed_dir in allowed_dirs:
                try:
                    # Use resolve() to normalize and prevent path traversal
                    path.relative_to(allowed_dir)
                    is_allowed = True
                    break
                except ValueError:
                    # path is not relative to allowed_dir
                    continue

            if not is_allowed:
                return [
                    TextContent(
                        type="text",
                        text=json.dumps(
                            {
                                "error": "Access denied: anomaly file must be in /var/log/mcp-watchdog or /tmp/mcp-watchdog-*"
                            },
                            indent=2,
                        ),
                    )
                ]

            if not path.exists():
                return [
                    TextContent(
                        type="text",
                        text=json.dumps(
                            {"error": f"Anomaly file not found: {anomaly_file}"}, indent=2
                        ),
                    )
                ]

            # Security: Only read .json files
            if path.suffix != ".json":
                return [
                    TextContent(
                        type="text",
                        text=json.dumps({"error": "Only .json files are allowed"}, indent=2),
                    )
                ]

            with open(path) as f:
                anomaly_data = json.load(f)

            # Return anomaly data for AI analysis
            # AI will receive this and can provide insights
            return [
                TextContent(
                    type="text",
                    text=json.dumps(
                        {
                            "message": "Security anomaly detected - AI analysis recommended",
                            "anomaly_count": len(anomaly_data.get("anomalies", [])),
                            "anomalies": anomaly_data.get("anomalies", []),
                            "timestamp": anomaly_data.get("timestamp"),
                            "full_report": anomaly_data.get("full_report", {}),
                        },
                        indent=2,
                    ),
                )
            ]

        except Exception as e:
            return [
                TextContent(
                    type="text",
                    text=json.dumps(
                        {"error": str(e), "message": "Failed to analyze anomaly"}, indent=2
                    ),
                )
            ]

    elif name == "monitoring_status":
        return _handle_monitoring_operation(
            lambda mgr: mgr.get_status(), "Failed to get monitoring status"
        )

    elif name == "start_monitoring":
        interval = arguments.get("interval_seconds", 3600)

        # Validate interval (min 5 minutes, max 24 hours)
        if interval < 300:
            return [
                TextContent(
                    type="text",
                    text=json.dumps(
                        {"error": "Minimum interval is 300 seconds (5 minutes)"}, indent=2
                    ),
                )
            ]
        if interval > 86400:
            return [
                TextContent(
                    type="text",
                    text=json.dumps(
                        {"error": "Maximum interval is 86400 seconds (24 hours)"}, indent=2
                    ),
                )
            ]

        return _handle_monitoring_operation(
            lambda mgr, **kw: mgr.start(**kw),
            "Failed to start monitoring",
            interval_seconds=interval,
        )

    elif name == "stop_monitoring":
        return _handle_monitoring_operation(lambda mgr: mgr.stop(), "Failed to stop monitoring")

    elif name == "cleanup_old_logs":
        return _handle_monitoring_operation(
            lambda mgr: mgr.cleanup_old_logs(), "Failed to cleanup logs"
        )

    else:
        raise ValueError(f"Unknown tool: {name}")


async def main():
    """Run MCP server."""
    async with stdio_server() as (read_stream, write_stream):
        await app.run(read_stream, write_stream, app.create_initialization_options())


def cli_main():
    """CLI entry point for testing and monitoring."""
    if len(sys.argv) > 1:
        command = sys.argv[1]

        if command == "test":
            # One-shot audit test
            from .utils.permissions import check_and_warn

            print("Running security audit...")
            check_and_warn()
            report = run_audit(mask_data=True, verbose=True)
            print("\n" + json.dumps(report, indent=2))

        elif command == "monitor":
            # Live monitoring daemon
            from .monitoring.daemon import SecurityMonitor

            # Parse optional arguments
            interval = 3600  # Default: 1 hour
            log_dir = "/var/log/mcp-watchdog"

            # Simple arg parsing
            for i, arg in enumerate(sys.argv[2:], start=2):
                if arg == "--interval" and i + 1 < len(sys.argv):
                    interval = int(sys.argv[i + 1])
                elif arg == "--log-dir" and i + 1 < len(sys.argv):
                    log_dir = sys.argv[i + 1]

            print(f"Starting security monitor (interval: {interval}s)")
            print(f"Logs will be written to: {log_dir}")
            print("Press Ctrl+C to stop\n")

            monitor = SecurityMonitor(interval_seconds=interval, log_dir=log_dir, verbose=True)
            monitor.run()

        elif command == "monitor-once":
            # Run single monitoring check (useful for testing)
            from .monitoring.daemon import SecurityMonitor

            log_dir = "/var/log/mcp-watchdog"
            baseline_path = "/var/lib/mcp-watchdog/baseline.json"

            # If not root, use temp paths
            if os.geteuid() != 0:
                log_dir = f"/tmp/mcp-watchdog-{os.getuid()}"
                baseline_path = f"{log_dir}/baseline.json"

            if len(sys.argv) > 2 and sys.argv[2] == "--log-dir":
                log_dir = sys.argv[3]
                baseline_path = f"{log_dir}/baseline.json"

            monitor = SecurityMonitor(log_dir=log_dir, baseline_path=baseline_path, verbose=True)
            result = monitor.run_once()
            print(f"\nCheck result: {result['status']}")
            if result.get("anomaly_file"):
                print(f"Anomaly file: {result['anomaly_file']}")

        else:
            print(f"Unknown command: {command}")
            print("\nUsage:")
            print("  mcp-watchdog test           - Run one-time security audit")
            print("  mcp-watchdog monitor        - Start continuous monitoring")
            print("  mcp-watchdog monitor-once   - Run single monitoring check")
            print("\nMonitor options:")
            print("  --interval SECONDS   - Check interval (default: 3600)")
            print("  --log-dir PATH       - Log directory (default: /var/log/mcp-watchdog)")
            sys.exit(1)
    else:
        # No command = run as MCP server
        import asyncio

        asyncio.run(main())


if __name__ == "__main__":
    cli_main()
