################################################################################

import sys
import types
from types import GenericAlias, TracebackType, CodeType
from typing import (
    TypeVarTuple,
    ClassVar,
    AbstractSet,
    MutableMapping,
    Iterable,
    Iterator,
    Callable,
    overload,
    SupportsBytes,
    Any,
    TypeVar,
    SupportsAbs,
    SupportsComplex,
    Sized,
    IO,
    Literal,
    BinaryIO,
    Reversible,
)
from collections.abc import Iterable, Buffer, Iterator, Reversible, Callable, Sized, MutableMapping
from io import FileIO, BufferedReader, BufferedWriter, BufferedRandom, TextIOWrapper
from os import PathLike
import ast
from ._typeshed_init import (
    SupportsIter,
    SupportsDunderLT,
    SupportsNext,
    SupportsWrite,
    SupportsKeysAndGetItem,
    SupportsDunderGT,
    SupportsLenAndGetItem,
    SupportsDivMod,
    SupportsRDivMod,
)
from ._dict_extra import dict_keys, dict_items, dict_values

################################################################################

__classes__ = [
    '_object',
    '_staticmethod',
    '_classmethod',
    '_type',
    '_super',
    '_int',
    '_float',
    '_complex',
    '_FormatMapMapping',
    '_TranslateTable',
    '_str',
    '_bytes',
    '_bytearray',
    '_memoryview',
    '_bool',
    '_slice',
    '_tuple',
    'function',
    '_list',
    '_dict',
    '_set',
    '_frozenset',
    '_enumerate',
    '_range',
    '_property',
    '_NotImplementedType',
    '_filter',
    '_GetItemIterable',
    '_map',
    '_SupportsWriteAndFlush',
    '_SupportsPow2',
    '_SupportsPow3NoneOnly',
    '_SupportsPow3',
    '_reversed',
    '_SupportsRound1',
    '_SupportsRound2',
    '_SupportsSumWithNoDefaultGiven',
    '_BaseException',
    '_GeneratorExit',
    '_KeyboardInterrupt',
    '_SystemExit',
    '_Exception',
    '_StopIteration',
    '_StopAsyncIteration',
]

__functions__ = [
    '_abs',
    '_all',
    '_any',
    '_ascii',
    '_bin',
    '_breakpoint',
    '_callable',
    '_chr',
    '_compile',
    '_compile',
    '_compile',
    '_compile',
    '_delattr',
    '_dir',
    '_divmod',
    '_divmod',
    '_format',
    '_getattr',
    '_getattr',
    '_getattr',
    '_getattr',
    '_getattr',
    '_getattr',
    '_globals',
    '_hasattr',
    '_hash',
    '_hex',
    '_id',
    '_input',
    '_iter',
    '_iter',
    '_iter',
    '_iter',
    '_isinstance',
    '_issubclass',
    '_len',
    '_locals',
    '_max',
    '_max',
    '_max',
    '_max',
    '_max',
    '_max',
    '_min',
    '_min',
    '_min',
    '_min',
    '_min',
    '_min',
    '_next',
    '_next',
    '_oct',
    '_open',
    '_open',
    '_open',
    '_open',
    '_open',
    '_open',
    '_open',
    '_ord',
    '_print',
    '_print',
    '_pow',
    '_pow',
    '_pow',
    '_pow',
    '_pow',
    '_pow',
    '_pow',
    '_pow',
    '_pow',
    '_pow',
    '_pow',
    '_pow',
    '_pow',
    '_pow',
    '_pow',
    '_repr',
    '_round',
    '_round',
    '_setattr',
    '_sorted',
    '_sorted',
    '_sum',
    '_sum',
    '_sum',
    '_vars',
    '_vars',
]

__aliases__ = ['_PositiveInteger', '_NegativeInteger', '_IntegerFormats', '_Opener']

__annos__ = []

__constants__ = ['EnvironmentError', 'IOError']

__all__ = [
    '_object',
    '_staticmethod',
    '_classmethod',
    '_type',
    '_super',
    '_int',
    '_float',
    '_complex',
    '_FormatMapMapping',
    '_TranslateTable',
    '_str',
    '_bytes',
    '_bytearray',
    '_memoryview',
    '_bool',
    '_slice',
    '_tuple',
    '_list',
    '_dict',
    '_set',
    '_frozenset',
    '_enumerate',
    '_range',
    '_property',
    '_NotImplementedType',
    '_filter',
    '_GetItemIterable',
    '_map',
    '_SupportsWriteAndFlush',
    '_SupportsPow2',
    '_SupportsPow3NoneOnly',
    '_SupportsPow3',
    '_reversed',
    '_SupportsRound1',
    '_SupportsRound2',
    '_SupportsSumWithNoDefaultGiven',
    '_BaseException',
    '_GeneratorExit',
    '_KeyboardInterrupt',
    '_SystemExit',
    '_Exception',
    '_StopIteration',
    '_StopAsyncIteration',
    '_abs',
    '_all',
    '_any',
    '_ascii',
    '_bin',
    '_breakpoint',
    '_callable',
    '_chr',
    '_compile',
    '_delattr',
    '_dir',
    '_divmod',
    '_format',
    '_getattr',
    '_globals',
    '_hasattr',
    '_hash',
    '_hex',
    '_id',
    '_input',
    '_iter',
    '_isinstance',
    '_issubclass',
    '_len',
    '_locals',
    '_max',
    '_min',
    '_next',
    '_oct',
    '_open',
    '_ord',
    '_print',
    '_pow',
    '_repr',
    '_round',
    '_setattr',
    '_sorted',
    '_sum',
    '_vars',
]

################################################################################


class _object:
    __doc__: str | None
    __dict__: dict[str, Any]
    __module__: str
    __annotations__: dict[str, Any]

    @property
    def __class__(self) -> type: ...
    @__class__.setter
    def __class__(self, type: type, /) -> None: ...
    def __init__(self) -> None: ...
    def __new__(cls) -> Any: ...
    def __setattr__(self, name: str, value: Any, /) -> None: ...
    def __delattr__(self, name: str, /) -> None: ...

    def __lt__(self, value: object, /) -> bool: ...
    def __le__(self, value: object, /) -> bool: ...
    def __eq__(self, value: object, /) -> bool: ...
    def __ne__(self, value: object, /) -> bool: ...
    def __gt__(self, value: object, /) -> bool: ...
    def __ge__(self, value: object, /) -> bool: ...

    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __hash__(self) -> int: ...
    def __format__(self, format_spec: str, /) -> str: ...
    def __getattribute__(self, name: str, /) -> Any: ...
    def __sizeof__(self) -> int: ...
    def __reduce__(self) -> str | tuple: ...
    def __reduce_ex__(self, protocol: int, /) -> str | tuple: ...

    if sys.version_info >= (3, 11):

        def __getstate__(self) -> object: ...

    def __dir__(self) -> Iterable[str]: ...
    def __init_subclass__(cls) -> None: ...
    @classmethod
    def __subclasshook__(cls, subclass: type, /) -> bool: ...


################################################################################


class _staticmethod:
    @property
    def __func__(self) -> Callable: ...
    @property
    def __isabstractmethod__(self) -> bool: ...
    def __init__(self, f: Callable, /) -> None: ...
    @overload
    def __get__(self, instance: None, owner: type, /) -> Callable: ...
    @overload
    def __get__(self, instance: Any, owner: type | None = None, /) -> Callable: ...

    if sys.version_info >= (3, 10):
        __name__: str
        __qualname__: str

        @property
        def __wrapped__(self) -> Callable: ...
        def __call__(self, *args: Any, **kwargs: Any) -> Any: ...

    if sys.version_info >= (3, 14):

        def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...

        __annotate__: AnnotateFunc | None


################################################################################


class _classmethod:
    @property
    def __func__(self) -> Callable: ...
    @property
    def __isabstractmethod__(self) -> bool: ...
    def __init__(self, f: Callable, /) -> None: ...
    @overload
    def __get__(self, instance: Any, owner: type | None = None, /) -> Callable: ...
    @overload
    def __get__(self, instance: None, owner: type, /) -> Callable: ...

    if sys.version_info >= (3, 10):
        __name__: str
        __qualname__: str

        @property
        def __wrapped__(self) -> Callable: ...

    if sys.version_info >= (3, 14):

        def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...

        __annotate__: AnnotateFunc | None


################################################################################


class _type:
    __bases__: tuple[type, ...]
    __module__: str
    __name__: str
    __qualname__: str
    __annotations__: dict[str, Any]

    @property
    def __base__(self) -> type | None: ...
    @property
    def __basicsize__(self) -> int: ...
    @property
    def __dict__(self) -> types.MappingProxyType[str, Any]: ...
    @property
    def __dictoffset__(self) -> int: ...
    @property
    def __flags__(self) -> int: ...
    @property
    def __itemsize__(self) -> int: ...
    @property
    def __mro__(self) -> tuple[type, ...]: ...
    @property
    def __text_signature__(self) -> str | None: ...
    @property
    def __weakrefoffset__(self) -> int: ...
    @overload
    def __init__(self, o: object, /) -> None: ...
    @overload
    def __init__(
        self, name: str, bases: tuple[type, ...], dict: dict[str, Any], /, **kwds: Any
    ) -> None: ...
    @overload
    def __new__(cls, o: object, /) -> type: ...
    @overload
    def __new__(
        cls: type, name: str, bases: tuple[type, ...], namespace: dict[str, Any], /, **kwds: Any
    ) -> Any: ...
    def __call__(self, *args: Any, **kwds: Any) -> Any: ...
    def __subclasses__(self: Any) -> list: ...
    def mro(self) -> list[type]: ...
    def __instancecheck__(self, instance: Any, /) -> bool: ...
    def __subclasscheck__(self, subclass: type, /) -> bool: ...
    @classmethod
    def __prepare__(
        metacls, name: str, bases: tuple[type, ...], /, **kwds: Any
    ) -> MutableMapping[str, object]: ...

    if sys.version_info >= (3, 10):

        def __or__(self, value: Any, /) -> types.UnionType: ...
        def __ror__(self, value: Any, /) -> types.UnionType: ...

    if sys.version_info >= (3, 12):
        __type_params__: tuple[TypeVar | Any | TypeVarTuple, ...]
    if sys.version_info >= (3, 14):
        __annotate__: AnnotateFunc | None


################################################################################


class _super:
    @overload
    def __init__(self, t: Any, obj: Any, /) -> None: ...
    @overload
    def __init__(self, t: Any, /) -> None: ...
    @overload
    def __init__(self) -> None: ...


################################################################################


class _int:
    @overload
    def __new__(cls, x: Any = ..., /) -> Any: ...
    @overload
    def __new__(cls, x: str | bytes | bytearray, /, base: int) -> Any: ...
    def as_integer_ratio(self) -> tuple[int, Literal[1]]: ...
    @property
    def real(self) -> int: ...
    @property
    def imag(self) -> Literal[0]: ...
    @property
    def numerator(self) -> int: ...
    @property
    def denominator(self) -> Literal[1]: ...
    def conjugate(self) -> int: ...
    def bit_length(self) -> int: ...

    if sys.version_info >= (3, 10):

        def bit_count(self) -> int: ...

    if sys.version_info >= (3, 11):

        def to_bytes(
            self,
            length: int = 1,
            byteorder: Literal["little", "big"] = "big",
            *,
            signed: bool = False,
        ) -> bytes: ...
        @classmethod
        def from_bytes(
            cls,
            bytes: Iterable[int] | SupportsBytes | Buffer,
            byteorder: Literal["little", "big"] = "big",
            *,
            signed: bool = False,
        ) -> Any: ...
    else:

        def to_bytes(
            self, length: int, byteorder: Literal["little", "big"], *, signed: bool = False
        ) -> bytes: ...
        @classmethod
        def from_bytes(
            cls,
            bytes: Iterable[int] | SupportsBytes | Buffer,
            byteorder: Literal["little", "big"],
            *,
            signed: bool = False,
        ) -> Any: ...

    if sys.version_info >= (3, 12):

        def is_integer(self) -> Literal[True]: ...

    def __add__(self, value: int, /) -> int: ...
    def __sub__(self, value: int, /) -> int: ...
    def __mul__(self, value: int, /) -> int: ...
    def __floordiv__(self, value: int, /) -> int: ...
    def __truediv__(self, value: int, /) -> float: ...
    def __mod__(self, value: int, /) -> int: ...
    def __divmod__(self, value: int, /) -> tuple[int, int]: ...
    def __radd__(self, value: int, /) -> int: ...
    def __rsub__(self, value: int, /) -> int: ...
    def __rmul__(self, value: int, /) -> int: ...
    def __rfloordiv__(self, value: int, /) -> int: ...
    def __rtruediv__(self, value: int, /) -> float: ...
    def __rmod__(self, value: int, /) -> int: ...
    def __rdivmod__(self, value: int, /) -> tuple[int, int]: ...
    @overload
    def __pow__(self, x: Literal[0], /) -> Literal[1]: ...
    @overload
    def __pow__(self, value: Literal[0], mod: None, /) -> Literal[1]: ...
    @overload
    def __pow__(
        self,
        value: Literal[
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
        ],
        mod: None = None,
        /,
    ) -> int: ...
    @overload
    def __pow__(
        self,
        value: Literal[
            -1,
            -2,
            -3,
            -4,
            -5,
            -6,
            -7,
            -8,
            -9,
            -10,
            -11,
            -12,
            -13,
            -14,
            -15,
            -16,
            -17,
            -18,
            -19,
            -20,
        ],
        mod: None = None,
        /,
    ) -> float: ...
    @overload
    def __pow__(self, value: int, mod: None = None, /) -> Any: ...
    @overload
    def __pow__(self, value: int, mod: int, /) -> int: ...
    def __rpow__(self, value: int, mod: int | None = None, /) -> Any: ...
    def __and__(self, value: int, /) -> int: ...
    def __or__(self, value: int, /) -> int: ...
    def __xor__(self, value: int, /) -> int: ...
    def __lshift__(self, value: int, /) -> int: ...
    def __rshift__(self, value: int, /) -> int: ...
    def __rand__(self, value: int, /) -> int: ...
    def __ror__(self, value: int, /) -> int: ...
    def __rxor__(self, value: int, /) -> int: ...
    def __rlshift__(self, value: int, /) -> int: ...
    def __rrshift__(self, value: int, /) -> int: ...
    def __neg__(self) -> int: ...
    def __pos__(self) -> int: ...
    def __invert__(self) -> int: ...
    def __trunc__(self) -> int: ...
    def __ceil__(self) -> int: ...
    def __floor__(self) -> int: ...

    if sys.version_info >= (3, 14):

        def __round__(self, ndigits: int | None = None, /) -> int: ...
    else:

        def __round__(self, ndigits: int = ..., /) -> int: ...

    def __getnewargs__(self) -> tuple[int]: ...
    def __eq__(self, value: object, /) -> bool: ...
    def __ne__(self, value: object, /) -> bool: ...
    def __lt__(self, value: int, /) -> bool: ...
    def __le__(self, value: int, /) -> bool: ...
    def __gt__(self, value: int, /) -> bool: ...
    def __ge__(self, value: int, /) -> bool: ...
    def __float__(self) -> float: ...
    def __int__(self) -> int: ...
    def __abs__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __bool__(self) -> bool: ...
    def __index__(self) -> int: ...


################################################################################


class _float:
    def __new__(cls, x: str | Buffer | float | int = ..., /) -> Any: ...
    def as_integer_ratio(self) -> tuple[int, int]: ...
    def hex(self) -> str: ...
    def is_integer(self) -> bool: ...
    @classmethod
    def fromhex(cls, string: str, /) -> Any: ...
    @property
    def real(self) -> float: ...
    @property
    def imag(self) -> float: ...
    def conjugate(self) -> float: ...
    def __add__(self, value: float, /) -> float: ...
    def __sub__(self, value: float, /) -> float: ...
    def __mul__(self, value: float, /) -> float: ...
    def __floordiv__(self, value: float, /) -> float: ...
    def __truediv__(self, value: float, /) -> float: ...
    def __mod__(self, value: float, /) -> float: ...
    def __divmod__(self, value: float, /) -> tuple[float, float]: ...
    @overload
    def __pow__(self, value: int, mod: None = None, /) -> float: ...
    @overload
    def __pow__(self, value: float, mod: None = None, /) -> Any: ...
    def __radd__(self, value: float, /) -> float: ...
    def __rsub__(self, value: float, /) -> float: ...
    def __rmul__(self, value: float, /) -> float: ...
    def __rfloordiv__(self, value: float, /) -> float: ...
    def __rtruediv__(self, value: float, /) -> float: ...
    def __rmod__(self, value: float, /) -> float: ...
    def __rdivmod__(self, value: float, /) -> tuple[float, float]: ...
    @overload
    def __rpow__(
        self,
        value: Literal[
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
        ],
        mod: None = None,
        /,
    ) -> float: ...
    @overload
    def __rpow__(
        self,
        value: Literal[
            -1,
            -2,
            -3,
            -4,
            -5,
            -6,
            -7,
            -8,
            -9,
            -10,
            -11,
            -12,
            -13,
            -14,
            -15,
            -16,
            -17,
            -18,
            -19,
            -20,
        ],
        mod: None = None,
        /,
    ) -> complex: ...
    @overload
    def __rpow__(self, value: float, mod: None = None, /) -> Any: ...
    def __getnewargs__(self) -> tuple[float]: ...
    def __trunc__(self) -> int: ...
    def __ceil__(self) -> int: ...
    def __floor__(self) -> int: ...
    @overload
    def __round__(self, ndigits: None = None, /) -> int: ...
    @overload
    def __round__(self, ndigits: int, /) -> float: ...
    def __eq__(self, value: object, /) -> bool: ...
    def __ne__(self, value: object, /) -> bool: ...
    def __lt__(self, value: float, /) -> bool: ...
    def __le__(self, value: float, /) -> bool: ...
    def __gt__(self, value: float, /) -> bool: ...
    def __ge__(self, value: float, /) -> bool: ...
    def __neg__(self) -> float: ...
    def __pos__(self) -> float: ...
    def __int__(self) -> int: ...
    def __float__(self) -> float: ...
    def __abs__(self) -> float: ...
    def __hash__(self) -> int: ...
    def __bool__(self) -> bool: ...

    if sys.version_info >= (3, 14):

        @classmethod
        def from_number(cls, number: float | int | float, /) -> Any: ...


################################################################################


class _complex:
    @overload
    def __new__(
        cls, real: complex | SupportsComplex | float | int = ..., imag: complex | float | int = ...
    ) -> Any: ...
    @overload
    def __new__(cls, real: str | SupportsComplex | float | int | complex) -> Any: ...
    @property
    def real(self) -> float: ...
    @property
    def imag(self) -> float: ...
    def conjugate(self) -> complex: ...
    def __add__(self, value: complex, /) -> complex: ...
    def __sub__(self, value: complex, /) -> complex: ...
    def __mul__(self, value: complex, /) -> complex: ...
    def __pow__(self, value: complex, mod: None = None, /) -> complex: ...
    def __truediv__(self, value: complex, /) -> complex: ...
    def __radd__(self, value: complex, /) -> complex: ...
    def __rsub__(self, value: complex, /) -> complex: ...
    def __rmul__(self, value: complex, /) -> complex: ...
    def __rpow__(self, value: complex, mod: None = None, /) -> complex: ...
    def __rtruediv__(self, value: complex, /) -> complex: ...
    def __eq__(self, value: object, /) -> bool: ...
    def __ne__(self, value: object, /) -> bool: ...
    def __neg__(self) -> complex: ...
    def __pos__(self) -> complex: ...
    def __abs__(self) -> float: ...
    def __hash__(self) -> int: ...
    def __bool__(self) -> bool: ...

    if sys.version_info >= (3, 11):

        def __complex__(self) -> complex: ...

    if sys.version_info >= (3, 14):

        @classmethod
        def from_number(cls, number: complex | SupportsComplex | float | int, /) -> Any: ...


################################################################################


class _FormatMapMapping:
    def __getitem__(self, key: str, /) -> Any: ...


################################################################################


class _TranslateTable:
    def __getitem__(self, key: int, /) -> str | int | None: ...


################################################################################


class _str:
    @overload
    def __new__(cls, object: object = ...) -> Any: ...
    @overload
    def __new__(cls, object: Buffer, encoding: str = ..., errors: str = ...) -> Any: ...
    @overload
    def capitalize(self) -> str: ...
    @overload
    def casefold(self) -> str: ...
    @overload
    def center(self, width: int, fillchar: str = " ", /) -> str: ...
    def count(self, sub: str, start: int | None = ..., end: int | None = ..., /) -> int: ...
    def encode(self, encoding: str = "utf-8", errors: str = "strict") -> bytes: ...
    def endswith(
        self, suffix: str | tuple[str, ...], start: int | None = ..., end: int | None = ..., /
    ) -> bool: ...
    @overload
    def expandtabs(self, tabsize: int = 8) -> str: ...
    def find(self, sub: str, start: int | None = ..., end: int | None = ..., /) -> int: ...
    @overload
    def format(self, *args: object, **kwargs: object) -> str: ...
    def format_map(self, mapping: _FormatMapMapping, /) -> str: ...
    def index(self, sub: str, start: int | None = ..., end: int | None = ..., /) -> int: ...
    def isalnum(self) -> bool: ...
    def isalpha(self) -> bool: ...
    def isascii(self) -> bool: ...
    def isdecimal(self) -> bool: ...
    def isdigit(self) -> bool: ...
    def isidentifier(self) -> bool: ...
    def islower(self) -> bool: ...
    def isnumeric(self) -> bool: ...
    def isprintable(self) -> bool: ...
    def isspace(self) -> bool: ...
    def istitle(self) -> bool: ...
    def isupper(self) -> bool: ...
    @overload
    def join(self, iterable: Iterable[str], /) -> str: ...
    @overload
    def ljust(self, width: int, fillchar: str = " ", /) -> str: ...
    @overload
    def lower(self) -> str: ...
    @overload
    def lstrip(self, chars: str | None = None, /) -> str: ...
    @overload
    def partition(self, sep: str, /) -> tuple[str, str, str]: ...

    if sys.version_info >= (3, 13):

        @overload
        def replace(self, old: str, new: str, /, count: int = -1) -> str: ...
    else:

        @overload
        def replace(self, old: str, new: str, count: int = -1, /) -> str: ...

    @overload
    def removeprefix(self, prefix: str, /) -> str: ...
    @overload
    def removesuffix(self, suffix: str, /) -> str: ...
    def rfind(self, sub: str, start: int | None = ..., end: int | None = ..., /) -> int: ...
    def rindex(self, sub: str, start: int | None = ..., end: int | None = ..., /) -> int: ...
    @overload
    def rjust(self, width: int, fillchar: str = " ", /) -> str: ...
    @overload
    def rpartition(self, sep: str, /) -> tuple[str, str, str]: ...
    @overload
    def rsplit(self, sep: str | None = None, maxsplit: int = -1) -> list[str]: ...
    @overload
    def rstrip(self, chars: str | None = None, /) -> str: ...
    @overload
    def split(self, sep: str | None = None, maxsplit: int = -1) -> list[str]: ...
    @overload
    def splitlines(self, keepends: bool = False) -> list[str]: ...
    def startswith(
        self, prefix: str | tuple[str, ...], start: int | None = ..., end: int | None = ..., /
    ) -> bool: ...
    @overload
    def strip(self, chars: str | None = None, /) -> str: ...
    @overload
    def swapcase(self) -> str: ...
    @overload
    def title(self) -> str: ...
    def translate(self, table: _TranslateTable, /) -> str: ...
    @overload
    def upper(self) -> str: ...
    @overload
    def zfill(self, width: int, /) -> str: ...
    @staticmethod
    @overload
    def maketrans(
        x: dict[int, Any] | dict[str, Any] | dict[str | int, Any], /
    ) -> dict[int, Any]: ...
    @staticmethod
    @overload
    def maketrans(x: str, y: str, /) -> dict[int, int]: ...
    @staticmethod
    @overload
    def maketrans(x: str, y: str, z: str, /) -> dict[int, int | None]: ...
    @overload
    def __add__(self, value: str, /) -> str: ...
    def __contains__(self, key: str, /) -> bool: ...
    def __eq__(self, value: object, /) -> bool: ...
    def __ge__(self, value: str, /) -> bool: ...
    @overload
    def __getitem__(self, key: int | slice, /) -> str: ...
    def __gt__(self, value: str, /) -> bool: ...
    def __hash__(self) -> int: ...
    @overload
    def __iter__(self) -> Iterator[str]: ...
    def __le__(self, value: str, /) -> bool: ...
    def __len__(self) -> int: ...
    def __lt__(self, value: str, /) -> bool: ...
    @overload
    def __mod__(self, value: Any, /) -> str: ...
    @overload
    def __mul__(self, value: int, /) -> str: ...
    def __ne__(self, value: object, /) -> bool: ...
    @overload
    def __rmul__(self, value: int, /) -> str: ...
    def __getnewargs__(self) -> tuple[str]: ...


################################################################################


class _bytes:
    @overload
    def __new__(cls, o: Iterable[int] | int | SupportsBytes | Buffer, /) -> Any: ...
    @overload
    def __new__(cls, string: str, /, encoding: str, errors: str = ...) -> Any: ...
    @overload
    def __new__(cls) -> Any: ...
    def capitalize(self) -> bytes: ...
    def center(self, width: int, fillchar: bytes = b" ", /) -> bytes: ...
    def count(
        self, sub: Buffer | int, start: int | None = ..., end: int | None = ..., /
    ) -> int: ...
    def decode(self, encoding: str = "utf-8", errors: str = "strict") -> str: ...
    def endswith(
        self, suffix: Buffer | tuple[Buffer, ...], start: int | None = ..., end: int | None = ..., /
    ) -> bool: ...
    def expandtabs(self, tabsize: int = 8) -> bytes: ...
    def find(self, sub: Buffer | int, start: int | None = ..., end: int | None = ..., /) -> int: ...
    def hex(self, sep: str | bytes = ..., bytes_per_sep: int = ...) -> str: ...
    def index(
        self, sub: Buffer | int, start: int | None = ..., end: int | None = ..., /
    ) -> int: ...
    def isalnum(self) -> bool: ...
    def isalpha(self) -> bool: ...
    def isascii(self) -> bool: ...
    def isdigit(self) -> bool: ...
    def islower(self) -> bool: ...
    def isspace(self) -> bool: ...
    def istitle(self) -> bool: ...
    def isupper(self) -> bool: ...
    def join(self, iterable_of_bytes: Iterable[Buffer], /) -> bytes: ...
    def ljust(self, width: int, fillchar: bytes | bytearray = b" ", /) -> bytes: ...
    def lower(self) -> bytes: ...
    def lstrip(self, bytes: Buffer | None = None, /) -> bytes: ...
    def partition(self, sep: Buffer, /) -> tuple[bytes, bytes, bytes]: ...
    def replace(self, old: Buffer, new: Buffer, count: int = -1, /) -> bytes: ...
    def removeprefix(self, prefix: Buffer, /) -> bytes: ...
    def removesuffix(self, suffix: Buffer, /) -> bytes: ...
    def rfind(
        self, sub: Buffer | int, start: int | None = ..., end: int | None = ..., /
    ) -> int: ...
    def rindex(
        self, sub: Buffer | int, start: int | None = ..., end: int | None = ..., /
    ) -> int: ...
    def rjust(self, width: int, fillchar: bytes | bytearray = b" ", /) -> bytes: ...
    def rpartition(self, sep: Buffer, /) -> tuple[bytes, bytes, bytes]: ...
    def rsplit(self, sep: Buffer | None = None, maxsplit: int = -1) -> list[bytes]: ...
    def rstrip(self, bytes: Buffer | None = None, /) -> bytes: ...
    def split(self, sep: Buffer | None = None, maxsplit: int = -1) -> list[bytes]: ...
    def splitlines(self, keepends: bool = False) -> list[bytes]: ...
    def startswith(
        self, prefix: Buffer | tuple[Buffer, ...], start: int | None = ..., end: int | None = ..., /
    ) -> bool: ...
    def strip(self, bytes: Buffer | None = None, /) -> bytes: ...
    def swapcase(self) -> bytes: ...
    def title(self) -> bytes: ...
    def translate(self, table: Buffer | None, /, delete: bytes = b"") -> bytes: ...
    def upper(self) -> bytes: ...
    def zfill(self, width: int, /) -> bytes: ...
    @classmethod
    def fromhex(cls, string: str, /) -> Any: ...
    @staticmethod
    def maketrans(frm: Buffer, to: Buffer, /) -> bytes: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[int]: ...
    def __hash__(self) -> int: ...
    @overload
    def __getitem__(self, key: int, /) -> int: ...
    @overload
    def __getitem__(self, key: slice, /) -> bytes: ...
    def __add__(self, value: Buffer, /) -> bytes: ...
    def __mul__(self, value: int, /) -> bytes: ...
    def __rmul__(self, value: int, /) -> bytes: ...
    def __mod__(self, value: Any, /) -> bytes: ...
    def __contains__(self, key: int | Buffer, /) -> bool: ...
    def __eq__(self, value: object, /) -> bool: ...
    def __ne__(self, value: object, /) -> bool: ...
    def __lt__(self, value: bytes, /) -> bool: ...
    def __le__(self, value: bytes, /) -> bool: ...
    def __gt__(self, value: bytes, /) -> bool: ...
    def __ge__(self, value: bytes, /) -> bool: ...
    def __getnewargs__(self) -> tuple[bytes]: ...

    if sys.version_info >= (3, 11):

        def __bytes__(self) -> bytes: ...

    def __buffer__(self, flags: int, /) -> memoryview: ...


################################################################################


class _bytearray:
    __hash__: ClassVar[None]

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, ints: Iterable[int] | int | Buffer, /) -> None: ...
    @overload
    def __init__(self, string: str, /, encoding: str, errors: str = ...) -> None: ...
    def append(self, item: int, /) -> None: ...
    def capitalize(self) -> bytearray: ...
    def center(self, width: int, fillchar: bytes = b" ", /) -> bytearray: ...
    def count(
        self, sub: Buffer | int, start: int | None = ..., end: int | None = ..., /
    ) -> int: ...
    def copy(self) -> bytearray: ...
    def decode(self, encoding: str = "utf-8", errors: str = "strict") -> str: ...
    def endswith(
        self, suffix: Buffer | tuple[Buffer, ...], start: int | None = ..., end: int | None = ..., /
    ) -> bool: ...
    def expandtabs(self, tabsize: int = 8) -> bytearray: ...
    def extend(self, iterable_of_ints: Iterable[int], /) -> None: ...
    def find(self, sub: Buffer | int, start: int | None = ..., end: int | None = ..., /) -> int: ...
    def hex(self, sep: str | bytes = ..., bytes_per_sep: int = ...) -> str: ...
    def index(
        self, sub: Buffer | int, start: int | None = ..., end: int | None = ..., /
    ) -> int: ...
    def insert(self, index: int, item: int, /) -> None: ...
    def isalnum(self) -> bool: ...
    def isalpha(self) -> bool: ...
    def isascii(self) -> bool: ...
    def isdigit(self) -> bool: ...
    def islower(self) -> bool: ...
    def isspace(self) -> bool: ...
    def istitle(self) -> bool: ...
    def isupper(self) -> bool: ...
    def join(self, iterable_of_bytes: Iterable[Buffer], /) -> bytearray: ...
    def ljust(self, width: int, fillchar: bytes | bytearray = b" ", /) -> bytearray: ...
    def lower(self) -> bytearray: ...
    def lstrip(self, bytes: Buffer | None = None, /) -> bytearray: ...
    def partition(self, sep: Buffer, /) -> tuple[bytearray, bytearray, bytearray]: ...
    def pop(self, index: int = -1, /) -> int: ...
    def remove(self, value: int, /) -> None: ...
    def removeprefix(self, prefix: Buffer, /) -> bytearray: ...
    def removesuffix(self, suffix: Buffer, /) -> bytearray: ...
    def replace(self, old: Buffer, new: Buffer, count: int = -1, /) -> bytearray: ...
    def rfind(
        self, sub: Buffer | int, start: int | None = ..., end: int | None = ..., /
    ) -> int: ...
    def rindex(
        self, sub: Buffer | int, start: int | None = ..., end: int | None = ..., /
    ) -> int: ...
    def rjust(self, width: int, fillchar: bytes | bytearray = b" ", /) -> bytearray: ...
    def rpartition(self, sep: Buffer, /) -> tuple[bytearray, bytearray, bytearray]: ...
    def rsplit(self, sep: Buffer | None = None, maxsplit: int = -1) -> list[bytearray]: ...
    def rstrip(self, bytes: Buffer | None = None, /) -> bytearray: ...
    def split(self, sep: Buffer | None = None, maxsplit: int = -1) -> list[bytearray]: ...
    def splitlines(self, keepends: bool = False) -> list[bytearray]: ...
    def startswith(
        self, prefix: Buffer | tuple[Buffer, ...], start: int | None = ..., end: int | None = ..., /
    ) -> bool: ...
    def strip(self, bytes: Buffer | None = None, /) -> bytearray: ...
    def swapcase(self) -> bytearray: ...
    def title(self) -> bytearray: ...
    def translate(self, table: Buffer | None, /, delete: bytes = b"") -> bytearray: ...
    def upper(self) -> bytearray: ...
    def zfill(self, width: int, /) -> bytearray: ...
    @classmethod
    def fromhex(cls, string: str, /) -> Any: ...
    @staticmethod
    def maketrans(frm: Buffer, to: Buffer, /) -> bytes: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[int]: ...
    @overload
    def __getitem__(self, key: int, /) -> int: ...
    @overload
    def __getitem__(self, key: slice, /) -> bytearray: ...
    @overload
    def __setitem__(self, key: int, value: int, /) -> None: ...
    @overload
    def __setitem__(self, key: slice, value: Iterable[int] | bytes, /) -> None: ...
    def __delitem__(self, key: int | slice, /) -> None: ...
    def __add__(self, value: Buffer, /) -> bytearray: ...
    def __iadd__(self, value: Buffer, /) -> Any: ...
    def __mul__(self, value: int, /) -> bytearray: ...
    def __rmul__(self, value: int, /) -> bytearray: ...
    def __imul__(self, value: int, /) -> Any: ...
    def __mod__(self, value: Any, /) -> bytes: ...
    def __contains__(self, key: int | Buffer, /) -> bool: ...
    def __eq__(self, value: object, /) -> bool: ...
    def __ne__(self, value: object, /) -> bool: ...
    def __lt__(self, value: Buffer, /) -> bool: ...
    def __le__(self, value: Buffer, /) -> bool: ...
    def __gt__(self, value: Buffer, /) -> bool: ...
    def __ge__(self, value: Buffer, /) -> bool: ...
    def __alloc__(self) -> int: ...
    def __buffer__(self, flags: int, /) -> memoryview: ...
    def __release_buffer__(self, buffer: memoryview, /) -> None: ...

    if sys.version_info >= (3, 14):

        def resize(self, size: int, /) -> None: ...


################################################################################


class _memoryview:
    index: ClassVar[None]
    count: ClassVar[None]

    @property
    def format(self) -> str: ...
    @property
    def itemsize(self) -> int: ...
    @property
    def shape(self) -> tuple[int, ...] | None: ...
    @property
    def strides(self) -> tuple[int, ...] | None: ...
    @property
    def suboffsets(self) -> tuple[int, ...] | None: ...
    @property
    def readonly(self) -> bool: ...
    @property
    def ndim(self) -> int: ...
    @property
    def obj(self) -> Buffer: ...
    @property
    def c_contiguous(self) -> bool: ...
    @property
    def f_contiguous(self) -> bool: ...
    @property
    def contiguous(self) -> bool: ...
    @property
    def nbytes(self) -> int: ...
    def __new__(cls, obj: Buffer) -> Any: ...
    def __enter__(self) -> Any: ...
    def __exit__(
        self,
        exc_type: type[BaseException] | None,
        exc_val: BaseException | None,
        exc_tb: TracebackType | None,
        /,
    ) -> None: ...
    @overload
    def cast(
        self, format: Literal["c", "@c"], shape: list[int] | tuple[int, ...] = ...
    ) -> memoryview: ...
    @overload
    def cast(
        self, format: Literal["f", "@f", "d", "@d"], shape: list[int] | tuple[int, ...] = ...
    ) -> memoryview: ...
    @overload
    def cast(
        self, format: Literal["?"], shape: list[int] | tuple[int, ...] = ...
    ) -> memoryview: ...
    @overload
    def cast(
        self,
        format: Literal[
            "b",
            "B",
            "@b",
            "@B",
            "h",
            "H",
            "@h",
            "@H",
            "i",
            "I",
            "@i",
            "@I",
            "l",
            "L",
            "@l",
            "@L",
            "q",
            "Q",
            "@q",
            "@Q",
            "P",
            "@P",
        ],
        shape: list[int] | tuple[int, ...] = ...,
    ) -> memoryview: ...
    @overload
    def __getitem__(self, key: int | tuple[int, ...], /) -> Any: ...
    @overload
    def __getitem__(self, key: slice, /) -> memoryview: ...
    def __contains__(self, x: object, /) -> bool: ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...
    def __eq__(self, value: object, /) -> bool: ...
    def __hash__(self) -> int: ...
    @overload
    def __setitem__(self, key: slice, value: Buffer, /) -> None: ...
    @overload
    def __setitem__(self, key: int | tuple[int, ...], value: Any, /) -> None: ...

    if sys.version_info >= (3, 10):

        def tobytes(self, order: Literal["C", "F", "A"] | None = "C") -> bytes: ...
    else:

        def tobytes(self, order: Literal["C", "F", "A"] | None = None) -> bytes: ...

    def tolist(self) -> list[int]: ...
    def toreadonly(self) -> memoryview: ...
    def release(self) -> None: ...
    def hex(self, sep: str | bytes = ..., bytes_per_sep: int = ...) -> str: ...
    def __buffer__(self, flags: int, /) -> memoryview: ...
    def __release_buffer__(self, buffer: memoryview, /) -> None: ...

    if sys.version_info >= (3, 14):

        def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...


################################################################################


class _bool:
    def __new__(cls, o: object = ..., /) -> Any: ...
    @overload
    def __and__(self, value: bool, /) -> bool: ...
    @overload
    def __and__(self, value: int, /) -> int: ...
    @overload
    def __or__(self, value: bool, /) -> bool: ...
    @overload
    def __or__(self, value: int, /) -> int: ...
    @overload
    def __xor__(self, value: bool, /) -> bool: ...
    @overload
    def __xor__(self, value: int, /) -> int: ...
    @overload
    def __rand__(self, value: bool, /) -> bool: ...
    @overload
    def __rand__(self, value: int, /) -> int: ...
    @overload
    def __ror__(self, value: bool, /) -> bool: ...
    @overload
    def __ror__(self, value: int, /) -> int: ...
    @overload
    def __rxor__(self, value: bool, /) -> bool: ...
    @overload
    def __rxor__(self, value: int, /) -> int: ...
    def __getnewargs__(self) -> tuple[int]: ...
    def __invert__(self) -> int: ...


################################################################################


class _slice:
    @property
    def start(self) -> Any: ...
    @property
    def step(self) -> Any: ...
    @property
    def stop(self) -> Any: ...
    @overload
    def __new__(cls, start: None, stop: None = None, step: None = None, /) -> slice: ...
    @overload
    def __new__(cls, stop: Any, /) -> slice: ...
    @overload
    def __new__(cls, start: Any, stop: None, step: None = None, /) -> slice: ...
    @overload
    def __new__(cls, start: None, stop: Any, step: None = None, /) -> slice: ...
    @overload
    def __new__(cls, start: Any, stop: Any, step: None = None, /) -> slice: ...
    @overload
    def __new__(cls, start: None, stop: None, step: Any, /) -> slice: ...
    @overload
    def __new__(cls, start: Any, stop: None, step: Any, /) -> slice: ...
    @overload
    def __new__(cls, start: None, stop: Any, step: Any, /) -> slice: ...
    @overload
    def __new__(cls, start: Any, stop: Any, step: Any, /) -> slice: ...
    def __eq__(self, value: object, /) -> bool: ...

    if sys.version_info >= (3, 12):

        def __hash__(self) -> int: ...
    else:
        __hash__: ClassVar[None]

    def indices(self, len: int, /) -> tuple[int, int, int]: ...


################################################################################


class _tuple:
    def __new__(cls, iterable: Iterable = ..., /) -> Any: ...
    def __len__(self) -> int: ...
    def __contains__(self, key: object, /) -> bool: ...
    @overload
    def __getitem__(self, key: int, /) -> Any: ...
    @overload
    def __getitem__(self, key: slice, /) -> tuple: ...
    def __iter__(self) -> Iterator: ...
    def __lt__(self, value: tuple, /) -> bool: ...
    def __le__(self, value: tuple, /) -> bool: ...
    def __gt__(self, value: tuple, /) -> bool: ...
    def __ge__(self, value: tuple, /) -> bool: ...
    def __eq__(self, value: object, /) -> bool: ...
    def __hash__(self) -> int: ...
    @overload
    def __add__(self, value: tuple, /) -> tuple: ...
    @overload
    def __add__(self, value: tuple, /) -> tuple: ...
    def __mul__(self, value: int, /) -> tuple: ...
    def __rmul__(self, value: int, /) -> tuple: ...
    def count(self, value: Any, /) -> int: ...
    def index(self, value: Any, start: int = 0, stop: int = sys.maxsize, /) -> int: ...
    def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...


################################################################################


class FunctionType:
    __code__: CodeType
    __defaults__: tuple | None
    __dict__: dict[str, Any]
    __name__: str
    __qualname__: str
    __annotations__: dict[str, Any]
    __kwdefaults__: dict[str, Any] | None
    __module__: str

    @property
    def __closure__(self) -> tuple | None: ...
    @property
    def __globals__(self) -> dict[str, Any]: ...

    if sys.version_info >= (3, 14):
        __annotate__: AnnotateFunc | None
    if sys.version_info >= (3, 10):

        @property
        def __builtins__(self) -> dict[str, Any]: ...

    if sys.version_info >= (3, 12):
        __type_params__: tuple
    if sys.version_info >= (3, 13):

        def __new__(
            cls,
            code: CodeType,
            globals: dict[str, Any],
            name: str | None = None,
            argdefs: tuple | None = None,
            closure: tuple | None = None,
            kwdefaults: dict[str, object] | None = None,
        ) -> Any: ...
    else:

        def __new__(
            cls,
            code: CodeType,
            globals: dict[str, Any],
            name: str | None = None,
            argdefs: tuple | None = None,
            closure: tuple | None = None,
        ) -> Any: ...

    def __get__(self, instance: object, owner: type | None = None, /) -> Any: ...


################################################################################


class _list:
    __hash__: ClassVar[None]

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, iterable: Iterable, /) -> None: ...
    def copy(self) -> list: ...
    def append(self, object: Any, /) -> None: ...
    def extend(self, iterable: Iterable, /) -> None: ...
    def pop(self, index: int = -1, /) -> Any: ...
    def index(self, value: Any, start: int = 0, stop: int = sys.maxsize, /) -> int: ...
    def count(self, value: Any, /) -> int: ...
    def insert(self, index: int, object: Any, /) -> None: ...
    def remove(self, value: Any, /) -> None: ...
    @overload
    def sort(self: list, *, key: None = None, reverse: bool = False) -> None: ...
    @overload
    def sort(
        self, *, key: Callable[[Any], SupportsDunderLT | SupportsDunderGT], reverse: bool = False
    ) -> None: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator: ...
    @overload
    def __getitem__(self, i: int, /) -> Any: ...
    @overload
    def __getitem__(self, s: slice, /) -> list: ...
    @overload
    def __setitem__(self, key: int, value: Any, /) -> None: ...
    @overload
    def __setitem__(self, key: slice, value: Iterable, /) -> None: ...
    def __delitem__(self, key: int | slice, /) -> None: ...
    @overload
    def __add__(self, value: list, /) -> list: ...
    @overload
    def __add__(self, value: list, /) -> list: ...
    def __iadd__(self, value: Iterable, /) -> Any: ...
    def __mul__(self, value: int, /) -> list: ...
    def __rmul__(self, value: int, /) -> list: ...
    def __imul__(self, value: int, /) -> Any: ...
    def __contains__(self, key: object, /) -> bool: ...
    def __reversed__(self) -> Iterator: ...
    def __gt__(self, value: list, /) -> bool: ...
    def __ge__(self, value: list, /) -> bool: ...
    def __lt__(self, value: list, /) -> bool: ...
    def __le__(self, value: list, /) -> bool: ...
    def __eq__(self, value: object, /) -> bool: ...
    def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...


################################################################################


class _dict:
    __hash__: ClassVar[None]

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self: dict, **kwargs: Any) -> None: ...  # pyright: ignore[reportInvalidTypeVarUse]  #11780
    @overload
    def __init__(self, map: SupportsKeysAndGetItem, /) -> None: ...
    @overload
    def __init__(
        self: dict,  # pyright: ignore[reportInvalidTypeVarUse]  #11780
        map: SupportsKeysAndGetItem,
        /,
        **kwargs: Any,
    ) -> None: ...
    @overload
    def __init__(self, iterable: Iterable, /) -> None: ...
    @overload
    def __init__(
        self: dict,  # pyright: ignore[reportInvalidTypeVarUse]  #11780
        iterable: Iterable,
        /,
        **kwargs: Any,
    ) -> None: ...
    @overload
    def __init__(self: dict, iterable: Iterable[list], /) -> None: ...
    @overload
    def __init__(self: dict, iterable: Iterable[list], /) -> None: ...
    def __new__(cls, *args: Any, **kwargs: Any) -> Any: ...
    def copy(self) -> dict: ...
    def keys(self) -> dict_keys: ...
    def values(self) -> dict_values: ...
    def items(self) -> dict_items: ...
    @classmethod
    @overload
    def fromkeys(cls, iterable: Iterable, value: None = None, /) -> dict: ...
    @classmethod
    @overload
    def fromkeys(cls, iterable: Iterable, value: Any, /) -> dict: ...
    @overload
    def get(self, key: Any, default: None = None, /) -> Any: ...
    @overload
    def get(self, key: Any, default: Any, /) -> Any: ...
    @overload
    def get(self, key: Any, default: Any, /) -> Any: ...
    @overload
    def pop(self, key: Any, /) -> Any: ...
    @overload
    def pop(self, key: Any, default: Any, /) -> Any: ...
    @overload
    def pop(self, key: Any, default: Any, /) -> Any: ...
    def __len__(self) -> int: ...
    def __getitem__(self, key: Any, /) -> Any: ...
    def __setitem__(self, key: Any, value: Any, /) -> None: ...
    def __delitem__(self, key: Any, /) -> None: ...
    def __iter__(self) -> Iterator: ...
    def __eq__(self, value: object, /) -> bool: ...
    def __reversed__(self) -> Iterator: ...
    def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...
    @overload
    def __or__(self, value: dict, /) -> dict: ...
    @overload
    def __or__(self, value: dict, /) -> dict: ...
    @overload
    def __ror__(self, value: dict, /) -> dict: ...
    @overload
    def __ror__(self, value: dict, /) -> dict: ...
    @overload
    def __ior__(self, value: SupportsKeysAndGetItem, /) -> Any: ...
    @overload
    def __ior__(self, value: Iterable, /) -> Any: ...


################################################################################


class _set:
    __hash__: ClassVar[None]

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, iterable: Iterable, /) -> None: ...
    def add(self, element: Any, /) -> None: ...
    def copy(self) -> set: ...
    def difference(self, *s: Iterable) -> set: ...
    def difference_update(self, *s: Iterable) -> None: ...
    def discard(self, element: Any, /) -> None: ...
    def intersection(self, *s: Iterable) -> set: ...
    def intersection_update(self, *s: Iterable) -> None: ...
    def isdisjoint(self, s: Iterable, /) -> bool: ...
    def issubset(self, s: Iterable, /) -> bool: ...
    def issuperset(self, s: Iterable, /) -> bool: ...
    def remove(self, element: Any, /) -> None: ...
    def symmetric_difference(self, s: Iterable, /) -> set: ...
    def symmetric_difference_update(self, s: Iterable, /) -> None: ...
    def union(self, *s: Iterable) -> set: ...
    def update(self, *s: Iterable) -> None: ...
    def __len__(self) -> int: ...
    def __contains__(self, o: object, /) -> bool: ...
    def __iter__(self) -> Iterator: ...
    def __and__(self, value: AbstractSet, /) -> set: ...
    def __iand__(self, value: AbstractSet, /) -> Any: ...
    def __or__(self, value: AbstractSet, /) -> set: ...
    def __ior__(self, value: AbstractSet, /) -> Any: ...
    def __sub__(self, value: AbstractSet, /) -> set: ...
    def __isub__(self, value: AbstractSet, /) -> Any: ...
    def __xor__(self, value: AbstractSet, /) -> set: ...
    def __ixor__(self, value: AbstractSet, /) -> Any: ...
    def __le__(self, value: AbstractSet, /) -> bool: ...
    def __lt__(self, value: AbstractSet, /) -> bool: ...
    def __ge__(self, value: AbstractSet, /) -> bool: ...
    def __gt__(self, value: AbstractSet, /) -> bool: ...
    def __eq__(self, value: object, /) -> bool: ...
    def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...


################################################################################


class _frozenset:
    @overload
    def __new__(cls) -> Any: ...
    @overload
    def __new__(cls, iterable: Iterable, /) -> Any: ...
    def copy(self) -> frozenset: ...
    def difference(self, *s: Iterable) -> frozenset: ...
    def intersection(self, *s: Iterable) -> frozenset: ...
    def isdisjoint(self, s: Iterable, /) -> bool: ...
    def issubset(self, s: Iterable, /) -> bool: ...
    def issuperset(self, s: Iterable, /) -> bool: ...
    def symmetric_difference(self, s: Iterable, /) -> frozenset: ...
    def union(self, *s: Iterable) -> frozenset: ...
    def __len__(self) -> int: ...
    def __contains__(self, o: object, /) -> bool: ...
    def __iter__(self) -> Iterator: ...
    def __and__(self, value: AbstractSet, /) -> frozenset: ...
    def __or__(self, value: AbstractSet, /) -> frozenset: ...
    def __sub__(self, value: AbstractSet, /) -> frozenset: ...
    def __xor__(self, value: AbstractSet, /) -> frozenset: ...
    def __le__(self, value: AbstractSet, /) -> bool: ...
    def __lt__(self, value: AbstractSet, /) -> bool: ...
    def __ge__(self, value: AbstractSet, /) -> bool: ...
    def __gt__(self, value: AbstractSet, /) -> bool: ...
    def __eq__(self, value: object, /) -> bool: ...
    def __hash__(self) -> int: ...
    def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...


################################################################################


class _enumerate:
    def __new__(cls, iterable: Iterable, start: int = 0) -> Any: ...
    def __iter__(self) -> Any: ...
    def __next__(self) -> tuple: ...
    def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...


################################################################################


class _range:
    @property
    def start(self) -> int: ...
    @property
    def stop(self) -> int: ...
    @property
    def step(self) -> int: ...
    @overload
    def __new__(cls, stop: int, /) -> Any: ...
    @overload
    def __new__(cls, start: int, stop: int, step: int = ..., /) -> Any: ...
    def count(self, value: int, /) -> int: ...
    def index(self, value: int, /) -> int: ...
    def __len__(self) -> int: ...
    def __eq__(self, value: object, /) -> bool: ...
    def __hash__(self) -> int: ...
    def __contains__(self, key: object, /) -> bool: ...
    def __iter__(self) -> Iterator[int]: ...
    @overload
    def __getitem__(self, key: int, /) -> int: ...
    @overload
    def __getitem__(self, key: slice, /) -> range: ...
    def __reversed__(self) -> Iterator[int]: ...


################################################################################


class _property:
    fget: Callable[[Any], Any] | None
    fset: Callable[[Any, Any], None] | None
    fdel: Callable[[Any], None] | None
    __isabstractmethod__: bool
    if sys.version_info >= (3, 13):
        __name__: str

    def __init__(
        self,
        fget: Callable[[Any], Any] | None = ...,
        fset: Callable[[Any, Any], None] | None = ...,
        fdel: Callable[[Any], None] | None = ...,
        doc: str | None = ...,
    ) -> None: ...
    def getter(self, fget: Callable[[Any], Any], /) -> property: ...
    def setter(self, fset: Callable[[Any, Any], None], /) -> property: ...
    def deleter(self, fdel: Callable[[Any], None], /) -> property: ...
    @overload
    def __get__(self, instance: None, owner: type, /) -> Any: ...
    @overload
    def __get__(self, instance: Any, owner: type | None = None, /) -> Any: ...
    def __set__(self, instance: Any, value: Any, /) -> None: ...
    def __delete__(self, instance: Any, /) -> None: ...


################################################################################


class _NotImplementedType:
    __call__: None


################################################################################


class _filter:
    @overload
    def __new__(cls, function: None, iterable: Iterable, /) -> Any: ...
    @overload
    def __new__(cls, function: Callable[[Any], bool], iterable: Iterable, /) -> Any: ...
    @overload
    def __new__(cls, function: Callable[[Any], bool], iterable: Iterable, /) -> Any: ...
    @overload
    def __new__(cls, function: Callable[[Any], Any], iterable: Iterable, /) -> Any: ...
    def __iter__(self) -> Any: ...
    def __next__(self) -> Any: ...


################################################################################


class _GetItemIterable:
    def __getitem__(self, i: int, /) -> Any: ...


################################################################################


class _map:
    if sys.version_info >= (3, 14):

        @overload
        def __new__(
            cls, func: Callable[[Any], Any], iterable: Iterable, /, *, strict: bool = False
        ) -> Any: ...
        @overload
        def __new__(
            cls,
            func: Callable[[Any, Any], Any],
            iterable: Iterable,
            iter2: Iterable,
            /,
            *,
            strict: bool = False,
        ) -> Any: ...
        @overload
        def __new__(
            cls,
            func: Callable[[Any, Any, Any], Any],
            iterable: Iterable,
            iter2: Iterable,
            iter3: Iterable,
            /,
            *,
            strict: bool = False,
        ) -> Any: ...
        @overload
        def __new__(
            cls,
            func: Callable[[Any, Any, Any, Any], Any],
            iterable: Iterable,
            iter2: Iterable,
            iter3: Iterable,
            iter4: Iterable,
            /,
            *,
            strict: bool = False,
        ) -> Any: ...
        @overload
        def __new__(
            cls,
            func: Callable[[Any, Any, Any, Any, Any], Any],
            iterable: Iterable,
            iter2: Iterable,
            iter3: Iterable,
            iter4: Iterable,
            iter5: Iterable,
            /,
            *,
            strict: bool = False,
        ) -> Any: ...
        @overload
        def __new__(
            cls,
            func: Callable,
            iterable: Iterable,
            iter2: Iterable,
            iter3: Iterable,
            iter4: Iterable,
            iter5: Iterable,
            iter6: Iterable,
            /,
            *iterables: Iterable,
            strict: bool = False,
        ) -> Any: ...
    else:

        @overload
        def __new__(cls, func: Callable[[Any], Any], iterable: Iterable, /) -> Any: ...
        @overload
        def __new__(
            cls, func: Callable[[Any, Any], Any], iterable: Iterable, iter2: Iterable, /
        ) -> Any: ...
        @overload
        def __new__(
            cls,
            func: Callable[[Any, Any, Any], Any],
            iterable: Iterable,
            iter2: Iterable,
            iter3: Iterable,
            /,
        ) -> Any: ...
        @overload
        def __new__(
            cls,
            func: Callable[[Any, Any, Any, Any], Any],
            iterable: Iterable,
            iter2: Iterable,
            iter3: Iterable,
            iter4: Iterable,
            /,
        ) -> Any: ...
        @overload
        def __new__(
            cls,
            func: Callable[[Any, Any, Any, Any, Any], Any],
            iterable: Iterable,
            iter2: Iterable,
            iter3: Iterable,
            iter4: Iterable,
            iter5: Iterable,
            /,
        ) -> Any: ...
        @overload
        def __new__(
            cls,
            func: Callable,
            iterable: Iterable,
            iter2: Iterable,
            iter3: Iterable,
            iter4: Iterable,
            iter5: Iterable,
            iter6: Iterable,
            /,
            *iterables: Iterable,
        ) -> Any: ...

    def __iter__(self) -> Any: ...
    def __next__(self) -> Any: ...


################################################################################


class _SupportsWriteAndFlush:
    pass


################################################################################


class _SupportsPow2:
    def __pow__(self, other: Any, /) -> Any: ...


################################################################################


class _SupportsPow3NoneOnly:
    def __pow__(self, other: Any, modulo: None = None, /) -> Any: ...


################################################################################


class _SupportsPow3:
    def __pow__(self, other: Any, modulo: Any, /) -> Any: ...


################################################################################


class _reversed:
    @overload
    def __new__(cls, sequence: Reversible, /) -> Iterator: ...
    @overload
    def __new__(cls, sequence: SupportsLenAndGetItem, /) -> Iterator: ...
    def __iter__(self) -> Any: ...
    def __next__(self) -> Any: ...
    def __length_hint__(self) -> int: ...


################################################################################


class _SupportsRound1:
    def __round__(self) -> Any: ...


################################################################################


class _SupportsRound2:
    def __round__(self, ndigits: int, /) -> Any: ...


################################################################################


class _SupportsSumWithNoDefaultGiven:
    pass


################################################################################


class _BaseException:
    args: tuple
    __cause__: BaseException | None
    __context__: BaseException | None
    __suppress_context__: bool
    __traceback__: TracebackType | None

    def __init__(self, *args: object) -> None: ...
    def __new__(cls, *args: Any, **kwds: Any) -> Any: ...
    def __setstate__(self, state: dict | None, /) -> None: ...
    def with_traceback(self, tb: TracebackType | None, /) -> Any: ...

    if sys.version_info >= (3, 11):
        # only present after add_note() is called
        __notes__: list

        def add_note(self, note: str, /) -> None: ...


################################################################################


class _GeneratorExit:
    pass


################################################################################


class _KeyboardInterrupt:
    pass


################################################################################


class _SystemExit:
    code: int


################################################################################


class _Exception:
    pass


################################################################################


class _StopIteration:
    value: Any


################################################################################


class _StopAsyncIteration:
    pass


################################################################################


def _abs(x: SupportsAbs, /) -> Any: ...


def _all(iterable: Iterable, /) -> bool: ...


def _any(iterable: Iterable, /) -> bool: ...


def _ascii(obj: object, /) -> str: ...


def _bin(number: int | int, /) -> str: ...


def _breakpoint(*args: Any, **kws: Any) -> None: ...


def _callable(obj: object, /) -> bool: ...


def _chr(i: int | int, /) -> str: ...


@overload
def _compile(
    source: str | Buffer | ast.AST | ast.AST | ast.AST,
    filename: str | Buffer | PathLike,
    mode: str,
    flags: Literal[0],
    dont_inherit: bool = False,
    optimize: int = -1,
    *,
    _feature_version: int = -1,
) -> CodeType: ...


@overload
def _compile(
    source: str | Buffer | ast.AST | ast.AST | ast.AST,
    filename: str | Buffer | PathLike,
    mode: str,
    *,
    dont_inherit: bool = False,
    optimize: int = -1,
    _feature_version: int = -1,
) -> CodeType: ...


@overload
def _compile(
    source: str | Buffer | ast.AST | ast.AST | ast.AST,
    filename: str | Buffer | PathLike,
    mode: str,
    flags: Literal[1024],
    dont_inherit: bool = False,
    optimize: int = -1,
    *,
    _feature_version: int = -1,
) -> ast.AST: ...


@overload
def _compile(
    source: str | Buffer | ast.AST | ast.AST | ast.AST,
    filename: str | Buffer | PathLike,
    mode: str,
    flags: int,
    dont_inherit: bool = False,
    optimize: int = -1,
    *,
    _feature_version: int = -1,
) -> Any: ...


def _delattr(obj: object, name: str, /) -> None: ...


def _dir(o: object = ..., /) -> list: ...


@overload
def _divmod(x: SupportsDivMod, y: Any, /) -> Any: ...


@overload
def _divmod(x: Any, y: SupportsRDivMod, /) -> Any: ...


def _format(value: object, format_spec: str = "", /) -> str: ...


@overload
def _getattr(o: object, name: str, /) -> Any: ...


@overload
def _getattr(o: object, name: str, default: None, /) -> Any: ...


@overload
def _getattr(o: object, name: str, default: bool, /) -> Any | bool: ...


@overload
def _getattr(o: object, name: str, default: list, /) -> Any | list: ...


@overload
def _getattr(o: object, name: str, default: dict, /) -> Any | dict: ...


@overload
def _getattr(o: object, name: str, default: Any, /) -> Any: ...


def _globals() -> dict: ...


def _hasattr(obj: object, name: str, /) -> bool: ...


def _hash(obj: object, /) -> int: ...


def _hex(number: int | int, /) -> str: ...


def _id(obj: object, /) -> int: ...


def _input(prompt: object = "", /) -> str: ...


@overload
def _iter(object: SupportsIter, /) -> Any: ...


@overload
def _iter(object: _GetItemIterable, /) -> Iterator: ...


@overload
def _iter(object: Callable[[], Any], sentinel: None, /) -> Iterator: ...


@overload
def _iter(object: Callable[[], Any], sentinel: object, /) -> Iterator: ...


def _isinstance(obj: object, class_or_tuple: type | tuple, /) -> bool: ...


def _issubclass(cls: type, class_or_tuple: type | tuple, /) -> bool: ...


def _len(obj: Sized, /) -> int: ...


def _locals() -> dict: ...


@overload
def _max(arg1: Any, arg2: Any, /, *_args: Any, key: None = None) -> Any: ...


@overload
def _max(
    arg1: Any, arg2: Any, /, *_args: Any, key: Callable[[Any], SupportsDunderLT | SupportsDunderGT]
) -> Any: ...


@overload
def _max(iterable: Iterable, /, *, key: None = None) -> Any: ...


@overload
def _max(
    iterable: Iterable, /, *, key: Callable[[Any], SupportsDunderLT | SupportsDunderGT]
) -> Any: ...


@overload
def _max(iterable: Iterable, /, *, key: None = None, default: Any) -> Any: ...


@overload
def _max(
    iterable: Iterable,
    /,
    *,
    key: Callable[[Any], SupportsDunderLT | SupportsDunderGT],
    default: Any,
) -> Any: ...


@overload
def _min(arg1: Any, arg2: Any, /, *_args: Any, key: None = None) -> Any: ...


@overload
def _min(
    arg1: Any, arg2: Any, /, *_args: Any, key: Callable[[Any], SupportsDunderLT | SupportsDunderGT]
) -> Any: ...


@overload
def _min(iterable: Iterable, /, *, key: None = None) -> Any: ...


@overload
def _min(
    iterable: Iterable, /, *, key: Callable[[Any], SupportsDunderLT | SupportsDunderGT]
) -> Any: ...


@overload
def _min(iterable: Iterable, /, *, key: None = None, default: Any) -> Any: ...


@overload
def _min(
    iterable: Iterable,
    /,
    *,
    key: Callable[[Any], SupportsDunderLT | SupportsDunderGT],
    default: Any,
) -> Any: ...


@overload
def _next(i: SupportsNext, /) -> Any: ...


@overload
def _next(i: SupportsNext, default: Any, /) -> Any: ...


def _oct(number: int | int, /) -> str: ...


@overload
def _open(
    file: int | str | bytes | PathLike[str] | PathLike[bytes],
    mode: Literal[
        "r+",
        "+r",
        "rt+",
        "r+t",
        "+rt",
        "tr+",
        "t+r",
        "+tr",
        "w+",
        "+w",
        "wt+",
        "w+t",
        "+wt",
        "tw+",
        "t+w",
        "+tw",
        "a+",
        "+a",
        "at+",
        "a+t",
        "+at",
        "ta+",
        "t+a",
        "+ta",
        "x+",
        "+x",
        "xt+",
        "x+t",
        "+xt",
        "tx+",
        "t+x",
        "+tx",
    ]
    | Literal["w", "wt", "tw", "a", "at", "ta", "x", "xt", "tx"]
    | Literal["r", "rt", "tr", "U", "rU", "Ur", "rtU", "rUt", "Urt", "trU", "tUr", "Utr"] = "r",
    buffering: int = -1,
    encoding: str | None = None,
    errors: str | None = None,
    newline: str | None = None,
    closefd: bool = True,
    opener: Callable[[str, int], int] | None = None,
) -> TextIOWrapper: ...


@overload
def _open(
    file: int | str | bytes | PathLike[str] | PathLike[bytes],
    mode: Literal[
        "rb+",
        "r+b",
        "+rb",
        "br+",
        "b+r",
        "+br",
        "wb+",
        "w+b",
        "+wb",
        "bw+",
        "b+w",
        "+bw",
        "ab+",
        "a+b",
        "+ab",
        "ba+",
        "b+a",
        "+ba",
        "xb+",
        "x+b",
        "+xb",
        "bx+",
        "b+x",
        "+bx",
    ]
    | Literal["rb", "br", "rbU", "rUb", "Urb", "brU", "bUr", "Ubr"]
    | Literal["wb", "bw", "ab", "ba", "xb", "bx"],
    buffering: Literal[0],
    encoding: None = None,
    errors: None = None,
    newline: None = None,
    closefd: bool = True,
    opener: Callable[[str, int], int] | None = None,
) -> FileIO: ...


@overload
def _open(
    file: int | str | bytes | PathLike[str] | PathLike[bytes],
    mode: Literal[
        "rb+",
        "r+b",
        "+rb",
        "br+",
        "b+r",
        "+br",
        "wb+",
        "w+b",
        "+wb",
        "bw+",
        "b+w",
        "+bw",
        "ab+",
        "a+b",
        "+ab",
        "ba+",
        "b+a",
        "+ba",
        "xb+",
        "x+b",
        "+xb",
        "bx+",
        "b+x",
        "+bx",
    ],
    buffering: Literal[-1, 1] = -1,
    encoding: None = None,
    errors: None = None,
    newline: None = None,
    closefd: bool = True,
    opener: Callable[[str, int], int] | None = None,
) -> BufferedRandom: ...


@overload
def _open(
    file: int | str | bytes | PathLike[str] | PathLike[bytes],
    mode: Literal["wb", "bw", "ab", "ba", "xb", "bx"],
    buffering: Literal[-1, 1] = -1,
    encoding: None = None,
    errors: None = None,
    newline: None = None,
    closefd: bool = True,
    opener: Callable[[str, int], int] | None = None,
) -> BufferedWriter: ...


@overload
def _open(
    file: int | str | bytes | PathLike[str] | PathLike[bytes],
    mode: Literal["rb", "br", "rbU", "rUb", "Urb", "brU", "bUr", "Ubr"],
    buffering: Literal[-1, 1] = -1,
    encoding: None = None,
    errors: None = None,
    newline: None = None,
    closefd: bool = True,
    opener: Callable[[str, int], int] | None = None,
) -> BufferedReader: ...


@overload
def _open(
    file: int | str | bytes | PathLike[str] | PathLike[bytes],
    mode: Literal[
        "rb+",
        "r+b",
        "+rb",
        "br+",
        "b+r",
        "+br",
        "wb+",
        "w+b",
        "+wb",
        "bw+",
        "b+w",
        "+bw",
        "ab+",
        "a+b",
        "+ab",
        "ba+",
        "b+a",
        "+ba",
        "xb+",
        "x+b",
        "+xb",
        "bx+",
        "b+x",
        "+bx",
    ]
    | Literal["rb", "br", "rbU", "rUb", "Urb", "brU", "bUr", "Ubr"]
    | Literal["wb", "bw", "ab", "ba", "xb", "bx"],
    buffering: int = -1,
    encoding: None = None,
    errors: None = None,
    newline: None = None,
    closefd: bool = True,
    opener: Callable[[str, int], int] | None = None,
) -> BinaryIO: ...


@overload
def _open(
    file: int | str | bytes | PathLike[str] | PathLike[bytes],
    mode: str,
    buffering: int = -1,
    encoding: str | None = None,
    errors: str | None = None,
    newline: str | None = None,
    closefd: bool = True,
    opener: Callable[[str, int], int] | None = None,
) -> IO[Any]: ...


def _ord(c: str | bytes | bytearray, /) -> int: ...


@overload
def _print(
    *values: object,
    sep: str | None = " ",
    end: str | None = "\n",
    file: SupportsWrite | None = None,
    flush: Literal[False] = False,
) -> None: ...


@overload
def _print(
    *values: object,
    sep: str | None = " ",
    end: str | None = "\n",
    file: _SupportsWriteAndFlush | None = None,
    flush: bool,
) -> None: ...


@overload
def _pow(base: int, exp: int, mod: int) -> int: ...


@overload
def _pow(base: int, exp: Literal[0], mod: None = None) -> Literal[1]: ...


@overload
def _pow(
    base: int,
    exp: Literal[
        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25
    ],
    mod: None = None,
) -> int: ...


@overload
def _pow(
    base: int,
    exp: Literal[
        -1, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, -12, -13, -14, -15, -16, -17, -18, -19, -20
    ],
    mod: None = None,
) -> float: ...


@overload
def _pow(base: int, exp: int, mod: None = None) -> Any: ...


@overload
def _pow(
    base: Literal[
        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25
    ],
    exp: float,
    mod: None = None,
) -> float: ...


@overload
def _pow(
    base: Literal[
        -1, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, -12, -13, -14, -15, -16, -17, -18, -19, -20
    ],
    exp: float,
    mod: None = None,
) -> complex: ...


@overload
def _pow(base: float, exp: int, mod: None = None) -> float: ...


@overload
def _pow(base: float, exp: complex | _SupportsPow2, mod: None = None) -> Any: ...


@overload
def _pow(base: complex, exp: complex | _SupportsPow2, mod: None = None) -> complex: ...


@overload
def _pow(base: _SupportsPow2, exp: Any, mod: None = None) -> Any: ...


@overload
def _pow(base: _SupportsPow3NoneOnly, exp: Any, mod: None = None) -> Any: ...


@overload
def _pow(base: _SupportsPow3, exp: Any, mod: Any) -> Any: ...


@overload
def _pow(base: _SupportsPow2, exp: float, mod: None = None) -> Any: ...


@overload
def _pow(base: _SupportsPow2, exp: complex, mod: None = None) -> complex: ...


def _repr(obj: object, /) -> str: ...


@overload
def _round(number: _SupportsRound1, ndigits: None = None) -> Any: ...


@overload
def _round(number: _SupportsRound2, ndigits: int) -> Any: ...


def _setattr(obj: object, name: str, value: Any, /) -> None: ...


@overload
def _sorted(iterable: Iterable, /, *, key: None = None, reverse: bool = False) -> list: ...


@overload
def _sorted(
    iterable: Iterable,
    /,
    *,
    key: Callable[[Any], SupportsDunderLT | SupportsDunderGT],
    reverse: bool = False,
) -> list: ...


@overload
def _sum(iterable: Iterable[bool | int], /, start: int = 0) -> int: ...


@overload
def _sum(iterable: Iterable, /) -> Any | Literal[0]: ...


@overload
def _sum(iterable: Iterable, /, start: Any) -> Any: ...


@overload
def _vars(object: type, /) -> types.MappingProxyType[str, Any]: ...


@overload
def _vars(object: Any = ..., /) -> dict: ...
