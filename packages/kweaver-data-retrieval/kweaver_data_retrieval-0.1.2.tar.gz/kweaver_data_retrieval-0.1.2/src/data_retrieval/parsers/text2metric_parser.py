import json
import re
from json import JSONDecodeError
from typing import Optional, Dict, List

from langchain_core.outputs import Generation

from langchain_core.output_parsers import StrOutputParser
from langchain_core.pydantic_v1 import BaseModel, Field

from data_retrieval.datasource.af_indicator import AFIndicator
from data_retrieval.logs.logger import logger
from data_retrieval.parsers.base import BaseJsonParser


operator_mapping = {
    "<": "小于",
    "<=": "小于或等于",
    ">": "大于",
    ">=": "大于或等于",
    "=": "等于",
    "<>": "不等于",
    "null": "为空",
    "not null": "不为空",
    "include": "包含",
    "not include": "不包含",
    "prefix": "开头是",
    "not prefix": "开头不是",
    "in list": "在列表中",
    "belong": "属于",
    "true": "为是",
    "false": "为否",
    "between": "介于"
}

date_format_mapping = {
    "year": "按年",
    "quarter": "按季度",
    "month": "按月",
    "week": "按周",
    "day": "按日"
}

# Metrics params in prompt:
# 如果用户需要生成同比或者环比参数，请生成 metrics 参数, metrics 是一个JSON对象,格式如下:
# "metrics": {
#     "type": ... type of metrics,
#     "interval": ... interval of metrics,
#     "value_type": ... value_type of metrics,
# }

# 其中:

# - type: 字符串, 从数组中选择 "yoy" | "mom" | "qoq" | "dod"
# - interval: 整数, 默认为1, 表示同比或环比的间隔为1, 根据用户问题设置, 比如用户想计算"2年前同期的数据", 则设置为2
# - value_type: 数组, 可选 "value" | "percent"，尽量只选择一个，默认为 ["value"]。除非用户明确提到同时需要，则设置为["value", "percent"]
metric_type_mapping = {
    "yoy": "year",
    "mom": "month",
    "qoq": "quarter",
    "dod": "day"
}

value_type_mapping = {
    "value": "growth_value",
    "percent": "growth_rate"
}

metric_type_name_mapping = {
    "year": "同比",
    "month": "月环比",
    "quarter": "季度环比",
    "day": "天环比"
}

value_type_name_mapping = {
    "growth_value": "增长值",
    "growth_rate": "增长率"
}

class Text2MetricParser(BaseJsonParser):
    indicator: AFIndicator = None
    language: str = "cn"
    essential_explain: bool = True

    def _remove_comment(self, result: List[Generation]):
        for res in result:
            res.text = re.sub(r'//.*?(\r?\n|$)', '', res.text)

        return result
    
    
    def _fix_json_brackets(self, result):
        str_parser = StrOutputParser()
        text = str_parser.parse_result(result)
        text = text.replace("{{", "{").replace("}}", "}")
        return text

    def parse_result(self, result, *, partial: bool = False):
        result = self._remove_comment(result)
        try:
            extracted = super().parse_result(result, partial=partial)
        except Exception as e:
            logger.error(f"Error parsing result, try to fix: {e}")
            text = self._fix_json_brackets(result)
            extracted = super().parse_result([Generation(text=text)], partial=partial)

        logger.debug(f"params extracted from llm: {extracted}")
        new_result = self._correct_params_and_explanation(extracted)
        logger.debug(f"params and explanation after correction: {new_result}")

        return new_result

    def _transform_metric_params(self, metrics: Dict):
        # 
        # metrics param required:
        # {
        #     "metrics":{
        #         "type": "value", // value指标值、 sameperiod同环比、 proportion占比
        #         "sameperiod_config": {
        #             "method": ["growth_value","growth_rate"], 计算方式枚举值：growth_value增长值、growth_rate增长率 列表至少有一项
        #             "offset": 2, //偏移量
        #             "time_granularity": "day", 时间粒度： day日、month月、quarter季度、year年
        #         }   // 当type==sameperiod时，sameperiod_config必须存在以及method、offset、time_granularity
        #     }
        # }
        #
        # metrics params generated by llm:
        # metrics: {
        #     "type": "mom",
        #     "interval": 1,
        #     "value_type": ["value", "percent"]
        #
        tranformed = {
            "type": "sameperiod",
            "sameperiod_config": {
                "offset": metrics.get("interval", 1),
                "method": ["growth_value", "growth_rate"],
                # "method": [value_type_mapping.get(value_type) for value_type in metrics.get("value_type", ["value"])],
                "time_granularity": metric_type_mapping.get(metrics.get("type", "yoy").lower())
            }
        }

        return tranformed


    def _correct_params_and_explanation(self, result: Dict):
        #
        # explanation required:
        # explanation: {
        #   "指标名称": [
        #     {
        #       "指标": 指标名称,
        #     },
        #     {
        #       "时间": 从 A 到 B,
        #     },
        #     {
        #       "维度": 维度指,
        #     }
        #   ]
        # }
        #
        res = {}
        explanation = []

        indicator_id = result.get("id", "")
                
        if indicator_id == "":
            return result

        params = result.get("params", {})

        # transform metrics params
        metrics = params.get("metrics", {})
        
        if metrics:
            params["metrics"] = self._transform_metric_params(metrics)
        else:
            if "metrics" in params:
                del params["metrics"]
        
        # correct params
        params = self.indicator.params_correction(params, indicator_id)
        result["params"] = params
        
        desc = self.indicator.get_description_by_id(indicator_id)


        # add indicator explain
        indicator_explain = {
            "指标": result.get("explanation", "")
        }
        explanation.append(indicator_explain)

        # add time explain
        time_constraint = result.get("params", {}).get("time_constraint", {})
        time_explain = {
            "时间": self._format_time_constraint(time_constraint)
        }
        explanation.append(time_explain)

        # add dimension explain
        filters = result.get("params", {}).get("filters", [])

        # 将 filters 中的 field_id 转换为实际的 field_id
        filter_dict = {}
        for filter in filters:
            filter_dict[filter["field_id"]] = filter

        # 将 dimension 中的 field_id 转换为实际的 field_id
        dimensions_in_params = result.get("params", {}).get("dimensions", [])

        dimenstion_dict = {}
        for dim_param in dimensions_in_params:
            field_info = self.indicator.get_field_info_by_id(indicator_id, dim_param["field_id"])
            
            dim_param["business_name"] = field_info["business_name"]
            dim_param["technical_name"] = field_info["technical_name"]
            dimenstion_dict[dim_param["field_id"]] = dim_param

        # show explain for each dimension
        for dim in desc.get("analysis_dimensions", {}):
            
            is_essential_dim = False

            # add display name for dimension
            dimension_name = dim.get("business_name", "")

            if dim.get("field_id") in dimenstion_dict:
                dim_param = dimenstion_dict[dim["field_id"]]
                dimension_name = self._format_dimension_name(dim_param)
                dim_param["display_name"] = dimension_name
                is_essential_dim = True

            filter_value = "全部"
            if dim["field_id"] in filter_dict:
                filter = filter_dict.get(dim["field_id"])
                filter_value = self._format_filter(filter)
                is_essential_dim = True

            dimension_explain = {
                dimension_name: filter_value
            }

            if not self.essential_explain or is_essential_dim:
                explanation.append(dimension_explain)
        
        # add metrics explain
        metrics = params.get("metrics", {})

        if metrics != {}:
            metric_explain = {
                "同环比": self._format_metric_config(metrics.get("sameperiod_config", {}))
            }
            explanation.append(metric_explain)

        indicator_name = desc.get("name", "")

        if indicator_name != "":    
            res[indicator_name] = explanation
        else:
            res["指标"] = explanation

        result["explanation"] = res

        return result
    
    def _format_dimension_name(self, dimension: Dict):
        if dimension.get("business_name") == "":
            return ""
        
        if dimension.get("format", "") == "":
            return dimension["business_name"]
        
        if dimension["format"] in date_format_mapping:
            dimension_format = date_format_mapping[dimension["format"]]
            return f"{dimension['business_name']}({dimension_format})"
        
        return f"{dimension['business_name']} ({dimension['format']})"
    
    def _format_time_constraint(self, time_constraint: Dict):
        if time_constraint.get("start_time", "") == "":
            return ""
        
        if time_constraint.get("end_time", "") == "":
            return ""
        
        return f"从 {time_constraint['start_time']} 到 {time_constraint['end_time']}"
    
    def _format_filter(self, filter: Dict):
        res = ""
        if filter.get("field_id", "") == "":
            return res
        
        operator = filter.get("operator")
        if operator is None:
            return res
        
        res += operator_mapping.get(operator, "")
        
        value = filter.get("value")
        if value == []:
            return res
        
        res += " " + ", ".join(value)
        
        return res

    def _format_metric_config(self, config: Dict):
        res = ""

        time_granularity = config.get("time_granularity", "")
        if time_granularity == "":
            return res
        
        res += f"{metric_type_name_mapping.get(time_granularity)} "

        method = config.get("method", [])
        if method == []:
            return res
        
        res += ", ".join([value_type_name_mapping.get(method) for method in method])

        offset = config.get("offset", 1)
        if offset != 1:
            res += f", 周期偏移量 {offset}"

        return res
