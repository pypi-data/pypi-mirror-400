"""
INN Training Entry Point
----------------------------------------------------------------------------------
Main entry point for training INN-based models and other neural network architectures.
Supports regression and classification tasks with multiple model types.

Copyright (C) 2024  Chanwook Park
Northwestern University, Evanston, Illinois, US, chanwookpark2024@u.northwestern.edu

Usage:
    # As MCP tool - config is passed directly from train_data tool
    from pyinn.main import train_model
    model = train_model(config, run_type='regression')

Supported Models:
    - linear:    Linear INN (Interpolating Neural Network)
    - nonlinear: Nonlinear INN with radial basis functions
    - gaussian:  Gaussian INN
    - MLP:       Multi-Layer Perceptron
    - KAN:       Kolmogorov-Arnold Network
    - FNO:       Fourier Neural Operator
"""

import os
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2'  # Suppress TF/XLA warnings
from jax import config as jax_config
import jax.numpy as jnp
jax_config.update("jax_enable_x64", False)  # single precision

# Local imports
from . import dataset_classification
from . import dataset_regression
from . import train
from . import plot
from .model_utils import save_model_data, save_errors_val


# =============================================================================
# MAIN TRAINING FUNCTION
# =============================================================================

def train_model(config: dict, run_type: str = 'regression', gpu_idx: int = 0):
    """
    Main training function.

    Args:
        config: Configuration dictionary containing MODEL_PARAM, DATA_PARAM,
                TRAIN_PARAM, and PLOT sections. This is generated by the
                train_data MCP tool.
        run_type: Problem type - 'regression' or 'classification'
        gpu_idx: GPU device index (default: 0)

    Returns:
        Trained model (regressor or classifier)

    Example:
        config = execute_train_data(
            input_col=[0, 1, 2],
            output_col=[3],
            data_filenames=['train.csv', 'test.csv'],
            interp_method='MLP'
        )
        model = train_model(config, run_type='regression')
    """
    # Configure GPU
    os.environ["CUDA_DEVICE_ORDER"] = "PCI_BUS_ID"
    os.environ["CUDA_VISIBLE_DEVICES"] = str(gpu_idx)

    # Extract configuration
    interp_method = config['MODEL_PARAM']['interp_method']
    data_filenames = config['DATA_PARAM']['data_filenames']

    print("=" * 60)
    print("INN Training Pipeline")
    print("=" * 60)
    print(f"Run type:     {run_type}")
    print(f"Method:       {interp_method}")
    print(f"Data files:   {data_filenames}")
    print(f"GPU index:    {gpu_idx}")
    print("=" * 60)

    # =========================== REGRESSION ===========================
    if run_type == "regression":
        # Load data
        data = dataset_regression.Data_regression(config)

        # Select trainer based on method
        if interp_method in ["linear", "nonlinear", "gaussian"]:  # for INN
            # Handle sequential training for INN
            if isinstance(config['MODEL_PARAM'].get('nmode'), list):
                nmode_list = config['MODEL_PARAM']['nmode']
                params = None
                errors_train, errors_val, errors_epoch = [], [], []

                for i, nmode in enumerate(nmode_list):
                    config['MODEL_PARAM']['nmode'] = nmode

                    if i == 0:
                        regressor = train.Regression_INN(data, config)
                        regressor.train()
                        params = regressor.params
                        errors_train = list(regressor.errors_train)
                        errors_val = list(regressor.errors_val)
                        errors_epoch = list(regressor.errors_epoch)
                    else:
                        regressor_seq = train.Regression_INN_sequential(data, config, params)
                        regressor_seq.train()

                        # Concatenate parameters
                        params_current = regressor_seq.params
                        if isinstance(params_current, list):
                            params = [jnp.concatenate([p, pc], axis=0)
                                     for p, pc in zip(params, params_current)]
                        else:
                            params = jnp.concatenate([params, params_current], axis=0)

                        # Concatenate error histories
                        errors_train += list(regressor_seq.errors_train)
                        errors_val += list(regressor_seq.errors_val)
                        epoch_offset = i * config['TRAIN_PARAM']['num_epochs_INN']
                        errors_epoch += [e + epoch_offset for e in regressor_seq.errors_epoch]

                # Update regressor with final params and errors
                regressor.params = params
                regressor.errors_train = errors_train
                regressor.errors_val = errors_val
                regressor.errors_epoch = errors_epoch
            else:
                regressor = train.Regression_INN(data, config)
                regressor.train()

        elif interp_method == "MLP":
            regressor = train.Regression_MLP(data, config)
            regressor.train()

        elif interp_method == "KAN":
            regressor = train.Regression_KAN(data, config)
            regressor.train()

        elif interp_method == "FNO":
            regressor = train.Regression_FNO(data, config)
            regressor.train()

        else:
            raise ValueError(f"Unknown interpolation method: {interp_method}")

        # Save model if configured
        if config['TRAIN_PARAM'].get('bool_save_model', False):
            save_model_data(config, data, regressor.params, interp_method)
            save_errors_val(regressor.errors_val, interp_method)

        # Plot results (includes spatial comparison if plot_in_axis is specified)
        if config.get('PLOT', {}).get('bool_plot', False):
            plot.plot_regression(regressor, data, config)

        return regressor

    # ========================= CLASSIFICATION =========================
    # elif run_type == "classification":
    #     # Load data
    #     data = dataset_classification.Data_classification(config)

    #     # Select trainer based on method
    #     if interp_method in ["linear", "nonlinear"]:
    #         classifier = train.Classification_INN(data, config)
    #     elif interp_method == "MLP":
    #         classifier = train.Classification_MLP(data, config)
    #     elif interp_method == "KAN":
    #         classifier = train.Classification_KAN(data, config)
    #     elif interp_method == "FNO":
    #         classifier = train.Classification_FNO(data, config)
    #     else:
    #         raise ValueError(f"Unknown interpolation method: {interp_method}")

    #     classifier.train()

    #     # Save model if configured
    #     if config['TRAIN_PARAM'].get('bool_save_model', False):
    #         save_model_data(config, data, classifier.params, interp_method)

    #     # Plot results
    #     if config.get('PLOT', {}).get('bool_plot', False):
    #         plot.plot_classification(classifier, data, config)

    #     return classifier

    else:
        raise ValueError(f"Unknown run type: {run_type}")
