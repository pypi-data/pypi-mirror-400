//
// Copyright 2025 Formata, Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//


some_obj: {
    field: 42
}


#[test]
fn assign_field() {
    let o = self.some_obj;
    assert_eq(o.field, 42);

    o.field = 50;
    assert_eq(o.field, 50);
}


#[type]
MyArrayFieldType: {
    msg: ''
}
array: [
    {
        msg: 'hello'
    } as MyArrayFieldType,
    {
        msg: 'world'
    } as MyArrayFieldType,
]

#[test]
fn array_field() {
    for (const o in self.array) {
        assert(o.instance_of('MyArrayFieldType'));
    }
}


#[readonly]
read_only_field: 42

#[test]
fn readonly_field() {
    try self.read_only_field = 89;
    catch (error: str) assert_eq(error, 'FieldReadOnlySet');

    assert_eq(self.read_only_field, 42);
}


Inner: {
    #[private]
    private_field: 'secret'

    #[test]
    fn can_see() {
        assert_eq(self.private_field, 'secret');
    }

    InnerInner: {
        #[test]
        fn cannot_see() {
            assert_not(super.private_field);
        }
    }
}

#[test]
fn cannot_see() {
    assert_not(self.Inner.private_field);
}


const const_field: 'hello, there'

#[test]
fn const_fields() {
    try self.const_field = 'yo, dude';
    catch (error: str) assert_eq(error, 'AssignConst');
    assert_eq(self.const_field, 'hello, there');
}


#[test]
fn dynamic_const_field() {
    const var = 'hello';
    self.mydyfield = var;
    self.mydyfield = 'dude'; // should not error here
}


FieldTypes: {
    bool | int union_field: true
    (str, ver) tup_field: ('hi', 1.0.0)

    #[test]
    fn set_union_field() {
        self.union_field = 42;
        assert_eq(self.union_field, 42);

        self.union_field = false;
        assert_eq(self.union_field, false);
    }

    #[test]
    fn non_union_type_converted() {
        self.union_field = 'hi'; // casts to bool
        assert_eq(self.union_field, true);
    }

    #[test]
    fn set_tup_field() {
        self.tup_field = ('yo', 0.3.3);
        assert_eq(self.tup_field, ('yo', 0.3.3));
    }
}


ParseFieldBeforeComment: {
    field: 'hello'

    /// This is a comment that would have killed the expr.
    fn my_func() {}

    another: 42

    /**
     * This is a block comment, also failed before without a ';'.
     */
    fn another_func() {}

    first: 1.2.3

    /// Comment after semver on a field
    second: 'hi'
}


#[type]
AbsolutePathModify: {
    field: []

    #[test]
    fn push_list_back() {
        root.Lang.Fields.AbsolutePathModify.field.push_back('hello');
        <Fields.AbsolutePathModify>.field.push_back('bob');
        assert_eq(self.field, ['hello', 'bob']);
    }
}
