
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union, Optional as _Optional


from ._transform_ops_gen import _Dialect

@_ods_cext.register_operation(_Dialect)
class MatchAttentionOp(_ods_ir.OpView):
  r"""
  Matches operations from the IREELinalgExt dialect that implement
  attention: iree_linalg_ext.attention.
  
  ### Example
  
  ```mlir
  #map_query = affine_map<(d0, d1, d2, d3, d4, d5) -> (d0, d1, d2, d4)>
  #map_key = affine_map<(d0, d1, d2, d3, d4, d5) -> (d0, d1, d5, d4)>
  #map_value = affine_map<(d0, d1, d2, d3, d4, d5) -> (d0, d1, d3, d5)>
  #map_scale = affine_map<(d0, d1, d2, d3, d4, d5) -> ()>
  #map_output = affine_map<(d0, d1, d2, d3, d4, d5) -> (d0, d1, d2, d3)>
  
  %batch_dims, %m_dims, %n_dims, %k1_dims, %k2_dims =
    transform.iree.match.attention %attn_op,
      query_type = f32, key_type = f32, value_type = f32, output_type = f32,
      indexing_maps = [#map_query, #map_key, #map_value, #map_scale, #map_output] :
      !transform.any_op -> !transform.param<i64>
  ```
  
  This succeeds when `%attn_op` is an attention operation with f32 element
  types for query, key, value, and output tensors, and matches the specified
  indexing maps pattern.
  
  #### Return modes
  
  Succeeds if the operation is an attention operation, and
  produces a silenceable failure otherwise.
  
  #### Results
  
  Returns arrays of dimension sizes extracted from the iteration domain:
  - batch_dims: Array of batch dimension sizes.
  - m_dims: Array of query sequence length dimension sizes.
  - n_dims: Array of number of heads dimension sizes.
  - k1_dims: Array of key/value sequence length dimension sizes.
  - k2_dims: Array of key embedding dimension sizes.
  
  The exact interpretation depends on the indexing maps of the attention op.
  """

  OPERATION_NAME = "transform.iree.match.attention"

  _ODS_REGIONS = (0, True)

  def __init__(self, batch_dims, m_dims, n_dims, k1_dims, k2_dims, operand_handle, query_type, key_type, value_type, output_type, indexing_maps, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand_handle)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["query_type"] = (query_type if (
    isinstance(query_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(query_type, context=_ods_context))
    attributes["key_type"] = (key_type if (
    isinstance(key_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(key_type, context=_ods_context))
    attributes["value_type"] = (value_type if (
    isinstance(value_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(value_type, context=_ods_context))
    attributes["output_type"] = (output_type if (
    isinstance(output_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(output_type, context=_ods_context))
    attributes["indexing_maps"] = (indexing_maps if (
    isinstance(indexing_maps, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AffineMapArrayAttr')) else
      _ods_ir.AttrBuilder.get('AffineMapArrayAttr')(indexing_maps, context=_ods_context))
    results = []
    results.append(batch_dims)
    results.append(m_dims)
    results.append(n_dims)
    results.append(k1_dims)
    results.append(k2_dims)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand_handle(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def query_type(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["query_type"]

  @query_type.setter
  def query_type(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["query_type"] = value

  @builtins.property
  def key_type(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["key_type"]

  @key_type.setter
  def key_type(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["key_type"] = value

  @builtins.property
  def value_type(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["value_type"]

  @value_type.setter
  def value_type(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value_type"] = value

  @builtins.property
  def output_type(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["output_type"]

  @output_type.setter
  def output_type(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["output_type"] = value

  @builtins.property
  def indexing_maps(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["indexing_maps"]

  @indexing_maps.setter
  def indexing_maps(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["indexing_maps"] = value

  @builtins.property
  def batch_dims(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

  @builtins.property
  def m_dims(self) -> _ods_ir.OpResult:
    return self.operation.results[1]

  @builtins.property
  def n_dims(self) -> _ods_ir.OpResult:
    return self.operation.results[2]

  @builtins.property
  def k1_dims(self) -> _ods_ir.OpResult:
    return self.operation.results[3]

  @builtins.property
  def k2_dims(self) -> _ods_ir.OpResult:
    return self.operation.results[4]

def iree_match_attention(batch_dims, m_dims, n_dims, k1_dims, k2_dims, operand_handle, query_type, key_type, value_type, output_type, indexing_maps, *, loc=None, ip=None) -> _ods_ir.OpResultList:
  return MatchAttentionOp(batch_dims=batch_dims, m_dims=m_dims, n_dims=n_dims, k1_dims=k1_dims, k2_dims=k2_dims, operand_handle=operand_handle, query_type=query_type, key_type=key_type, value_type=value_type, output_type=output_type, indexing_maps=indexing_maps, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class MatchCastCompatibleDagFromRootOp(_ods_ir.OpView):
  r"""
  Checks whether the given root op matches an operation dag specified in the
  body of this op. Enforces cast compatibilty between types rather than a
  strict equality, similar to `iree.match.cast_compatible_type`.
  
  Note: This operation is experimental and subject to change. General subgraph
  matching is difficult and can spawn various DSLs and a slew of transforms.
  This op tries to keep it relatively simple an inflexible, reflecting the
  expected use case of splicing in hand written kernels that can be equally
  inflexible.
  
  #### Return modes
  
  Succeeds if the root operation matches the dag given by this op, and
  produces a silenceable failure otherwise. Produces a definite failure
  if the operand is not associated with a single payload value.
  
  On success, this operation produces a handle to the inputs and outputs
  of the operation dag based on the outputs of the root op and the block
  arguments of this operations body.
  """

  OPERATION_NAME = "transform.iree.match.cast_compatible_dag_from_root"

  _ODS_REGIONS = (1, True)

  def __init__(self, inputs, outputs, operand_handle, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand_handle)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(inputs)
    results.append(outputs)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand_handle(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def inputs(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

  @builtins.property
  def outputs(self) -> _ods_ir.OpResult:
    return self.operation.results[1]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def iree_match_cast_compatible_dag_from_root(inputs, outputs, operand_handle, *, loc=None, ip=None) -> _ods_ir.OpResultList:
  return MatchCastCompatibleDagFromRootOp(inputs=inputs, outputs=outputs, operand_handle=operand_handle, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class MatchCastCompatibleTypesOp(_ods_ir.OpView):
  r"""
  Checks whether the given value is cast-compatible with the given target
  type attribute.
  
  Currently this operation only allows casting of tensor types. Other types
  must match exactly.
  
  #### Return modes
  
  Succeeds if the value's type is compatible with the target type, and
  produces a silenceable failure otherwise. Produces a definite failure
  if the operand is not associated with a single payload value.
  """

  OPERATION_NAME = "transform.iree.match.cast_compatible_type"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand_handle, target_type, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand_handle)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["target_type"] = (target_type if (
    isinstance(target_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(target_type, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand_handle(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def target_type(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["target_type"]

  @target_type.setter
  def target_type(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["target_type"] = value

def iree_match_cast_compatible_type(operand_handle, target_type, *, loc=None, ip=None) -> MatchCastCompatibleTypesOp:
  return MatchCastCompatibleTypesOp(operand_handle=operand_handle, target_type=target_type, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class MatchContractionOp(_ods_ir.OpView):
  r"""
  Matches operations that implement the ContractionOpInterface.
  This includes operations like linalg.matmul, linalg.batch_matmul, etc.
  
  Optionally matches specific indexing maps patterns.
  
  ### Example
  
  ```mlir
  #map_lhs = affine_map<(d0, d1, d2) -> (d0, d2)>
  #map_rhs = affine_map<(d0, d1, d2) -> (d1, d2)>
  #map_output = affine_map<(d0, d1, d2) -> (d0, d1)>
  
  %batch_dims, %m_dims, %n_dims, %k_dims =
    transform.iree.match.contraction %matmul_op,
      lhs_type = f32, rhs_type = f32, output_type = f32,
      indexing_maps = [#map_lhs, #map_rhs, #map_output] :
      !transform.any_op -> !transform.param<i64>
  ```
  
  This succeeds when `%matmul_op` is a contraction operation with f32 input
  types and f32 output type, and matches the specified indexing maps pattern.
  
  #### Return modes
  
  Succeeds if the operation is a contraction operation, and
  produces a silenceable failure otherwise.
  
  #### Results
  
  Returns arrays of dimension sizes for each contraction dimension:
  - batch_dims: Array of batch dimension sizes.
  - m_dims: Array of M dimension sizes.
  - n_dims: Array of N dimension sizes.
  - k_dims: Array of K dimension sizes.
  """

  OPERATION_NAME = "transform.iree.match.contraction"

  _ODS_REGIONS = (0, True)

  def __init__(self, batch_dims, m_dims, n_dims, k_dims, operand_handle, lhs_type, rhs_type, output_type, *, indexing_maps=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand_handle)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["lhs_type"] = (lhs_type if (
    isinstance(lhs_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(lhs_type, context=_ods_context))
    attributes["rhs_type"] = (rhs_type if (
    isinstance(rhs_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(rhs_type, context=_ods_context))
    attributes["output_type"] = (output_type if (
    isinstance(output_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(output_type, context=_ods_context))
    if indexing_maps is not None: attributes["indexing_maps"] = (indexing_maps if (
        isinstance(indexing_maps, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('AffineMapArrayAttr')) else
          _ods_ir.AttrBuilder.get('AffineMapArrayAttr')(indexing_maps, context=_ods_context))
    results = []
    results.append(batch_dims)
    results.append(m_dims)
    results.append(n_dims)
    results.append(k_dims)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand_handle(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def lhs_type(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["lhs_type"]

  @lhs_type.setter
  def lhs_type(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["lhs_type"] = value

  @builtins.property
  def rhs_type(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["rhs_type"]

  @rhs_type.setter
  def rhs_type(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["rhs_type"] = value

  @builtins.property
  def output_type(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["output_type"]

  @output_type.setter
  def output_type(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["output_type"] = value

  @builtins.property
  def indexing_maps(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "indexing_maps" not in self.operation.attributes:
      return None
    return self.operation.attributes["indexing_maps"]

  @indexing_maps.setter
  def indexing_maps(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["indexing_maps"] = value
    elif "indexing_maps" in self.operation.attributes:
      del self.operation.attributes["indexing_maps"]

  @indexing_maps.deleter
  def indexing_maps(self):
    del self.operation.attributes["indexing_maps"]

  @builtins.property
  def batch_dims(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

  @builtins.property
  def m_dims(self) -> _ods_ir.OpResult:
    return self.operation.results[1]

  @builtins.property
  def n_dims(self) -> _ods_ir.OpResult:
    return self.operation.results[2]

  @builtins.property
  def k_dims(self) -> _ods_ir.OpResult:
    return self.operation.results[3]

def iree_match_contraction(batch_dims, m_dims, n_dims, k_dims, operand_handle, lhs_type, rhs_type, output_type, *, indexing_maps=None, loc=None, ip=None) -> _ods_ir.OpResultList:
  return MatchContractionOp(batch_dims=batch_dims, m_dims=m_dims, n_dims=n_dims, k_dims=k_dims, operand_handle=operand_handle, lhs_type=lhs_type, rhs_type=rhs_type, output_type=output_type, indexing_maps=indexing_maps, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class MatchConvolutionOp(_ods_ir.OpView):
  r"""
  Matches operations that implement the ConvolutionOpInterface.
  This includes operations like linalg.conv_2d_nhwc_hwcf,
  linalg.conv_2d_nchw_fchw, linalg.depthwise_conv_2d_nhwc_hwc, etc.
  
  Optionally matches specific indexing maps patterns.
  
  ### Example
  
  ```mlir
  #map_input = affine_map<(d0, d1, d2, d3, d4, d5, d6) -> (d0, d1 + d4, d2 + d5, d6)>
  #map_filter = affine_map<(d0, d1, d2, d3, d4, d5, d6) -> (d4, d5, d6, d3)>
  #map_output = affine_map<(d0, d1, d2, d3, d4, d5, d6) -> (d0, d1, d2, d3)>
  
  %batch_dims, %output_image_dims, %output_channel_dims, %filter_dims,
  %input_channel_dims, %depth_dims, %strides, %dilations =
    transform.iree.match.convolution %conv_op,
      lhs_type = f32, rhs_type = f32, output_type = f32,
      indexing_maps = [#map_input, #map_filter, #map_output] :
      !transform.any_op -> !transform.param<i64>
  ```
  
  This succeeds when `%conv_op` is a convolution operation with f32 element
  types for input, filter, and output tensors.
  
  #### Return modes
  
  Succeeds if the operation is a convolution operation, and
  produces a silenceable failure otherwise.
  
  #### Results
  
  Returns arrays of dimension sizes for each convolution dimension:
  - batch_dims: Array of batch dimension sizes.
  - output_image_dims: Array of output spatial dimension sizes.
  - output_channel_dims: Array of output channel dimension sizes.
  - filter_dims: Array of filter spatial dimension sizes.
  - input_channel_dims: Array of input channel dimension sizes.
  - depth_dims: Array of depth dimension sizes (for depthwise convolutions).
  - strides: Array of stride values.
  - dilations: Array of dilation values.
  """

  OPERATION_NAME = "transform.iree.match.convolution"

  _ODS_REGIONS = (0, True)

  def __init__(self, batch_dims, output_image_dims, output_channel_dims, filter_dims, input_channel_dims, depth_dims, strides, dilations, operand_handle, lhs_type, rhs_type, output_type, *, indexing_maps=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand_handle)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["lhs_type"] = (lhs_type if (
    isinstance(lhs_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(lhs_type, context=_ods_context))
    attributes["rhs_type"] = (rhs_type if (
    isinstance(rhs_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(rhs_type, context=_ods_context))
    attributes["output_type"] = (output_type if (
    isinstance(output_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(output_type, context=_ods_context))
    if indexing_maps is not None: attributes["indexing_maps"] = (indexing_maps if (
        isinstance(indexing_maps, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('AffineMapArrayAttr')) else
          _ods_ir.AttrBuilder.get('AffineMapArrayAttr')(indexing_maps, context=_ods_context))
    results = []
    results.append(batch_dims)
    results.append(output_image_dims)
    results.append(output_channel_dims)
    results.append(filter_dims)
    results.append(input_channel_dims)
    results.append(depth_dims)
    results.append(strides)
    results.append(dilations)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand_handle(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def lhs_type(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["lhs_type"]

  @lhs_type.setter
  def lhs_type(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["lhs_type"] = value

  @builtins.property
  def rhs_type(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["rhs_type"]

  @rhs_type.setter
  def rhs_type(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["rhs_type"] = value

  @builtins.property
  def output_type(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["output_type"]

  @output_type.setter
  def output_type(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["output_type"] = value

  @builtins.property
  def indexing_maps(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "indexing_maps" not in self.operation.attributes:
      return None
    return self.operation.attributes["indexing_maps"]

  @indexing_maps.setter
  def indexing_maps(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["indexing_maps"] = value
    elif "indexing_maps" in self.operation.attributes:
      del self.operation.attributes["indexing_maps"]

  @indexing_maps.deleter
  def indexing_maps(self):
    del self.operation.attributes["indexing_maps"]

  @builtins.property
  def batch_dims(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

  @builtins.property
  def output_image_dims(self) -> _ods_ir.OpResult:
    return self.operation.results[1]

  @builtins.property
  def output_channel_dims(self) -> _ods_ir.OpResult:
    return self.operation.results[2]

  @builtins.property
  def filter_dims(self) -> _ods_ir.OpResult:
    return self.operation.results[3]

  @builtins.property
  def input_channel_dims(self) -> _ods_ir.OpResult:
    return self.operation.results[4]

  @builtins.property
  def depth_dims(self) -> _ods_ir.OpResult:
    return self.operation.results[5]

  @builtins.property
  def strides(self) -> _ods_ir.OpResult:
    return self.operation.results[6]

  @builtins.property
  def dilations(self) -> _ods_ir.OpResult:
    return self.operation.results[7]

def iree_match_convolution(batch_dims, output_image_dims, output_channel_dims, filter_dims, input_channel_dims, depth_dims, strides, dilations, operand_handle, lhs_type, rhs_type, output_type, *, indexing_maps=None, loc=None, ip=None) -> _ods_ir.OpResultList:
  return MatchConvolutionOp(batch_dims=batch_dims, output_image_dims=output_image_dims, output_channel_dims=output_channel_dims, filter_dims=filter_dims, input_channel_dims=input_channel_dims, depth_dims=depth_dims, strides=strides, dilations=dilations, operand_handle=operand_handle, lhs_type=lhs_type, rhs_type=rhs_type, output_type=output_type, indexing_maps=indexing_maps, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class MatchDimBoundsOp(_ods_ir.OpView):
  r"""
  Checks whether a dim is within a specified lower and upper bound.
  
  #### Return modes
  
  Succeeds if the value's type is compatible with the target type, and
  produces a silenceable failure otherwise. Produces a definite failure
  if the operand is not associated with a single payload value.
  """

  OPERATION_NAME = "transform.iree.match.dim_bounds"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand_handle, dim, *, lower_bound=None, upper_bound=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand_handle)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dim"] = (dim if (
    isinstance(dim, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(dim, context=_ods_context))
    if lower_bound is not None: attributes["lower_bound"] = (lower_bound if (
        isinstance(lower_bound, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(lower_bound, context=_ods_context))
    if upper_bound is not None: attributes["upper_bound"] = (upper_bound if (
        isinstance(upper_bound, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(upper_bound, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand_handle(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def dim(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["dim"]

  @dim.setter
  def dim(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dim"] = value

  @builtins.property
  def lower_bound(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "lower_bound" not in self.operation.attributes:
      return None
    return self.operation.attributes["lower_bound"]

  @lower_bound.setter
  def lower_bound(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["lower_bound"] = value
    elif "lower_bound" in self.operation.attributes:
      del self.operation.attributes["lower_bound"]

  @lower_bound.deleter
  def lower_bound(self):
    del self.operation.attributes["lower_bound"]

  @builtins.property
  def upper_bound(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "upper_bound" not in self.operation.attributes:
      return None
    return self.operation.attributes["upper_bound"]

  @upper_bound.setter
  def upper_bound(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["upper_bound"] = value
    elif "upper_bound" in self.operation.attributes:
      del self.operation.attributes["upper_bound"]

  @upper_bound.deleter
  def upper_bound(self):
    del self.operation.attributes["upper_bound"]

def iree_match_dim_bounds(operand_handle, dim, *, lower_bound=None, upper_bound=None, loc=None, ip=None) -> MatchDimBoundsOp:
  return MatchDimBoundsOp(operand_handle=operand_handle, dim=dim, lower_bound=lower_bound, upper_bound=upper_bound, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class MatchDimIsMultipleOfOp(_ods_ir.OpView):
  r"""
  Checks whether the given dimension given shaped value is a multiple of the
  given size.
  
  #### Return modes
  
  Succeeds if the value's type is compatible with the target type, and
  produces a silenceable failure otherwise. Produces a definite failure
  if the operand is not associated with a single payload value.
  """

  OPERATION_NAME = "transform.iree.match.dim_is_multiple_of"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand_handle, dim, size, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand_handle)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dim"] = (dim if (
    isinstance(dim, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(dim, context=_ods_context))
    attributes["size"] = (size if (
    isinstance(size, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(size, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand_handle(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def dim(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["dim"]

  @dim.setter
  def dim(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dim"] = value

  @builtins.property
  def size(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["size"]

  @size.setter
  def size(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["size"] = value

def iree_match_dim_is_multiple_of(operand_handle, dim, size, *, loc=None, ip=None) -> MatchDimIsMultipleOfOp:
  return MatchDimIsMultipleOfOp(operand_handle=operand_handle, dim=dim, size=size, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class MatchDimsEqualOp(_ods_ir.OpView):
  r"""
  Matches dimension sizes against expected values.
  Each position in the dimension sizes array must match the corresponding
  expected value exactly.
  
  ### Example
  
  ```mlir
  transform.iree.match.size_equals %m, [512, 256] : !transform.param<i64>
  ```
  
  This succeeds when `%m` has exactly two dimensions, 512 and 256.
  
  #### Return modes
  
  Succeeds if all parameters match their corresponding expected values, and
  produces a silenceable failure otherwise.
  """

  OPERATION_NAME = "transform.iree.match.dims_equal"

  _ODS_REGIONS = (0, True)

  def __init__(self, dimension_sizes, expected_values, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(dimension_sizes)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["expected_values"] = (expected_values if (
    isinstance(expected_values, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(expected_values, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def dimension_sizes(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def expected_values(self) -> _ods_ir.DenseI64ArrayAttr:
    return self.operation.attributes["expected_values"]

  @expected_values.setter
  def expected_values(self, value: _ods_ir.DenseI64ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["expected_values"] = value

def iree_match_dims_equal(dimension_sizes, expected_values, *, loc=None, ip=None) -> MatchDimsEqualOp:
  return MatchDimsEqualOp(dimension_sizes=dimension_sizes, expected_values=expected_values, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class MatchRegionsOp(_ods_ir.OpView):
  r"""
  Does a structural comparison of the regions of the single op contained
  within the region of this op against the regions of the target operation.
  
  #### Return modes
  
  Succeeds if the operation body satisfies the specified criteria, produces a
  silenceable failure otherwise. Produces a definite failure if the operand is
  not associated with a single payload op.
  """

  OPERATION_NAME = "transform.iree.match.regions"

  _ODS_REGIONS = (1, True)

  def __init__(self, operand_handle, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand_handle)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand_handle(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def iree_match_regions(operand_handle, *, loc=None, ip=None) -> MatchRegionsOp:
  return MatchRegionsOp(operand_handle=operand_handle, loc=loc, ip=ip)
