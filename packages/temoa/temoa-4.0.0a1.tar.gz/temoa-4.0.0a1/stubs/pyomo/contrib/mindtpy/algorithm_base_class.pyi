import types

from _typeshed import Incomplete
from pyomo.common.collections import Bunch as Bunch
from pyomo.common.collections import ComponentMap as ComponentMap
from pyomo.common.collections import ComponentSet as ComponentSet
from pyomo.common.dependencies import attempt_import as attempt_import
from pyomo.common.errors import DeveloperError as DeveloperError
from pyomo.common.errors import InfeasibleConstraintException as InfeasibleConstraintException
from pyomo.contrib.fbbt.fbbt import fbbt as fbbt
from pyomo.contrib.gdpopt.solve_discrete_problem import (
    distinguish_mip_infeasible_or_unbounded as distinguish_mip_infeasible_or_unbounded,
)
from pyomo.contrib.gdpopt.util import SuppressInfeasibleWarning as SuppressInfeasibleWarning
from pyomo.contrib.gdpopt.util import get_main_elapsed_time as get_main_elapsed_time
from pyomo.contrib.gdpopt.util import lower_logger_level_to as lower_logger_level_to
from pyomo.contrib.gdpopt.util import time_code as time_code
from pyomo.contrib.mindtpy import __version__ as __version__
from pyomo.contrib.mindtpy.cut_generation import add_no_good_cuts as add_no_good_cuts
from pyomo.contrib.mindtpy.util import GurobiPersistent4MindtPy as GurobiPersistent4MindtPy
from pyomo.contrib.mindtpy.util import add_orthogonality_cuts as add_orthogonality_cuts
from pyomo.contrib.mindtpy.util import add_var_bound as add_var_bound
from pyomo.contrib.mindtpy.util import copy_var_list_values as copy_var_list_values
from pyomo.contrib.mindtpy.util import (
    copy_var_list_values_from_solution_pool as copy_var_list_values_from_solution_pool,
)
from pyomo.contrib.mindtpy.util import epigraph_reformulation as epigraph_reformulation
from pyomo.contrib.mindtpy.util import fp_converged as fp_converged
from pyomo.contrib.mindtpy.util import (
    generate_lag_objective_function as generate_lag_objective_function,
)
from pyomo.contrib.mindtpy.util import (
    generate_norm1_objective_function as generate_norm1_objective_function,
)
from pyomo.contrib.mindtpy.util import (
    generate_norm2sq_objective_function as generate_norm2sq_objective_function,
)
from pyomo.contrib.mindtpy.util import generate_norm_constraint as generate_norm_constraint
from pyomo.contrib.mindtpy.util import (
    generate_norm_inf_objective_function as generate_norm_inf_objective_function,
)
from pyomo.contrib.mindtpy.util import get_integer_solution as get_integer_solution
from pyomo.contrib.mindtpy.util import initialize_feas_subproblem as initialize_feas_subproblem
from pyomo.contrib.mindtpy.util import (
    set_solver_constraint_violation_tolerance as set_solver_constraint_violation_tolerance,
)
from pyomo.contrib.mindtpy.util import set_solver_mipgap as set_solver_mipgap
from pyomo.contrib.mindtpy.util import setup_results_object as setup_results_object
from pyomo.contrib.mindtpy.util import update_solver_timelimit as update_solver_timelimit
from pyomo.core import Block as Block
from pyomo.core import Constraint as Constraint
from pyomo.core import ConstraintList as ConstraintList
from pyomo.core import Expression as Expression
from pyomo.core import NonNegativeReals as NonNegativeReals
from pyomo.core import Objective as Objective
from pyomo.core import RangeSet as RangeSet
from pyomo.core import Reals as Reals
from pyomo.core import Suffix as Suffix
from pyomo.core import TransformationFactory as TransformationFactory
from pyomo.core import Var as Var
from pyomo.core import VarList as VarList
from pyomo.core import maximize as maximize
from pyomo.core import minimize as minimize
from pyomo.core import value as value
from pyomo.opt import SolutionStatus as SolutionStatus
from pyomo.opt import SolverFactory as SolverFactory
from pyomo.opt import SolverResults as SolverResults
from pyomo.opt import SolverStatus as SolverStatus
from pyomo.repn import generate_standard_repn as generate_standard_repn
from pyomo.solvers.plugins.solvers.gurobi_direct import gurobipy as gurobipy
from pyomo.solvers.plugins.solvers.persistent_solver import PersistentSolver as PersistentSolver
from pyomo.util.vars_from_expressions import get_vars_from_components as get_vars_from_components

single_tree: Incomplete
single_tree_available: Incomplete
tabu_list: Incomplete
tabu_list_available: Incomplete
egb: Incomplete
egb_available: Incomplete

class _MindtPyAlgorithm:
    working_model: Incomplete
    mip: Incomplete
    fixed_nlp: Incomplete
    results: Incomplete
    timing: Incomplete
    curr_int_sol: Incomplete
    should_terminate: bool
    integer_list: Incomplete
    integer_solution_to_cuts_index: Incomplete
    nlp_iter: int
    mip_iter: int
    mip_subiter: int
    nlp_infeasible_counter: int
    fp_iter: int
    primal_bound_progress_time: Incomplete
    dual_bound_progress_time: Incomplete
    abs_gap: Incomplete
    rel_gap: Incomplete
    log_formatter: str
    termination_condition_log_formatter: str
    fixed_nlp_log_formatter: str
    infeasible_fixed_nlp_log_formatter: str
    log_note_formatter: str
    primal_bound_improved: bool
    dual_bound_improved: bool
    best_solution_found: Incomplete
    best_solution_found_time: Incomplete
    stored_bound: Incomplete
    num_no_good_cuts_added: Incomplete
    last_iter_cuts: bool
    mip_start_lazy_oa_cuts: Incomplete
    mip_load_solutions: bool
    nlp_load_solutions: bool
    regularization_mip_load_solutions: bool
    def __init__(self, **kwds) -> None: ...
    def __enter__(self): ...
    def __exit__(
        self,
        t: type[BaseException] | None,
        v: BaseException | None,
        traceback: types.TracebackType | None,
    ) -> None: ...
    def available(self, exception_flag: bool = True): ...
    def license_is_valid(self): ...
    def version(self): ...
    def set_up_logger(self) -> None: ...
    util_block_name: Incomplete
    def create_utility_block(self, model, name) -> None: ...
    def model_is_valid(self): ...
    def build_ordered_component_lists(self, model) -> None: ...
    def add_cuts_components(self, model) -> None: ...
    def get_dual_integral(self): ...
    def get_primal_integral(self): ...
    primal_integral: Incomplete
    dual_integral: Incomplete
    primal_dual_gap_integral: Incomplete
    def get_integral_info(self) -> None: ...
    def update_gap(self) -> None: ...
    dual_bound: Incomplete
    def update_dual_bound(self, bound_value) -> None: ...
    def update_suboptimal_dual_bound(self, results) -> None: ...
    primal_bound: Incomplete
    def update_primal_bound(self, bound_value) -> None: ...
    objective_sense: Incomplete
    def process_objective(self, update_var_con_list: bool = True) -> None: ...
    original_model: Incomplete
    primal_bound_progress: Incomplete
    dual_bound_progress: Incomplete
    mip_objective_polynomial_degree: Incomplete
    mip_constraint_polynomial_degree: Incomplete
    def set_up_solve_data(self, model) -> None: ...
    def MindtPy_initialization(self) -> None: ...
    rnlp: Incomplete
    def init_rNLP(self, add_oa_cuts: bool = True) -> None: ...
    def init_max_binaries(self) -> None: ...
    def solve_subproblem(self): ...
    def handle_nlp_subproblem_tc(self, fixed_nlp, result, cb_opt=None) -> None: ...
    def handle_subproblem_optimal(self, fixed_nlp, cb_opt=None, fp: bool = False) -> None: ...
    def handle_subproblem_infeasible(self, fixed_nlp, cb_opt=None) -> None: ...
    def handle_subproblem_other_termination(
        self, fixed_nlp, termination_condition, cb_opt=None
    ) -> None: ...
    def solve_feasibility_subproblem(self): ...
    def handle_feasibility_subproblem_tc(self, subprob_terminate_cond, MindtPy) -> None: ...
    def algorithm_should_terminate(self, check_cycling): ...
    def fix_dual_bound(self, last_iter_cuts) -> None: ...
    def set_up_tabulist_callback(self) -> None: ...
    def set_up_lazy_OA_callback(self) -> None: ...
    def solve_main(self): ...
    def solve_fp_main(self): ...
    def solve_regularization_main(self): ...
    def set_up_mip_solver(self): ...
    def handle_main_optimal(self, main_mip, update_bound: bool = True) -> None: ...
    def handle_main_infeasible(self) -> None: ...
    def handle_main_max_timelimit(self, main_mip, main_mip_results) -> None: ...
    def handle_main_unbounded(self, main_mip): ...
    def handle_regularization_main_tc(self, main_mip, main_mip_results) -> None: ...
    def setup_main(self) -> None: ...
    def setup_fp_main(self) -> None: ...
    def setup_regularization_main(self) -> None: ...
    def update_result(self) -> None: ...
    def load_solution(self) -> None: ...
    def check_subsolver_validity(self) -> None: ...
    def check_config(self) -> None: ...
    def solve_fp_subproblem(self): ...
    def handle_fp_subproblem_optimal(self, fp_nlp) -> None: ...
    def handle_fp_main_tc(self, fp_main_results): ...
    def fp_loop(self) -> None: ...
    def initialize_mip_problem(self) -> None: ...
    mip_opt: Incomplete
    nlp_opt: Incomplete
    feasibility_nlp_opt: Incomplete
    regularization_mip_opt: Incomplete
    def initialize_subsolvers(self) -> None: ...
    def set_appsi_solver_update_config(self) -> None: ...
    initial_var_values: Incomplete
    def solve(self, model, **kwds): ...
    def objective_reformulation(self) -> None: ...
    def handle_main_mip_termination(self, main_mip, main_mip_results): ...
    def MindtPy_iteration_loop(self) -> None: ...
    def get_solution_name_obj(self, main_mip_results): ...
    def add_regularization(self) -> None: ...
    def bounds_converged(self): ...
    def reached_iteration_limit(self): ...
    def reached_time_limit(self): ...
    def reached_stalling_limit(self): ...
    def iteration_cycling(self): ...
